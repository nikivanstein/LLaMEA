{"id": "74b47235-5cc7-48d9-ae0c-5f14da69f640", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.4\n        self.social_constant = 1.4\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations >= self.budget:\n                break\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSODE(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization with Differential Evolution for adaptive exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 0, "fitness": 0.227141436060151, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6824868775399261, 0.6824868775399261, 0.6824868775399261, 0.18301594011999422, 0.18301594011999422, 0.18301594011999422, 0.7077193094596708, 0.7077193094596708, 0.7077193094596708, 0.03357934369273641, 0.03357934369273641, 0.03357934369273641, 0.4046273787009953, 0.4046273787009953, 0.4046273787009953, 0.4106874306477062, 0.4106874306477062, 0.4106874306477062, 0.13490518232010307, 0.13490518232010307, 0.13490518232010307, 0.12748401123435593, 0.12748401123435593, 0.12748401123435593, 0.12709814516080675, 0.12709814516080675, 0.12709814516080675, 0.12130088548982854, 0.12130088548982854, 0.12130088548982854, 0.09768252940523403, 0.09768252940523403, 0.09768252940523403, 0.12194827698643529, 0.12194827698643529, 0.12194827698643529, 0.9503498768753635, 0.9503498768753635, 0.9503498768753635, 0.9799053644586265, 0.9799053644586265, 0.9799053644586265, 0.9743237591676723, 0.9743237591676723, 0.9743237591676723, 0.2252799283800737, 0.2252799283800737, 0.2252799283800737, 0.23804726069775484, 0.23804726069775484, 0.23804726069775484, 0.17237972159366177, 0.17237972159366177, 0.17237972159366177, 0.2915079274917127, 0.2915079274917127, 0.2915079274917127, 0.2518704899822056, 0.2518704899822056, 0.2518704899822056, 0.11557504887505587, 0.11557504887505587, 0.11557504887505587, 0.1765320392729549, 0.1765320392729549, 0.1765320392729549, 0.1279967866236419, 0.1279967866236419, 0.1279967866236419, 0.1767488010910847, 0.1767488010910847, 0.1767488010910847, 0.182010183728178, 0.182010183728178, 0.182010183728178, 0.16420689314041592, 0.16420689314041592, 0.16420689314041592, 0.19783729601234923, 0.19783729601234923, 0.19783729601234923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02399354031074441, 0.02399354031074441, 0.02399354031074441, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0720904231318178, 0.0720904231318178, 0.0720904231318178, 0.017848164680206224, 0.017848164680206224, 0.017848164680206224, 0.04096072460291167, 0.04096072460291167, 0.04096072460291167, 0.03979614935054543, 0.03979614935054543, 0.03979614935054543, 0.06118689870446814, 0.06118689870446814, 0.06118689870446814, 0.05310634797910985, 0.05310634797910985, 0.05310634797910985, 0.0671584135916572, 0.0671584135916572, 0.0671584135916572, 0.0337168916585191, 0.0337168916585191, 0.0337168916585191, 0.07582650722969031, 0.07582650722969031, 0.07582650722969031, 0.47807390700489505, 0.47807390700489505, 0.47807390700489505, 0.4745244934231331, 0.4745244934231331, 0.4745244934231331, 0.4462968170468389, 0.4462968170468389, 0.4462968170468389, 0.09523980700049739, 0.09523980700049739, 0.09523980700049739, 0.10345788847421844, 0.10345788847421844, 0.10345788847421844, 0.12952993199086327, 0.12952993199086327, 0.12952993199086327, 0.12868784454690285, 0.12868784454690285, 0.12868784454690285, 0.17849476648760587, 0.17849476648760587, 0.17849476648760587, 0.15150979332297843, 0.15150979332297843, 0.15150979332297843, 0.3031650745141383, 0.3031650745141383, 0.3031650745141383, 0.305247421993747, 0.305247421993747, 0.305247421993747, 0.3551819738721953, 0.3551819738721953, 0.3551819738721953, 0.2838721586941172, 0.2838721586941172, 0.2838721586941172, 0.21014060696042725, 0.21014060696042725, 0.21014060696042725, 0.21647516140184542, 0.21647516140184542, 0.21647516140184542, 0.19648386710492172, 0.19648386710492172, 0.19648386710492172, 0.152275403947015, 0.152275403947015, 0.152275403947015, 0.1938401788966656, 0.1938401788966656, 0.1938401788966656, 0.2092302144603978, 0.2092302144603978, 0.2092302144603978, 0.19553372176482098, 0.19553372176482098, 0.19553372176482098, 0.1990304019631225, 0.1990304019631225, 0.1990304019631225, 0.7966440586256622, 0.7966440586256622, 0.7966440586256622, 0.1565349595077451, 0.1565349595077451, 0.1565349595077451, 0.1962296619899525, 0.1962296619899525, 0.1962296619899525, 0.20597536030175856, 0.20597536030175856, 0.20597536030175856, 0.2067614156830334, 0.2067614156830334, 0.2067614156830334, 0.15658909609360017, 0.15658909609360017, 0.15658909609360017, 0.18742001051219015, 0.18742001051219015, 0.18742001051219015, 0.18053863766009293, 0.18053863766009293, 0.18053863766009293, 0.17655578763020385, 0.17655578763020385, 0.17655578763020385, 0.08389854401097852, 0.08389854401097852, 0.08389854401097852, 0.06803125212377836, 0.06803125212377836, 0.06803125212377836, 0.06972242793231476, 0.06972242793231476, 0.06972242793231476]}, "mutation_prompt": null}
{"id": "18ac231b-a75f-4633-a4c1-ce3bf3ed6811", "solution": "import numpy as np\n\nclass HybridPSODEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.inertia_weight = 0.9  # Adaptive inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            # Dynamically adjust the inertia weight\n            self.inertia_weight = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Enhanced Differential Evolution\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations >= self.budget:\n                break\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSODEAdaptive(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSODEAdaptive", "description": "A hybrid Particle Swarm Optimization with Differential Evolution enhanced by adaptive parameter tuning for faster convergence.", "configspace": "", "generation": 1, "fitness": 0.2023206058209153, "feedback": "The algorithm HybridPSODEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "74b47235-5cc7-48d9-ae0c-5f14da69f640", "metadata": {"aucs": [0.5421852033783536, 0.5421852033783536, 0.5421852033783536, 0.5965598080905756, 0.5965598080905756, 0.5965598080905756, 0.5472199533002556, 0.5472199533002556, 0.5472199533002556, 0.02213445040080786, 0.02213445040080786, 0.02213445040080786, 0.2854488548003504, 0.2854488548003504, 0.2854488548003504, 0.03726586213136884, 0.03726586213136884, 0.03726586213136884, 0.10266507539995895, 0.10266507539995895, 0.10266507539995895, 0.0778133195182441, 0.0778133195182441, 0.0778133195182441, 0.0989295925332, 0.0989295925332, 0.0989295925332, 0.09295218295675389, 0.09295218295675389, 0.09295218295675389, 0.06577410358750457, 0.06577410358750457, 0.06577410358750457, 0.06724124628533013, 0.06724124628533013, 0.06724124628533013, 0.9854953072031121, 0.9854953072031121, 0.9854953072031121, 0.9858928518862825, 0.9858928518862825, 0.9858928518862825, 0.9774021243642658, 0.9774021243642658, 0.9774021243642658, 0.15614738580970733, 0.15614738580970733, 0.15614738580970733, 0.18586872042879354, 0.18586872042879354, 0.18586872042879354, 0.13531541402869096, 0.13531541402869096, 0.13531541402869096, 0.1541676750504566, 0.1541676750504566, 0.1541676750504566, 0.155437651193306, 0.155437651193306, 0.155437651193306, 0.13579240320859276, 0.13579240320859276, 0.13579240320859276, 0.13836434042990164, 0.13836434042990164, 0.13836434042990164, 0.15084665976389966, 0.15084665976389966, 0.15084665976389966, 0.12997876480148007, 0.12997876480148007, 0.12997876480148007, 0.014544701630432977, 0.014544701630432977, 0.014544701630432977, 0.1310591629699982, 0.1310591629699982, 0.1310591629699982, 0.07028926119890488, 0.07028926119890488, 0.07028926119890488, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014119476117813168, 0.00014119476117813168, 0.00014119476117813168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06467731907159324, 0.06467731907159324, 0.06467731907159324, 0.0190216567436724, 0.0190216567436724, 0.0190216567436724, 0.05993202540381115, 0.05993202540381115, 0.05993202540381115, 0.02784224035102345, 0.02784224035102345, 0.02784224035102345, 0.04637444074282626, 0.04637444074282626, 0.04637444074282626, 0.04892447291401225, 0.04892447291401225, 0.04892447291401225, 0.063741889498513, 0.063741889498513, 0.063741889498513, 0.032238475908871855, 0.032238475908871855, 0.032238475908871855, 0.06747120702799181, 0.06747120702799181, 0.06747120702799181, 0.4286438750831334, 0.4286438750831334, 0.4286438750831334, 0.4103169955916933, 0.4103169955916933, 0.4103169955916933, 0.3855930306513323, 0.3855930306513323, 0.3855930306513323, 0.08598265605624511, 0.08598265605624511, 0.08598265605624511, 0.08295326379151446, 0.08295326379151446, 0.08295326379151446, 0.10155965580901771, 0.10155965580901771, 0.10155965580901771, 0.1373638664989446, 0.1373638664989446, 0.1373638664989446, 0.1682549882341876, 0.1682549882341876, 0.1682549882341876, 0.12746738566634774, 0.12746738566634774, 0.12746738566634774, 0.27612563663895107, 0.27612563663895107, 0.27612563663895107, 0.2733126953491747, 0.2733126953491747, 0.2733126953491747, 0.29916413500517924, 0.29916413500517924, 0.29916413500517924, 0.2126508407452421, 0.2126508407452421, 0.2126508407452421, 0.16342578533865437, 0.16342578533865437, 0.16342578533865437, 0.2057757109391144, 0.2057757109391144, 0.2057757109391144, 0.18489545836420673, 0.18489545836420673, 0.18489545836420673, 0.17684317086514334, 0.17684317086514334, 0.17684317086514334, 0.17254838619310398, 0.17254838619310398, 0.17254838619310398, 0.1826899054706833, 0.1826899054706833, 0.1826899054706833, 0.21808704114856348, 0.21808704114856348, 0.21808704114856348, 0.16821496341811926, 0.16821496341811926, 0.16821496341811926, 0.6154141128626882, 0.6154141128626882, 0.6154141128626882, 0.4626304108175848, 0.4626304108175848, 0.4626304108175848, 0.14565309701570384, 0.14565309701570384, 0.14565309701570384, 0.19398888516720758, 0.19398888516720758, 0.19398888516720758, 0.2077342514814341, 0.2077342514814341, 0.2077342514814341, 0.19045928598369422, 0.19045928598369422, 0.19045928598369422, 0.21130005575543775, 0.21130005575543775, 0.21130005575543775, 0.2004125889907722, 0.2004125889907722, 0.2004125889907722, 0.18219394983118542, 0.18219394983118542, 0.18219394983118542, 0.061086235486030094, 0.061086235486030094, 0.061086235486030094, 0.06926225393938945, 0.06926225393938945, 0.06926225393938945, 0.09172204614220114, 0.09172204614220114, 0.09172204614220114]}, "mutation_prompt": null}
{"id": "5851d663-d82a-4917-b797-81bec27136cc", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 2, "fitness": 0.2590459958917981, "feedback": "The algorithm HybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "74b47235-5cc7-48d9-ae0c-5f14da69f640", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "5ee213ac-f40d-4b7c-8be3-9fa037c1d698", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "2d85787f-d093-4acd-9509-e0f86e003fd4", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adaptive inertia weight range\n        self.inertia_min = 0.4\n        self.cognitive_constant = 2.0  # Enhanced cognitive and social constants\n        self.social_constant = 2.0\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9  # Slightly higher crossover rate\n        self.chaos_coefficient = 0.7\n\n    def chaotic_map(self, x):\n        return (4.0 * x) * (1.0 - x)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        inertia_weight = self.inertia_weight\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight = max(self.inertia_min, inertia_weight * 0.99)  # Adaptive inertia weight reduction\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                chaos_seed = np.random.rand()\n                chaos_value = self.chaotic_map(chaos_seed)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) + chaos_value * self.chaos_coefficient, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 2 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase with dynamic step size\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                step_size = np.random.uniform(0.05, 0.15)\n                local_candidate = particles[i] + step_size * np.random.uniform(-1, 1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "A hybrid approach enhancing adaptive inertia, chaotic maps for diversity, and enhanced local search to boost convergence.", "configspace": "", "generation": 4, "fitness": 0.15170112974147443, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.29162379155019935, 0.29162379155019935, 0.29162379155019935, 0.3488713765926039, 0.3488713765926039, 0.3488713765926039, 0.3325007623741175, 0.3325007623741175, 0.3325007623741175, 0.029293668015085483, 0.029293668015085483, 0.029293668015085483, 0.0, 0.0, 0.0, 0.0014895342980270065, 0.0014895342980270065, 0.0014895342980270065, 0.08082964094605904, 0.08082964094605904, 0.08082964094605904, 0.058524787486092245, 0.058524787486092245, 0.058524787486092245, 0.05716752394948177, 0.05716752394948177, 0.05716752394948177, 0.060561117677680576, 0.060561117677680576, 0.060561117677680576, 0.03543922690148771, 0.03543922690148771, 0.03543922690148771, 0.0441170964227553, 0.0441170964227553, 0.0441170964227553, 0.9692709731731699, 0.9692709731731699, 0.9692709731731699, 0.9395801849976897, 0.9395801849976897, 0.9395801849976897, 0.938264022287235, 0.938264022287235, 0.938264022287235, 0.1034314057713549, 0.1034314057713549, 0.1034314057713549, 0.14389477052408273, 0.14389477052408273, 0.14389477052408273, 0.11194408924781296, 0.11194408924781296, 0.11194408924781296, 0.12900651890483883, 0.12900651890483883, 0.12900651890483883, 0.15815114185311419, 0.15815114185311419, 0.15815114185311419, 0.17374016310641305, 0.17374016310641305, 0.17374016310641305, 0.08032871814844877, 0.08032871814844877, 0.08032871814844877, 0.07735226383334481, 0.07735226383334481, 0.07735226383334481, 0.0637796003379888, 0.0637796003379888, 0.0637796003379888, 0.06821654971149549, 0.06821654971149549, 0.06821654971149549, 0.033762944451206534, 0.033762944451206534, 0.033762944451206534, 0.09522971669133973, 0.09522971669133973, 0.09522971669133973, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10599523884880313, 0.10599523884880313, 0.10599523884880313, 0.029661895580878284, 0.029661895580878284, 0.029661895580878284, 0.05094678563724442, 0.05094678563724442, 0.05094678563724442, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.056936920958643555, 0.056936920958643555, 0.056936920958643555, 0.02057430702449814, 0.02057430702449814, 0.02057430702449814, 0.03453733107473067, 0.03453733107473067, 0.03453733107473067, 0.28121761461878425, 0.28121761461878425, 0.28121761461878425, 0.24200474828880203, 0.24200474828880203, 0.24200474828880203, 0.279172681827787, 0.279172681827787, 0.279172681827787, 0.07385612432190791, 0.07385612432190791, 0.07385612432190791, 0.06861030994313255, 0.06861030994313255, 0.06861030994313255, 0.06221098200642006, 0.06221098200642006, 0.06221098200642006, 0.12593536704494268, 0.12593536704494268, 0.12593536704494268, 0.16778236632025634, 0.16778236632025634, 0.16778236632025634, 0.12520463455604225, 0.12520463455604225, 0.12520463455604225, 0.17012512729147078, 0.17012512729147078, 0.17012512729147078, 0.19474082965175699, 0.19474082965175699, 0.19474082965175699, 0.18734711671606097, 0.18734711671606097, 0.18734711671606097, 0.1090372260974577, 0.1090372260974577, 0.1090372260974577, 0.1553233073282596, 0.1553233073282596, 0.1553233073282596, 0.14758030360812102, 0.14758030360812102, 0.14758030360812102, 0.13962719238082677, 0.13962719238082677, 0.13962719238082677, 0.1507378316455088, 0.1507378316455088, 0.1507378316455088, 0.15091330913849865, 0.15091330913849865, 0.15091330913849865, 0.17022226093573223, 0.17022226093573223, 0.17022226093573223, 0.2127130918068505, 0.2127130918068505, 0.2127130918068505, 0.1548361450797564, 0.1548361450797564, 0.1548361450797564, 0.3006098899844174, 0.3006098899844174, 0.3006098899844174, 0.1564237386723436, 0.1564237386723436, 0.1564237386723436, 0.1617277593858948, 0.1617277593858948, 0.1617277593858948, 0.16376705545451953, 0.16376705545451953, 0.16376705545451953, 0.19047409895563028, 0.19047409895563028, 0.19047409895563028, 0.14260310870817372, 0.14260310870817372, 0.14260310870817372, 0.184977839577379, 0.184977839577379, 0.184977839577379, 0.18760235181062035, 0.18760235181062035, 0.18760235181062035, 0.17763253163684845, 0.17763253163684845, 0.17763253163684845, 0.059920219108662964, 0.059920219108662964, 0.059920219108662964, 0.05217569029915081, 0.05217569029915081, 0.05217569029915081, 0.05034441880621998, 0.05034441880621998, 0.05034441880621998]}, "mutation_prompt": null}
{"id": "ad687e5a-ab70-40c5-97f8-e78730f2ea0b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_constant = 2.0\n        self.social_constant = 2.0\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            sorted_indices = np.argsort(scores)\n            top_indices = sorted_indices[:self.population_size // 5]\n            elite_particles = particles[top_indices]\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            current_inertia_weight = (\n                self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (evaluations / self.budget)\n            )\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (current_inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "Enhance convergence by integrating adaptive inertia weight and elite selection strategy in the hybrid PSO-SADE-LS framework.", "configspace": "", "generation": 5, "fitness": 0.15124605133381244, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.2856624597408308, 0.2856624597408308, 0.2856624597408308, 0.3205160171321195, 0.3205160171321195, 0.3205160171321195, 0.34364433109881565, 0.34364433109881565, 0.34364433109881565, 0.05125106386543099, 0.05125106386543099, 0.05125106386543099, 0.014975735877932106, 0.014975735877932106, 0.014975735877932106, 0.00723632272864938, 0.00723632272864938, 0.00723632272864938, 0.06403490385116128, 0.06403490385116128, 0.06403490385116128, 0.0649139454314871, 0.0649139454314871, 0.0649139454314871, 0.06485117991182399, 0.06485117991182399, 0.06485117991182399, 0.05327149644500695, 0.05327149644500695, 0.05327149644500695, 0.05004463071179399, 0.05004463071179399, 0.05004463071179399, 0.0401768973613178, 0.0401768973613178, 0.0401768973613178, 0.9679587801804622, 0.9679587801804622, 0.9679587801804622, 0.9691512840261041, 0.9691512840261041, 0.9691512840261041, 0.9637847631450107, 0.9637847631450107, 0.9637847631450107, 0.1302474506357263, 0.1302474506357263, 0.1302474506357263, 0.09878424275587516, 0.09878424275587516, 0.09878424275587516, 0.11113583826220497, 0.11113583826220497, 0.11113583826220497, 0.16118657274658, 0.16118657274658, 0.16118657274658, 0.16491591421182605, 0.16491591421182605, 0.16491591421182605, 0.16121976915092817, 0.16121976915092817, 0.16121976915092817, 0.05796735120810648, 0.05796735120810648, 0.05796735120810648, 0.07339198581074347, 0.07339198581074347, 0.07339198581074347, 0.07139559696985565, 0.07139559696985565, 0.07139559696985565, 0.07332428871437424, 0.07332428871437424, 0.07332428871437424, 0.017723355370008687, 0.017723355370008687, 0.017723355370008687, 0.036217418488760034, 0.036217418488760034, 0.036217418488760034, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.041870388284840354, 0.041870388284840354, 0.041870388284840354, 0.009927506027068378, 0.009927506027068378, 0.009927506027068378, 0.009821722873785577, 0.009821722873785577, 0.009821722873785577, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.016987360955234343, 0.016987360955234343, 0.016987360955234343, 0.020971982127532263, 0.020971982127532263, 0.020971982127532263, 0.035992989561298594, 0.035992989561298594, 0.035992989561298594, 0.2658391379141286, 0.2658391379141286, 0.2658391379141286, 0.27699211743176955, 0.27699211743176955, 0.27699211743176955, 0.26365647093929045, 0.26365647093929045, 0.26365647093929045, 0.06373903029738048, 0.06373903029738048, 0.06373903029738048, 0.07499973255318959, 0.07499973255318959, 0.07499973255318959, 0.0675912469407276, 0.0675912469407276, 0.0675912469407276, 0.11807503010910825, 0.11807503010910825, 0.11807503010910825, 0.17748115671596876, 0.17748115671596876, 0.17748115671596876, 0.16271633743427372, 0.16271633743427372, 0.16271633743427372, 0.1756742452904546, 0.1756742452904546, 0.1756742452904546, 0.18072600053913068, 0.18072600053913068, 0.18072600053913068, 0.21446875478762917, 0.21446875478762917, 0.21446875478762917, 0.10590224823414551, 0.10590224823414551, 0.10590224823414551, 0.14175144203733303, 0.14175144203733303, 0.14175144203733303, 0.15352200872552402, 0.15352200872552402, 0.15352200872552402, 0.15813159249130382, 0.15813159249130382, 0.15813159249130382, 0.1586825231486697, 0.1586825231486697, 0.1586825231486697, 0.23268804612264526, 0.23268804612264526, 0.23268804612264526, 0.15364327197042582, 0.15364327197042582, 0.15364327197042582, 0.1603528914719986, 0.1603528914719986, 0.1603528914719986, 0.15572041802272962, 0.15572041802272962, 0.15572041802272962, 0.35470030012786924, 0.35470030012786924, 0.35470030012786924, 0.14891054347379173, 0.14891054347379173, 0.14891054347379173, 0.1683515926619219, 0.1683515926619219, 0.1683515926619219, 0.16452983574999358, 0.16452983574999358, 0.16452983574999358, 0.17065183948933083, 0.17065183948933083, 0.17065183948933083, 0.14830519947176635, 0.14830519947176635, 0.14830519947176635, 0.18331693934776172, 0.18331693934776172, 0.18331693934776172, 0.18061527940749678, 0.18061527940749678, 0.18061527940749678, 0.1795797056450228, 0.1795797056450228, 0.1795797056450228, 0.0633714511170399, 0.0633714511170399, 0.0633714511170399, 0.05996877490314623, 0.05996877490314623, 0.05996877490314623, 0.05050498579883367, 0.05050498579883367, 0.05050498579883367]}, "mutation_prompt": null}
{"id": "04ad4665-d20b-4d6c-bd51-b0bf854ae9f0", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "27ca7bf2-6836-4fe6-bc3f-e6ac70e42f48", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "77153590-4a72-4b31-aaa2-cb07554e7a32", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "f5741fa6-8bef-4f51-9f10-c199977f64bc", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_constant = 2.1\n        self.social_constant = 2.1\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        iteration = 0\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_initial - (self.inertia_weight_initial - self.inertia_weight_final) * (evaluations / self.budget)\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase with Diversity Preservation\n            diversity_threshold = 0.1 * (self.upper_bound - self.lower_bound)\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                if np.linalg.norm(particles[i] - global_best_position) < diversity_threshold:\n                    local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                else:\n                    local_candidate = particles[i] + np.random.uniform(-0.05, 0.05, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            iteration += 1\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm using adaptive inertia and diversity preservation to improve convergence in complex landscapes.", "configspace": "", "generation": 9, "fitness": 0.14180359871592538, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.2595145643551241, 0.2595145643551241, 0.2595145643551241, 0.28109702511589596, 0.28109702511589596, 0.28109702511589596, 0.2833211504410258, 0.2833211504410258, 0.2833211504410258, 0.009761676944574749, 0.009761676944574749, 0.009761676944574749, 0.0, 0.0, 0.0, 0.004961595181600553, 0.004961595181600553, 0.004961595181600553, 0.06503273825899092, 0.06503273825899092, 0.06503273825899092, 0.06720678590656337, 0.06720678590656337, 0.06720678590656337, 0.06678363461302395, 0.06678363461302395, 0.06678363461302395, 0.04935676355361085, 0.04935676355361085, 0.04935676355361085, 0.035822639799520384, 0.035822639799520384, 0.035822639799520384, 0.06601738328211981, 0.06601738328211981, 0.06601738328211981, 0.9636454837267423, 0.9636454837267423, 0.9636454837267423, 0.9686795075642015, 0.9686795075642015, 0.9686795075642015, 0.9680882138141808, 0.9680882138141808, 0.9680882138141808, 0.09765022360385245, 0.09765022360385245, 0.09765022360385245, 0.09645723562700892, 0.09645723562700892, 0.09645723562700892, 0.12112074801177386, 0.12112074801177386, 0.12112074801177386, 0.11807452642074112, 0.11807452642074112, 0.11807452642074112, 0.1364783797582113, 0.1364783797582113, 0.1364783797582113, 0.12860988847739696, 0.12860988847739696, 0.12860988847739696, 0.040875545305279815, 0.040875545305279815, 0.040875545305279815, 0.06867117671471112, 0.06867117671471112, 0.06867117671471112, 0.03572485970402617, 0.03572485970402617, 0.03572485970402617, 0.03330256228292072, 0.03330256228292072, 0.03330256228292072, 0.05464475301967919, 0.05464475301967919, 0.05464475301967919, 0.03879457995294999, 0.03879457995294999, 0.03879457995294999, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03914278692964779, 0.03914278692964779, 0.03914278692964779, 0.0032289448457996084, 0.0032289448457996084, 0.0032289448457996084, 0.01757383946356017, 0.01757383946356017, 0.01757383946356017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.024053022459481377, 0.024053022459481377, 0.024053022459481377, 0.01512182543476881, 0.01512182543476881, 0.01512182543476881, 0.032332442703050024, 0.032332442703050024, 0.032332442703050024, 0.2664619371345527, 0.2664619371345527, 0.2664619371345527, 0.23594929238286533, 0.23594929238286533, 0.23594929238286533, 0.23819530790497423, 0.23819530790497423, 0.23819530790497423, 0.07371598302094551, 0.07371598302094551, 0.07371598302094551, 0.0439833024191878, 0.0439833024191878, 0.0439833024191878, 0.05209862204312454, 0.05209862204312454, 0.05209862204312454, 0.14897565065658036, 0.14897565065658036, 0.14897565065658036, 0.14426107238066543, 0.14426107238066543, 0.14426107238066543, 0.12926912878066665, 0.12926912878066665, 0.12926912878066665, 0.16787184169811298, 0.16787184169811298, 0.16787184169811298, 0.2004650384808946, 0.2004650384808946, 0.2004650384808946, 0.19771197918098204, 0.19771197918098204, 0.19771197918098204, 0.10755242772680973, 0.10755242772680973, 0.10755242772680973, 0.13895549410214192, 0.13895549410214192, 0.13895549410214192, 0.14482180051710125, 0.14482180051710125, 0.14482180051710125, 0.150225808313717, 0.150225808313717, 0.150225808313717, 0.1671819728984052, 0.1671819728984052, 0.1671819728984052, 0.16267368095877555, 0.16267368095877555, 0.16267368095877555, 0.16186628903158196, 0.16186628903158196, 0.16186628903158196, 0.1558134562184187, 0.1558134562184187, 0.1558134562184187, 0.14574996718335642, 0.14574996718335642, 0.14574996718335642, 0.33904495525412004, 0.33904495525412004, 0.33904495525412004, 0.14963127914522245, 0.14963127914522245, 0.14963127914522245, 0.1632555770181633, 0.1632555770181633, 0.1632555770181633, 0.16274082078682872, 0.16274082078682872, 0.16274082078682872, 0.15572559684108378, 0.15572559684108378, 0.15572559684108378, 0.13589289523245862, 0.13589289523245862, 0.13589289523245862, 0.18158249701185158, 0.18158249701185158, 0.18158249701185158, 0.17272800687091527, 0.17272800687091527, 0.17272800687091527, 0.18391892092378448, 0.18391892092378448, 0.18391892092378448, 0.048456837496996585, 0.048456837496996585, 0.048456837496996585, 0.04575125315771056, 0.04575125315771056, 0.04575125315771056, 0.046183911501599284, 0.046183911501599284, 0.046183911501599284]}, "mutation_prompt": null}
{"id": "d171fd8f-fcf9-4b87-ad96-aa42e9f870c0", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size\n        self.inertia_weight = 0.9  # Dynamic inertia weight initialization\n        self.cognitive_constant = 2.0  # Increased cognitive constant\n        self.social_constant = 2.0  # Increased social constant\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            # Dynamic inertia weight update\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Adaptive Local Search Phase\n            local_search_range = 0.05 + 0.05 * (global_best_score / max(scores))\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-local_search_range, local_search_range, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_DE_ALS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_DE_ALS", "description": "A Heuristic combining Particle Swarm Optimization with Differential Evolution and Adaptive Local Search improved by dynamic velocity updates and adaptive parameter tuning.", "configspace": "", "generation": 10, "fitness": 0.14219739616339425, "feedback": "The algorithm EnhancedHybridPSO_DE_ALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.23993534698643448, 0.23993534698643448, 0.23993534698643448, 0.29863027247488005, 0.29863027247488005, 0.29863027247488005, 0.2694943437311058, 0.2694943437311058, 0.2694943437311058, 0.0054573949548666345, 0.0054573949548666345, 0.0054573949548666345, 0.0, 0.0, 0.0, 0.001406825118783317, 0.001406825118783317, 0.001406825118783317, 0.06142183999487183, 0.06142183999487183, 0.06142183999487183, 0.09398081541671677, 0.09398081541671677, 0.09398081541671677, 0.06633900655280289, 0.06633900655280289, 0.06633900655280289, 0.02619039264948586, 0.02619039264948586, 0.02619039264948586, 0.036936929667049534, 0.036936929667049534, 0.036936929667049534, 0.028655018587316783, 0.028655018587316783, 0.028655018587316783, 0.9772560157813847, 0.9772560157813847, 0.9772560157813847, 0.9750820265105739, 0.9750820265105739, 0.9750820265105739, 0.9762063274495097, 0.9762063274495097, 0.9762063274495097, 0.09417211988686103, 0.09417211988686103, 0.09417211988686103, 0.09209067891066502, 0.09209067891066502, 0.09209067891066502, 0.09373826288312792, 0.09373826288312792, 0.09373826288312792, 0.11510416559473668, 0.11510416559473668, 0.11510416559473668, 0.14015456461831366, 0.14015456461831366, 0.14015456461831366, 0.15499606529209853, 0.15499606529209853, 0.15499606529209853, 0.009564067508718632, 0.009564067508718632, 0.009564067508718632, 0.05385005258132913, 0.05385005258132913, 0.05385005258132913, 0.07556269187729359, 0.07556269187729359, 0.07556269187729359, 0.06591598584488678, 0.06591598584488678, 0.06591598584488678, 0.0379740863865482, 0.0379740863865482, 0.0379740863865482, 0.031016942930826907, 0.031016942930826907, 0.031016942930826907, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03164389561304193, 0.03164389561304193, 0.03164389561304193, 0.004658832406845281, 0.004658832406845281, 0.004658832406845281, 0.02695796279250462, 0.02695796279250462, 0.02695796279250462, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02278570719942441, 0.02278570719942441, 0.02278570719942441, 0.01645278167646025, 0.01645278167646025, 0.01645278167646025, 0.03331736689074005, 0.03331736689074005, 0.03331736689074005, 0.27315567804183893, 0.27315567804183893, 0.27315567804183893, 0.24818652110913186, 0.24818652110913186, 0.24818652110913186, 0.22588127113990708, 0.22588127113990708, 0.22588127113990708, 0.0596014462162997, 0.0596014462162997, 0.0596014462162997, 0.07246631588734276, 0.07246631588734276, 0.07246631588734276, 0.07883405045639647, 0.07883405045639647, 0.07883405045639647, 0.12976766810225127, 0.12976766810225127, 0.12976766810225127, 0.12180011791832002, 0.12180011791832002, 0.12180011791832002, 0.12939012946606288, 0.12939012946606288, 0.12939012946606288, 0.18548055052370627, 0.18548055052370627, 0.18548055052370627, 0.1756975084785155, 0.1756975084785155, 0.1756975084785155, 0.19719330458985773, 0.19719330458985773, 0.19719330458985773, 0.11317054470884647, 0.11317054470884647, 0.11317054470884647, 0.12493335597047261, 0.12493335597047261, 0.12493335597047261, 0.10413358837391862, 0.10413358837391862, 0.10413358837391862, 0.1725956303873578, 0.1725956303873578, 0.1725956303873578, 0.1414117987560074, 0.1414117987560074, 0.1414117987560074, 0.15632324981767975, 0.15632324981767975, 0.15632324981767975, 0.16077291199304367, 0.16077291199304367, 0.16077291199304367, 0.1511797422885005, 0.1511797422885005, 0.1511797422885005, 0.16899549176120976, 0.16899549176120976, 0.16899549176120976, 0.3179990141401301, 0.3179990141401301, 0.3179990141401301, 0.16203497670264932, 0.16203497670264932, 0.16203497670264932, 0.16065679930631882, 0.16065679930631882, 0.16065679930631882, 0.15703061567921428, 0.15703061567921428, 0.15703061567921428, 0.17123896404827088, 0.17123896404827088, 0.17123896404827088, 0.1861463644978546, 0.1861463644978546, 0.1861463644978546, 0.1962164296744473, 0.1962164296744473, 0.1962164296744473, 0.1818013968162735, 0.1818013968162735, 0.1818013968162735, 0.18953646769155574, 0.18953646769155574, 0.18953646769155574, 0.05755550207352644, 0.05755550207352644, 0.05755550207352644, 0.053373171116735785, 0.053373171116735785, 0.053373171116735785, 0.056703159260537594, 0.056703159260537594, 0.056703159260537594]}, "mutation_prompt": null}
{"id": "bb0ba8f4-f0e2-45dc-aa60-1c199d462b42", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.dynamic_population = True\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = self.initial_population_size\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += population_size\n\n            for i in range(population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight_dynamic = 0.4 + 0.5 * (1 - evaluations / self.budget)\n            r1 = np.random.rand(population_size, self.dim)\n            r2 = np.random.rand(population_size, self.dim)\n            velocities = (inertia_weight_dynamic * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            if self.dynamic_population and evaluations < self.budget / 2:\n                population_size = max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS_Enhanced(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS_Enhanced", "description": "Enhanced hybrid algorithm using adaptive inertia weight and dynamic population size for improved convergence speed.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (49,5) (50,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (49,5) (50,5) ')", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {}, "mutation_prompt": null}
{"id": "ecd3e276-a536-4240-be62-4ffb8b9ec192", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "239302c1-2240-4952-b07d-ce7f71953715", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "4f1f1e5a-122a-48d4-8059-ffd00fa12b06", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population for better exploration\n        self.inertia_weight = 0.7  # Adjusted for better exploration\n        self.cognitive_constant = 1.4\n        self.social_constant = 1.6  # Slightly increased to enhance convergence\n        self.mutation_factor = 0.6  # Adjusted to enhance diversity\n        self.crossover_rate = 0.9  # Increased for better exploration\n        self.learning_rate = 0.1  # Q-learning rate for adaptive inertia weight\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                self.social_constant * r2 * (global_best_position - particles)\n            )\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search with strategic step size adaptation\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                step_size = np.random.uniform(-0.2, 0.2, self.dim)  # Increased step size range\n                local_candidate = particles[i] + step_size\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            # Adaptive inertia weight adjustment (Q-learning inspired)\n            reward = np.mean(personal_best_scores) - global_best_score\n            self.inertia_weight += self.learning_rate * reward\n            self.inertia_weight = np.clip(self.inertia_weight, 0.4, 0.9)\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm integrating Q-learning-based adaptive PSO with self-adaptive DE and strategic local search to accelerate convergence.", "configspace": "", "generation": 14, "fitness": 0.14285177389844894, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.25087871617586466, 0.25087871617586466, 0.25087871617586466, 0.28899038992041537, 0.28899038992041537, 0.28899038992041537, 0.2509600594031236, 0.2509600594031236, 0.2509600594031236, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.017602012627731756, 0.017602012627731756, 0.017602012627731756, 0.06419592557779086, 0.06419592557779086, 0.06419592557779086, 0.08562192106147193, 0.08562192106147193, 0.08562192106147193, 0.05591770539992014, 0.05591770539992014, 0.05591770539992014, 0.060946037088772, 0.060946037088772, 0.060946037088772, 0.04248646787040922, 0.04248646787040922, 0.04248646787040922, 0.04423885640143943, 0.04423885640143943, 0.04423885640143943, 0.9632682995606034, 0.9632682995606034, 0.9632682995606034, 0.9764735608041485, 0.9764735608041485, 0.9764735608041485, 0.9753288160667519, 0.9753288160667519, 0.9753288160667519, 0.08700650075303096, 0.08700650075303096, 0.08700650075303096, 0.10949343979223702, 0.10949343979223702, 0.10949343979223702, 0.11544729074076676, 0.11544729074076676, 0.11544729074076676, 0.1820340390526337, 0.1820340390526337, 0.1820340390526337, 0.14174298932889995, 0.14174298932889995, 0.14174298932889995, 0.13015806415090314, 0.13015806415090314, 0.13015806415090314, 0.008623248681411733, 0.008623248681411733, 0.008623248681411733, 0.035725008958106264, 0.035725008958106264, 0.035725008958106264, 0.04154981616483344, 0.04154981616483344, 0.04154981616483344, 0.07665180404661842, 0.07665180404661842, 0.07665180404661842, 0.0, 0.0, 0.0, 0.018181054332031765, 0.018181054332031765, 0.018181054332031765, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.024161783250445157, 0.024161783250445157, 0.024161783250445157, 0.00476754514872213, 0.00476754514872213, 0.00476754514872213, 0.04237559003668989, 0.04237559003668989, 0.04237559003668989, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.008190521191221878, 0.008190521191221878, 0.008190521191221878, 0.010503555603893044, 0.010503555603893044, 0.010503555603893044, 0.029563914498747956, 0.029563914498747956, 0.029563914498747956, 0.2660632003036896, 0.2660632003036896, 0.2660632003036896, 0.2643619413619914, 0.2643619413619914, 0.2643619413619914, 0.20861651023258232, 0.20861651023258232, 0.20861651023258232, 0.08591343040633181, 0.08591343040633181, 0.08591343040633181, 0.06015156971935043, 0.06015156971935043, 0.06015156971935043, 0.06750358457502192, 0.06750358457502192, 0.06750358457502192, 0.13911837852000897, 0.13911837852000897, 0.13911837852000897, 0.1492292058513185, 0.1492292058513185, 0.1492292058513185, 0.12236736881259713, 0.12236736881259713, 0.12236736881259713, 0.1745129823081536, 0.1745129823081536, 0.1745129823081536, 0.21995465654554813, 0.21995465654554813, 0.21995465654554813, 0.2012433171543837, 0.2012433171543837, 0.2012433171543837, 0.11085598550216602, 0.11085598550216602, 0.11085598550216602, 0.11140307274983607, 0.11140307274983607, 0.11140307274983607, 0.09858605047817581, 0.09858605047817581, 0.09858605047817581, 0.1749339155965718, 0.1749339155965718, 0.1749339155965718, 0.19389055196861904, 0.19389055196861904, 0.19389055196861904, 0.16264528222944596, 0.16264528222944596, 0.16264528222944596, 0.15723434562987515, 0.15723434562987515, 0.15723434562987515, 0.15176537886836972, 0.15176537886836972, 0.15176537886836972, 0.15702373134577596, 0.15702373134577596, 0.15702373134577596, 0.35910414100564636, 0.35910414100564636, 0.35910414100564636, 0.1369133214962298, 0.1369133214962298, 0.1369133214962298, 0.167148790351762, 0.167148790351762, 0.167148790351762, 0.16293452434924205, 0.16293452434924205, 0.16293452434924205, 0.15121702692472916, 0.15121702692472916, 0.15121702692472916, 0.13689951483405371, 0.13689951483405371, 0.13689951483405371, 0.18193058040807297, 0.18193058040807297, 0.18193058040807297, 0.17889062543724776, 0.17889062543724776, 0.17889062543724776, 0.19705172204395893, 0.19705172204395893, 0.19705172204395893, 0.05278661518080985, 0.05278661518080985, 0.05278661518080985, 0.06905798759027171, 0.06905798759027171, 0.06905798759027171, 0.07093347721685017, 0.07093347721685017, 0.07093347721685017]}, "mutation_prompt": null}
{"id": "9f7dd4ea-4e80-4d69-adfc-d77c02578845", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size\n        self.inertia_weight_max = 0.9  # Dynamic inertia weight\n        self.inertia_weight_min = 0.4\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant\n        self.social_constant = 1.3  # Adjusted social constant\n        self.mutation_factor = 0.6  # Enhanced mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget))\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                crossover_indices = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector[crossover_indices] = mutant_vector[crossover_indices]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Optimized Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "An improved hybrid algorithm combining dynamic inertia weight PSO, enhanced DE with adaptive mutation, and optimized local search for accelerated convergence.", "configspace": "", "generation": 15, "fitness": 0.17582940002871755, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.4043548343887202, 0.4043548343887202, 0.4043548343887202, 0.40299329253165805, 0.40299329253165805, 0.40299329253165805, 0.39811605566296526, 0.39811605566296526, 0.39811605566296526, 0.020058873081972295, 0.020058873081972295, 0.020058873081972295, 0.017198011606121666, 0.017198011606121666, 0.017198011606121666, 0.010599423600754054, 0.010599423600754054, 0.010599423600754054, 0.09231241520441968, 0.09231241520441968, 0.09231241520441968, 0.06946597905504881, 0.06946597905504881, 0.06946597905504881, 0.07767905750476234, 0.07767905750476234, 0.07767905750476234, 0.05198868075363228, 0.05198868075363228, 0.05198868075363228, 0.06797126054252911, 0.06797126054252911, 0.06797126054252911, 0.06644121949058701, 0.06644121949058701, 0.06644121949058701, 0.9740411159461395, 0.9740411159461395, 0.9740411159461395, 0.9631097013677511, 0.9631097013677511, 0.9631097013677511, 0.9627936400305706, 0.9627936400305706, 0.9627936400305706, 0.16871720190914108, 0.16871720190914108, 0.16871720190914108, 0.1603815386605002, 0.1603815386605002, 0.1603815386605002, 0.19506737930924245, 0.19506737930924245, 0.19506737930924245, 0.19425698912732603, 0.19425698912732603, 0.19425698912732603, 0.2121133988489018, 0.2121133988489018, 0.2121133988489018, 0.1712693013751201, 0.1712693013751201, 0.1712693013751201, 0.09290353404055163, 0.09290353404055163, 0.09290353404055163, 0.0892138960028338, 0.0892138960028338, 0.0892138960028338, 0.0932106426763386, 0.0932106426763386, 0.0932106426763386, 0.08253503537788798, 0.08253503537788798, 0.08253503537788798, 0.034818523063792184, 0.034818523063792184, 0.034818523063792184, 0.1032600693054182, 0.1032600693054182, 0.1032600693054182, 0.0, 0.0, 0.0, 0.0028831371565424257, 0.0028831371565424257, 0.0028831371565424257, 0.0, 0.0, 0.0, 0.023949310551590997, 0.023949310551590997, 0.023949310551590997, 0.015776264084272018, 0.015776264084272018, 0.015776264084272018, 0.047052208239376725, 0.047052208239376725, 0.047052208239376725, 0.00910412178736808, 0.00910412178736808, 0.00910412178736808, 0.024460157470266863, 0.024460157470266863, 0.024460157470266863, 0.012699250982367793, 0.012699250982367793, 0.012699250982367793, 0.05766407539537899, 0.05766407539537899, 0.05766407539537899, 0.054804315199479814, 0.054804315199479814, 0.054804315199479814, 0.042156999578137455, 0.042156999578137455, 0.042156999578137455, 0.3546274027737458, 0.3546274027737458, 0.3546274027737458, 0.3480847581806028, 0.3480847581806028, 0.3480847581806028, 0.32391613832580346, 0.32391613832580346, 0.32391613832580346, 0.09389684380466679, 0.09389684380466679, 0.09389684380466679, 0.08041789826372314, 0.08041789826372314, 0.08041789826372314, 0.07786200202839155, 0.07786200202839155, 0.07786200202839155, 0.12348276231887045, 0.12348276231887045, 0.12348276231887045, 0.16294216146567309, 0.16294216146567309, 0.16294216146567309, 0.1623238847890519, 0.1623238847890519, 0.1623238847890519, 0.22650553773572335, 0.22650553773572335, 0.22650553773572335, 0.21182414595534893, 0.21182414595534893, 0.21182414595534893, 0.23464340802923522, 0.23464340802923522, 0.23464340802923522, 0.16323436387923362, 0.16323436387923362, 0.16323436387923362, 0.14462407279715883, 0.14462407279715883, 0.14462407279715883, 0.11977073470547661, 0.11977073470547661, 0.11977073470547661, 0.16810553695491726, 0.16810553695491726, 0.16810553695491726, 0.18709052075160326, 0.18709052075160326, 0.18709052075160326, 0.1922170142384092, 0.1922170142384092, 0.1922170142384092, 0.184820162422351, 0.184820162422351, 0.184820162422351, 0.1674671778475294, 0.1674671778475294, 0.1674671778475294, 0.19607490877176292, 0.19607490877176292, 0.19607490877176292, 0.5758275546701077, 0.5758275546701077, 0.5758275546701077, 0.15475787586282064, 0.15475787586282064, 0.15475787586282064, 0.16551464127011062, 0.16551464127011062, 0.16551464127011062, 0.28861140788858286, 0.28861140788858286, 0.28861140788858286, 0.1809115475359342, 0.1809115475359342, 0.1809115475359342, 0.14890398579136377, 0.14890398579136377, 0.14890398579136377, 0.1777729912981778, 0.1777729912981778, 0.1777729912981778, 0.1819650577386267, 0.1819650577386267, 0.1819650577386267, 0.17597102492283723, 0.17597102492283723, 0.17597102492283723, 0.06490946465457348, 0.06490946465457348, 0.06490946465457348, 0.061156705110235854, 0.061156705110235854, 0.061156705110235854, 0.09206219837554708, 0.09206219837554708, 0.09206219837554708]}, "mutation_prompt": null}
{"id": "f98d4d29-2354-4198-a747-ba9a4e36b7c5", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "3a8d7d9d-1702-4508-b1fe-5f0043ed78b9", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population for better exploration\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9  # Slightly increased to explore more diversity\n        self.alpha = 1.5  # Levy flight parameter\n\n    def levy_flight(self, size):\n        sigma = (np.gamma(1 + self.alpha) * np.sin(np.pi * self.alpha / 2) /\n                 (np.gamma((1 + self.alpha) / 2) * self.alpha *\n                  2 ** ((self.alpha - 1) / 2))) ** (1 / self.alpha)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / abs(v) ** (1 / self.alpha)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            inertia_weight = (self.inertia_weight_final +\n                              (self.inertia_weight_initial - self.inertia_weight_final) *\n                              ((self.budget - evaluations) / self.budget))\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Improved Local Search with Levy Flight\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                levy_step = self.levy_flight(self.dim)\n                local_candidate = particles[i] + levy_step\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "Enhanced hybrid algorithm incorporating dynamic parameter adjustment and Levy flight for exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {}, "mutation_prompt": null}
{"id": "ba4b9080-72f2-4008-995b-e5ec3d59c4ed", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "f076d746-7628-478f-b825-0c8f0b64a0a3", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "d71d6bd2-3ac1-4793-96c5-a68a3af51f4e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population for better exploration\n        self.inertia_weight = 0.6  # Slightly increased inertia to stabilize exploration\n        self.cognitive_constant = 1.2  # Reduced cognitive constant to balance personal vs. global influence\n        self.social_constant = 1.8  # Increased social constant for stronger convergence\n        self.mutation_factor = 0.6  # Increased mutation factor for more diverse solutions\n        self.crossover_rate = 0.9  # Higher crossover rate to encourage exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3  # More variance in mutation factor\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                candidates = particles[i] + np.random.uniform(-0.2, 0.2, (5, self.dim))  # More local candidates\n                candidates = np.clip(candidates, self.lower_bound, self.upper_bound)\n                local_scores = np.apply_along_axis(func, 1, candidates)\n                evaluations += 5\n                best_local_idx = np.argmin(local_scores)\n                if local_scores[best_local_idx] < scores[i]:\n                    particles[i] = candidates[best_local_idx]\n                    scores[i] = local_scores[best_local_idx]\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "A faster adaptive hybrid algorithm combining enhanced PSO with adaptive DE and greedy local search for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.16694429874094702, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.33306411978554984, 0.33306411978554984, 0.33306411978554984, 0.3120390481483981, 0.3120390481483981, 0.3120390481483981, 0.3595854155309057, 0.3595854155309057, 0.3595854155309057, 0.013809159112462499, 0.013809159112462499, 0.013809159112462499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003232892456757175, 0.003232892456757175, 0.003232892456757175, 0.09346128790182506, 0.09346128790182506, 0.09346128790182506, 0.0546335425150668, 0.0546335425150668, 0.0546335425150668, 0.0772123644461642, 0.0772123644461642, 0.0772123644461642, 0.058704857102870656, 0.058704857102870656, 0.058704857102870656, 0.06800746541068092, 0.06800746541068092, 0.06800746541068092, 0.047398728892323216, 0.047398728892323216, 0.047398728892323216, 0.9235240792889292, 0.9235240792889292, 0.9235240792889292, 0.9253124237214976, 0.9253124237214976, 0.9253124237214976, 0.9191015950141406, 0.9191015950141406, 0.9191015950141406, 0.16080027494370264, 0.16080027494370264, 0.16080027494370264, 0.18384122718567308, 0.18384122718567308, 0.18384122718567308, 0.13912295179257506, 0.13912295179257506, 0.13912295179257506, 0.19339193840068758, 0.19339193840068758, 0.19339193840068758, 0.15029247955876368, 0.15029247955876368, 0.15029247955876368, 0.1560224912924485, 0.1560224912924485, 0.1560224912924485, 0.08887783304676633, 0.08887783304676633, 0.08887783304676633, 0.08504189684901198, 0.08504189684901198, 0.08504189684901198, 0.12405874282174989, 0.12405874282174989, 0.12405874282174989, 0.07981869345554149, 0.07981869345554149, 0.07981869345554149, 0.07907940691725002, 0.07907940691725002, 0.07907940691725002, 0.009453185234670092, 0.009453185234670092, 0.009453185234670092, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08646570467511827, 0.08646570467511827, 0.08646570467511827, 0.04442787853441421, 0.04442787853441421, 0.04442787853441421, 0.0582273091814659, 0.0582273091814659, 0.0582273091814659, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04523785241745626, 0.04523785241745626, 0.04523785241745626, 0.030314434345161456, 0.030314434345161456, 0.030314434345161456, 0.04799254403043074, 0.04799254403043074, 0.04799254403043074, 0.33142430720363814, 0.33142430720363814, 0.33142430720363814, 0.31012615150821565, 0.31012615150821565, 0.31012615150821565, 0.29511163635952864, 0.29511163635952864, 0.29511163635952864, 0.07987162723086871, 0.07987162723086871, 0.07987162723086871, 0.08590341076296792, 0.08590341076296792, 0.08590341076296792, 0.07443168020468638, 0.07443168020468638, 0.07443168020468638, 0.1909861833592027, 0.1909861833592027, 0.1909861833592027, 0.16153687012606555, 0.16153687012606555, 0.16153687012606555, 0.1633726850531264, 0.1633726850531264, 0.1633726850531264, 0.2258269336492884, 0.2258269336492884, 0.2258269336492884, 0.2080364798107428, 0.2080364798107428, 0.2080364798107428, 0.22442203433994146, 0.22442203433994146, 0.22442203433994146, 0.13613392101686017, 0.13613392101686017, 0.13613392101686017, 0.13312162677951545, 0.13312162677951545, 0.13312162677951545, 0.11457079870379616, 0.11457079870379616, 0.11457079870379616, 0.173907528027334, 0.173907528027334, 0.173907528027334, 0.19853063451384634, 0.19853063451384634, 0.19853063451384634, 0.1954414301550751, 0.1954414301550751, 0.1954414301550751, 0.18096430605126557, 0.18096430605126557, 0.18096430605126557, 0.17076815813298896, 0.17076815813298896, 0.17076815813298896, 0.17106774539899894, 0.17106774539899894, 0.17106774539899894, 0.5462827447327723, 0.5462827447327723, 0.5462827447327723, 0.15074347553734901, 0.15074347553734901, 0.15074347553734901, 0.16404320909090253, 0.16404320909090253, 0.16404320909090253, 0.27513006049971833, 0.27513006049971833, 0.27513006049971833, 0.17986243862614681, 0.17986243862614681, 0.17986243862614681, 0.15090650297349928, 0.15090650297349928, 0.15090650297349928, 0.18008955240459723, 0.18008955240459723, 0.18008955240459723, 0.18170156218991285, 0.18170156218991285, 0.18170156218991285, 0.16888495626130462, 0.16888495626130462, 0.16888495626130462, 0.0727630791720052, 0.0727630791720052, 0.0727630791720052, 0.07348169788191394, 0.07348169788191394, 0.07348169788191394, 0.0982902575796526, 0.0982902575796526, 0.0982902575796526]}, "mutation_prompt": null}
{"id": "ba363b7a-62ca-44a5-bca5-f5d87ab7f859", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Adjusted inertia weight for exploration-exploitation balance\n        self.cognitive_constant_base = 1.5\n        self.social_constant_base = 1.5\n        self.mutation_factor = 0.6  # Slightly increased mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better exploration\n\n    def levy_flight(self, scale):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1/3)\n        return step\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            # Dynamic adjustment of cognitive and social constants\n            cognitive_constant = self.cognitive_constant_base * (0.5 + 0.5 * np.random.rand())\n            social_constant = self.social_constant_base * (0.5 + 0.5 * np.random.rand())\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          cognitive_constant * r1 * (personal_best_positions - particles) +\n                          social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Levy flight mechanism for exploration\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                levy_step = self.levy_flight(0.1)\n                local_candidate = particles[i] + levy_step\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "Introducing a dynamic adjustment of cognitive and social constants and incorporating a Levy flight mechanism for exploration to enhance convergence speed.", "configspace": "", "generation": 21, "fitness": 0.2221361690444225, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.57696079082088, 0.57696079082088, 0.57696079082088, 0.5803600123141209, 0.5803600123141209, 0.5803600123141209, 0.6016206852508753, 0.6016206852508753, 0.6016206852508753, 0.029435117066707206, 0.029435117066707206, 0.029435117066707206, 0.23614845358172243, 0.23614845358172243, 0.23614845358172243, 0.21579388622170304, 0.21579388622170304, 0.21579388622170304, 0.11186486717528987, 0.11186486717528987, 0.11186486717528987, 0.09789364323349403, 0.09789364323349403, 0.09789364323349403, 0.10326599475753051, 0.10326599475753051, 0.10326599475753051, 0.07646576060610055, 0.07646576060610055, 0.07646576060610055, 0.09458558395849281, 0.09458558395849281, 0.09458558395849281, 0.07878324967575645, 0.07878324967575645, 0.07878324967575645, 0.9669434264948527, 0.9669434264948527, 0.9669434264948527, 0.9572942560797495, 0.9572942560797495, 0.9572942560797495, 0.942104064278132, 0.942104064278132, 0.942104064278132, 0.26065974312812745, 0.26065974312812745, 0.26065974312812745, 0.24075519432786763, 0.24075519432786763, 0.24075519432786763, 0.25022268575633067, 0.25022268575633067, 0.25022268575633067, 0.30643095461137404, 0.30643095461137404, 0.30643095461137404, 0.20490046774427428, 0.20490046774427428, 0.20490046774427428, 0.24328003710941248, 0.24328003710941248, 0.24328003710941248, 0.16699060006045707, 0.16699060006045707, 0.16699060006045707, 0.11711078222201465, 0.11711078222201465, 0.11711078222201465, 0.1426554267138599, 0.1426554267138599, 0.1426554267138599, 0.16232115563057847, 0.16232115563057847, 0.16232115563057847, 0.15647253381697757, 0.15647253381697757, 0.15647253381697757, 0.10006539919394819, 0.10006539919394819, 0.10006539919394819, 0.0, 0.0, 0.0, 0.000829636899390751, 0.000829636899390751, 0.000829636899390751, 0.0, 0.0, 0.0, 0.03735182908044843, 0.03735182908044843, 0.03735182908044843, 0.05150899264477615, 0.05150899264477615, 0.05150899264477615, 0.07381671732200157, 0.07381671732200157, 0.07381671732200157, 0.1036124678804008, 0.1036124678804008, 0.1036124678804008, 0.033360260691856825, 0.033360260691856825, 0.033360260691856825, 0.051402138930527475, 0.051402138930527475, 0.051402138930527475, 0.09540148989488584, 0.09540148989488584, 0.09540148989488584, 0.13433201059871225, 0.13433201059871225, 0.13433201059871225, 0.07725229041992587, 0.07725229041992587, 0.07725229041992587, 0.43449667770179234, 0.43449667770179234, 0.43449667770179234, 0.42233721874387875, 0.42233721874387875, 0.42233721874387875, 0.43369680183469383, 0.43369680183469383, 0.43369680183469383, 0.08905897080470238, 0.08905897080470238, 0.08905897080470238, 0.12022324599825318, 0.12022324599825318, 0.12022324599825318, 0.09596965367117605, 0.09596965367117605, 0.09596965367117605, 0.1851121182616512, 0.1851121182616512, 0.1851121182616512, 0.131746137203127, 0.131746137203127, 0.131746137203127, 0.16612667244265777, 0.16612667244265777, 0.16612667244265777, 0.31347962567823606, 0.31347962567823606, 0.31347962567823606, 0.2482259113319446, 0.2482259113319446, 0.2482259113319446, 0.31201103165884236, 0.31201103165884236, 0.31201103165884236, 0.14422459422287992, 0.14422459422287992, 0.14422459422287992, 0.237269433498005, 0.237269433498005, 0.237269433498005, 0.2347262661291768, 0.2347262661291768, 0.2347262661291768, 0.19510784845719964, 0.19510784845719964, 0.19510784845719964, 0.2003932751955816, 0.2003932751955816, 0.2003932751955816, 0.21076703094886984, 0.21076703094886984, 0.21076703094886984, 0.2009975370193794, 0.2009975370193794, 0.2009975370193794, 0.1807821047722158, 0.1807821047722158, 0.1807821047722158, 0.18921528809108645, 0.18921528809108645, 0.18921528809108645, 0.7484237075336024, 0.7484237075336024, 0.7484237075336024, 0.16115844582057637, 0.16115844582057637, 0.16115844582057637, 0.13422559193957206, 0.13422559193957206, 0.13422559193957206, 0.2041321303815059, 0.2041321303815059, 0.2041321303815059, 0.36835167380581924, 0.36835167380581924, 0.36835167380581924, 0.15312036416418273, 0.15312036416418273, 0.15312036416418273, 0.18131637366345765, 0.18131637366345765, 0.18131637366345765, 0.1794364151324518, 0.1794364151324518, 0.1794364151324518, 0.1984010893422784, 0.1984010893422784, 0.1984010893422784, 0.07044261586711842, 0.07044261586711842, 0.07044261586711842, 0.07855889832804874, 0.07855889832804874, 0.07855889832804874, 0.09001681536090078, 0.09001681536090078, 0.09001681536090078]}, "mutation_prompt": null}
{"id": "5fe0f2ca-37dd-4900-bfb7-c4bb07f528f3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_constant = 2.0  # Increased learning rate\n        self.social_constant = 2.0  # Increased social influence\n        self.mutation_factor = 0.6  # Adaptive mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        no_improvement_iterations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n                    no_improvement_iterations = 0\n                else:\n                    no_improvement_iterations += 1\n\n            if no_improvement_iterations > 10:  # Reinitialize some particles if no improvement\n                reinit_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.1), replace=False)\n                particles[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                no_improvement_iterations = 0\n\n            # Local Search Phase with extended search range\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced convergence algorithm integrating adaptive learning rates, diverse mutation strategies, and strategic reinitialization to accelerate performance.", "configspace": "", "generation": 22, "fitness": 0.15406217937624, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.28857241710550385, 0.28857241710550385, 0.28857241710550385, 0.3357409804407431, 0.3357409804407431, 0.3357409804407431, 0.37179146099285176, 0.37179146099285176, 0.37179146099285176, 0.04409744631244794, 0.04409744631244794, 0.04409744631244794, 0.006045972601254834, 0.006045972601254834, 0.006045972601254834, 0.034402515135889544, 0.034402515135889544, 0.034402515135889544, 0.06612605902680302, 0.06612605902680302, 0.06612605902680302, 0.08178607557433115, 0.08178607557433115, 0.08178607557433115, 0.06862088317853177, 0.06862088317853177, 0.06862088317853177, 0.04503547495677718, 0.04503547495677718, 0.04503547495677718, 0.046539012780419164, 0.046539012780419164, 0.046539012780419164, 0.04901681891734755, 0.04901681891734755, 0.04901681891734755, 0.968205346268451, 0.968205346268451, 0.968205346268451, 0.9682673041141447, 0.9682673041141447, 0.9682673041141447, 0.967621120058201, 0.967621120058201, 0.967621120058201, 0.10294527631770667, 0.10294527631770667, 0.10294527631770667, 0.1056395887211522, 0.1056395887211522, 0.1056395887211522, 0.11608437685527717, 0.11608437685527717, 0.11608437685527717, 0.18196156551165654, 0.18196156551165654, 0.18196156551165654, 0.15836609319477835, 0.15836609319477835, 0.15836609319477835, 0.13681717515589387, 0.13681717515589387, 0.13681717515589387, 0.06561633706791259, 0.06561633706791259, 0.06561633706791259, 0.07840001185716228, 0.07840001185716228, 0.07840001185716228, 0.04479935728064699, 0.04479935728064699, 0.04479935728064699, 0.08098239087439507, 0.08098239087439507, 0.08098239087439507, 0.07732896747808116, 0.07732896747808116, 0.07732896747808116, 0.03129240701638081, 0.03129240701638081, 0.03129240701638081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05162814913051039, 0.05162814913051039, 0.05162814913051039, 0.012208872089821687, 0.012208872089821687, 0.012208872089821687, 0.07611382737635775, 0.07611382737635775, 0.07611382737635775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03621908242885563, 0.03621908242885563, 0.03621908242885563, 0.03687125155319937, 0.03687125155319937, 0.03687125155319937, 0.03551679755205461, 0.03551679755205461, 0.03551679755205461, 0.31516483405977624, 0.31516483405977624, 0.31516483405977624, 0.2775477302031307, 0.2775477302031307, 0.2775477302031307, 0.26945022892841786, 0.26945022892841786, 0.26945022892841786, 0.07916652059591855, 0.07916652059591855, 0.07916652059591855, 0.04954881635038544, 0.04954881635038544, 0.04954881635038544, 0.0697461003084181, 0.0697461003084181, 0.0697461003084181, 0.14016811971327003, 0.14016811971327003, 0.14016811971327003, 0.11822269745837966, 0.11822269745837966, 0.11822269745837966, 0.1747231238176833, 0.1747231238176833, 0.1747231238176833, 0.17891618765547246, 0.17891618765547246, 0.17891618765547246, 0.15492491116483542, 0.15492491116483542, 0.15492491116483542, 0.22346682546561947, 0.22346682546561947, 0.22346682546561947, 0.11391160441131165, 0.11391160441131165, 0.11391160441131165, 0.12221449394214745, 0.12221449394214745, 0.12221449394214745, 0.13218414443382753, 0.13218414443382753, 0.13218414443382753, 0.16171721115905424, 0.16171721115905424, 0.16171721115905424, 0.16323022657139952, 0.16323022657139952, 0.16323022657139952, 0.15185975015860698, 0.15185975015860698, 0.15185975015860698, 0.16134455100320155, 0.16134455100320155, 0.16134455100320155, 0.17685924368001238, 0.17685924368001238, 0.17685924368001238, 0.15865342022013518, 0.15865342022013518, 0.15865342022013518, 0.34773028424102437, 0.34773028424102437, 0.34773028424102437, 0.16766887586406787, 0.16766887586406787, 0.16766887586406787, 0.1580545685696345, 0.1580545685696345, 0.1580545685696345, 0.16517489231490468, 0.16517489231490468, 0.16517489231490468, 0.1805257601602882, 0.1805257601602882, 0.1805257601602882, 0.14499590736849854, 0.14499590736849854, 0.14499590736849854, 0.19223119327166038, 0.19223119327166038, 0.19223119327166038, 0.190916338800607, 0.190916338800607, 0.190916338800607, 0.19457390456135704, 0.19457390456135704, 0.19457390456135704, 0.06772934589935486, 0.06772934589935486, 0.06772934589935486, 0.06433102788208778, 0.06433102788208778, 0.06433102788208778, 0.054263659929251085, 0.054263659929251085, 0.054263659929251085]}, "mutation_prompt": null}
{"id": "ef4e23c8-2685-478a-8cc4-5cf6f4cd198b", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "a39a06db-04d3-41b1-b7d9-305772c8de6a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for better exploration\n        self.inertia_weight = 0.4  # Reduced inertia weight to enhance convergence speed\n        self.cognitive_constant = 1.2  # Adjusted cognitive factor\n        self.social_constant = 1.7  # Increased influence of global best\n        self.mutation_factor = 0.6  # Adjusted mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for higher exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor * (0.5 + np.random.rand() * 0.5)  # Dynamic mutation factor\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase with adaptive step size\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                adaptive_step_size = 0.05 + 0.05 * np.random.rand()\n                local_candidate = particles[i] + np.random.uniform(-adaptive_step_size, adaptive_step_size, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "A hybrid algorithm that integrates Particle Swarm Optimization with Adaptive Differential Evolution and Enhanced Local Search for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.2526705523153029, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.7416725172857266, 0.7416725172857266, 0.7416725172857266, 0.7388171598300253, 0.7388171598300253, 0.7388171598300253, 0.7339708740278159, 0.7339708740278159, 0.7339708740278159, 0.10220566467548975, 0.10220566467548975, 0.10220566467548975, 0.4644991229490514, 0.4644991229490514, 0.4644991229490514, 0.04815178120262609, 0.04815178120262609, 0.04815178120262609, 0.10807630453528405, 0.10807630453528405, 0.10807630453528405, 0.06612964457104831, 0.06612964457104831, 0.06612964457104831, 0.08834754473499107, 0.08834754473499107, 0.08834754473499107, 0.10746835489912065, 0.10746835489912065, 0.10746835489912065, 0.09575153786719925, 0.09575153786719925, 0.09575153786719925, 0.08766702428911322, 0.08766702428911322, 0.08766702428911322, 0.9461706971551991, 0.9461706971551991, 0.9461706971551991, 0.9616634663259476, 0.9616634663259476, 0.9616634663259476, 0.9631745205495459, 0.9631745205495459, 0.9631745205495459, 0.32385053397038377, 0.32385053397038377, 0.32385053397038377, 0.29150122441927895, 0.29150122441927895, 0.29150122441927895, 0.3845657282198326, 0.3845657282198326, 0.3845657282198326, 0.754817304417985, 0.754817304417985, 0.754817304417985, 0.15936656457384468, 0.15936656457384468, 0.15936656457384468, 0.12125279539634848, 0.12125279539634848, 0.12125279539634848, 0.11897881335880034, 0.11897881335880034, 0.11897881335880034, 0.1274198255318728, 0.1274198255318728, 0.1274198255318728, 0.12416075992982101, 0.12416075992982101, 0.12416075992982101, 0.001917028358737638, 0.001917028358737638, 0.001917028358737638, 0.20511013202150052, 0.20511013202150052, 0.20511013202150052, 0.08807604021122717, 0.08807604021122717, 0.08807604021122717, 0.0, 0.0, 0.0, 0.0075178501574473255, 0.0075178501574473255, 0.0075178501574473255, 0.0, 0.0, 0.0, 0.06445268645615976, 0.06445268645615976, 0.06445268645615976, 0.04385551451382963, 0.04385551451382963, 0.04385551451382963, 0.13650574823788042, 0.13650574823788042, 0.13650574823788042, 0.03728799857151821, 0.03728799857151821, 0.03728799857151821, 0.05967350607805344, 0.05967350607805344, 0.05967350607805344, 0.12766816185667518, 0.12766816185667518, 0.12766816185667518, 0.11573811714002769, 0.11573811714002769, 0.11573811714002769, 0.11900442193010241, 0.11900442193010241, 0.11900442193010241, 0.07609206747393049, 0.07609206747393049, 0.07609206747393049, 0.4746126350999127, 0.4746126350999127, 0.4746126350999127, 0.47092417114608365, 0.47092417114608365, 0.47092417114608365, 0.498549037299043, 0.498549037299043, 0.498549037299043, 0.08667350323974965, 0.08667350323974965, 0.08667350323974965, 0.12085777058900238, 0.12085777058900238, 0.12085777058900238, 0.0851666617062038, 0.0851666617062038, 0.0851666617062038, 0.2219318999521731, 0.2219318999521731, 0.2219318999521731, 0.18068474430312031, 0.18068474430312031, 0.18068474430312031, 0.22962526576797238, 0.22962526576797238, 0.22962526576797238, 0.37701390206997853, 0.37701390206997853, 0.37701390206997853, 0.38420960863893006, 0.38420960863893006, 0.38420960863893006, 0.34223607630532893, 0.34223607630532893, 0.34223607630532893, 0.1371005242765736, 0.1371005242765736, 0.1371005242765736, 0.2593884126495569, 0.2593884126495569, 0.2593884126495569, 0.2409901774840787, 0.2409901774840787, 0.2409901774840787, 0.19769232808587844, 0.19769232808587844, 0.19769232808587844, 0.18611681052915374, 0.18611681052915374, 0.18611681052915374, 0.21241966709259652, 0.21241966709259652, 0.21241966709259652, 0.1849720467206829, 0.1849720467206829, 0.1849720467206829, 0.19688213024863066, 0.19688213024863066, 0.19688213024863066, 0.5383073617793981, 0.5383073617793981, 0.5383073617793981, 0.8348225087348146, 0.8348225087348146, 0.8348225087348146, 0.15676043406056628, 0.15676043406056628, 0.15676043406056628, 0.16686397082322924, 0.16686397082322924, 0.16686397082322924, 0.46149873978427913, 0.46149873978427913, 0.46149873978427913, 0.20727453893025127, 0.20727453893025127, 0.20727453893025127, 0.1604202101199429, 0.1604202101199429, 0.1604202101199429, 0.17098644222028125, 0.17098644222028125, 0.17098644222028125, 0.17832685258360415, 0.17832685258360415, 0.17832685258360415, 0.18539223557062212, 0.18539223557062212, 0.18539223557062212, 0.08875564461920749, 0.08875564461920749, 0.08875564461920749, 0.09349577354381855, 0.09349577354381855, 0.09349577354381855, 0.11874864300370158, 0.11874864300370158, 0.11874864300370158]}, "mutation_prompt": null}
{"id": "b914112a-c7d2-498e-bab8-6c9b1d8957f0", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "4727694e-2daa-4530-93d5-af32d9182d64", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "022fd79c-968e-4198-8416-9e1b11e04a9f", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "ae2a571e-c49d-4011-a902-1b12c6cb5e58", "solution": "import numpy as np\n\nclass AdaptivePSO_DE_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_constant = 2.0  # Increased cognitive influence\n        self.social_constant = 2.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Higher crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight = (self.inertia_weight_final + (self.inertia_weight_initial - self.inertia_weight_final) *\n                              (1 - evaluations / self.budget))\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor * (1 - scores[i] / global_best_score)\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n            \n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.normal(0, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "AdaptivePSO_DE_Dynamic", "description": "A hybrid method integrating adaptive PSO with DE and dynamic mutation strategies to accelerate convergence.", "configspace": "", "generation": 28, "fitness": 0.15012348522119867, "feedback": "The algorithm AdaptivePSO_DE_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.24696350819447754, 0.24696350819447754, 0.24696350819447754, 0.3215450075538284, 0.3215450075538284, 0.3215450075538284, 0.2907036811622481, 0.2907036811622481, 0.2907036811622481, 0.013433306308128556, 0.013433306308128556, 0.013433306308128556, 0.013348635188000668, 0.013348635188000668, 0.013348635188000668, 0.015479810914343028, 0.015479810914343028, 0.015479810914343028, 0.09167038407217465, 0.09167038407217465, 0.09167038407217465, 0.06328989428601017, 0.06328989428601017, 0.06328989428601017, 0.06945781695018016, 0.06945781695018016, 0.06945781695018016, 0.030724339644246146, 0.030724339644246146, 0.030724339644246146, 0.04233128041800971, 0.04233128041800971, 0.04233128041800971, 0.048543635657454454, 0.048543635657454454, 0.048543635657454454, 0.9777427449349358, 0.9777427449349358, 0.9777427449349358, 0.9771240903912395, 0.9771240903912395, 0.9771240903912395, 0.9765459524715979, 0.9765459524715979, 0.9765459524715979, 0.12447118474743057, 0.12447118474743057, 0.12447118474743057, 0.1132179828795854, 0.1132179828795854, 0.1132179828795854, 0.13767569851536532, 0.13767569851536532, 0.13767569851536532, 0.1505226144317785, 0.1505226144317785, 0.1505226144317785, 0.1420193083272996, 0.1420193083272996, 0.1420193083272996, 0.15359938317166655, 0.15359938317166655, 0.15359938317166655, 0.07000857397963522, 0.07000857397963522, 0.07000857397963522, 0.066925130795217, 0.066925130795217, 0.066925130795217, 0.0786975252398453, 0.0786975252398453, 0.0786975252398453, 0.07960888553036605, 0.07960888553036605, 0.07960888553036605, 0.05708981660559842, 0.05708981660559842, 0.05708981660559842, 0.029623982057631615, 0.029623982057631615, 0.029623982057631615, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03174634006327692, 0.03174634006327692, 0.03174634006327692, 0.023644252523935205, 0.023644252523935205, 0.023644252523935205, 0.007100453608399615, 0.007100453608399615, 0.007100453608399615, 0.0, 0.0, 0.0, 0.0015968842920703885, 0.0015968842920703885, 0.0015968842920703885, 0.0, 0.0, 0.0, 0.0217291971946022, 0.0217291971946022, 0.0217291971946022, 0.02410240625813098, 0.02410240625813098, 0.02410240625813098, 0.03163773878404941, 0.03163773878404941, 0.03163773878404941, 0.2592062841226731, 0.2592062841226731, 0.2592062841226731, 0.27782687226460734, 0.27782687226460734, 0.27782687226460734, 0.25637859956515596, 0.25637859956515596, 0.25637859956515596, 0.0580319510645646, 0.0580319510645646, 0.0580319510645646, 0.06027014392423313, 0.06027014392423313, 0.06027014392423313, 0.04861158418421818, 0.04861158418421818, 0.04861158418421818, 0.1409683415256051, 0.1409683415256051, 0.1409683415256051, 0.1548960749953343, 0.1548960749953343, 0.1548960749953343, 0.17468932720122576, 0.17468932720122576, 0.17468932720122576, 0.1834582139690224, 0.1834582139690224, 0.1834582139690224, 0.1858235321938665, 0.1858235321938665, 0.1858235321938665, 0.17311075601533032, 0.17311075601533032, 0.17311075601533032, 0.0887314983014239, 0.0887314983014239, 0.0887314983014239, 0.14979710835173077, 0.14979710835173077, 0.14979710835173077, 0.11305501406324092, 0.11305501406324092, 0.11305501406324092, 0.1652339461004787, 0.1652339461004787, 0.1652339461004787, 0.16122727738504494, 0.16122727738504494, 0.16122727738504494, 0.16515343045607678, 0.16515343045607678, 0.16515343045607678, 0.1632991455880345, 0.1632991455880345, 0.1632991455880345, 0.15991826463427639, 0.15991826463427639, 0.15991826463427639, 0.15950381555865367, 0.15950381555865367, 0.15950381555865367, 0.35050733090443786, 0.35050733090443786, 0.35050733090443786, 0.13948460709009813, 0.13948460709009813, 0.13948460709009813, 0.16133532822019947, 0.16133532822019947, 0.16133532822019947, 0.20665020123562416, 0.20665020123562416, 0.20665020123562416, 0.20594632089155784, 0.20594632089155784, 0.20594632089155784, 0.18044151133733777, 0.18044151133733777, 0.18044151133733777, 0.18088790112594666, 0.18088790112594666, 0.18088790112594666, 0.19084695194907486, 0.19084695194907486, 0.19084695194907486, 0.1900543379715548, 0.1900543379715548, 0.1900543379715548, 0.061176698085521286, 0.061176698085521286, 0.061176698085521286, 0.054830038723011953, 0.054830038723011953, 0.054830038723011953, 0.06361707977438291, 0.06361707977438291, 0.06361707977438291]}, "mutation_prompt": null}
{"id": "2adcbcef-ceef-4bf8-84ae-67afa1a791d1", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_constant = 2.0\n        self.social_constant = 2.0\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight = (self.initial_inertia_weight - \n                              (self.initial_inertia_weight - self.final_inertia_weight) * (evaluations / self.budget))\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm utilizing adaptive inertia weights and a comprehensive local search strategy to improve exploration and convergence.", "configspace": "", "generation": 29, "fitness": 0.14870228124521057, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.2574121147938475, 0.2574121147938475, 0.2574121147938475, 0.3076037547036444, 0.3076037547036444, 0.3076037547036444, 0.32446763333114714, 0.32446763333114714, 0.32446763333114714, 0.019295219923610274, 0.019295219923610274, 0.019295219923610274, 0.004591091349436471, 0.004591091349436471, 0.004591091349436471, 0.005768519483331458, 0.005768519483331458, 0.005768519483331458, 0.06043445037366402, 0.06043445037366402, 0.06043445037366402, 0.07601586297328289, 0.07601586297328289, 0.07601586297328289, 0.04909277043249827, 0.04909277043249827, 0.04909277043249827, 0.043177007096087294, 0.043177007096087294, 0.043177007096087294, 0.04503617457138498, 0.04503617457138498, 0.04503617457138498, 0.053233654172984646, 0.053233654172984646, 0.053233654172984646, 0.9771292921400929, 0.9771292921400929, 0.9771292921400929, 0.9763414533469117, 0.9763414533469117, 0.9763414533469117, 0.9762113389915377, 0.9762113389915377, 0.9762113389915377, 0.09201047269991591, 0.09201047269991591, 0.09201047269991591, 0.11598344316231779, 0.11598344316231779, 0.11598344316231779, 0.13460586585409562, 0.13460586585409562, 0.13460586585409562, 0.11298445907661758, 0.11298445907661758, 0.11298445907661758, 0.13712463816323872, 0.13712463816323872, 0.13712463816323872, 0.1423525193194375, 0.1423525193194375, 0.1423525193194375, 0.05348320998938694, 0.05348320998938694, 0.05348320998938694, 0.0794545948859543, 0.0794545948859543, 0.0794545948859543, 0.07860125202998514, 0.07860125202998514, 0.07860125202998514, 0.0820027678777756, 0.0820027678777756, 0.0820027678777756, 0.04905922599148871, 0.04905922599148871, 0.04905922599148871, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03290347946803829, 0.03290347946803829, 0.03290347946803829, 0.06426109587863815, 0.06426109587863815, 0.06426109587863815, 0.01814438796133977, 0.01814438796133977, 0.01814438796133977, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.019448704743656564, 0.019448704743656564, 0.019448704743656564, 0.04069507680201967, 0.04069507680201967, 0.04069507680201967, 0.03692436825664569, 0.03692436825664569, 0.03692436825664569, 0.27944505327466707, 0.27944505327466707, 0.27944505327466707, 0.27353099194981756, 0.27353099194981756, 0.27353099194981756, 0.26471714323700557, 0.26471714323700557, 0.26471714323700557, 0.061639668174795936, 0.061639668174795936, 0.061639668174795936, 0.04936401795929102, 0.04936401795929102, 0.04936401795929102, 0.05916103224181768, 0.05916103224181768, 0.05916103224181768, 0.1338017008752258, 0.1338017008752258, 0.1338017008752258, 0.14634900656203353, 0.14634900656203353, 0.14634900656203353, 0.1382605005542975, 0.1382605005542975, 0.1382605005542975, 0.1985689637044057, 0.1985689637044057, 0.1985689637044057, 0.18317676005419203, 0.18317676005419203, 0.18317676005419203, 0.18983334625525972, 0.18983334625525972, 0.18983334625525972, 0.13544534214811355, 0.13544534214811355, 0.13544534214811355, 0.13337004322268187, 0.13337004322268187, 0.13337004322268187, 0.10750882928570826, 0.10750882928570826, 0.10750882928570826, 0.14499480332725556, 0.14499480332725556, 0.14499480332725556, 0.16591279594081954, 0.16591279594081954, 0.16591279594081954, 0.1548568304988519, 0.1548568304988519, 0.1548568304988519, 0.15956927866531367, 0.15956927866531367, 0.15956927866531367, 0.15065556083559672, 0.15065556083559672, 0.15065556083559672, 0.17245184862973362, 0.17245184862973362, 0.17245184862973362, 0.43674889635719005, 0.43674889635719005, 0.43674889635719005, 0.1549548587731966, 0.1549548587731966, 0.1549548587731966, 0.16492813170140597, 0.16492813170140597, 0.16492813170140597, 0.16872304692063067, 0.16872304692063067, 0.16872304692063067, 0.17724574262916082, 0.17724574262916082, 0.17724574262916082, 0.13936306257055509, 0.13936306257055509, 0.13936306257055509, 0.18283253214269735, 0.18283253214269735, 0.18283253214269735, 0.16666128437875471, 0.16666128437875471, 0.16666128437875471, 0.18867556250761042, 0.18867556250761042, 0.18867556250761042, 0.05721334416095036, 0.05721334416095036, 0.05721334416095036, 0.05255673897907731, 0.05255673897907731, 0.05255673897907731, 0.04819763129303323, 0.04819763129303323, 0.04819763129303323]}, "mutation_prompt": null}
{"id": "d1735690-92c6-429b-884c-066c1d1beee0", "solution": "import numpy as np\n\nclass EnhancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population for diversity\n        self.inertia_weight = 0.6  # Slightly adjusted for exploration\n        self.cognitive_constant = 1.7  # Increased for stronger personal learning\n        self.social_constant = 1.3  # Reduced for controlled convergence\n        self.mutation_factor = 0.9  # Increased for more aggressive mutations\n        self.crossover_rate = 0.9  # Increased for higher crossover chances\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Narrower initial velocity\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            # Adaptive DE Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = 0.5 + np.random.rand() * 0.5  # Adaptive mutation factor\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)  # Wider search area\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedPSO_DE", "description": "A hybrid metaheuristic algorithm integrating Adaptive Differential Evolution with Enhanced Particle Swarm Optimization, emphasizing diversity and adaptive learning for improved convergence.", "configspace": "", "generation": 30, "fitness": 0.22578356668719174, "feedback": "The algorithm EnhancedPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.5497282060441975, 0.5497282060441975, 0.5497282060441975, 0.5378595942827995, 0.5378595942827995, 0.5378595942827995, 0.5268586753760929, 0.5268586753760929, 0.5268586753760929, 0.20749879236451751, 0.20749879236451751, 0.20749879236451751, 0.23199158174326695, 0.23199158174326695, 0.23199158174326695, 0.1917517403795006, 0.1917517403795006, 0.1917517403795006, 0.09985572629466222, 0.09985572629466222, 0.09985572629466222, 0.09174094954539269, 0.09174094954539269, 0.09174094954539269, 0.08736622135951588, 0.08736622135951588, 0.08736622135951588, 0.07840781319632184, 0.07840781319632184, 0.07840781319632184, 0.09070530582887626, 0.09070530582887626, 0.09070530582887626, 0.09124464625436779, 0.09124464625436779, 0.09124464625436779, 0.9731043544139566, 0.9731043544139566, 0.9731043544139566, 0.9658219225326001, 0.9658219225326001, 0.9658219225326001, 0.9635959516266454, 0.9635959516266454, 0.9635959516266454, 0.2659108222685982, 0.2659108222685982, 0.2659108222685982, 0.21919052964876462, 0.21919052964876462, 0.21919052964876462, 0.22221235186515742, 0.22221235186515742, 0.22221235186515742, 0.2509477554050876, 0.2509477554050876, 0.2509477554050876, 0.15944558991994362, 0.15944558991994362, 0.15944558991994362, 0.29939639846018695, 0.29939639846018695, 0.29939639846018695, 0.14250012817584634, 0.14250012817584634, 0.14250012817584634, 0.14076909384542324, 0.14076909384542324, 0.14076909384542324, 0.1418172691736267, 0.1418172691736267, 0.1418172691736267, 0.1055254581853795, 0.1055254581853795, 0.1055254581853795, 0.14388533797758596, 0.14388533797758596, 0.14388533797758596, 0.15849890834338876, 0.15849890834338876, 0.15849890834338876, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03353399496892617, 0.03353399496892617, 0.03353399496892617, 0.012375433985428064, 0.012375433985428064, 0.012375433985428064, 0.0777458492031059, 0.0777458492031059, 0.0777458492031059, 0.028959796393869697, 0.028959796393869697, 0.028959796393869697, 0.05456147845584913, 0.05456147845584913, 0.05456147845584913, 0.03361960789445306, 0.03361960789445306, 0.03361960789445306, 0.12625942416695468, 0.12625942416695468, 0.12625942416695468, 0.04192870612784538, 0.04192870612784538, 0.04192870612784538, 0.05460134684997153, 0.05460134684997153, 0.05460134684997153, 0.4259031365422751, 0.4259031365422751, 0.4259031365422751, 0.41722156508948616, 0.41722156508948616, 0.41722156508948616, 0.4203987488887565, 0.4203987488887565, 0.4203987488887565, 0.11238836900170213, 0.11238836900170213, 0.11238836900170213, 0.09347181943954586, 0.09347181943954586, 0.09347181943954586, 0.1040445204216337, 0.1040445204216337, 0.1040445204216337, 0.31571913597426593, 0.31571913597426593, 0.31571913597426593, 0.14620084480973328, 0.14620084480973328, 0.14620084480973328, 0.1371529808873111, 0.1371529808873111, 0.1371529808873111, 0.2785627303969992, 0.2785627303969992, 0.2785627303969992, 0.281391981493213, 0.281391981493213, 0.281391981493213, 0.31047122427809104, 0.31047122427809104, 0.31047122427809104, 0.1726115742741816, 0.1726115742741816, 0.1726115742741816, 0.1537925467781277, 0.1537925467781277, 0.1537925467781277, 0.1276580346560866, 0.1276580346560866, 0.1276580346560866, 0.20110349052564347, 0.20110349052564347, 0.20110349052564347, 0.18985543774899472, 0.18985543774899472, 0.18985543774899472, 0.1819615726935837, 0.1819615726935837, 0.1819615726935837, 0.18450027171392425, 0.18450027171392425, 0.18450027171392425, 0.20933353185614123, 0.20933353185614123, 0.20933353185614123, 0.20725186779742144, 0.20725186779742144, 0.20725186779742144, 0.7538914209657184, 0.7538914209657184, 0.7538914209657184, 0.1533710586416046, 0.1533710586416046, 0.1533710586416046, 0.6109626419971211, 0.6109626419971211, 0.6109626419971211, 0.4914271320787428, 0.4914271320787428, 0.4914271320787428, 0.20172188533165314, 0.20172188533165314, 0.20172188533165314, 0.15166485496821802, 0.15166485496821802, 0.15166485496821802, 0.18369732145930606, 0.18369732145930606, 0.18369732145930606, 0.18906594722065695, 0.18906594722065695, 0.18906594722065695, 0.19542578866178384, 0.19542578866178384, 0.19542578866178384, 0.07971110943081461, 0.07971110943081461, 0.07971110943081461, 0.07196169061058388, 0.07196169061058388, 0.07196169061058388, 0.1013038022863777, 0.1013038022863777, 0.1013038022863777]}, "mutation_prompt": null}
{"id": "119d02b7-9551-4b59-a26a-b0e29a5bd895", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "ce5932b6-21d2-42fe-a0f5-2a4c5a9ed4ec", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population for diversity\n        self.inertia_weight = 0.7  # Adjusted inertia for better exploration/exploitation\n        self.cognitive_constant = 1.4  # Slightly reduced for balance\n        self.social_constant = 1.6  # Increased for better global search\n        self.mutation_factor = 0.6  # Enhanced mutation for exploration\n        self.crossover_rate = 0.9  # Higher crossover for more trial vectors\n\n    def levy_flight(self, L):\n        # Lvy flight step\n        u = np.random.normal(0, 1, size=self.dim) * (0.01 / np.power(np.random.normal(0, 1), 1 / L))\n        return u\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles += velocities  # Removed clipping for free exploration\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Lvy Flight Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                step = self.levy_flight(1.5)\n                levy_candidate = particles[i] + step\n                levy_candidate = np.clip(levy_candidate, self.lower_bound, self.upper_bound)\n                levy_score = func(levy_candidate)\n                evaluations += 1\n                if levy_score < scores[i]:\n                    particles[i] = levy_candidate\n                    scores[i] = levy_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm integrating Lvy flight-based exploration with adaptive learning rates for faster convergence.", "configspace": "", "generation": 32, "fitness": 0.15629851806802778, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.20.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.3217437979646046, 0.3217437979646046, 0.3217437979646046, 0.32158161672630126, 0.32158161672630126, 0.32158161672630126, 0.2534707020737301, 0.2534707020737301, 0.2534707020737301, 0.010036447575700547, 0.010036447575700547, 0.010036447575700547, 0.0, 0.0, 0.0, 0.043582112516543425, 0.043582112516543425, 0.043582112516543425, 0.07189868289157098, 0.07189868289157098, 0.07189868289157098, 0.07857687583066286, 0.07857687583066286, 0.07857687583066286, 0.059469434347458106, 0.059469434347458106, 0.059469434347458106, 0.05242210680541626, 0.05242210680541626, 0.05242210680541626, 0.07087161678219234, 0.07087161678219234, 0.07087161678219234, 0.025226922380085726, 0.025226922380085726, 0.025226922380085726, 0.9689114076536833, 0.9689114076536833, 0.9689114076536833, 0.9761771481656809, 0.9761771481656809, 0.9761771481656809, 0.9767542841150041, 0.9767542841150041, 0.9767542841150041, 0.11337785349550245, 0.11337785349550245, 0.11337785349550245, 0.0889333455878657, 0.0889333455878657, 0.0889333455878657, 0.12961268796441605, 0.12961268796441605, 0.12961268796441605, 0.1509348318439423, 0.1509348318439423, 0.1509348318439423, 0.17825693749221205, 0.17825693749221205, 0.17825693749221205, 0.157009947606786, 0.157009947606786, 0.157009947606786, 0.11093087794245404, 0.11093087794245404, 0.11093087794245404, 0.07729921379704252, 0.07729921379704252, 0.07729921379704252, 0.08169033044178431, 0.08169033044178431, 0.08169033044178431, 0.07140148669738977, 0.07140148669738977, 0.07140148669738977, 0.09055500007981243, 0.09055500007981243, 0.09055500007981243, 0.10825254934566597, 0.10825254934566597, 0.10825254934566597, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0275009912257701, 0.0275009912257701, 0.0275009912257701, 0.011565441592504389, 0.011565441592504389, 0.011565441592504389, 0.03438681176357783, 0.03438681176357783, 0.03438681176357783, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025584273607748176, 0.025584273607748176, 0.025584273607748176, 0.04909541314247612, 0.04909541314247612, 0.04909541314247612, 0.015551311992777817, 0.015551311992777817, 0.015551311992777817, 0.322605037871427, 0.322605037871427, 0.322605037871427, 0.3518383401477254, 0.3518383401477254, 0.3518383401477254, 0.35115010722797324, 0.35115010722797324, 0.35115010722797324, 0.07247994819162451, 0.07247994819162451, 0.07247994819162451, 0.053869545688007725, 0.053869545688007725, 0.053869545688007725, 0.07317827904658447, 0.07317827904658447, 0.07317827904658447, 0.1434306907541948, 0.1434306907541948, 0.1434306907541948, 0.1276799919469388, 0.1276799919469388, 0.1276799919469388, 0.12679205317125086, 0.12679205317125086, 0.12679205317125086, 0.18919531966759573, 0.18919531966759573, 0.18919531966759573, 0.16713359390966742, 0.16713359390966742, 0.16713359390966742, 0.17551740394040793, 0.17551740394040793, 0.17551740394040793, 0.12516454292936974, 0.12516454292936974, 0.12516454292936974, 0.1353997784639569, 0.1353997784639569, 0.1353997784639569, 0.09896601935282268, 0.09896601935282268, 0.09896601935282268, 0.1729864980240824, 0.1729864980240824, 0.1729864980240824, 0.15317979690302963, 0.15317979690302963, 0.15317979690302963, 0.1729336297713595, 0.1729336297713595, 0.1729336297713595, 0.16958393628515367, 0.16958393628515367, 0.16958393628515367, 0.15587969113646072, 0.15587969113646072, 0.15587969113646072, 0.16190883925628274, 0.16190883925628274, 0.16190883925628274, 0.4771723113030947, 0.4771723113030947, 0.4771723113030947, 0.15190114297217971, 0.15190114297217971, 0.15190114297217971, 0.16093429086340183, 0.16093429086340183, 0.16093429086340183, 0.1570545206628663, 0.1570545206628663, 0.1570545206628663, 0.14289344037513296, 0.14289344037513296, 0.14289344037513296, 0.21855124756232447, 0.21855124756232447, 0.21855124756232447, 0.1701299749551517, 0.1701299749551517, 0.1701299749551517, 0.19011555460811258, 0.19011555460811258, 0.19011555460811258, 0.17595378712069965, 0.17595378712069965, 0.17595378712069965, 0.06131784122388084, 0.06131784122388084, 0.06131784122388084, 0.041164241239196264, 0.041164241239196264, 0.041164241239196264, 0.05276944287768259, 0.05276944287768259, 0.05276944287768259]}, "mutation_prompt": null}
{"id": "fdc89e11-f1ed-4afc-833e-2a777f804635", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for better exploration\n        self.inertia_weight = 0.6  # Slightly increased inertia for broader exploration\n        self.cognitive_constant = 1.8  # Enhanced cognitive factor\n        self.social_constant = 1.4  # Reduced social factor to promote diversity\n        self.mutation_factor = 0.6  # Adjusted mutation factor for wider search\n        self.crossover_rate = 0.9  # Higher crossover rate for more aggressive evolution\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3  # Increased adaptation range\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Selective Local Search Phase\n            for i in range(self.population_size // 2):  # Local search on half of the population\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.05, 0.05, self.dim)  # Reduced step size\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm leveraging dynamic strategy adaptation and selective local search to accelerate convergence.", "configspace": "", "generation": 33, "fitness": 0.21599279862610138, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6158131785982746, 0.6158131785982746, 0.6158131785982746, 0.5457876789199976, 0.5457876789199976, 0.5457876789199976, 0.6231478784112049, 0.6231478784112049, 0.6231478784112049, 0.19150419694889953, 0.19150419694889953, 0.19150419694889953, 0.09723237023460896, 0.09723237023460896, 0.09723237023460896, 0.011371435293854981, 0.011371435293854981, 0.011371435293854981, 0.15009597345034742, 0.15009597345034742, 0.15009597345034742, 0.11942282842802054, 0.11942282842802054, 0.11942282842802054, 0.11020627469934152, 0.11020627469934152, 0.11020627469934152, 0.1065376613128105, 0.1065376613128105, 0.1065376613128105, 0.10380948120134326, 0.10380948120134326, 0.10380948120134326, 0.09340641009144712, 0.09340641009144712, 0.09340641009144712, 0.9640556941565517, 0.9640556941565517, 0.9640556941565517, 0.9696533790134897, 0.9696533790134897, 0.9696533790134897, 0.9669146555486534, 0.9669146555486534, 0.9669146555486534, 0.24203243659537343, 0.24203243659537343, 0.24203243659537343, 0.23530085710412418, 0.23530085710412418, 0.23530085710412418, 0.2727257376727056, 0.2727257376727056, 0.2727257376727056, 0.2588624938472903, 0.2588624938472903, 0.2588624938472903, 0.17345257438231365, 0.17345257438231365, 0.17345257438231365, 0.17766518229171324, 0.17766518229171324, 0.17766518229171324, 0.16585294607676948, 0.16585294607676948, 0.16585294607676948, 0.12392163587325977, 0.12392163587325977, 0.12392163587325977, 0.14637024480861005, 0.14637024480861005, 0.14637024480861005, 0.15566895433825378, 0.15566895433825378, 0.15566895433825378, 0.09758395303872691, 0.09758395303872691, 0.09758395303872691, 0.09020113207008396, 0.09020113207008396, 0.09020113207008396, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06118200643086169, 0.06118200643086169, 0.06118200643086169, 0.00626843569510549, 0.00626843569510549, 0.00626843569510549, 0.05182754768155651, 0.05182754768155651, 0.05182754768155651, 0.007340823126859464, 0.007340823126859464, 0.007340823126859464, 0.0449684119049667, 0.0449684119049667, 0.0449684119049667, 0.03356089587814348, 0.03356089587814348, 0.03356089587814348, 0.13939188755817922, 0.13939188755817922, 0.13939188755817922, 0.1534515172623664, 0.1534515172623664, 0.1534515172623664, 0.049516941617939514, 0.049516941617939514, 0.049516941617939514, 0.41624299020435296, 0.41624299020435296, 0.41624299020435296, 0.44582920989376873, 0.44582920989376873, 0.44582920989376873, 0.44495535562904853, 0.44495535562904853, 0.44495535562904853, 0.07821889119080083, 0.07821889119080083, 0.07821889119080083, 0.10190212846742619, 0.10190212846742619, 0.10190212846742619, 0.07876257262954878, 0.07876257262954878, 0.07876257262954878, 0.16168400998470955, 0.16168400998470955, 0.16168400998470955, 0.1352324719694208, 0.1352324719694208, 0.1352324719694208, 0.19981377792435462, 0.19981377792435462, 0.19981377792435462, 0.2636987688856345, 0.2636987688856345, 0.2636987688856345, 0.31200385531924435, 0.31200385531924435, 0.31200385531924435, 0.30430433164234383, 0.30430433164234383, 0.30430433164234383, 0.1396161318345085, 0.1396161318345085, 0.1396161318345085, 0.18194874699152885, 0.18194874699152885, 0.18194874699152885, 0.14909588353290948, 0.14909588353290948, 0.14909588353290948, 0.19931678686136434, 0.19931678686136434, 0.19931678686136434, 0.19481001775890927, 0.19481001775890927, 0.19481001775890927, 0.2093320800119648, 0.2093320800119648, 0.2093320800119648, 0.17598011840089678, 0.17598011840089678, 0.17598011840089678, 0.1903936059978214, 0.1903936059978214, 0.1903936059978214, 0.35383240088051304, 0.35383240088051304, 0.35383240088051304, 0.71574924400831, 0.71574924400831, 0.71574924400831, 0.1543963356273078, 0.1543963356273078, 0.1543963356273078, 0.16879885413570705, 0.16879885413570705, 0.16879885413570705, 0.281945845689895, 0.281945845689895, 0.281945845689895, 0.20619455470899628, 0.20619455470899628, 0.20619455470899628, 0.15275813991512333, 0.15275813991512333, 0.15275813991512333, 0.17772913927216905, 0.17772913927216905, 0.17772913927216905, 0.19042906419417793, 0.19042906419417793, 0.19042906419417793, 0.1917426464334696, 0.1917426464334696, 0.1917426464334696, 0.06590838637325092, 0.06590838637325092, 0.06590838637325092, 0.0647629673526946, 0.0647629673526946, 0.0647629673526946, 0.08798647579308094, 0.08798647579308094, 0.08798647579308094]}, "mutation_prompt": null}
{"id": "421c18ca-b25f-4686-9c9b-77132e62e32c", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for better exploration\n        self.inertia_weight = 0.9\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.6  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Higher crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            inertia_weight_dynamic = 0.9 - (0.5 * (evaluations / self.budget))\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight_dynamic * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.1\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Refined Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.normal(0, 0.05, self.dim)  # Normal distribution for local search\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm combining adaptive inertia PSO, dynamic differential evolution, and a refined local search for improved convergence.", "configspace": "", "generation": 34, "fitness": 0.17342033755796057, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.38217722910747975, 0.38217722910747975, 0.38217722910747975, 0.4127389141729214, 0.4127389141729214, 0.4127389141729214, 0.40552512303265664, 0.40552512303265664, 0.40552512303265664, 0.017963578860614282, 0.017963578860614282, 0.017963578860614282, 0.02592858379011831, 0.02592858379011831, 0.02592858379011831, 0.05132098928871398, 0.05132098928871398, 0.05132098928871398, 0.0875828362591421, 0.0875828362591421, 0.0875828362591421, 0.0611441804576196, 0.0611441804576196, 0.0611441804576196, 0.06541346501789025, 0.06541346501789025, 0.06541346501789025, 0.0682021689806368, 0.0682021689806368, 0.0682021689806368, 0.06695917327351875, 0.06695917327351875, 0.06695917327351875, 0.07410766446927664, 0.07410766446927664, 0.07410766446927664, 0.976319856379914, 0.976319856379914, 0.976319856379914, 0.9660444484527134, 0.9660444484527134, 0.9660444484527134, 0.9621353688028395, 0.9621353688028395, 0.9621353688028395, 0.14506709824015562, 0.14506709824015562, 0.14506709824015562, 0.128740714754369, 0.128740714754369, 0.128740714754369, 0.1901385411519444, 0.1901385411519444, 0.1901385411519444, 0.14241678774709488, 0.14241678774709488, 0.14241678774709488, 0.1495690482498876, 0.1495690482498876, 0.1495690482498876, 0.1564790003555856, 0.1564790003555856, 0.1564790003555856, 0.11024051283417102, 0.11024051283417102, 0.11024051283417102, 0.09128984130582174, 0.09128984130582174, 0.09128984130582174, 0.11117380539356325, 0.11117380539356325, 0.11117380539356325, 0.08977907156703857, 0.08977907156703857, 0.08977907156703857, 0.07054205028228333, 0.07054205028228333, 0.07054205028228333, 0.054599215701840675, 0.054599215701840675, 0.054599215701840675, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.056355065632466506, 0.056355065632466506, 0.056355065632466506, 0.0883041226885416, 0.0883041226885416, 0.0883041226885416, 0.052932816681503625, 0.052932816681503625, 0.052932816681503625, 0.019641087921105083, 0.019641087921105083, 0.019641087921105083, 0.006751846629930336, 0.006751846629930336, 0.006751846629930336, 0.012097580601212021, 0.012097580601212021, 0.012097580601212021, 0.08515177234705329, 0.08515177234705329, 0.08515177234705329, 0.0724670957841439, 0.0724670957841439, 0.0724670957841439, 0.044070802603245696, 0.044070802603245696, 0.044070802603245696, 0.34094591391457985, 0.34094591391457985, 0.34094591391457985, 0.3340413762941912, 0.3340413762941912, 0.3340413762941912, 0.35612341866873387, 0.35612341866873387, 0.35612341866873387, 0.08734672448119496, 0.08734672448119496, 0.08734672448119496, 0.08272605701830782, 0.08272605701830782, 0.08272605701830782, 0.06755503712281719, 0.06755503712281719, 0.06755503712281719, 0.15276361726729792, 0.15276361726729792, 0.15276361726729792, 0.11341130184965709, 0.11341130184965709, 0.11341130184965709, 0.1344251641629144, 0.1344251641629144, 0.1344251641629144, 0.24308551806907763, 0.24308551806907763, 0.24308551806907763, 0.20887362497072814, 0.20887362497072814, 0.20887362497072814, 0.23644485239572233, 0.23644485239572233, 0.23644485239572233, 0.16806338592749448, 0.16806338592749448, 0.16806338592749448, 0.1755266441590715, 0.1755266441590715, 0.1755266441590715, 0.11987799567517154, 0.11987799567517154, 0.11987799567517154, 0.1627894775085157, 0.1627894775085157, 0.1627894775085157, 0.19889532221914819, 0.19889532221914819, 0.19889532221914819, 0.1938088559939699, 0.1938088559939699, 0.1938088559939699, 0.1851291576515598, 0.1851291576515598, 0.1851291576515598, 0.19329996794239546, 0.19329996794239546, 0.19329996794239546, 0.16857289228537975, 0.16857289228537975, 0.16857289228537975, 0.4405478144078394, 0.4405478144078394, 0.4405478144078394, 0.1480927987641837, 0.1480927987641837, 0.1480927987641837, 0.1649858042742357, 0.1649858042742357, 0.1649858042742357, 0.19939391499994685, 0.19939391499994685, 0.19939391499994685, 0.21774570274131155, 0.21774570274131155, 0.21774570274131155, 0.14542572747554638, 0.14542572747554638, 0.14542572747554638, 0.1761285259652513, 0.1761285259652513, 0.1761285259652513, 0.17842745749547106, 0.17842745749547106, 0.17842745749547106, 0.17459399263625086, 0.17459399263625086, 0.17459399263625086, 0.08421777669325636, 0.08421777669325636, 0.08421777669325636, 0.06995232358234804, 0.06995232358234804, 0.06995232358234804, 0.06167470074058079, 0.06167470074058079, 0.06167470074058079]}, "mutation_prompt": null}
{"id": "ed172224-30ed-4b37-9bde-2499cf83e807", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "814fcf43-baf4-471b-9e62-20a61ebc7e7e", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "4f70c9e4-2a9e-4bea-97c4-c024e2d24290", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "b2a48678-e7ad-4c10-af16-5572a33a92a0", "solution": "import numpy as np\n\nclass HybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = HybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "HybridPSO_SADE_LS", "description": "An adaptive algorithm combining Particle Swarm Optimization with Self-Adaptive Differential Evolution and local search to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.6829491332689965, 0.6829491332689965, 0.6829491332689965, 0.6995892482729698, 0.6995892482729698, 0.6995892482729698, 0.7432743219012075, 0.7432743219012075, 0.7432743219012075, 0.37841399996752645, 0.37841399996752645, 0.37841399996752645, 0.4356348024987434, 0.4356348024987434, 0.4356348024987434, 0.0298099545946392, 0.0298099545946392, 0.0298099545946392, 0.10981086999249945, 0.10981086999249945, 0.10981086999249945, 0.09331951539099137, 0.09331951539099137, 0.09331951539099137, 0.15005582061357237, 0.15005582061357237, 0.15005582061357237, 0.09724479512306405, 0.09724479512306405, 0.09724479512306405, 0.12668464878664365, 0.12668464878664365, 0.12668464878664365, 0.09906160371808725, 0.09906160371808725, 0.09906160371808725, 0.9574570454026833, 0.9574570454026833, 0.9574570454026833, 0.9524512918459814, 0.9524512918459814, 0.9524512918459814, 0.953850545421145, 0.953850545421145, 0.953850545421145, 0.2935989035713985, 0.2935989035713985, 0.2935989035713985, 0.26659350127694903, 0.26659350127694903, 0.26659350127694903, 0.2810789042331908, 0.2810789042331908, 0.2810789042331908, 0.5870449910438493, 0.5870449910438493, 0.5870449910438493, 0.7033297905856436, 0.7033297905856436, 0.7033297905856436, 0.6910311287885478, 0.6910311287885478, 0.6910311287885478, 0.19165379890432466, 0.19165379890432466, 0.19165379890432466, 0.1215994062407535, 0.1215994062407535, 0.1215994062407535, 0.17509488631860126, 0.17509488631860126, 0.17509488631860126, 0.1767789173575346, 0.1767789173575346, 0.1767789173575346, 0.17181523548904365, 0.17181523548904365, 0.17181523548904365, 0.06106142370985923, 0.06106142370985923, 0.06106142370985923, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07954035192880471, 0.07954035192880471, 0.07954035192880471, 0.05277488176969947, 0.05277488176969947, 0.05277488176969947, 0.14382990109611238, 0.14382990109611238, 0.14382990109611238, 0.042585159174359566, 0.042585159174359566, 0.042585159174359566, 0.056054518270468146, 0.056054518270468146, 0.056054518270468146, 0.07407441118970925, 0.07407441118970925, 0.07407441118970925, 0.19930448470522466, 0.19930448470522466, 0.19930448470522466, 0.20634641055760716, 0.20634641055760716, 0.20634641055760716, 0.09083969367235278, 0.09083969367235278, 0.09083969367235278, 0.44757594753794283, 0.44757594753794283, 0.44757594753794283, 0.5039889475465074, 0.5039889475465074, 0.5039889475465074, 0.45599475230564057, 0.45599475230564057, 0.45599475230564057, 0.0956156398650575, 0.0956156398650575, 0.0956156398650575, 0.11621262860288584, 0.11621262860288584, 0.11621262860288584, 0.08171028245619583, 0.08171028245619583, 0.08171028245619583, 0.14480476037931966, 0.14480476037931966, 0.14480476037931966, 0.17717160670634202, 0.17717160670634202, 0.17717160670634202, 0.18067977275634362, 0.18067977275634362, 0.18067977275634362, 0.35939704322660904, 0.35939704322660904, 0.35939704322660904, 0.38438713746211906, 0.38438713746211906, 0.38438713746211906, 0.3242375532516383, 0.3242375532516383, 0.3242375532516383, 0.14866847520110527, 0.14866847520110527, 0.14866847520110527, 0.25778780569218185, 0.25778780569218185, 0.25778780569218185, 0.16678389451227016, 0.16678389451227016, 0.16678389451227016, 0.1811461538258935, 0.1811461538258935, 0.1811461538258935, 0.19713726721169955, 0.19713726721169955, 0.19713726721169955, 0.193581264384442, 0.193581264384442, 0.193581264384442, 0.20866696647338367, 0.20866696647338367, 0.20866696647338367, 0.19133293802289453, 0.19133293802289453, 0.19133293802289453, 0.21082571429000263, 0.21082571429000263, 0.21082571429000263, 0.7942491168004332, 0.7942491168004332, 0.7942491168004332, 0.15645964629800146, 0.15645964629800146, 0.15645964629800146, 0.16759659602034738, 0.16759659602034738, 0.16759659602034738, 0.16703554062609383, 0.16703554062609383, 0.16703554062609383, 0.2067702184136302, 0.2067702184136302, 0.2067702184136302, 0.15485847231476346, 0.15485847231476346, 0.15485847231476346, 0.18148929932370006, 0.18148929932370006, 0.18148929932370006, 0.18924335206150578, 0.18924335206150578, 0.18924335206150578, 0.19151156707024886, 0.19151156707024886, 0.19151156707024886, 0.07329833265640884, 0.07329833265640884, 0.07329833265640884, 0.0771802052011944, 0.0771802052011944, 0.0771802052011944, 0.08827450902987388, 0.08827450902987388, 0.08827450902987388]}, "mutation_prompt": null}
{"id": "0e438401-6d06-4454-976b-26c154539897", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Adaptive inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.6  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Slightly increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        def adapt_inertia(evals):\n            # Linearly decrease inertia weight\n            return 0.4 + (0.5 * (1 - evals / self.budget))\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            self.inertia_weight = adapt_inertia(evaluations)\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.05, 0.05, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n                # Neighborhood search\n                neighbors = particles + np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n                neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n                neighbor_scores = np.apply_along_axis(func, 1, neighbors)\n                evaluations += self.population_size\n                better_neighbors = neighbor_scores < scores\n                particles[better_neighbors] = neighbors[better_neighbors]\n                scores[better_neighbors] = neighbor_scores[better_neighbors]\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "An enhanced hybrid algorithm that integrates adaptive inertia weight and neighborhood search to improve convergence speed.", "configspace": "", "generation": 39, "fitness": 0.1400137864244617, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.13.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.2764040346637887, 0.2764040346637887, 0.2764040346637887, 0.2716587650651223, 0.2716587650651223, 0.2716587650651223, 0.3349759576050868, 0.3349759576050868, 0.3349759576050868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032629109646222787, 0.0032629109646222787, 0.0032629109646222787, 0.08394474324305845, 0.08394474324305845, 0.08394474324305845, 0.06604758179849501, 0.06604758179849501, 0.06604758179849501, 0.06535932268578659, 0.06535932268578659, 0.06535932268578659, 0.04996551102847113, 0.04996551102847113, 0.04996551102847113, 0.058935411924840087, 0.058935411924840087, 0.058935411924840087, 0.05919021370485211, 0.05919021370485211, 0.05919021370485211, 0.7542557718494602, 0.7542557718494602, 0.7542557718494602, 0.5296266214394271, 0.5296266214394271, 0.5296266214394271, 0.5389431303423322, 0.5389431303423322, 0.5389431303423322, 0.10718557220689251, 0.10718557220689251, 0.10718557220689251, 0.08394168121070689, 0.08394168121070689, 0.08394168121070689, 0.16313314339169993, 0.16313314339169993, 0.16313314339169993, 0.06688812048427695, 0.06688812048427695, 0.06688812048427695, 0.18333005764235455, 0.18333005764235455, 0.18333005764235455, 0.1391604743993512, 0.1391604743993512, 0.1391604743993512, 0.05217926593298361, 0.05217926593298361, 0.05217926593298361, 0.09979594347126564, 0.09979594347126564, 0.09979594347126564, 0.048676523686984385, 0.048676523686984385, 0.048676523686984385, 0.04782501449184151, 0.04782501449184151, 0.04782501449184151, 0.06903328567548506, 0.06903328567548506, 0.06903328567548506, 0.032777927865795586, 0.032777927865795586, 0.032777927865795586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09272368544712006, 0.09272368544712006, 0.09272368544712006, 0.047943880675203165, 0.047943880675203165, 0.047943880675203165, 0.08996552346527154, 0.08996552346527154, 0.08996552346527154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030405294208047606, 0.030405294208047606, 0.030405294208047606, 0.038055006733928476, 0.038055006733928476, 0.038055006733928476, 0.04734015970288852, 0.04734015970288852, 0.04734015970288852, 0.2913757724673466, 0.2913757724673466, 0.2913757724673466, 0.2311106567719039, 0.2311106567719039, 0.2311106567719039, 0.26379774569499803, 0.26379774569499803, 0.26379774569499803, 0.11265377427782497, 0.11265377427782497, 0.11265377427782497, 0.09071682500725275, 0.09071682500725275, 0.09071682500725275, 0.06537673322117099, 0.06537673322117099, 0.06537673322117099, 0.19321946437577087, 0.19321946437577087, 0.19321946437577087, 0.16645163258134255, 0.16645163258134255, 0.16645163258134255, 0.18745611772770798, 0.18745611772770798, 0.18745611772770798, 0.19603356251834692, 0.19603356251834692, 0.19603356251834692, 0.18164842700714112, 0.18164842700714112, 0.18164842700714112, 0.18275619706996316, 0.18275619706996316, 0.18275619706996316, 0.10778752100656641, 0.10778752100656641, 0.10778752100656641, 0.12969041300966677, 0.12969041300966677, 0.12969041300966677, 0.10754446811128715, 0.10754446811128715, 0.10754446811128715, 0.16385354328724444, 0.16385354328724444, 0.16385354328724444, 0.1758026041766887, 0.1758026041766887, 0.1758026041766887, 0.18938827760903654, 0.18938827760903654, 0.18938827760903654, 0.18034161332135534, 0.18034161332135534, 0.18034161332135534, 0.18107601059975875, 0.18107601059975875, 0.18107601059975875, 0.17265766883857903, 0.17265766883857903, 0.17265766883857903, 0.36769115421213694, 0.36769115421213694, 0.36769115421213694, 0.1653762061760139, 0.1653762061760139, 0.1653762061760139, 0.1609713839542355, 0.1609713839542355, 0.1609713839542355, 0.20108836531854313, 0.20108836531854313, 0.20108836531854313, 0.18888007198175571, 0.18888007198175571, 0.18888007198175571, 0.15368568924765802, 0.15368568924765802, 0.15368568924765802, 0.18080344848183494, 0.18080344848183494, 0.18080344848183494, 0.17350279574525151, 0.17350279574525151, 0.17350279574525151, 0.19508577941627214, 0.19508577941627214, 0.19508577941627214, 0.06466427958776144, 0.06466427958776144, 0.06466427958776144, 0.05939288878224547, 0.05939288878224547, 0.05939288878224547, 0.0653809939691391, 0.0653809939691391, 0.0653809939691391]}, "mutation_prompt": null}
{"id": "3310d7a1-edbd-456e-b07d-144f4e2b2bf2", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Increased inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Slightly increased social constant\n        self.mutation_factor = 0.6  # Increased mutation factor\n        self.crossover_rate = 0.9   # Increased crossover rate\n        self.adaptive_momentum = 0.1  # Introduced adaptive momentum\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles += velocities * (1 - self.adaptive_momentum)\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Selective Local Search Phase with Elitism\n            elite_indices = personal_best_scores.argsort()[:self.population_size // 2]\n            for i in elite_indices:\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.05, 0.05, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score\n\n# Example usage:\n# optimizer = EnhancedHybridPSO_SADE_LS(budget=1000, dim=10)\n# best_position, best_score = optimizer(some_black_box_function)", "name": "EnhancedHybridPSO_SADE_LS", "description": "A modified hybrid optimization algorithm integrating adaptive moments in PSO and a selective elitism mechanism to enhance convergence speed.", "configspace": "", "generation": 40, "fitness": 0.14502731367818614, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.22566538813534887, 0.22566538813534887, 0.22566538813534887, 0.1792178029877688, 0.1792178029877688, 0.1792178029877688, 0.1757191599798933, 0.1757191599798933, 0.1757191599798933, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05370734285033052, 0.05370734285033052, 0.05370734285033052, 0.056655430419136565, 0.056655430419136565, 0.056655430419136565, 0.046583376409876975, 0.046583376409876975, 0.046583376409876975, 0.06319278413995977, 0.06319278413995977, 0.06319278413995977, 0.05412179749913815, 0.05412179749913815, 0.05412179749913815, 0.06363424107051108, 0.06363424107051108, 0.06363424107051108, 0.9811482973604714, 0.9811482973604714, 0.9811482973604714, 0.9621192561723019, 0.9621192561723019, 0.9621192561723019, 0.9610148099998941, 0.9610148099998941, 0.9610148099998941, 0.09439038616588424, 0.09439038616588424, 0.09439038616588424, 0.11348755028057456, 0.11348755028057456, 0.11348755028057456, 0.13756591024452647, 0.13756591024452647, 0.13756591024452647, 0.18995031796499684, 0.18995031796499684, 0.18995031796499684, 0.15893646111905835, 0.15893646111905835, 0.15893646111905835, 0.16273675261002063, 0.16273675261002063, 0.16273675261002063, 0.10258093558911019, 0.10258093558911019, 0.10258093558911019, 0.07039943574037166, 0.07039943574037166, 0.07039943574037166, 0.09097073748227436, 0.09097073748227436, 0.09097073748227436, 0.0965769142270132, 0.0965769142270132, 0.0965769142270132, 0.02825539461866977, 0.02825539461866977, 0.02825539461866977, 0.019929341939951883, 0.019929341939951883, 0.019929341939951883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13287443393662557, 0.13287443393662557, 0.13287443393662557, 0.0048567544842790245, 0.0048567544842790245, 0.0048567544842790245, 0.039461698158488656, 0.039461698158488656, 0.039461698158488656, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023145786907988075, 0.023145786907988075, 0.023145786907988075, 0.03197083029898695, 0.03197083029898695, 0.03197083029898695, 0.044553952496903526, 0.044553952496903526, 0.044553952496903526, 0.18586347890913701, 0.18586347890913701, 0.18586347890913701, 0.20730149591902358, 0.20730149591902358, 0.20730149591902358, 0.29268545087016096, 0.29268545087016096, 0.29268545087016096, 0.06313867739167345, 0.06313867739167345, 0.06313867739167345, 0.06765255365752676, 0.06765255365752676, 0.06765255365752676, 0.07919600417598016, 0.07919600417598016, 0.07919600417598016, 0.15320186353971244, 0.15320186353971244, 0.15320186353971244, 0.12867774353403605, 0.12867774353403605, 0.12867774353403605, 0.12827383114877267, 0.12827383114877267, 0.12827383114877267, 0.182413854826732, 0.182413854826732, 0.182413854826732, 0.1660785613382304, 0.1660785613382304, 0.1660785613382304, 0.21420806749505528, 0.21420806749505528, 0.21420806749505528, 0.13088522059543117, 0.13088522059543117, 0.13088522059543117, 0.13824950279498405, 0.13824950279498405, 0.13824950279498405, 0.10558068607942883, 0.10558068607942883, 0.10558068607942883, 0.17345823881379352, 0.17345823881379352, 0.17345823881379352, 0.15040283603621485, 0.15040283603621485, 0.15040283603621485, 0.18419605630900482, 0.18419605630900482, 0.18419605630900482, 0.15680440408434915, 0.15680440408434915, 0.15680440408434915, 0.16764688674833683, 0.16764688674833683, 0.16764688674833683, 0.15816005858855609, 0.15816005858855609, 0.15816005858855609, 0.32607460191667437, 0.32607460191667437, 0.32607460191667437, 0.15435996263410667, 0.15435996263410667, 0.15435996263410667, 0.16815558449844725, 0.16815558449844725, 0.16815558449844725, 0.15389936273588245, 0.15389936273588245, 0.15389936273588245, 0.14990723703006115, 0.14990723703006115, 0.14990723703006115, 0.1356701575097028, 0.1356701575097028, 0.1356701575097028, 0.17418546484402175, 0.17418546484402175, 0.17418546484402175, 0.17646919817689488, 0.17646919817689488, 0.17646919817689488, 0.18463336469567737, 0.18463336469567737, 0.18463336469567737, 0.05950432910324999, 0.05950432910324999, 0.05950432910324999, 0.06567534640672057, 0.06567534640672057, 0.06567534640672057, 0.09303322113146728, 0.09303322113146728, 0.09303322113146728]}, "mutation_prompt": null}
{"id": "74889a20-85ff-41ee-bb51-b0bb62fba72e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_SADE_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant\n        self.social_constant = 1.7  # Adjusted social constant\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.learning_rate = 0.1  # New adaptive learning rate\n        self.elite_fraction = 0.2  # New elite selection fraction\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            # Elite selection\n            elite_count = max(int(self.elite_fraction * self.population_size), 1)\n            elite_indices = np.argsort(scores)[:elite_count]\n            for i in elite_indices:\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Local Search Phase with adaptive learning rate\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.1, 0.1, self.dim) * self.learning_rate\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridPSO_SADE_LS", "description": "Integrates Adaptive Learning Rate and Elite Selection into HybridPSO_SADE_LS to accelerate convergence.", "configspace": "", "generation": 41, "fitness": 0.20291225285635622, "feedback": "The algorithm EnhancedHybridPSO_SADE_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.5528940008845029, 0.5528940008845029, 0.5528940008845029, 0.4858303339120925, 0.4858303339120925, 0.4858303339120925, 0.5297790628193366, 0.5297790628193366, 0.5297790628193366, 0.13505282189422319, 0.13505282189422319, 0.13505282189422319, 0.02015451066065832, 0.02015451066065832, 0.02015451066065832, 0.02925183681431276, 0.02925183681431276, 0.02925183681431276, 0.09931986543595417, 0.09931986543595417, 0.09931986543595417, 0.1308230611208282, 0.1308230611208282, 0.1308230611208282, 0.11218461763257548, 0.11218461763257548, 0.11218461763257548, 0.09577282670677034, 0.09577282670677034, 0.09577282670677034, 0.08427005917258357, 0.08427005917258357, 0.08427005917258357, 0.10370789583526763, 0.10370789583526763, 0.10370789583526763, 0.9761106574318317, 0.9761106574318317, 0.9761106574318317, 0.975334761067546, 0.975334761067546, 0.975334761067546, 0.9752270132641799, 0.9752270132641799, 0.9752270132641799, 0.2279297113008466, 0.2279297113008466, 0.2279297113008466, 0.2629503227096226, 0.2629503227096226, 0.2629503227096226, 0.259268925155013, 0.259268925155013, 0.259268925155013, 0.20574424589803186, 0.20574424589803186, 0.20574424589803186, 0.15868994785288693, 0.15868994785288693, 0.15868994785288693, 0.17279284293354724, 0.17279284293354724, 0.17279284293354724, 0.1459582463912502, 0.1459582463912502, 0.1459582463912502, 0.1099600293374573, 0.1099600293374573, 0.1099600293374573, 0.1488527454618921, 0.1488527454618921, 0.1488527454618921, 0.13515102198093687, 0.13515102198093687, 0.13515102198093687, 0.14748361130121268, 0.14748361130121268, 0.14748361130121268, 0.12192755920768283, 0.12192755920768283, 0.12192755920768283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225029461254415, 0.04225029461254415, 0.04225029461254415, 0.006857950090915943, 0.006857950090915943, 0.006857950090915943, 0.0706242737015702, 0.0706242737015702, 0.0706242737015702, 0.020015639189334244, 0.020015639189334244, 0.020015639189334244, 0.04178711801756185, 0.04178711801756185, 0.04178711801756185, 0.012830005237665865, 0.012830005237665865, 0.012830005237665865, 0.14539020619376464, 0.14539020619376464, 0.14539020619376464, 0.03240319490497712, 0.03240319490497712, 0.03240319490497712, 0.04907144740093283, 0.04907144740093283, 0.04907144740093283, 0.42886683939130876, 0.42886683939130876, 0.42886683939130876, 0.4192017027540813, 0.4192017027540813, 0.4192017027540813, 0.41607476957474654, 0.41607476957474654, 0.41607476957474654, 0.08930074884600403, 0.08930074884600403, 0.08930074884600403, 0.09621015102747044, 0.09621015102747044, 0.09621015102747044, 0.07634969003911596, 0.07634969003911596, 0.07634969003911596, 0.1351095779184659, 0.1351095779184659, 0.1351095779184659, 0.16139806940479162, 0.16139806940479162, 0.16139806940479162, 0.13415967606036683, 0.13415967606036683, 0.13415967606036683, 0.22136430870342827, 0.22136430870342827, 0.22136430870342827, 0.3080577549058142, 0.3080577549058142, 0.3080577549058142, 0.3193942794745127, 0.3193942794745127, 0.3193942794745127, 0.2160325030443362, 0.2160325030443362, 0.2160325030443362, 0.17440019528645467, 0.17440019528645467, 0.17440019528645467, 0.13964449184043992, 0.13964449184043992, 0.13964449184043992, 0.18112688737434424, 0.18112688737434424, 0.18112688737434424, 0.17495389235066983, 0.17495389235066983, 0.17495389235066983, 0.19044669125261593, 0.19044669125261593, 0.19044669125261593, 0.18386896789753726, 0.18386896789753726, 0.18386896789753726, 0.18211672204601526, 0.18211672204601526, 0.18211672204601526, 0.2076112355423101, 0.2076112355423101, 0.2076112355423101, 0.6904048099113957, 0.6904048099113957, 0.6904048099113957, 0.15492566292984888, 0.15492566292984888, 0.15492566292984888, 0.16789813325497527, 0.16789813325497527, 0.16789813325497527, 0.16584131734458007, 0.16584131734458007, 0.16584131734458007, 0.20675369135820953, 0.20675369135820953, 0.20675369135820953, 0.15253441901843856, 0.15253441901843856, 0.15253441901843856, 0.16327278295316805, 0.16327278295316805, 0.16327278295316805, 0.21689713671329947, 0.21689713671329947, 0.21689713671329947, 0.17413680944224819, 0.17413680944224819, 0.17413680944224819, 0.08376529626611895, 0.08376529626611895, 0.08376529626611895, 0.07520293033110104, 0.07520293033110104, 0.07520293033110104, 0.0784073978671237, 0.0784073978671237, 0.0784073978671237]}, "mutation_prompt": null}
{"id": "cae9a10d-8562-4133-80bf-18ba6715a954", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 42, "fitness": 0.26881263163131286, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "5851d663-d82a-4917-b797-81bec27136cc", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "e721cad8-d6a3-4b25-b274-cae65b5330e6", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "a145b63a-83bc-4617-b178-c66004d549d9", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "b6b9ad23-6c92-4772-98b8-892140e5dfc5", "solution": "import numpy as np\n\nclass EnhancedSwarmDifferentialOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.2\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Adaptive Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                exploration_vector = particles[i] + np.random.normal(0, 0.1, self.dim)\n                exploration_vector = np.clip(exploration_vector, self.lower_bound, self.upper_bound)\n                exploration_score = func(exploration_vector)\n                evaluations += 1\n                if exploration_score < scores[i]:\n                    particles[i] = exploration_vector\n                    scores[i] = exploration_score\n\n        return global_best_position, global_best_score", "name": "EnhancedSwarmDifferentialOptimizer", "description": "A novel dual-phase strategy integrating competitive swarm intelligence with adaptive multi-agent differential evolution for enhanced convergence.", "configspace": "", "generation": 45, "fitness": 0.23189172747360323, "feedback": "The algorithm EnhancedSwarmDifferentialOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.6950925641367713, 0.6950925641367713, 0.6950925641367713, 0.6830342232352002, 0.6830342232352002, 0.6830342232352002, 0.6876444204117995, 0.6876444204117995, 0.6876444204117995, 0.2511202454487991, 0.2511202454487991, 0.2511202454487991, 0.361125660927078, 0.361125660927078, 0.361125660927078, 0.3192431971004064, 0.3192431971004064, 0.3192431971004064, 0.10753738335486307, 0.10753738335486307, 0.10753738335486307, 0.09287446718248904, 0.09287446718248904, 0.09287446718248904, 0.14815530282041856, 0.14815530282041856, 0.14815530282041856, 0.15816433670098595, 0.15816433670098595, 0.15816433670098595, 0.12268529791306915, 0.12268529791306915, 0.12268529791306915, 0.07486614681492432, 0.07486614681492432, 0.07486614681492432, 0.9572669029354679, 0.9572669029354679, 0.9572669029354679, 0.9678286946581534, 0.9678286946581534, 0.9678286946581534, 0.9672402502390459, 0.9672402502390459, 0.9672402502390459, 0.24031833064865438, 0.24031833064865438, 0.24031833064865438, 0.22678807555485014, 0.22678807555485014, 0.22678807555485014, 0.279627744930542, 0.279627744930542, 0.279627744930542, 0.3047175886030964, 0.3047175886030964, 0.3047175886030964, 0.21003587585295658, 0.21003587585295658, 0.21003587585295658, 0.11752649160404549, 0.11752649160404549, 0.11752649160404549, 0.1457943622388953, 0.1457943622388953, 0.1457943622388953, 0.12602459983180125, 0.12602459983180125, 0.12602459983180125, 0.09759044619924384, 0.09759044619924384, 0.09759044619924384, 0.13916216215759247, 0.13916216215759247, 0.13916216215759247, 0.1554455373139655, 0.1554455373139655, 0.1554455373139655, 0.10657626705471446, 0.10657626705471446, 0.10657626705471446, 0.0, 0.0, 0.0, 0.0020524839129820727, 0.0020524839129820727, 0.0020524839129820727, 0.0, 0.0, 0.0, 0.08244707896366688, 0.08244707896366688, 0.08244707896366688, 0.018110383088146942, 0.018110383088146942, 0.018110383088146942, 0.04454154229269247, 0.04454154229269247, 0.04454154229269247, 0.04297188386470985, 0.04297188386470985, 0.04297188386470985, 0.05159578604309334, 0.05159578604309334, 0.05159578604309334, 0.06359077089242715, 0.06359077089242715, 0.06359077089242715, 0.09625655222308027, 0.09625655222308027, 0.09625655222308027, 0.08979491735395528, 0.08979491735395528, 0.08979491735395528, 0.08173814473592789, 0.08173814473592789, 0.08173814473592789, 0.4635172598932652, 0.4635172598932652, 0.4635172598932652, 0.4750051295764578, 0.4750051295764578, 0.4750051295764578, 0.4749283601093197, 0.4749283601093197, 0.4749283601093197, 0.09040305811338656, 0.09040305811338656, 0.09040305811338656, 0.10802124000857982, 0.10802124000857982, 0.10802124000857982, 0.09620796475068183, 0.09620796475068183, 0.09620796475068183, 0.22479851453959743, 0.22479851453959743, 0.22479851453959743, 0.18977749215425277, 0.18977749215425277, 0.18977749215425277, 0.15285628991985867, 0.15285628991985867, 0.15285628991985867, 0.3094642967611547, 0.3094642967611547, 0.3094642967611547, 0.31201241033272786, 0.31201241033272786, 0.31201241033272786, 0.33341309150310905, 0.33341309150310905, 0.33341309150310905, 0.15301731675589658, 0.15301731675589658, 0.15301731675589658, 0.2486128869616432, 0.2486128869616432, 0.2486128869616432, 0.14061840628438405, 0.14061840628438405, 0.14061840628438405, 0.1779797507917208, 0.1779797507917208, 0.1779797507917208, 0.18163241799010343, 0.18163241799010343, 0.18163241799010343, 0.18164615042355703, 0.18164615042355703, 0.18164615042355703, 0.20089298626740615, 0.20089298626740615, 0.20089298626740615, 0.20291917769176382, 0.20291917769176382, 0.20291917769176382, 0.19478587066077357, 0.19478587066077357, 0.19478587066077357, 0.8052837638334784, 0.8052837638334784, 0.8052837638334784, 0.1536466195257974, 0.1536466195257974, 0.1536466195257974, 0.1701470679556467, 0.1701470679556467, 0.1701470679556467, 0.16789384100443927, 0.16789384100443927, 0.16789384100443927, 0.20404792148691142, 0.20404792148691142, 0.20404792148691142, 0.15560415328739496, 0.15560415328739496, 0.15560415328739496, 0.18673953198122717, 0.18673953198122717, 0.18673953198122717, 0.185986486695094, 0.185986486695094, 0.185986486695094, 0.18399987800133433, 0.18399987800133433, 0.18399987800133433, 0.08057692708371378, 0.08057692708371378, 0.08057692708371378, 0.07764761357896166, 0.07764761357896166, 0.07764761357896166, 0.09553438293528072, 0.09553438293528072, 0.09553438293528072]}, "mutation_prompt": null}
{"id": "e0e8f5e1-7c09-4948-9ef9-b62592dd7ed3", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "b093e102-f1d5-4d19-9ad5-6b37cea24598", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "c67249fd-0aec-49aa-9991-249e9dd01dc0", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "b8960985-50c2-4d1a-a19b-114130248318", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "feb2c0be-f34f-4a0c-9c0e-6f322248ad60", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "ef251b35-12d6-49a7-ba2e-056f56068b96", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "6834957a-33e6-4f93-8d00-56b427b47c85", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "bec7c904-e935-49cb-ad35-d10d300cb104", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "78f3a081-9c13-4413-9b27-8fae19f15250", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "2e893bfa-479c-4626-a492-0a384782cabe", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.inertia_weight = 0.4\n        self.cognitive_constant = 1.7\n        self.social_constant = 1.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutation_factor_dynamic = self.mutation_factor + np.random.rand() * 0.3\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid algorithm integrating Adaptive PSO and DE variants with enhanced parameter adaptation and dynamic local search strategies to boost convergence.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.8225627799901088, 0.8225627799901088, 0.8225627799901088, 0.8155138372316004, 0.8155138372316004, 0.8155138372316004, 0.8335120123819698, 0.8335120123819698, 0.8335120123819698, 0.6320590120582814, 0.6320590120582814, 0.6320590120582814, 0.6122389430879689, 0.6122389430879689, 0.6122389430879689, 0.34621454594788037, 0.34621454594788037, 0.34621454594788037, 0.13467412128363465, 0.13467412128363465, 0.13467412128363465, 0.06790626114412057, 0.06790626114412057, 0.06790626114412057, 0.14933390073585706, 0.14933390073585706, 0.14933390073585706, 0.1355224129817285, 0.1355224129817285, 0.1355224129817285, 0.08937510021518213, 0.08937510021518213, 0.08937510021518213, 0.10241071238140798, 0.10241071238140798, 0.10241071238140798, 0.9543406782003259, 0.9543406782003259, 0.9543406782003259, 0.9665201553361286, 0.9665201553361286, 0.9665201553361286, 0.9643111540081988, 0.9643111540081988, 0.9643111540081988, 0.3574274753226697, 0.3574274753226697, 0.3574274753226697, 0.3374125286312829, 0.3374125286312829, 0.3374125286312829, 0.40907329751599086, 0.40907329751599086, 0.40907329751599086, 0.21542097151268436, 0.21542097151268436, 0.21542097151268436, 0.26650923481290634, 0.26650923481290634, 0.26650923481290634, 0.17133481125935124, 0.17133481125935124, 0.17133481125935124, 0.1830636327524947, 0.1830636327524947, 0.1830636327524947, 0.12917655629457936, 0.12917655629457936, 0.12917655629457936, 0.12168741188303756, 0.12168741188303756, 0.12168741188303756, 0.19106127018438568, 0.19106127018438568, 0.19106127018438568, 0.12778416474660104, 0.12778416474660104, 0.12778416474660104, 0.24562660300765715, 0.24562660300765715, 0.24562660300765715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0798883125934926, 0.0798883125934926, 0.0798883125934926, 0.08737111140939757, 0.08737111140939757, 0.08737111140939757, 0.03677802822189591, 0.03677802822189591, 0.03677802822189591, 0.05582035306682842, 0.05582035306682842, 0.05582035306682842, 0.15885711937571811, 0.15885711937571811, 0.15885711937571811, 0.11898396238625797, 0.11898396238625797, 0.11898396238625797, 0.1170651121280264, 0.1170651121280264, 0.1170651121280264, 0.15411679306008574, 0.15411679306008574, 0.15411679306008574, 0.12762373256449433, 0.12762373256449433, 0.12762373256449433, 0.5848803100561891, 0.5848803100561891, 0.5848803100561891, 0.5234155516491377, 0.5234155516491377, 0.5234155516491377, 0.5149424445836548, 0.5149424445836548, 0.5149424445836548, 0.12957710007508527, 0.12957710007508527, 0.12957710007508527, 0.12875634996306817, 0.12875634996306817, 0.12875634996306817, 0.10336738028198666, 0.10336738028198666, 0.10336738028198666, 0.18149129439465417, 0.18149129439465417, 0.18149129439465417, 0.19322281407539166, 0.19322281407539166, 0.19322281407539166, 0.19232583783057744, 0.19232583783057744, 0.19232583783057744, 0.3442502533241255, 0.3442502533241255, 0.3442502533241255, 0.3158413223527001, 0.3158413223527001, 0.3158413223527001, 0.4816473926022039, 0.4816473926022039, 0.4816473926022039, 0.24319478709434272, 0.24319478709434272, 0.24319478709434272, 0.18878839933920322, 0.18878839933920322, 0.18878839933920322, 0.14512560405394903, 0.14512560405394903, 0.14512560405394903, 0.20818644848446188, 0.20818644848446188, 0.20818644848446188, 0.19117721533137577, 0.19117721533137577, 0.19117721533137577, 0.21199011600010287, 0.21199011600010287, 0.21199011600010287, 0.1938467283981805, 0.1938467283981805, 0.1938467283981805, 0.21468070508385328, 0.21468070508385328, 0.21468070508385328, 0.21799005766138413, 0.21799005766138413, 0.21799005766138413, 0.8583091343398832, 0.8583091343398832, 0.8583091343398832, 0.165628985397704, 0.165628985397704, 0.165628985397704, 0.1731069058624879, 0.1731069058624879, 0.1731069058624879, 0.16794249720913845, 0.16794249720913845, 0.16794249720913845, 0.20887793804296484, 0.20887793804296484, 0.20887793804296484, 0.15457982256728553, 0.15457982256728553, 0.15457982256728553, 0.1816321045234065, 0.1816321045234065, 0.1816321045234065, 0.18782197403967837, 0.18782197403967837, 0.18782197403967837, 0.1810877886745318, 0.1810877886745318, 0.1810877886745318, 0.08239962289037761, 0.08239962289037761, 0.08239962289037761, 0.08785248954551428, 0.08785248954551428, 0.08785248954551428, 0.07769399201169325, 0.07769399201169325, 0.07769399201169325]}, "mutation_prompt": null}
{"id": "93e603eb-37c5-44e0-a4f8-e7f1e09b8eee", "solution": "import numpy as np\n\nclass DynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for diversity\n        self.inertia_weight = 0.5  # Adjusted inertia weight\n        self.cognitive_constant = 1.5  # Adjusted cognitive constant\n        self.social_constant = 1.5  # Adjusted social constant\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.adaptive_switch_rate = 0.3  # New rate for adaptive strategy switching\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.6, 0.6, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 2):  # Reduced local search for exploration balance\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.3, 0.3, self.dim)  # Increased local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "DynamicHybridOptimizer", "description": "A dynamically adaptive hybrid optimizer blending Particle Swarm and Differential Evolution with a focus on diversity preservation and enhanced local exploration.", "configspace": "", "generation": 56, "fitness": 0.2773046602506817, "feedback": "The algorithm DynamicHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "cae9a10d-8562-4133-80bf-18ba6715a954", "metadata": {"aucs": [0.7981983363975884, 0.7981983363975884, 0.7981983363975884, 0.8000648975930913, 0.8000648975930913, 0.8000648975930913, 0.8186591907456836, 0.8186591907456836, 0.8186591907456836, 0.4324729672872467, 0.4324729672872467, 0.4324729672872467, 0.589649350679359, 0.589649350679359, 0.589649350679359, 0.5500749956942835, 0.5500749956942835, 0.5500749956942835, 0.13315827550276205, 0.13315827550276205, 0.13315827550276205, 0.15348424329879362, 0.15348424329879362, 0.15348424329879362, 0.14602188899283464, 0.14602188899283464, 0.14602188899283464, 0.09439225377337623, 0.09439225377337623, 0.09439225377337623, 0.11932918025412431, 0.11932918025412431, 0.11932918025412431, 0.08616078800713645, 0.08616078800713645, 0.08616078800713645, 0.9730173648683009, 0.9730173648683009, 0.9730173648683009, 0.9727066338899909, 0.9727066338899909, 0.9727066338899909, 0.9713109458925067, 0.9713109458925067, 0.9713109458925067, 0.4410959676912275, 0.4410959676912275, 0.4410959676912275, 0.4192216672569863, 0.4192216672569863, 0.4192216672569863, 0.41452533784160284, 0.41452533784160284, 0.41452533784160284, 0.2229055932569075, 0.2229055932569075, 0.2229055932569075, 0.20962354044127884, 0.20962354044127884, 0.20962354044127884, 0.17564964711120923, 0.17564964711120923, 0.17564964711120923, 0.19338884191905337, 0.19338884191905337, 0.19338884191905337, 0.1308092605945298, 0.1308092605945298, 0.1308092605945298, 0.1982754924360136, 0.1982754924360136, 0.1982754924360136, 0.12310299543414838, 0.12310299543414838, 0.12310299543414838, 0.2185871880215441, 0.2185871880215441, 0.2185871880215441, 0.026471411020111413, 0.026471411020111413, 0.026471411020111413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013533417427208372, 0.0013533417427208372, 0.0013533417427208372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1288603903438108, 0.1288603903438108, 0.1288603903438108, 0.023634145184140865, 0.023634145184140865, 0.023634145184140865, 0.08385446365671201, 0.08385446365671201, 0.08385446365671201, 0.04848372583309357, 0.04848372583309357, 0.04848372583309357, 0.07090258717800757, 0.07090258717800757, 0.07090258717800757, 0.06227074632983132, 0.06227074632983132, 0.06227074632983132, 0.19769654726647323, 0.19769654726647323, 0.19769654726647323, 0.043447238043946124, 0.043447238043946124, 0.043447238043946124, 0.10434412336086729, 0.10434412336086729, 0.10434412336086729, 0.5137523861740425, 0.5137523861740425, 0.5137523861740425, 0.4915949925768037, 0.4915949925768037, 0.4915949925768037, 0.5322723521107782, 0.5322723521107782, 0.5322723521107782, 0.1145290603467023, 0.1145290603467023, 0.1145290603467023, 0.11226400189428731, 0.11226400189428731, 0.11226400189428731, 0.1295823366785942, 0.1295823366785942, 0.1295823366785942, 0.26006184952120825, 0.26006184952120825, 0.26006184952120825, 0.49640689147822736, 0.49640689147822736, 0.49640689147822736, 0.2887069475822728, 0.2887069475822728, 0.2887069475822728, 0.3449549472614287, 0.3449549472614287, 0.3449549472614287, 0.4049409080849593, 0.4049409080849593, 0.4049409080849593, 0.44080612656366225, 0.44080612656366225, 0.44080612656366225, 0.22235636411530413, 0.22235636411530413, 0.22235636411530413, 0.1899526581858031, 0.1899526581858031, 0.1899526581858031, 0.13887281804755436, 0.13887281804755436, 0.13887281804755436, 0.1807575628943645, 0.1807575628943645, 0.1807575628943645, 0.21637025832051338, 0.21637025832051338, 0.21637025832051338, 0.1946504233418488, 0.1946504233418488, 0.1946504233418488, 0.21227390506597377, 0.21227390506597377, 0.21227390506597377, 0.20241141278049735, 0.20241141278049735, 0.20241141278049735, 0.5147428765229178, 0.5147428765229178, 0.5147428765229178, 0.8799311725404427, 0.8799311725404427, 0.8799311725404427, 0.15711506428075606, 0.15711506428075606, 0.15711506428075606, 0.1694035987907475, 0.1694035987907475, 0.1694035987907475, 0.1686967667387964, 0.1686967667387964, 0.1686967667387964, 0.20942951503853802, 0.20942951503853802, 0.20942951503853802, 0.15549114479603143, 0.15549114479603143, 0.15549114479603143, 0.17640282839504884, 0.17640282839504884, 0.17640282839504884, 0.21573987367782554, 0.21573987367782554, 0.21573987367782554, 0.18960019777309678, 0.18960019777309678, 0.18960019777309678, 0.08105998986946339, 0.08105998986946339, 0.08105998986946339, 0.07552558064561021, 0.07552558064561021, 0.07552558064561021, 0.10787316111368195, 0.10787316111368195, 0.10787316111368195]}, "mutation_prompt": null}
{"id": "2135a444-d715-4cca-8840-3fd9912f4d95", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for more exploration\n        self.inertia_weight = 0.7  # Increased inertia weight for global exploration\n        self.cognitive_constant = 1.8  # Enhanced cognitive constant for better personal learning\n        self.social_constant = 2.0  # Enhanced social constant for improved global learning\n        self.mutation_factor = 0.9  # Revised mutation factor for stronger trial generation\n        self.crossover_rate = 0.9  # Higher crossover rate for more diverse solutions\n        self.adaptive_learning_rate = 0.4  # New rate for adaptive parameter tuning\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))  # Expanded velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_learning_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Prioritized Local Search Phase\n            for i in range(self.population_size // 3):  # More intense local search for exploitation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.5, 0.5, self.dim)  # Expanded local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "AdaptiveHybridOptimizer", "description": "A hybrid optimizer integrating adaptive learning for parameter tuning and local search prioritization to enhance convergence speed.", "configspace": "", "generation": 57, "fitness": 0.18437899403574623, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.21.", "error": "", "parent_id": "93e603eb-37c5-44e0-a4f8-e7f1e09b8eee", "metadata": {"aucs": [0.37948716561569884, 0.37948716561569884, 0.37948716561569884, 0.4532893590665622, 0.4532893590665622, 0.4532893590665622, 0.44623925127684994, 0.44623925127684994, 0.44623925127684994, 0.0975276935075482, 0.0975276935075482, 0.0975276935075482, 0.03212375863552386, 0.03212375863552386, 0.03212375863552386, 0.002617353547318957, 0.002617353547318957, 0.002617353547318957, 0.08150687545739488, 0.08150687545739488, 0.08150687545739488, 0.09699335794347841, 0.09699335794347841, 0.09699335794347841, 0.08043024967623169, 0.08043024967623169, 0.08043024967623169, 0.05573060573349686, 0.05573060573349686, 0.05573060573349686, 0.07110490245299772, 0.07110490245299772, 0.07110490245299772, 0.04948097594613576, 0.04948097594613576, 0.04948097594613576, 0.9789520328201246, 0.9789520328201246, 0.9789520328201246, 0.9708706879496107, 0.9708706879496107, 0.9708706879496107, 0.9784035018254041, 0.9784035018254041, 0.9784035018254041, 0.1820878290762512, 0.1820878290762512, 0.1820878290762512, 0.14993035012893174, 0.14993035012893174, 0.14993035012893174, 0.17267533381463906, 0.17267533381463906, 0.17267533381463906, 0.29321566537677235, 0.29321566537677235, 0.29321566537677235, 0.18722894473925322, 0.18722894473925322, 0.18722894473925322, 0.19117437754039557, 0.19117437754039557, 0.19117437754039557, 0.07553160371012713, 0.07553160371012713, 0.07553160371012713, 0.11156359037146335, 0.11156359037146335, 0.11156359037146335, 0.12046547465219937, 0.12046547465219937, 0.12046547465219937, 0.0944285560750523, 0.0944285560750523, 0.0944285560750523, 0.14495140588691557, 0.14495140588691557, 0.14495140588691557, 0.09315078106587793, 0.09315078106587793, 0.09315078106587793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021138701859256037, 0.021138701859256037, 0.021138701859256037, 0.009957184917315676, 0.009957184917315676, 0.009957184917315676, 0.0282563122000693, 0.0282563122000693, 0.0282563122000693, 0.010988931721528927, 0.010988931721528927, 0.010988931721528927, 0.013087455077166132, 0.013087455077166132, 0.013087455077166132, 0.010286724780563805, 0.010286724780563805, 0.010286724780563805, 0.03359548025916592, 0.03359548025916592, 0.03359548025916592, 0.02662166672262356, 0.02662166672262356, 0.02662166672262356, 0.051697641992876964, 0.051697641992876964, 0.051697641992876964, 0.3498119631425738, 0.3498119631425738, 0.3498119631425738, 0.34621179957939907, 0.34621179957939907, 0.34621179957939907, 0.3358830352178003, 0.3358830352178003, 0.3358830352178003, 0.06954830331657902, 0.06954830331657902, 0.06954830331657902, 0.07363972385700124, 0.07363972385700124, 0.07363972385700124, 0.10301861636473764, 0.10301861636473764, 0.10301861636473764, 0.18846497133797047, 0.18846497133797047, 0.18846497133797047, 0.170634286055791, 0.170634286055791, 0.170634286055791, 0.14262924790729137, 0.14262924790729137, 0.14262924790729137, 0.2549665998520869, 0.2549665998520869, 0.2549665998520869, 0.22478360817003495, 0.22478360817003495, 0.22478360817003495, 0.19903305942019667, 0.19903305942019667, 0.19903305942019667, 0.1711594023127585, 0.1711594023127585, 0.1711594023127585, 0.1935410129007502, 0.1935410129007502, 0.1935410129007502, 0.1692828236123758, 0.1692828236123758, 0.1692828236123758, 0.19586113851807618, 0.19586113851807618, 0.19586113851807618, 0.1646203351776423, 0.1646203351776423, 0.1646203351776423, 0.18373294101255255, 0.18373294101255255, 0.18373294101255255, 0.19737909780822127, 0.19737909780822127, 0.19737909780822127, 0.17486808278247667, 0.17486808278247667, 0.17486808278247667, 0.18410775140760627, 0.18410775140760627, 0.18410775140760627, 0.7081224911522295, 0.7081224911522295, 0.7081224911522295, 0.1562549238528016, 0.1562549238528016, 0.1562549238528016, 0.16628183329578838, 0.16628183329578838, 0.16628183329578838, 0.22957153385902884, 0.22957153385902884, 0.22957153385902884, 0.2004466354231954, 0.2004466354231954, 0.2004466354231954, 0.15091598926444982, 0.15091598926444982, 0.15091598926444982, 0.1980930052572003, 0.1980930052572003, 0.1980930052572003, 0.18370611765749456, 0.18370611765749456, 0.18370611765749456, 0.19456617513443808, 0.19456617513443808, 0.19456617513443808, 0.06795141821741668, 0.06795141821741668, 0.06795141821741668, 0.05719131989285853, 0.05719131989285853, 0.05719131989285853, 0.07191654439008233, 0.07191654439008233, 0.07191654439008233]}, "mutation_prompt": null}
{"id": "b7c5c48f-0f7d-4eb4-8c0b-e99633f27637", "solution": "import numpy as np\n\nclass EnhancedDynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for improved exploration\n        self.inertia_weight = 0.7  # Increased inertia for better global exploration\n        self.cognitive_constant = 2.0  # Enhanced cognitive constant for quicker personal best convergence\n        self.social_constant = 1.3  # Reduced social constant to balance exploration\n        self.mutation_factor = 0.9  # Enhanced mutation factor for more aggressive exploration\n        self.crossover_rate = 0.9  # Higher crossover rate for diversified solutions\n        self.adaptive_switch_rate = 0.25  # Adjusted rate for adaptive strategy\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        adaptive_phase = True\n        dynamic_population_size = self.population_size\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles[:dynamic_population_size])\n            evaluations += dynamic_population_size\n\n            for i in range(dynamic_population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(dynamic_population_size, self.dim)\n            r2 = np.random.rand(dynamic_population_size, self.dim)\n            velocities[:dynamic_population_size] = (self.inertia_weight * velocities[:dynamic_population_size] +\n                                                     self.cognitive_constant * r1 * (personal_best_positions[:dynamic_population_size] - particles[:dynamic_population_size]) +\n                                                     self.social_constant * r2 * (global_best_position - particles[:dynamic_population_size]))\n            particles[:dynamic_population_size] = np.clip(particles[:dynamic_population_size] + velocities[:dynamic_population_size], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(dynamic_population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(dynamic_population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Dynamic Local Search Phase\n            for i in range(dynamic_population_size // 3):  # Focused local search for convergence\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            # Dynamic population size adjustment\n            if evaluations + dynamic_population_size < self.budget:\n                dynamic_population_size = int(self.population_size * (1 - evaluations / self.budget))\n\n        return global_best_position, global_best_score", "name": "EnhancedDynamicHybridOptimizer", "description": "Enhanced Dynamic Hybrid Optimizer with Adaptive Learning and Dynamic Population for accelerated convergence.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "93e603eb-37c5-44e0-a4f8-e7f1e09b8eee", "metadata": {}, "mutation_prompt": null}
{"id": "ddffb6fd-386a-41cf-b622-186d85005549", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 59, "fitness": 0.2781280055186673, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "93e603eb-37c5-44e0-a4f8-e7f1e09b8eee", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "a781477c-784f-4aa3-87d5-96ba6820a05f", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "60b54d15-4a0d-4026-a147-f935bd19b9b0", "solution": "import numpy as np\n\nclass EnhancedDynamicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30  # Dynamic population starts smaller\n        self.max_population_size = 60  # Allow population to grow\n        self.inertia_weight = 0.5  # Slightly higher inertia for stability\n        self.cognitive_constant = 1.3  # Adjusted cognitive constant\n        self.social_constant = 1.5  # Adjusted social constant\n        self.mutation_factor = 0.85  # Fine-tuned mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.expansion_rate = 0.1  # Rate of increasing population size\n        self.adaptive_switch_rate = 0.3  # Slightly increased adaptive switch rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = self.initial_population_size\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += population_size\n\n            for i in range(population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(population_size, self.dim)\n            r2 = np.random.rand(population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Dynamic Local Search Phase\n            for i in range(int(population_size * 0.2)):  # Reduced local search frequency\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.3, 0.3, self.dim)  # Broader local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            # Dynamically adjust population size\n            if np.random.rand() < self.expansion_rate:\n                new_particles = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                particles = np.vstack((particles, new_particles))\n                velocities = np.vstack((velocities, np.random.uniform(-0.5, 0.5, (5, self.dim))))\n                personal_best_positions = np.vstack((personal_best_positions, new_particles))\n                personal_best_scores = np.append(personal_best_scores, np.full(5, np.inf))\n                population_size = min(population_size + 5, self.max_population_size)\n\n        return global_best_position, global_best_score", "name": "EnhancedDynamicOptimizer", "description": "A synergy of Dynamic Population and Adaptive Strategy Adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (60,5) (65,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (60,5) (65,5) ')", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {}, "mutation_prompt": null}
{"id": "fc2e9765-03b5-4722-999c-c65f3e51df4a", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "e5b85ab8-11ad-4dbd-a637-2648da6a97ee", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "d7a36976-bdd0-4946-bd99-760c614ebf39", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "f141a488-e31a-400d-b195-4aa927ea5a90", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "532c4cfb-b176-4f7d-ac14-6b454d422b82", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "6048b0fb-24d5-42ea-8b6b-5c5a061f64d2", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "cf77d7b5-c972-44da-9be4-711fefa76ba3", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "6e8079ed-26fc-4559-a316-8c0bd87930a4", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "b8e06678-b9df-45eb-b498-3e0506680d64", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "92207d9f-53de-4d76-844a-eeca3ba31b18", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "fb5dceb5-56db-4f39-9abd-0ab68246e635", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "c2ccfc78-9958-4c20-9b60-cea505ed3462", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight\n        self.cognitive_constant = 1.2  # Reduced cognitive constant\n        self.social_constant = 1.8  # Increased social constant\n        self.mutation_factor = 0.9  # Enhanced mutation factor\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.adaptive_switch_rate = 0.3  # Increased adaptive strategy switch rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Further reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n        dynamic_scaling_factor = 0.5  # Initial dynamic scaling factor\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            # Adjust inertia weight dynamically\n            self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations >= self.budget:\n                break\n\n            # Enhanced Local Search Phase with dynamic scaling\n            for i in range(self.population_size // 2):  # Increased local search participation\n                if evaluations >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim) * dynamic_scaling_factor\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            dynamic_scaling_factor *= 0.95  # Decay the dynamic scaling factor for precision\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer combining Differential Evolution with Particle Swarm Optimization and dynamic scaling for enhanced convergence.", "configspace": "", "generation": 73, "fitness": 0.20168625177867286, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.5283975917125743, 0.5283975917125743, 0.5283975917125743, 0.4753321114986222, 0.4753321114986222, 0.4753321114986222, 0.5745231636414682, 0.5745231636414682, 0.5745231636414682, 0.009950375383859456, 0.009950375383859456, 0.009950375383859456, 0.1910672231310645, 0.1910672231310645, 0.1910672231310645, 0.09762103761682339, 0.09762103761682339, 0.09762103761682339, 0.11486441540009129, 0.11486441540009129, 0.11486441540009129, 0.11545968538947149, 0.11545968538947149, 0.11545968538947149, 0.08174231560079892, 0.08174231560079892, 0.08174231560079892, 0.09755347234195033, 0.09755347234195033, 0.09755347234195033, 0.09730092937848256, 0.09730092937848256, 0.09730092937848256, 0.06920120046814404, 0.06920120046814404, 0.06920120046814404, 0.9739077893979837, 0.9739077893979837, 0.9739077893979837, 0.9755453729060078, 0.9755453729060078, 0.9755453729060078, 0.9881325951738321, 0.9881325951738321, 0.9881325951738321, 0.238597260402999, 0.238597260402999, 0.238597260402999, 0.24119963319327953, 0.24119963319327953, 0.24119963319327953, 0.24632358780681174, 0.24632358780681174, 0.24632358780681174, 0.28098777079898496, 0.28098777079898496, 0.28098777079898496, 0.24456539705365898, 0.24456539705365898, 0.24456539705365898, 0.11419240111527706, 0.11419240111527706, 0.11419240111527706, 0.15688676430564286, 0.15688676430564286, 0.15688676430564286, 0.10259522638216989, 0.10259522638216989, 0.10259522638216989, 0.12433013462625131, 0.12433013462625131, 0.12433013462625131, 0.11307752761146317, 0.11307752761146317, 0.11307752761146317, 0.10136062353240072, 0.10136062353240072, 0.10136062353240072, 0.09357611032186686, 0.09357611032186686, 0.09357611032186686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030746829729879632, 0.0030746829729879632, 0.0030746829729879632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041194184775140585, 0.041194184775140585, 0.041194184775140585, 0.0025529679506136604, 0.0025529679506136604, 0.0025529679506136604, 0.010640869357058325, 0.010640869357058325, 0.010640869357058325, 0.037202353487089335, 0.037202353487089335, 0.037202353487089335, 0.047933373426643056, 0.047933373426643056, 0.047933373426643056, 0.041859350776394466, 0.041859350776394466, 0.041859350776394466, 0.011064012631038178, 0.011064012631038178, 0.011064012631038178, 0.028646235646995644, 0.028646235646995644, 0.028646235646995644, 0.06081407149508944, 0.06081407149508944, 0.06081407149508944, 0.40373260222473484, 0.40373260222473484, 0.40373260222473484, 0.4211622626983086, 0.4211622626983086, 0.4211622626983086, 0.3885213364842691, 0.3885213364842691, 0.3885213364842691, 0.0863686820127274, 0.0863686820127274, 0.0863686820127274, 0.07319457574254862, 0.07319457574254862, 0.07319457574254862, 0.0990869604992014, 0.0990869604992014, 0.0990869604992014, 0.14925997473872854, 0.14925997473872854, 0.14925997473872854, 0.14565934259283553, 0.14565934259283553, 0.14565934259283553, 0.14504584106315, 0.14504584106315, 0.14504584106315, 0.19883140288872891, 0.19883140288872891, 0.19883140288872891, 0.26626944442232625, 0.26626944442232625, 0.26626944442232625, 0.24869578754432786, 0.24869578754432786, 0.24869578754432786, 0.12572423054096526, 0.12572423054096526, 0.12572423054096526, 0.1988201608494815, 0.1988201608494815, 0.1988201608494815, 0.11912602947310502, 0.11912602947310502, 0.11912602947310502, 0.17569128578306592, 0.17569128578306592, 0.17569128578306592, 0.1687479307266695, 0.1687479307266695, 0.1687479307266695, 0.19176679537168428, 0.19176679537168428, 0.19176679537168428, 0.20393700241161128, 0.20393700241161128, 0.20393700241161128, 0.1965420990766823, 0.1965420990766823, 0.1965420990766823, 0.1942564052689163, 0.1942564052689163, 0.1942564052689163, 0.6285147261236165, 0.6285147261236165, 0.6285147261236165, 0.5434542088551773, 0.5434542088551773, 0.5434542088551773, 0.16871103676936505, 0.16871103676936505, 0.16871103676936505, 0.161443310282801, 0.161443310282801, 0.161443310282801, 0.19266373778008372, 0.19266373778008372, 0.19266373778008372, 0.15305767360666855, 0.15305767360666855, 0.15305767360666855, 0.17270858660030008, 0.17270858660030008, 0.17270858660030008, 0.18067454661878257, 0.18067454661878257, 0.18067454661878257, 0.1835688974821067, 0.1835688974821067, 0.1835688974821067, 0.07644105986792726, 0.07644105986792726, 0.07644105986792726, 0.06584612530078304, 0.06584612530078304, 0.06584612530078304, 0.060412247651734474, 0.060412247651734474, 0.060412247651734474]}, "mutation_prompt": null}
{"id": "50274b7d-b41d-4b1b-8f52-60cbc29c48ff", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "a098db85-12d0-4213-863e-d7660e3f7f4a", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "457a8342-155d-4ac7-af61-a1bf915786b9", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "7f8d2353-0f0d-4bdc-9c98-b171f2f7d272", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "6342b6dd-3471-4f96-8651-e5107e3eafdd", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "a0f3124b-a777-45a4-aa41-1a48e2656955", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "bae166ad-caf2-446d-b295-a98dd9b6143b", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Reduced population size for more focused search\n        self.inertia_weight = 0.5  # Slightly increased inertia weight for better momentum\n        self.cognitive_constant = 1.6  # Increased cognitive constant for personal exploration\n        self.social_constant = 1.8  # Increased social constant for enhanced convergence\n        self.mutation_factor = 0.7  # Moderated mutation factor for controlled diversity\n        self.crossover_rate = 0.85  # Balanced crossover rate for effective recombination\n        self.adaptive_learning_rate = 0.1  # New adaptive learning rate for scaling improvements\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            # Adaptive Learning Rate Adjustment\n            self.inertia_weight *= (1 - self.adaptive_learning_rate)\n            self.cognitive_constant *= (1 + self.adaptive_learning_rate / 2)\n            self.social_constant *= (1 + self.adaptive_learning_rate / 2)\n\n            # Dynamic Mutation Strategy for Diversity\n            if np.random.rand() < 0.3:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search with Dynamic Range\n            for i in range(self.population_size // 3):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.15, 0.15, self.dim)  # Narrowed search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizerV2", "description": "A refined, exploration-enhanced optimizer that integrates adaptive learning rates with a dynamic mutation strategy to boost convergence speed.", "configspace": "", "generation": 80, "fitness": 0.1508401011014668, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.2681185875144795, 0.2681185875144795, 0.2681185875144795, 0.3771824597565796, 0.3771824597565796, 0.3771824597565796, 0.38770479906719424, 0.38770479906719424, 0.38770479906719424, 0.01640778886305394, 0.01640778886305394, 0.01640778886305394, 0.0032459435666923886, 0.0032459435666923886, 0.0032459435666923886, 0.0024061429526285316, 0.0024061429526285316, 0.0024061429526285316, 0.046378451392334874, 0.046378451392334874, 0.046378451392334874, 0.055454788609822225, 0.055454788609822225, 0.055454788609822225, 0.04751728688950474, 0.04751728688950474, 0.04751728688950474, 0.04750653221847756, 0.04750653221847756, 0.04750653221847756, 0.07649265673253358, 0.07649265673253358, 0.07649265673253358, 0.053214199697715237, 0.053214199697715237, 0.053214199697715237, 0.9885243280396276, 0.9885243280396276, 0.9885243280396276, 0.9795847390784599, 0.9795847390784599, 0.9795847390784599, 0.9814434330386775, 0.9814434330386775, 0.9814434330386775, 0.1551331010442063, 0.1551331010442063, 0.1551331010442063, 0.05295508235259416, 0.05295508235259416, 0.05295508235259416, 0.09906469554305186, 0.09906469554305186, 0.09906469554305186, 0.05527238928517342, 0.05527238928517342, 0.05527238928517342, 0.16149166441423934, 0.16149166441423934, 0.16149166441423934, 0.1122023090651415, 0.1122023090651415, 0.1122023090651415, 0.11194693459232663, 0.11194693459232663, 0.11194693459232663, 0.12565592241924683, 0.12565592241924683, 0.12565592241924683, 0.12112552524205078, 0.12112552524205078, 0.12112552524205078, 0.043138292180509574, 0.043138292180509574, 0.043138292180509574, 0.10901782442961627, 0.10901782442961627, 0.10901782442961627, 0.09648553946013994, 0.09648553946013994, 0.09648553946013994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023275663934737678, 0.023275663934737678, 0.023275663934737678, 0.027687668553087352, 0.027687668553087352, 0.027687668553087352, 0.0188676577602932, 0.0188676577602932, 0.0188676577602932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032210707490798685, 0.032210707490798685, 0.032210707490798685, 0.00806929581268645, 0.00806929581268645, 0.00806929581268645, 0.36012483652172156, 0.36012483652172156, 0.36012483652172156, 0.3014232833374977, 0.3014232833374977, 0.3014232833374977, 0.2974611737213605, 0.2974611737213605, 0.2974611737213605, 0.08149384830630513, 0.08149384830630513, 0.08149384830630513, 0.07612688105013554, 0.07612688105013554, 0.07612688105013554, 0.058289731229052455, 0.058289731229052455, 0.058289731229052455, 0.13339607671176668, 0.13339607671176668, 0.13339607671176668, 0.14373786071273864, 0.14373786071273864, 0.14373786071273864, 0.12222204755051336, 0.12222204755051336, 0.12222204755051336, 0.17499818980693593, 0.17499818980693593, 0.17499818980693593, 0.14395285377587874, 0.14395285377587874, 0.14395285377587874, 0.14671562281004535, 0.14671562281004535, 0.14671562281004535, 0.16234436538653385, 0.16234436538653385, 0.16234436538653385, 0.15215694840595884, 0.15215694840595884, 0.15215694840595884, 0.11596189879445906, 0.11596189879445906, 0.11596189879445906, 0.15317020473079923, 0.15317020473079923, 0.15317020473079923, 0.14529043103085182, 0.14529043103085182, 0.14529043103085182, 0.17076174350763307, 0.17076174350763307, 0.17076174350763307, 0.1767289195942272, 0.1767289195942272, 0.1767289195942272, 0.16826845528084888, 0.16826845528084888, 0.16826845528084888, 0.15008394630229083, 0.15008394630229083, 0.15008394630229083, 0.18241544312366043, 0.18241544312366043, 0.18241544312366043, 0.15064759914090176, 0.15064759914090176, 0.15064759914090176, 0.15985178385430154, 0.15985178385430154, 0.15985178385430154, 0.20397032900001344, 0.20397032900001344, 0.20397032900001344, 0.18936678459648681, 0.18936678459648681, 0.18936678459648681, 0.17580061666619717, 0.17580061666619717, 0.17580061666619717, 0.1686126122086158, 0.1686126122086158, 0.1686126122086158, 0.1850127107833608, 0.1850127107833608, 0.1850127107833608, 0.18416209489191226, 0.18416209489191226, 0.18416209489191226, 0.0518278626435027, 0.0518278626435027, 0.0518278626435027, 0.04647140524445659, 0.04647140524445659, 0.04647140524445659, 0.04215630758696676, 0.04215630758696676, 0.04215630758696676]}, "mutation_prompt": null}
{"id": "6a59a409-4a00-46d1-a560-42979a953283", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "862c58a2-2c57-41a7-a9e4-13b972c8846f", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40  # Reduced population size for faster convergence\n        self.inertia_weight = 0.4  # Adjusted inertia weight for PSO phase\n        self.cognitive_constant = 1.4  # Adjusted cognitive constant\n        self.social_constant = 1.6  # Adjusted social constant\n        self.mutation_factor = 0.8  # Higher mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for better mixing\n        self.adaptive_switch_rate = 0.25  # Refined adaptive strategy switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(self.population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            # Enhanced Local Search Phase\n            for i in range(self.population_size // 3):  # Further reduced local search for faster adaptation\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.25, 0.25, self.dim)  # Adjusted local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A diversity-driven hybrid optimizer combining Adaptive Differential Evolution with Local Search for accelerated convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.87434589816081, 0.87434589816081, 0.87434589816081, 0.8614345120832075, 0.8614345120832075, 0.8614345120832075, 0.8585660830685579, 0.8585660830685579, 0.8585660830685579, 0.6161088955332752, 0.6161088955332752, 0.6161088955332752, 0.654204860455911, 0.654204860455911, 0.654204860455911, 0.052245284339259346, 0.052245284339259346, 0.052245284339259346, 0.11833118588210023, 0.11833118588210023, 0.11833118588210023, 0.13798362065258096, 0.13798362065258096, 0.13798362065258096, 0.0906510307896915, 0.0906510307896915, 0.0906510307896915, 0.11684244293286994, 0.11684244293286994, 0.11684244293286994, 0.14011244386964905, 0.14011244386964905, 0.14011244386964905, 0.14954603081970685, 0.14954603081970685, 0.14954603081970685, 0.9612352815004391, 0.9612352815004391, 0.9612352815004391, 0.9747277993068889, 0.9747277993068889, 0.9747277993068889, 0.9736700052560865, 0.9736700052560865, 0.9736700052560865, 0.6009438709233658, 0.6009438709233658, 0.6009438709233658, 0.5096901463971246, 0.5096901463971246, 0.5096901463971246, 0.6255007780315017, 0.6255007780315017, 0.6255007780315017, 0.16503191387210758, 0.16503191387210758, 0.16503191387210758, 0.1903896488864809, 0.1903896488864809, 0.1903896488864809, 0.11616585393169776, 0.11616585393169776, 0.11616585393169776, 0.20229940533723634, 0.20229940533723634, 0.20229940533723634, 0.12909784893276033, 0.12909784893276033, 0.12909784893276033, 0.1711005777374932, 0.1711005777374932, 0.1711005777374932, 0.18756187284937065, 0.18756187284937065, 0.18756187284937065, 0.22189541827951564, 0.22189541827951564, 0.22189541827951564, 0.23799298177897865, 0.23799298177897865, 0.23799298177897865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06825642422931033, 0.06825642422931033, 0.06825642422931033, 0.02496882139093537, 0.02496882139093537, 0.02496882139093537, 0.0527853032907134, 0.0527853032907134, 0.0527853032907134, 0.0483285525703554, 0.0483285525703554, 0.0483285525703554, 0.2554734092891826, 0.2554734092891826, 0.2554734092891826, 0.09805496521310286, 0.09805496521310286, 0.09805496521310286, 0.14680686509839636, 0.14680686509839636, 0.14680686509839636, 0.07088963152404415, 0.07088963152404415, 0.07088963152404415, 0.08159489507189044, 0.08159489507189044, 0.08159489507189044, 0.5225890086792153, 0.5225890086792153, 0.5225890086792153, 0.5580082379618383, 0.5580082379618383, 0.5580082379618383, 0.5431118994678986, 0.5431118994678986, 0.5431118994678986, 0.1021323188234976, 0.1021323188234976, 0.1021323188234976, 0.12717792770567593, 0.12717792770567593, 0.12717792770567593, 0.08786538327906379, 0.08786538327906379, 0.08786538327906379, 0.41231271303453365, 0.41231271303453365, 0.41231271303453365, 0.17499145185247567, 0.17499145185247567, 0.17499145185247567, 0.20797179246886432, 0.20797179246886432, 0.20797179246886432, 0.2956024953015023, 0.2956024953015023, 0.2956024953015023, 0.3134338524890229, 0.3134338524890229, 0.3134338524890229, 0.41930114955467346, 0.41930114955467346, 0.41930114955467346, 0.2344377804297877, 0.2344377804297877, 0.2344377804297877, 0.24395155685709247, 0.24395155685709247, 0.24395155685709247, 0.14120438208871533, 0.14120438208871533, 0.14120438208871533, 0.18733958552863805, 0.18733958552863805, 0.18733958552863805, 0.19989887791075112, 0.19989887791075112, 0.19989887791075112, 0.1961696149466765, 0.1961696149466765, 0.1961696149466765, 0.2067976098168649, 0.2067976098168649, 0.2067976098168649, 0.1987197111665564, 0.1987197111665564, 0.1987197111665564, 0.19869353697540248, 0.19869353697540248, 0.19869353697540248, 0.8987084485530042, 0.8987084485530042, 0.8987084485530042, 0.15760443453004536, 0.15760443453004536, 0.15760443453004536, 0.1767298693893946, 0.1767298693893946, 0.1767298693893946, 0.1676216973405652, 0.1676216973405652, 0.1676216973405652, 0.21095358088965466, 0.21095358088965466, 0.21095358088965466, 0.2097190656118001, 0.2097190656118001, 0.2097190656118001, 0.19546045553461766, 0.19546045553461766, 0.19546045553461766, 0.17539624226525408, 0.17539624226525408, 0.17539624226525408, 0.19001344488391647, 0.19001344488391647, 0.19001344488391647, 0.08275546838387837, 0.08275546838387837, 0.08275546838387837, 0.13280199878751386, 0.13280199878751386, 0.13280199878751386, 0.07060624554905404, 0.07060624554905404, 0.07060624554905404]}, "mutation_prompt": null}
{"id": "2ba820d8-8ac4-46a4-a9da-dc3845feec7c", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Initial larger population\n        self.min_population_size = 20  # Minimum population size for adaptation\n        self.inertia_weight = 0.5  # Slightly increased inertia weight\n        self.cognitive_constant = 1.2  # Lower cognitive constant for balanced exploration\n        self.social_constant = 1.7  # Slightly increased social constant for convergence\n        self.mutation_factor = 0.9  # Higher mutation factor for exploration\n        self.crossover_rate = 0.8  # Reduced crossover rate for selective mixing\n        self.adaptive_switch_rate = 0.3  # Increased adaptive switching rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.initial_population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.initial_population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        adaptive_phase = True\n        current_population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += current_population_size\n\n            for i in range(current_population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            r1 = np.random.rand(current_population_size, self.dim)\n            r2 = np.random.rand(current_population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_switch_rate:\n                adaptive_phase = not adaptive_phase\n\n            if adaptive_phase:\n                for i in range(current_population_size):\n                    if evaluations + 1 >= self.budget:\n                        break\n                    idxs = [idx for idx in range(current_population_size) if idx != i]\n                    a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(particles[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            trial_vector[j] = mutant_vector[j]\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < scores[i]:\n                        particles[i] = trial_vector\n                        scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(current_population_size // 3):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[i] + np.random.uniform(-0.2, 0.2, self.dim)  # More refined local search range\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[i]:\n                    particles[i] = local_candidate\n                    scores[i] = local_score\n\n            # Adaptive Population Reduction\n            if current_population_size > self.min_population_size and np.random.rand() < 0.1:\n                current_population_size -= 1\n                particles = particles[:current_population_size]\n                velocities = velocities[:current_population_size]\n                personal_best_positions = personal_best_positions[:current_population_size]\n                personal_best_scores = personal_best_scores[:current_population_size]\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizerV2", "description": "A refined hybrid optimizer with adaptive population reduction strategy and random neighborhood search to enhance convergence speed.", "configspace": "", "generation": 83, "fitness": 0.26876082016199015, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.8451795222007326, 0.8451795222007326, 0.8451795222007326, 0.8401521419846849, 0.8401521419846849, 0.8401521419846849, 0.8357713642397417, 0.8357713642397417, 0.8357713642397417, 0.039487618344786424, 0.039487618344786424, 0.039487618344786424, 0.6075765218751137, 0.6075765218751137, 0.6075765218751137, 0.05295117642401148, 0.05295117642401148, 0.05295117642401148, 0.11472637563553234, 0.11472637563553234, 0.11472637563553234, 0.12144977390798817, 0.12144977390798817, 0.12144977390798817, 0.1143308488242657, 0.1143308488242657, 0.1143308488242657, 0.15630478384836421, 0.15630478384836421, 0.15630478384836421, 0.09192123948066311, 0.09192123948066311, 0.09192123948066311, 0.051084094948444125, 0.051084094948444125, 0.051084094948444125, 0.9782761959970444, 0.9782761959970444, 0.9782761959970444, 0.9852481936991687, 0.9852481936991687, 0.9852481936991687, 0.9775290785764984, 0.9775290785764984, 0.9775290785764984, 0.5790665419466725, 0.5790665419466725, 0.5790665419466725, 0.5930340295960237, 0.5930340295960237, 0.5930340295960237, 0.5546470138049396, 0.5546470138049396, 0.5546470138049396, 0.1550379510645098, 0.1550379510645098, 0.1550379510645098, 0.2083744555556225, 0.2083744555556225, 0.2083744555556225, 0.24752414043600202, 0.24752414043600202, 0.24752414043600202, 0.21609426325214498, 0.21609426325214498, 0.21609426325214498, 0.1291920736044342, 0.1291920736044342, 0.1291920736044342, 0.20935236553539927, 0.20935236553539927, 0.20935236553539927, 0.13079183563515306, 0.13079183563515306, 0.13079183563515306, 0.2528405235688468, 0.2528405235688468, 0.2528405235688468, 0.08031557260153754, 0.08031557260153754, 0.08031557260153754, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028088126306598293, 0.028088126306598293, 0.028088126306598293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10506724682609636, 0.10506724682609636, 0.10506724682609636, 0.017180399127364243, 0.017180399127364243, 0.017180399127364243, 0.05685664741276997, 0.05685664741276997, 0.05685664741276997, 0.04719419874288311, 0.04719419874288311, 0.04719419874288311, 0.08503718990482534, 0.08503718990482534, 0.08503718990482534, 0.10015188259819696, 0.10015188259819696, 0.10015188259819696, 0.06940626916969395, 0.06940626916969395, 0.06940626916969395, 0.04063154589503881, 0.04063154589503881, 0.04063154589503881, 0.08148804248373964, 0.08148804248373964, 0.08148804248373964, 0.5129345638528027, 0.5129345638528027, 0.5129345638528027, 0.5210528759495837, 0.5210528759495837, 0.5210528759495837, 0.5504465531666705, 0.5504465531666705, 0.5504465531666705, 0.1240110828578207, 0.1240110828578207, 0.1240110828578207, 0.1218146086244466, 0.1218146086244466, 0.1218146086244466, 0.1113935191319515, 0.1113935191319515, 0.1113935191319515, 0.16776245411054946, 0.16776245411054946, 0.16776245411054946, 0.20269715338883754, 0.20269715338883754, 0.20269715338883754, 0.1801010149697687, 0.1801010149697687, 0.1801010149697687, 0.33115114644163746, 0.33115114644163746, 0.33115114644163746, 0.28840680303257793, 0.28840680303257793, 0.28840680303257793, 0.47590121512442296, 0.47590121512442296, 0.47590121512442296, 0.20026563515277107, 0.20026563515277107, 0.20026563515277107, 0.18949222117549236, 0.18949222117549236, 0.18949222117549236, 0.26741575759585645, 0.26741575759585645, 0.26741575759585645, 0.22135039773862197, 0.22135039773862197, 0.22135039773862197, 0.20839191686632252, 0.20839191686632252, 0.20839191686632252, 0.19781368039502967, 0.19781368039502967, 0.19781368039502967, 0.6614091052058813, 0.6614091052058813, 0.6614091052058813, 0.18486515187470776, 0.18486515187470776, 0.18486515187470776, 0.17595105991182458, 0.17595105991182458, 0.17595105991182458, 0.9160258698696582, 0.9160258698696582, 0.9160258698696582, 0.15831765656101127, 0.15831765656101127, 0.15831765656101127, 0.17024354423724908, 0.17024354423724908, 0.17024354423724908, 0.16829298320279462, 0.16829298320279462, 0.16829298320279462, 0.21050722645125863, 0.21050722645125863, 0.21050722645125863, 0.1559881286171365, 0.1559881286171365, 0.1559881286171365, 0.17936501222762857, 0.17936501222762857, 0.17936501222762857, 0.19022952268115734, 0.19022952268115734, 0.19022952268115734, 0.19107438926382192, 0.19107438926382192, 0.19107438926382192, 0.09325661129744056, 0.09325661129744056, 0.09325661129744056, 0.08648596859897129, 0.08648596859897129, 0.08648596859897129, 0.1368029770320549, 0.1368029770320549, 0.1368029770320549]}, "mutation_prompt": null}
{"id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 84, "fitness": 0.2830748552973877, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "ddffb6fd-386a-41cf-b622-186d85005549", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "18638948-0ee1-4056-b6f5-8017a78e6cc9", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "818cd0cb-a14b-4bbb-b7a4-a8c0148cd7e1", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "97090aec-135c-4870-8602-51cc387b1131", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "0de38b2a-5a3d-4a9b-8ce9-6eda6fc52744", "solution": "import numpy as np\n\nclass MemoryEnhancedOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increase population size for diversified search\n        self.inertia_weight = 0.4  # Adjusted inertia weight for balanced exploration-exploitation\n        self.cognitive_constant = 1.4  # Slightly reduced cognitive constant to avoid premature convergence\n        self.social_constant = 1.8  # Enhanced social constant to leverage collective intelligence\n        self.mutation_factor = 0.8  # Reduced mutation factor for stability\n        self.crossover_rate = 0.8  # Tweaked crossover rate to maintain diversity\n        self.elitism_rate = 0.15  # Increased elitism to ensure progress retention\n        self.memory_factor = 0.1  # Introduced memory factor to retain useful historical solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Narrower velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n        historical_best_positions = []\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n                    historical_best_positions.append(global_best_position)\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            if historical_best_positions and len(historical_best_positions) > 10:\n                historical_best_positions = historical_best_positions[-10:]\n                for mem_pos in historical_best_positions:\n                    mem_candidate = mem_pos + self.memory_factor * np.random.uniform(-1.0, 1.0, self.dim)\n                    mem_candidate = np.clip(mem_candidate, self.lower_bound, self.upper_bound)\n                    mem_score = func(mem_candidate)\n                    evaluations += 1\n                    if mem_score < global_best_score:\n                        global_best_score = mem_score\n                        global_best_position = mem_candidate\n\n        return global_best_position, global_best_score", "name": "MemoryEnhancedOptimizer", "description": "A blended optimizer integrating enhanced memory strategies and adaptive convergence mechanisms for rapid solution refinement.", "configspace": "", "generation": 88, "fitness": 0.25191871729633886, "feedback": "The algorithm MemoryEnhancedOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.7445208980402847, 0.7445208980402847, 0.7445208980402847, 0.7302432495101002, 0.7302432495101002, 0.7302432495101002, 0.7477371357016711, 0.7477371357016711, 0.7477371357016711, 0.4113234915110805, 0.4113234915110805, 0.4113234915110805, 0.04712319264294851, 0.04712319264294851, 0.04712319264294851, 0.04805871065278566, 0.04805871065278566, 0.04805871065278566, 0.1500914370298997, 0.1500914370298997, 0.1500914370298997, 0.1349464285495089, 0.1349464285495089, 0.1349464285495089, 0.10574096602732641, 0.10574096602732641, 0.10574096602732641, 0.10314808726938918, 0.10314808726938918, 0.10314808726938918, 0.14174754462512718, 0.14174754462512718, 0.14174754462512718, 0.12167161251075065, 0.12167161251075065, 0.12167161251075065, 0.9746938807361654, 0.9746938807361654, 0.9746938807361654, 0.972527010718683, 0.972527010718683, 0.972527010718683, 0.978665065174017, 0.978665065174017, 0.978665065174017, 0.3619929734991675, 0.3619929734991675, 0.3619929734991675, 0.2632843405202683, 0.2632843405202683, 0.2632843405202683, 0.33745746590400905, 0.33745746590400905, 0.33745746590400905, 0.3445567295296711, 0.3445567295296711, 0.3445567295296711, 0.15881849294298678, 0.15881849294298678, 0.15881849294298678, 0.424798836084771, 0.424798836084771, 0.424798836084771, 0.18696548579684458, 0.18696548579684458, 0.18696548579684458, 0.21929036153867365, 0.21929036153867365, 0.21929036153867365, 0.18241596905068946, 0.18241596905068946, 0.18241596905068946, 0.11367270837441013, 0.11367270837441013, 0.11367270837441013, 0.20077004048871638, 0.20077004048871638, 0.20077004048871638, 0.2105098415891794, 0.2105098415891794, 0.2105098415891794, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009493047463718929, 0.0009493047463718929, 0.0009493047463718929, 0.0, 0.0, 0.0, 0.034293625302679875, 0.034293625302679875, 0.034293625302679875, 0.03038662267319292, 0.03038662267319292, 0.03038662267319292, 0.052626551526872234, 0.052626551526872234, 0.052626551526872234, 0.14369665828286993, 0.14369665828286993, 0.14369665828286993, 0.11994474684154133, 0.11994474684154133, 0.11994474684154133, 0.08144368984669303, 0.08144368984669303, 0.08144368984669303, 0.06052966473024701, 0.06052966473024701, 0.06052966473024701, 0.08260530469318128, 0.08260530469318128, 0.08260530469318128, 0.06375168191663849, 0.06375168191663849, 0.06375168191663849, 0.5264739571905337, 0.5264739571905337, 0.5264739571905337, 0.49639740757940776, 0.49639740757940776, 0.49639740757940776, 0.5077614541600348, 0.5077614541600348, 0.5077614541600348, 0.10794162702080812, 0.10794162702080812, 0.10794162702080812, 0.10532137205634062, 0.10532137205634062, 0.10532137205634062, 0.08513501984779759, 0.08513501984779759, 0.08513501984779759, 0.1525128593093159, 0.1525128593093159, 0.1525128593093159, 0.16233863492079703, 0.16233863492079703, 0.16233863492079703, 0.1832449550859736, 0.1832449550859736, 0.1832449550859736, 0.384026997855197, 0.384026997855197, 0.384026997855197, 0.2176701660416901, 0.2176701660416901, 0.2176701660416901, 0.4108709945329353, 0.4108709945329353, 0.4108709945329353, 0.19795926774982875, 0.19795926774982875, 0.19795926774982875, 0.17997767310656076, 0.17997767310656076, 0.17997767310656076, 0.13663637176345, 0.13663637176345, 0.13663637176345, 0.18651246784797426, 0.18651246784797426, 0.18651246784797426, 0.23800572136678388, 0.23800572136678388, 0.23800572136678388, 0.1807112459796475, 0.1807112459796475, 0.1807112459796475, 0.22183947659931957, 0.22183947659931957, 0.22183947659931957, 0.20370855924746478, 0.20370855924746478, 0.20370855924746478, 0.1982713893517244, 0.1982713893517244, 0.1982713893517244, 0.8845444358452099, 0.8845444358452099, 0.8845444358452099, 0.1569194618182923, 0.1569194618182923, 0.1569194618182923, 0.1676502696966905, 0.1676502696966905, 0.1676502696966905, 0.5823566625647867, 0.5823566625647867, 0.5823566625647867, 0.20871741241980446, 0.20871741241980446, 0.20871741241980446, 0.1539892499742498, 0.1539892499742498, 0.1539892499742498, 0.18293833098041146, 0.18293833098041146, 0.18293833098041146, 0.20074796255122662, 0.20074796255122662, 0.20074796255122662, 0.1908261785755675, 0.1908261785755675, 0.1908261785755675, 0.07680453989823655, 0.07680453989823655, 0.07680453989823655, 0.07459374571496868, 0.07459374571496868, 0.07459374571496868, 0.08764197010395325, 0.08764197010395325, 0.08764197010395325]}, "mutation_prompt": null}
{"id": "25efe214-e3ed-47d0-b99e-fda7a2f88ab4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size to enhance diversity\n        self.inertia_weight = 0.4  # Balanced inertia weight for stable exploration\n        self.cognitive_constant = 1.4  # Balanced cognitive constant\n        self.social_constant = 1.8  # Increased social constant for stronger convergence\n        self.mutation_factor = 0.8  # Adaptive mutation factor for refined exploration\n        self.crossover_rate = 0.9  # Increased crossover rate for better gene mixing\n        self.elitism_rate = 0.15  # Higher elitism rate to preserve top solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                mutant_factor = self.mutation_factor * (1 + 0.1 * np.random.rand())  # Adaptive mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + mutant_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Deep local search on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveOptimizer", "description": "A convergence-enhanced optimizer combining adaptive mutation strategies and elite-driven local search intensification.", "configspace": "", "generation": 89, "fitness": 0.26579197558091194, "feedback": "The algorithm EnhancedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.7630325024999708, 0.7630325024999708, 0.7630325024999708, 0.7547449032706554, 0.7547449032706554, 0.7547449032706554, 0.757006836189991, 0.757006836189991, 0.757006836189991, 0.5357703354495646, 0.5357703354495646, 0.5357703354495646, 0.42763762598287836, 0.42763762598287836, 0.42763762598287836, 0.30530389645933786, 0.30530389645933786, 0.30530389645933786, 0.10257304144944523, 0.10257304144944523, 0.10257304144944523, 0.07267373043744807, 0.07267373043744807, 0.07267373043744807, 0.09102733513326366, 0.09102733513326366, 0.09102733513326366, 0.12236715380623131, 0.12236715380623131, 0.12236715380623131, 0.11944968598459349, 0.11944968598459349, 0.11944968598459349, 0.09802072404633422, 0.09802072404633422, 0.09802072404633422, 0.9816530527439872, 0.9816530527439872, 0.9816530527439872, 0.9819647892466626, 0.9819647892466626, 0.9819647892466626, 0.972325003781005, 0.972325003781005, 0.972325003781005, 0.35815165453533926, 0.35815165453533926, 0.35815165453533926, 0.3310064818844234, 0.3310064818844234, 0.3310064818844234, 0.28184189110909996, 0.28184189110909996, 0.28184189110909996, 0.16708103431968813, 0.16708103431968813, 0.16708103431968813, 0.33413844396219905, 0.33413844396219905, 0.33413844396219905, 0.11519390154492015, 0.11519390154492015, 0.11519390154492015, 0.18807327236330285, 0.18807327236330285, 0.18807327236330285, 0.20182190760861207, 0.20182190760861207, 0.20182190760861207, 0.19071751741472331, 0.19071751741472331, 0.19071751741472331, 0.12253285861241381, 0.12253285861241381, 0.12253285861241381, 0.15114177293428477, 0.15114177293428477, 0.15114177293428477, 0.20779667748256714, 0.20779667748256714, 0.20779667748256714, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01967592668774576, 0.01967592668774576, 0.01967592668774576, 0.0517814675643522, 0.0517814675643522, 0.0517814675643522, 0.05848636991129408, 0.05848636991129408, 0.05848636991129408, 0.05629186663216057, 0.05629186663216057, 0.05629186663216057, 0.045991332069704405, 0.045991332069704405, 0.045991332069704405, 0.12003978691736061, 0.12003978691736061, 0.12003978691736061, 0.05729750621956642, 0.05729750621956642, 0.05729750621956642, 0.24930686912066846, 0.24930686912066846, 0.24930686912066846, 0.0719261721661556, 0.0719261721661556, 0.0719261721661556, 0.05521737406094529, 0.05521737406094529, 0.05521737406094529, 0.559399800035167, 0.559399800035167, 0.559399800035167, 0.47987046167551417, 0.47987046167551417, 0.47987046167551417, 0.5327816771012079, 0.5327816771012079, 0.5327816771012079, 0.12222659802837965, 0.12222659802837965, 0.12222659802837965, 0.11437132598478061, 0.11437132598478061, 0.11437132598478061, 0.1078727876895349, 0.1078727876895349, 0.1078727876895349, 0.30407978473101993, 0.30407978473101993, 0.30407978473101993, 0.1879052770472277, 0.1879052770472277, 0.1879052770472277, 0.21590117971418354, 0.21590117971418354, 0.21590117971418354, 0.35212501252603834, 0.35212501252603834, 0.35212501252603834, 0.3991720772108447, 0.3991720772108447, 0.3991720772108447, 0.40964681246501067, 0.40964681246501067, 0.40964681246501067, 0.13310665587207327, 0.13310665587207327, 0.13310665587207327, 0.17916722232086646, 0.17916722232086646, 0.17916722232086646, 0.14030999197062377, 0.14030999197062377, 0.14030999197062377, 0.2001039580595545, 0.2001039580595545, 0.2001039580595545, 0.20737598053027473, 0.20737598053027473, 0.20737598053027473, 0.21223622814965215, 0.21223622814965215, 0.21223622814965215, 0.1882968373415399, 0.1882968373415399, 0.1882968373415399, 0.18249810280065082, 0.18249810280065082, 0.18249810280065082, 0.4166662604471656, 0.4166662604471656, 0.4166662604471656, 0.8534553150361769, 0.8534553150361769, 0.8534553150361769, 0.15717337824167876, 0.15717337824167876, 0.15717337824167876, 0.1683584965334095, 0.1683584965334095, 0.1683584965334095, 0.6110782898934476, 0.6110782898934476, 0.6110782898934476, 0.2077780330442287, 0.2077780330442287, 0.2077780330442287, 0.15372088108879556, 0.15372088108879556, 0.15372088108879556, 0.1907143775060588, 0.1907143775060588, 0.1907143775060588, 0.18037858063677614, 0.18037858063677614, 0.18037858063677614, 0.18781259281841745, 0.18781259281841745, 0.18781259281841745, 0.08467350224528014, 0.08467350224528014, 0.08467350224528014, 0.0789903881176155, 0.0789903881176155, 0.0789903881176155, 0.09671167335956887, 0.09671167335956887, 0.09671167335956887]}, "mutation_prompt": null}
{"id": "b138db1d-d33c-4932-a9ae-e938e85c786d", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Slightly increased population size for better exploration\n        self.initial_inertia_weight = 0.7  # Adaptive inertia weight starting value\n        self.cognitive_constant = 2.0  # Enhanced cognitive learning rate\n        self.social_constant = 1.5  # Reduced social constant for balance\n        self.mutation_factor = 0.8  # Reduced mutation factor for focused diversity\n        self.crossover_rate = 0.9  # Increased crossover rate to enhance recombination\n        self.elitism_rate = 0.2  # Increased elitism rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Chaotic initialization using logistic map\n        chaotic_map = np.random.rand(self.population_size, self.dim)\n        for i in range(100):  # Iterate to stabilize chaotic sequence\n            chaotic_map = 4 * chaotic_map * (1 - chaotic_map)\n        particles = self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        iterations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n\n            # Adapt inertia weight over iterations\n            inertia_weight = self.initial_inertia_weight - (iterations / (self.budget / self.population_size)) * 0.4\n            velocities = (inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.1, 0.1, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n            iterations += 1\n\n        return global_best_position, global_best_score", "name": "AdaptiveChaoticHybridOptimizer", "description": "A hybrid optimizer utilizing adaptive learning coefficients and chaotic initialization to enhance exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.1867201422591922, "feedback": "The algorithm AdaptiveChaoticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.44623190177837213, 0.44623190177837213, 0.44623190177837213, 0.5458220611291567, 0.5458220611291567, 0.5458220611291567, 0.5143993565052061, 0.5143993565052061, 0.5143993565052061, 0.16137943727040405, 0.16137943727040405, 0.16137943727040405, 0.1820339594638486, 0.1820339594638486, 0.1820339594638486, 0.029904699707560933, 0.029904699707560933, 0.029904699707560933, 0.08850621887506926, 0.08850621887506926, 0.08850621887506926, 0.08925093583456079, 0.08925093583456079, 0.08925093583456079, 0.09271803602062734, 0.09271803602062734, 0.09271803602062734, 0.09908837135022752, 0.09908837135022752, 0.09908837135022752, 0.0783547174879945, 0.0783547174879945, 0.0783547174879945, 0.07811860242426105, 0.07811860242426105, 0.07811860242426105, 0.9795507455100421, 0.9795507455100421, 0.9795507455100421, 0.9714472429911062, 0.9714472429911062, 0.9714472429911062, 0.9789456382379426, 0.9789456382379426, 0.9789456382379426, 0.1394283703049729, 0.1394283703049729, 0.1394283703049729, 0.1847895172288061, 0.1847895172288061, 0.1847895172288061, 0.2027101675331232, 0.2027101675331232, 0.2027101675331232, 0.16722260975683745, 0.16722260975683745, 0.16722260975683745, 0.22899260708423597, 0.22899260708423597, 0.22899260708423597, 0.12589807664481867, 0.12589807664481867, 0.12589807664481867, 0.13577882381324358, 0.13577882381324358, 0.13577882381324358, 0.14842641225654696, 0.14842641225654696, 0.14842641225654696, 0.13292187666847255, 0.13292187666847255, 0.13292187666847255, 0.15329020918342418, 0.15329020918342418, 0.15329020918342418, 0.030845396847125284, 0.030845396847125284, 0.030845396847125284, 0.06646935693163092, 0.06646935693163092, 0.06646935693163092, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0408833298041309, 0.0408833298041309, 0.0408833298041309, 0.05156686647531894, 0.05156686647531894, 0.05156686647531894, 0.05185085044682147, 0.05185085044682147, 0.05185085044682147, 0.015909982484940688, 0.015909982484940688, 0.015909982484940688, 0.007711401883092495, 0.007711401883092495, 0.007711401883092495, 0.027454261780971878, 0.027454261780971878, 0.027454261780971878, 0.08502383098803623, 0.08502383098803623, 0.08502383098803623, 0.09155107789132033, 0.09155107789132033, 0.09155107789132033, 0.07281202501585027, 0.07281202501585027, 0.07281202501585027, 0.38720626038599426, 0.38720626038599426, 0.38720626038599426, 0.3899742934421935, 0.3899742934421935, 0.3899742934421935, 0.37429861678604504, 0.37429861678604504, 0.37429861678604504, 0.12014825873369117, 0.12014825873369117, 0.12014825873369117, 0.0689307769810037, 0.0689307769810037, 0.0689307769810037, 0.08434740238689942, 0.08434740238689942, 0.08434740238689942, 0.1478711655865501, 0.1478711655865501, 0.1478711655865501, 0.13058092608238547, 0.13058092608238547, 0.13058092608238547, 0.14808165331219203, 0.14808165331219203, 0.14808165331219203, 0.21431444375130437, 0.21431444375130437, 0.21431444375130437, 0.20516907956389763, 0.20516907956389763, 0.20516907956389763, 0.2401540539421716, 0.2401540539421716, 0.2401540539421716, 0.19272314554834802, 0.19272314554834802, 0.19272314554834802, 0.17692256058623823, 0.17692256058623823, 0.17692256058623823, 0.1616980965550816, 0.1616980965550816, 0.1616980965550816, 0.1579585679868698, 0.1579585679868698, 0.1579585679868698, 0.18254471309466458, 0.18254471309466458, 0.18254471309466458, 0.18670737576945162, 0.18670737576945162, 0.18670737576945162, 0.1870617746510591, 0.1870617746510591, 0.1870617746510591, 0.2087499640984316, 0.2087499640984316, 0.2087499640984316, 0.18567424452073567, 0.18567424452073567, 0.18567424452073567, 0.16056315083791983, 0.16056315083791983, 0.16056315083791983, 0.17886165391972386, 0.17886165391972386, 0.17886165391972386, 0.1837133429257477, 0.1837133429257477, 0.1837133429257477, 0.16075439836972671, 0.16075439836972671, 0.16075439836972671, 0.1942181710902946, 0.1942181710902946, 0.1942181710902946, 0.19265850731639333, 0.19265850731639333, 0.19265850731639333, 0.17216372152223625, 0.17216372152223625, 0.17216372152223625, 0.17949336364737045, 0.17949336364737045, 0.17949336364737045, 0.18062717582723675, 0.18062717582723675, 0.18062717582723675, 0.06606007269153469, 0.06606007269153469, 0.06606007269153469, 0.06102551097196829, 0.06102551097196829, 0.06102551097196829, 0.06530482416637728, 0.06530482416637728, 0.06530482416637728]}, "mutation_prompt": null}
{"id": "cec63bf2-5342-44fd-9058-918a626c473d", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "f0bf5767-62ac-426b-ad43-e717dad8e099", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "1305b05f-1c05-4351-86c1-d6cf11e6adac", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "0f0b2f68-c7dc-4ba6-a136-a2339606dcd0", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "4848414d-f1ef-4a59-9669-12d859a4dc12", "solution": "import numpy as np\n\nclass EnhancedChaoticAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40  # Reduced initial population size for faster convergence\n        self.inertia_weight = 0.5  # Increased inertia weight for balanced exploration-exploitation\n        self.cognitive_constant = 2.0  # Further increased cognitive constant for enhanced personal learning\n        self.social_constant = 1.5  # Reduced social constant to balance global influence\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor for focused exploration\n        self.crossover_rate = 0.9  # Increased crossover rate for more aggressive trials\n        self.elitism_rate = 0.05  # Reduced elitism rate to allow wider exploration initially\n    \n    def logistic_map(self, z):\n        return 4.0 * z * (1 - z)  # Logistic map for chaotic exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = self.initial_population_size\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n        z = np.random.rand()\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += population_size\n\n            for i in range(population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(population_size, self.dim)\n            r2 = np.random.rand(population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search enhanced by chaotic map\n                if evaluations + 1 >= self.budget:\n                    break\n                z = self.logistic_map(z)\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim) * z\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n            # Adaptive increase in population size\n            if evaluations < self.budget * 0.5:\n                population_size = min(100, population_size + 5)\n\n        return global_best_position, global_best_score", "name": "EnhancedChaoticAdaptiveOptimizer", "description": "Integrating chaotic local exploration and adaptive population sizing with Particle Swarm Optimization (PSO) for improved convergence speed in diverse optimization tasks.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {}, "mutation_prompt": null}
{"id": "c1b5c5bb-6164-4879-8e71-9e37951ae3f0", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60  # Increased population size for more exploration\n        self.inertia_weight = 0.5  # Dynamic inertia weight starting higher\n        self.cognitive_constant = 1.4  # Adjusted for balanced personal learning\n        self.social_constant = 1.9  # Increased for enhanced social learning\n        self.mutation_factor = 0.8  # Adjusted mutation factor for diversity control\n        self.crossover_rate = 0.9  # Increased crossover rate for more mixing\n        self.elitism_rate = 0.15  # Increased elitism to retain better solutions\n        self.local_search_intensity = 0.1  # Intensity of local search exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(\n                    -self.local_search_intensity, self.local_search_intensity, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizerV2", "description": "A hybrid optimizer integrating Particle Swarm Optimization (PSO) with adaptive local search to enhance convergence speed using dynamic parameter tuning.", "configspace": "", "generation": 96, "fitness": 0.17634998252698086, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.42081869427227037, 0.42081869427227037, 0.42081869427227037, 0.3923599277661418, 0.3923599277661418, 0.3923599277661418, 0.40456657193245504, 0.40456657193245504, 0.40456657193245504, 0.04136015071928045, 0.04136015071928045, 0.04136015071928045, 0.10091836502421925, 0.10091836502421925, 0.10091836502421925, 0.023604876347208648, 0.023604876347208648, 0.023604876347208648, 0.09184145029126534, 0.09184145029126534, 0.09184145029126534, 0.07156322662708992, 0.07156322662708992, 0.07156322662708992, 0.07603294861117593, 0.07603294861117593, 0.07603294861117593, 0.09591934719519035, 0.09591934719519035, 0.09591934719519035, 0.0759130612574741, 0.0759130612574741, 0.0759130612574741, 0.0646815024853713, 0.0646815024853713, 0.0646815024853713, 0.9828629535734856, 0.9828629535734856, 0.9828629535734856, 0.9713810536005041, 0.9713810536005041, 0.9713810536005041, 0.9709089508155777, 0.9709089508155777, 0.9709089508155777, 0.12919242236349215, 0.12919242236349215, 0.12919242236349215, 0.12589962016422418, 0.12589962016422418, 0.12589962016422418, 0.15787209091858856, 0.15787209091858856, 0.15787209091858856, 0.16959147617289183, 0.16959147617289183, 0.16959147617289183, 0.1539137998495398, 0.1539137998495398, 0.1539137998495398, 0.17328496726538833, 0.17328496726538833, 0.17328496726538833, 0.1031374250573115, 0.1031374250573115, 0.1031374250573115, 0.102405046671458, 0.102405046671458, 0.102405046671458, 0.0891534291097349, 0.0891534291097349, 0.0891534291097349, 0.0938769092835331, 0.0938769092835331, 0.0938769092835331, 0.07619853947447142, 0.07619853947447142, 0.07619853947447142, 0.09037019974392135, 0.09037019974392135, 0.09037019974392135, 0.0, 0.0, 0.0, 0.01462103955024141, 0.01462103955024141, 0.01462103955024141, 0.0, 0.0, 0.0, 0.019892531852725548, 0.019892531852725548, 0.019892531852725548, 0.02092452539509848, 0.02092452539509848, 0.02092452539509848, 0.048029992279760014, 0.048029992279760014, 0.048029992279760014, 0.014814535962912267, 0.014814535962912267, 0.014814535962912267, 0.02789698202504476, 0.02789698202504476, 0.02789698202504476, 0.020464918648752994, 0.020464918648752994, 0.020464918648752994, 0.035651687287014844, 0.035651687287014844, 0.035651687287014844, 0.052523838031600656, 0.052523838031600656, 0.052523838031600656, 0.04581881906388385, 0.04581881906388385, 0.04581881906388385, 0.3591629523136697, 0.3591629523136697, 0.3591629523136697, 0.3453799130086208, 0.3453799130086208, 0.3453799130086208, 0.3724474518204448, 0.3724474518204448, 0.3724474518204448, 0.06781108781739387, 0.06781108781739387, 0.06781108781739387, 0.08511752511105986, 0.08511752511105986, 0.08511752511105986, 0.06690125369960731, 0.06690125369960731, 0.06690125369960731, 0.12324159370007637, 0.12324159370007637, 0.12324159370007637, 0.18289532609084436, 0.18289532609084436, 0.18289532609084436, 0.132996283824228, 0.132996283824228, 0.132996283824228, 0.22147713594784568, 0.22147713594784568, 0.22147713594784568, 0.188174995445334, 0.188174995445334, 0.188174995445334, 0.2560230029704038, 0.2560230029704038, 0.2560230029704038, 0.14564133678165747, 0.14564133678165747, 0.14564133678165747, 0.1590319808813634, 0.1590319808813634, 0.1590319808813634, 0.1159920059306776, 0.1159920059306776, 0.1159920059306776, 0.17250919612246907, 0.17250919612246907, 0.17250919612246907, 0.17154359048230094, 0.17154359048230094, 0.17154359048230094, 0.21401637619367864, 0.21401637619367864, 0.21401637619367864, 0.19765090454690182, 0.19765090454690182, 0.19765090454690182, 0.1696273223485214, 0.1696273223485214, 0.1696273223485214, 0.15884176838136477, 0.15884176838136477, 0.15884176838136477, 0.5092494895666986, 0.5092494895666986, 0.5092494895666986, 0.15031928190628785, 0.15031928190628785, 0.15031928190628785, 0.1659326621613083, 0.1659326621613083, 0.1659326621613083, 0.27522782596860684, 0.27522782596860684, 0.27522782596860684, 0.22842387182080193, 0.22842387182080193, 0.22842387182080193, 0.14899436763605822, 0.14899436763605822, 0.14899436763605822, 0.17925481148628275, 0.17925481148628275, 0.17925481148628275, 0.1894599430298931, 0.1894599430298931, 0.1894599430298931, 0.18207102617639526, 0.18207102617639526, 0.18207102617639526, 0.07473835360172487, 0.07473835360172487, 0.07473835360172487, 0.05726192562598298, 0.05726192562598298, 0.05726192562598298, 0.07951430285381744, 0.07951430285381744, 0.07951430285381744]}, "mutation_prompt": null}
{"id": "d47e18f9-9a59-40ba-b59b-4f2937e2a543", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "544fb899-5a40-4255-9e2a-456301871c4f", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
{"id": "cfbb1aab-c436-4688-bf2c-f26938cb80de", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size for better diversity\n        self.inertia_weight = 0.3  # Reduced inertia weight to emphasize recent velocity\n        self.cognitive_constant = 1.5  # Increased cognitive constant for personal learning\n        self.social_constant = 1.7  # Increased social constant for social learning\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled mixing\n        self.elitism_rate = 0.1  # Introduced elitism to retain best solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = particles.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            scores = np.apply_along_axis(func, 1, particles)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if scores[i] < personal_best_scores[i]:\n                    personal_best_scores[i] = scores[i]\n                    personal_best_positions[i] = particles[i]\n                if scores[i] < global_best_score:\n                    global_best_score = scores[i]\n                    global_best_position = particles[i]\n\n            sorted_indices = np.argsort(scores)\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = sorted_indices[:elite_count]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities +\n                          self.cognitive_constant * r1 * (personal_best_positions - particles) +\n                          self.social_constant * r2 * (global_best_position - particles))\n            particles = np.clip(particles + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations + 1 >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < scores[i]:\n                    particles[i] = trial_vector\n                    scores[i] = trial_score\n\n            if evaluations + 1 >= self.budget:\n                break\n\n            for i in range(elite_count):  # Local search only on elite solutions\n                if evaluations + 1 >= self.budget:\n                    break\n                local_candidate = particles[elite_indices[i]] + np.random.uniform(-0.2, 0.2, self.dim)\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                local_score = func(local_candidate)\n                evaluations += 1\n                if local_score < scores[elite_indices[i]]:\n                    particles[elite_indices[i]] = local_candidate\n                    scores[elite_indices[i]] = local_score\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimizer blending Differential Evolution (DE) with a focus on exploitative local search and adaptive parameter tuning for enhanced convergence speed.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "007ab108-eefe-4ad9-85f2-3fee40eba360", "metadata": {"aucs": [0.8496577214530276, 0.8496577214530276, 0.8496577214530276, 0.8445600168516352, 0.8445600168516352, 0.8445600168516352, 0.835666755325859, 0.835666755325859, 0.835666755325859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5318401858921851, 0.5318401858921851, 0.5318401858921851, 0.6943177653306545, 0.6943177653306545, 0.6943177653306545, 0.12670787215220058, 0.12670787215220058, 0.12670787215220058, 0.10639849472634488, 0.10639849472634488, 0.10639849472634488, 0.12910457247361862, 0.12910457247361862, 0.12910457247361862, 0.1087998590080631, 0.1087998590080631, 0.1087998590080631, 0.11123792901347185, 0.11123792901347185, 0.11123792901347185, 0.12231063028642353, 0.12231063028642353, 0.12231063028642353, 0.9760851742485069, 0.9760851742485069, 0.9760851742485069, 0.9754062043448904, 0.9754062043448904, 0.9754062043448904, 0.9765916424519788, 0.9765916424519788, 0.9765916424519788, 0.4202236526369566, 0.4202236526369566, 0.4202236526369566, 0.39239363531484484, 0.39239363531484484, 0.39239363531484484, 0.43485729273717066, 0.43485729273717066, 0.43485729273717066, 0.6969937859286128, 0.6969937859286128, 0.6969937859286128, 0.20843008262269314, 0.20843008262269314, 0.20843008262269314, 0.1491100438901145, 0.1491100438901145, 0.1491100438901145, 0.2104361908175827, 0.2104361908175827, 0.2104361908175827, 0.19997298949877773, 0.19997298949877773, 0.19997298949877773, 0.12030963512306847, 0.12030963512306847, 0.12030963512306847, 0.2008310236731613, 0.2008310236731613, 0.2008310236731613, 0.12815687793796438, 0.12815687793796438, 0.12815687793796438, 0.1342746413079351, 0.1342746413079351, 0.1342746413079351, 0.016222544608443745, 0.016222544608443745, 0.016222544608443745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004226311908077651, 0.0004226311908077651, 0.0004226311908077651, 0.06922239652190998, 0.06922239652190998, 0.06922239652190998, 0.007637807062993884, 0.007637807062993884, 0.007637807062993884, 0.06350710129821824, 0.06350710129821824, 0.06350710129821824, 0.04853927735544461, 0.04853927735544461, 0.04853927735544461, 0.09595566281439982, 0.09595566281439982, 0.09595566281439982, 0.09402489769337952, 0.09402489769337952, 0.09402489769337952, 0.18898365849698395, 0.18898365849698395, 0.18898365849698395, 0.03726338554630182, 0.03726338554630182, 0.03726338554630182, 0.22947209308297223, 0.22947209308297223, 0.22947209308297223, 0.5592426144911986, 0.5592426144911986, 0.5592426144911986, 0.5546674754810703, 0.5546674754810703, 0.5546674754810703, 0.5408417884787877, 0.5408417884787877, 0.5408417884787877, 0.10244911905075571, 0.10244911905075571, 0.10244911905075571, 0.14056476582162436, 0.14056476582162436, 0.14056476582162436, 0.10242756121877739, 0.10242756121877739, 0.10242756121877739, 0.18109327094060945, 0.18109327094060945, 0.18109327094060945, 0.24440913178102974, 0.24440913178102974, 0.24440913178102974, 0.14116675552147806, 0.14116675552147806, 0.14116675552147806, 0.3127609173137337, 0.3127609173137337, 0.3127609173137337, 0.38716996545974836, 0.38716996545974836, 0.38716996545974836, 0.4358511338783738, 0.4358511338783738, 0.4358511338783738, 0.21348606646746515, 0.21348606646746515, 0.21348606646746515, 0.22472457894651987, 0.22472457894651987, 0.22472457894651987, 0.16290773723374408, 0.16290773723374408, 0.16290773723374408, 0.18242685584278628, 0.18242685584278628, 0.18242685584278628, 0.1942604860072007, 0.1942604860072007, 0.1942604860072007, 0.2483465105051632, 0.2483465105051632, 0.2483465105051632, 0.2224314704663145, 0.2224314704663145, 0.2224314704663145, 0.19493126043530296, 0.19493126043530296, 0.19493126043530296, 0.19672626561932505, 0.19672626561932505, 0.19672626561932505, 0.8902149577514329, 0.8902149577514329, 0.8902149577514329, 0.1577485687478899, 0.1577485687478899, 0.1577485687478899, 0.8726611439698876, 0.8726611439698876, 0.8726611439698876, 0.20660227604910197, 0.20660227604910197, 0.20660227604910197, 0.20966897607235946, 0.20966897607235946, 0.20966897607235946, 0.15535097079390037, 0.15535097079390037, 0.15535097079390037, 0.17708089784501357, 0.17708089784501357, 0.17708089784501357, 0.16879449931655277, 0.16879449931655277, 0.16879449931655277, 0.18225799529275988, 0.18225799529275988, 0.18225799529275988, 0.09153160052032039, 0.09153160052032039, 0.09153160052032039, 0.07951329328915613, 0.07951329328915613, 0.07951329328915613, 0.1109525400829321, 0.1109525400829321, 0.1109525400829321]}, "mutation_prompt": null}
