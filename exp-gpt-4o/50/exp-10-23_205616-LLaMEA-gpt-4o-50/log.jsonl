{"id": "559c5ecb-f9bd-4109-b6f5-feb081f55561", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "53fe4b94-cab3-4982-8fcc-51a0a761f78f", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "559c5ecb-f9bd-4109-b6f5-feb081f55561", "metadata": {}, "mutation_prompt": null}
{"id": "b6417732-953b-42d5-982f-99f7b7e57320", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 2, "fitness": 0.20840163130664546, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "559c5ecb-f9bd-4109-b6f5-feb081f55561", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "0db9556e-ecd8-4aef-9b08-723d90ba3c24", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "6b38b92e-23a4-4132-a568-4378e980950b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "a7170149-4637-4f9e-ae15-468242ac10b0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "920a8dec-8f00-4bba-8832-bdd8ba79c49f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "7f945056-45e3-44b8-89ed-531a18c3fc91", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self, num_parents):\n        selected_parents = []\n        for _ in range(num_parents):\n            contenders = np.random.choice(self.population_size, size=3, replace=False)\n            best = min(contenders, key=lambda idx: self.fitness[idx])\n            selected_parents.append(self.population[best])\n        return np.array(selected_parents)\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutation_de(self, target, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            parents = self.select_parents_tournament(self.population_size)\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                rand1, rand2 = np.random.choice(idxs, 2, replace=False)\n                mutant = self.mutation_de(parents[i], best, self.population[rand1], self.population[rand2])\n                offspring = self.crossover(parents[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution, favoring diverse exploration and exploitation strategies.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.7457477969732204, 0.8834046017569531, 0.5773301656068469, 0.4948657584395538, 0.4504363016443913, 0.3941190573152278, 0.3353281358691005, 0.42554448801980993, 0.4161294231181445, 0.043447963211232676, 9.999999999998899e-05, 0.7350509501933821, 0.3017812481374894, 0.5212218399237701, 0.6230637913852448, 0.062390097398421274, 9.999999999998899e-05, 9.999999999998899e-05, 0.09261459028572083, 0.1626717348835517, 0.12394355011630198, 0.08410564691198474, 0.0963573790694009, 0.12011443384767839, 0.11462463959388391, 0.130236052912291, 0.10991788864793905, 0.08574224064044433, 0.11637597738773164, 0.13581251823210128, 0.09050487177045308, 0.08771911186817072, 0.08338721369725921, 0.10242419530525315, 0.12884016415738375, 0.10790858827715222, 0.9730828723447669, 0.9844451625305467, 0.9743664511727811, 0.9719682869430611, 0.9742920980453523, 0.9715393304860519, 0.9732338714928184, 0.9663495793987865, 0.97684295312841, 0.1917441519717008, 0.24096716823882747, 0.2727334540037164, 0.171451507314212, 0.06255280222947235, 0.5426186020503234, 0.47178865884193244, 0.45910776892044736, 0.26595638265053145, 0.1587277103971173, 0.17176434281162023, 0.22865245864682182, 0.19311943843005575, 0.2795629593789156, 0.19061753220901967, 0.17302593781333075, 0.23492750019591702, 0.16709093971181954, 0.12334472252296202, 0.0849709794551512, 0.15532119956855417, 0.10364049520382157, 0.12824903556256229, 0.10387326015490295, 0.1346044124112934, 0.20527686879423712, 0.0066629795425416916, 0.1308851531327495, 0.13319778929812598, 0.12653174582288174, 0.14833630967258615, 9.999999999998899e-05, 0.1436888329319438, 0.131279723491057, 9.999999999998899e-05, 0.011487429521166104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020698101651232537, 0.0390362650841245, 0.02849013017238211, 0.06105063666679833, 9.999999999998899e-05, 0.007493205509566003, 0.010603903031592532, 0.014973056453993161, 0.02833594117506366, 9.999999999998899e-05, 0.06898230048490861, 0.04769832902651838, 9.999999999998899e-05, 0.06585681111156938, 0.16525450888484539, 0.32476181303419405, 9.999999999998899e-05, 9.999999999998899e-05, 0.18545054322577248, 0.06120873785210368, 0.11916844391001347, 0.09425468750527433, 0.057310331276904214, 0.0989902534621162, 0.08743596038200885, 0.04603331016377943, 0.097659540205425, 0.24592122005621653, 0.25530097088638226, 0.43699549415546446, 0.3888667470118077, 0.5174528441754684, 0.40605899964952186, 0.4819398534457192, 0.3432443994392316, 0.5171969552649965, 0.06806896708195831, 0.05467107867266363, 0.07389115619527387, 0.10605704598537646, 0.13576885280865714, 0.06339974277170735, 0.07285640024147966, 0.08411108407775081, 0.057073104166442734, 0.20317697851551042, 0.2396197532837978, 0.11842175776965747, 0.18103811351112964, 0.11653314571283813, 0.10798713552628325, 0.11465470584204507, 0.19424578318810004, 0.15465595337283755, 0.25504451654402627, 0.31626761960522465, 0.31207568306478184, 0.20579041807506748, 0.23303605500934677, 0.22163683815414614, 0.31189572851886127, 0.21726714691459637, 0.3112676199467541, 0.13449220679486007, 0.2347590237392777, 0.24828347998735434, 0.12517553168610318, 0.1655370955093005, 0.15263604692678923, 0.24809754321290556, 0.14963603944355308, 0.1759644457062539, 0.16181490073214555, 0.20465190071394213, 0.16829521112765433, 0.15959167046207134, 0.16001870404404472, 0.21952254603678956, 0.18334135181850875, 0.15508028710990407, 0.18513899308490978, 0.1995197463384829, 0.19514804051025303, 0.1625865913840535, 0.18618456437530917, 0.19179524826477623, 0.19712409702822242, 0.16415658009639522, 0.2070298641473577, 0.18595074256240096, 0.16999026461984013, 0.2046702474307427, 0.1521731664727375, 0.6869001672630994, 0.1802137453350693, 0.3234910320358637, 0.11770499811089463, 0.2495834922020217, 0.11079670908297445, 0.29167478916219747, 0.15511632010490284, 0.3196165037433448, 0.10719122784731894, 0.2714871490798849, 0.15596257441245287, 0.19612481880621568, 0.22009812212523527, 0.15416223736979373, 0.17125897412231406, 0.14286590795512544, 0.1683075588960854, 0.16940944846127493, 0.17849297384122487, 0.17996374374288082, 0.15730415836352274, 0.15082468014828132, 0.15878740359512544, 0.09012636463873347, 0.06698196466192019, 0.06503984034299848, 0.0630347110295757, 0.0652453065842834, 0.06095656519924164, 0.07342508745707854, 0.05517521544480297, 0.05588248574905541]}, "mutation_prompt": null}
{"id": "7e588977-2770-4b3e-b023-e69201ce2416", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = max(0.4, self.mutation_factor * 0.98)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2 = self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(best, rand1, rand2)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "Enhanced Differential Evolution with Adaptive Parameter Control and Elitism for Robust Optimization.", "configspace": "", "generation": 8, "fitness": 0.25539121309931473, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "b6417732-953b-42d5-982f-99f7b7e57320", "metadata": {"aucs": [0.6319306516504671, 0.6146888749761426, 0.633627109027574, 0.9491242292440194, 0.5970426027740847, 0.9479428621058509, 0.40239792277611364, 0.42138729669178243, 0.9524689298384709, 0.006641008302136875, 0.00408291285904272, 0.010112643179364333, 0.1052364251761877, 0.01602387931005067, 9.999999999998899e-05, 9.999999999998899e-05, 0.14926846102910307, 9.999999999998899e-05, 0.11193972236676508, 0.11945064090052382, 0.08982446219458673, 0.11085464503396047, 0.09724751705803414, 0.11285231329130074, 0.12659765801263034, 0.16233089322631644, 0.11622304086928326, 0.09746104670700484, 0.06664958285442968, 0.11845735773696742, 0.10771611408708104, 0.052231774667551134, 0.08037262456463834, 0.1070695391533043, 0.07977483849155109, 0.07478603752878976, 0.44578896124026823, 0.4477397929713488, 0.9694456088313096, 0.9729317274623327, 0.9765860672732023, 0.9819751175015682, 0.9819698729497535, 0.958272066656813, 0.9858299825330933, 0.462699483979678, 0.17933595507799416, 0.060688389902322504, 0.8824283793779326, 0.8003632772826897, 0.8860792508240519, 0.5335389446379808, 0.24850248359956972, 0.5992269675805327, 0.23165187919026253, 0.23053081705029832, 0.15195716518718605, 0.222113274712482, 0.19322242916997434, 0.9533577762589606, 0.12669010562297223, 0.9502741385638936, 0.3852644723477959, 0.1419336795199999, 0.18908699495459003, 0.15958944858941793, 0.10370586507984192, 0.14318887543253733, 0.13661816912727776, 0.20239472514643608, 0.155898571473863, 0.1672505026396488, 0.14319906002867533, 0.197681134044699, 9.999999999998899e-05, 0.13297648690578845, 0.20498774594040836, 0.1379579203981055, 0.13140605745912093, 0.16627155276867345, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03230569311754028, 9.999999999998899e-05, 9.999999999998899e-05, 0.023121918142649855, 0.07046038597470905, 0.008370938017939755, 0.059274196927688205, 0.19850496902812542, 0.13606738795910733, 0.1198322406064879, 0.09272152253061683, 0.0984732085623975, 0.08240730249696859, 0.21667305304175877, 0.08017906929004348, 0.06930381936493868, 0.2779324056541582, 0.1387654012120203, 0.15795076730310598, 0.16432953317526922, 0.12392304725695302, 0.11517651213906444, 0.37290463655298745, 0.18739335745572072, 0.13503415791015416, 0.16128944481783458, 0.25499885052865656, 0.1810295343215521, 0.06990304601902975, 0.15915510852401638, 0.14728818072286298, 0.1911680363333048, 0.050087143341803864, 0.11156598516922, 0.5336066471018667, 0.42892194848745535, 0.7155284485652003, 0.523084149642965, 0.3622813844935402, 0.558832870165377, 0.5083381673395329, 0.5195266312034037, 0.4882165448966327, 0.07077284143676443, 0.07750212572002235, 0.11730855547093744, 0.09738646226395287, 0.0769960110878466, 0.09587117893738428, 0.080194130869925, 0.0919716598236604, 0.0783026299496623, 0.1957243580387642, 0.18685618592572906, 0.2204532372893112, 0.21488074445313876, 0.20218333325133475, 0.2050922136788521, 0.1500089196038591, 0.13461181872778327, 0.48816751282010096, 0.4377459064396647, 0.2662555299005076, 0.2865958073241397, 0.26082831228475867, 0.3572132480334711, 0.37182151361779836, 0.4382377730064845, 0.24946641800267388, 0.3531634432222359, 0.1853690507413147, 0.3850924566464403, 0.2289067056221037, 0.23774921830831675, 0.22677043210949932, 0.21406354908700043, 0.24042522996173898, 0.25464950185471735, 0.15315792656740446, 0.24410357883218126, 0.1738355499558184, 0.21742311910286172, 0.25503936470029687, 0.22428775416305224, 0.23100672030736058, 0.21230732622101922, 0.21970889831644402, 0.21814133905647481, 0.18689290256555602, 0.19405281091735382, 0.19631367772354957, 0.1913671599418585, 0.19297582547818215, 0.1875402508552061, 0.25619254153527926, 0.18540239782016543, 0.25593405147005865, 0.40439745937368266, 0.17765283724319691, 0.15431602173789327, 0.5626695047801905, 0.2009380929847543, 0.20106840345142485, 0.14305282378764805, 0.16388907389117535, 0.9604490226873271, 0.9570590821461632, 0.21387301760997257, 0.07358454715000429, 0.21252983111034518, 0.2806390389035429, 0.15687204366698793, 0.10496507659383736, 0.10471775491192403, 0.30980545265789206, 0.18083015546124614, 0.18184821891949343, 0.18139856125976372, 0.18774299303585518, 0.19520091350924618, 0.17791083601432434, 0.17529590461739608, 0.1731353047813582, 0.2467378863180636, 0.08748609266836538, 0.08396251836318314, 0.0819752570372495, 0.07428562043877451, 0.09988984755282293, 0.07892228414940106, 0.09327774837138059, 0.06559981163401551, 0.10894733921493693]}, "mutation_prompt": null}
{"id": "bbe3c31b-28f3-4767-8135-694df3e1ced6", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, best, rand1, rand2):\n        mutant_vector = best + self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = max(0.4, self.mutation_factor * 0.98)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2 = self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(best, rand1, rand2)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "Enhanced Differential Evolution with Adaptive Parameter Control and Elitism for Robust Optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7e588977-2770-4b3e-b023-e69201ce2416", "metadata": {"aucs": [0.6319306516504671, 0.6146888749761426, 0.633627109027574, 0.9491242292440194, 0.5970426027740847, 0.9479428621058509, 0.40239792277611364, 0.42138729669178243, 0.9524689298384709, 0.006641008302136875, 0.00408291285904272, 0.010112643179364333, 0.1052364251761877, 0.01602387931005067, 9.999999999998899e-05, 9.999999999998899e-05, 0.14926846102910307, 9.999999999998899e-05, 0.11193972236676508, 0.11945064090052382, 0.08982446219458673, 0.11085464503396047, 0.09724751705803414, 0.11285231329130074, 0.12659765801263034, 0.16233089322631644, 0.11622304086928326, 0.09746104670700484, 0.06664958285442968, 0.11845735773696742, 0.10771611408708104, 0.052231774667551134, 0.08037262456463834, 0.1070695391533043, 0.07977483849155109, 0.07478603752878976, 0.44578896124026823, 0.4477397929713488, 0.9694456088313096, 0.9729317274623327, 0.9765860672732023, 0.9819751175015682, 0.9819698729497535, 0.958272066656813, 0.9858299825330933, 0.462699483979678, 0.17933595507799416, 0.060688389902322504, 0.8824283793779326, 0.8003632772826897, 0.8860792508240519, 0.5335389446379808, 0.24850248359956972, 0.5992269675805327, 0.23165187919026253, 0.23053081705029832, 0.15195716518718605, 0.222113274712482, 0.19322242916997434, 0.9533577762589606, 0.12669010562297223, 0.9502741385638936, 0.3852644723477959, 0.1419336795199999, 0.18908699495459003, 0.15958944858941793, 0.10370586507984192, 0.14318887543253733, 0.13661816912727776, 0.20239472514643608, 0.155898571473863, 0.1672505026396488, 0.14319906002867533, 0.197681134044699, 9.999999999998899e-05, 0.13297648690578845, 0.20498774594040836, 0.1379579203981055, 0.13140605745912093, 0.16627155276867345, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03230569311754028, 9.999999999998899e-05, 9.999999999998899e-05, 0.023121918142649855, 0.07046038597470905, 0.008370938017939755, 0.059274196927688205, 0.19850496902812542, 0.13606738795910733, 0.1198322406064879, 0.09272152253061683, 0.0984732085623975, 0.08240730249696859, 0.21667305304175877, 0.08017906929004348, 0.06930381936493868, 0.2779324056541582, 0.1387654012120203, 0.15795076730310598, 0.16432953317526922, 0.12392304725695302, 0.11517651213906444, 0.37290463655298745, 0.18739335745572072, 0.13503415791015416, 0.16128944481783458, 0.25499885052865656, 0.1810295343215521, 0.06990304601902975, 0.15915510852401638, 0.14728818072286298, 0.1911680363333048, 0.050087143341803864, 0.11156598516922, 0.5336066471018667, 0.42892194848745535, 0.7155284485652003, 0.523084149642965, 0.3622813844935402, 0.558832870165377, 0.5083381673395329, 0.5195266312034037, 0.4882165448966327, 0.07077284143676443, 0.07750212572002235, 0.11730855547093744, 0.09738646226395287, 0.0769960110878466, 0.09587117893738428, 0.080194130869925, 0.0919716598236604, 0.0783026299496623, 0.1957243580387642, 0.18685618592572906, 0.2204532372893112, 0.21488074445313876, 0.20218333325133475, 0.2050922136788521, 0.1500089196038591, 0.13461181872778327, 0.48816751282010096, 0.4377459064396647, 0.2662555299005076, 0.2865958073241397, 0.26082831228475867, 0.3572132480334711, 0.37182151361779836, 0.4382377730064845, 0.24946641800267388, 0.3531634432222359, 0.1853690507413147, 0.3850924566464403, 0.2289067056221037, 0.23774921830831675, 0.22677043210949932, 0.21406354908700043, 0.24042522996173898, 0.25464950185471735, 0.15315792656740446, 0.24410357883218126, 0.1738355499558184, 0.21742311910286172, 0.25503936470029687, 0.22428775416305224, 0.23100672030736058, 0.21230732622101922, 0.21970889831644402, 0.21814133905647481, 0.18689290256555602, 0.19405281091735382, 0.19631367772354957, 0.1913671599418585, 0.19297582547818215, 0.1875402508552061, 0.25619254153527926, 0.18540239782016543, 0.25593405147005865, 0.40439745937368266, 0.17765283724319691, 0.15431602173789327, 0.5626695047801905, 0.2009380929847543, 0.20106840345142485, 0.14305282378764805, 0.16388907389117535, 0.9604490226873271, 0.9570590821461632, 0.21387301760997257, 0.07358454715000429, 0.21252983111034518, 0.2806390389035429, 0.15687204366698793, 0.10496507659383736, 0.10471775491192403, 0.30980545265789206, 0.18083015546124614, 0.18184821891949343, 0.18139856125976372, 0.18774299303585518, 0.19520091350924618, 0.17791083601432434, 0.17529590461739608, 0.1731353047813582, 0.2467378863180636, 0.08748609266836538, 0.08396251836318314, 0.0819752570372495, 0.07428562043877451, 0.09988984755282293, 0.07892228414940106, 0.09327774837138059, 0.06559981163401551, 0.10894733921493693]}, "mutation_prompt": null}
{"id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation and Enhanced Diversity Mechanism for Black Box Optimization.", "configspace": "", "generation": 10, "fitness": 0.3531441078343829, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "7e588977-2770-4b3e-b023-e69201ce2416", "metadata": {"aucs": [0.7829262836775208, 0.757625230177035, 0.742433823777809, 0.7810122530548849, 0.7719586289633724, 0.7479369143062713, 0.7579638102069373, 0.7639859588603789, 0.7427026920995703, 0.6070743523737151, 0.594086503009364, 0.5530902487880818, 0.5860310849584282, 0.5629054968304839, 0.6007994551075391, 0.6033694363464495, 0.5731559395188219, 0.5389414544728961, 0.11025516573738625, 0.1002088046257621, 0.09718553799317309, 0.11386519374872917, 0.10318131610312742, 0.09966146761213601, 0.10349572982505784, 0.1102490205140475, 0.09623543878199892, 0.10822792399114844, 0.09502734999654183, 0.09443535992278362, 0.1121387406501082, 0.09115992760363756, 0.09107155825873192, 0.11401911735098036, 0.11229801314163579, 0.094955941390925, 0.9288535485617976, 0.8927467075232504, 0.8983587603414795, 0.8846304077083483, 0.907807936686073, 0.9528710214622826, 0.917273534587856, 0.9833710563599636, 0.9148389522445087, 0.39982128592526545, 0.36691011408030494, 0.3843268338557213, 0.41514539984713905, 0.38501929858079975, 0.4074511757567113, 0.4005912678041472, 0.4289243480053164, 0.3779674974077146, 0.7403727524196456, 0.7057133971114583, 0.7234012880269938, 0.7869408391965298, 0.7222471084882485, 0.7259950281149011, 0.7459816183571177, 0.7035711444205833, 0.6803387275482251, 0.29192065763832664, 0.26810916369424465, 0.3070789613722197, 0.3081056830619937, 0.3522946336693179, 0.263920132178013, 0.3514796705551717, 0.339650737453391, 0.4145042652569444, 0.4134974086575999, 0.049344148935588916, 0.2301489300218782, 0.34177579004902126, 0.31122005836147104, 0.32657547659152253, 0.3463520904419334, 0.35012468545996467, 0.29711123983170673, 0.31046363473847205, 0.2856086873762279, 0.26068255157939324, 0.3346472242721792, 0.3173795062429797, 0.30179731831730716, 0.3059590071439229, 0.30120345627611234, 0.29166947808791455, 0.5313360110546657, 0.43319152793745885, 0.4715985513297897, 0.4569865608993344, 0.4028674651685291, 0.4564595065828876, 0.5434929416798435, 0.45696070028071145, 0.47595759897318524, 0.14538883970999794, 0.09654208515493756, 0.11336208309690776, 0.2138003906352416, 0.11318781286138269, 0.13124252747120768, 0.13133029429061038, 0.10355612327448904, 0.17260457524787076, 0.28274957329213646, 0.29136827042619606, 0.25918938508204803, 0.29216674298278755, 0.2741226881786323, 0.28263183955219096, 0.2697574229944999, 0.2590468210919449, 0.2511749503806068, 0.6549679261790402, 0.6604526087969906, 0.6461284999852459, 0.6391541978832669, 0.6507175656585977, 0.6420472167505827, 0.639084228951013, 0.623092857552169, 0.6278267391968095, 0.08442874288497892, 0.08513406987884287, 0.09769353320245333, 0.10816158721171398, 0.10306076695887223, 0.08798422108214599, 0.0887245217873619, 0.09684875488474387, 0.08277646877518696, 0.17723693622328496, 0.13678182148955642, 0.14241861829299451, 0.14202089983952215, 0.13610391378455766, 0.1322747133246217, 0.15034359885261606, 0.12722226976554685, 0.14903418916733968, 0.3583283069139337, 0.3444653708474724, 0.33123834081067516, 0.36834676623724494, 0.34721712426564066, 0.3436944863936203, 0.3805108403961103, 0.37429342100477536, 0.36083494300091745, 0.27916871005401434, 0.2853989864435874, 0.26041743574780185, 0.27520198977612886, 0.27639562719307975, 0.2629814112379911, 0.3152392696643138, 0.2888007849704245, 0.2930809762074469, 0.19386696873644638, 0.20068571988950812, 0.20528951410758023, 0.19077320818115562, 0.19821595251117086, 0.19821754478340603, 0.17780196323558028, 0.1713126009747482, 0.17898379190119718, 0.22717664752701439, 0.18713041523330642, 0.1963082062051471, 0.17829980275723756, 0.1869238747609423, 0.18916778855970173, 0.20263716127467168, 0.18284835851226167, 0.1900965866558718, 0.16718756515263156, 0.7250753265721206, 0.744400209773306, 0.17147996677936095, 0.4247768075110121, 0.1856685741962938, 0.6020145768187327, 0.4468536266178874, 0.6775464175363277, 0.7572873491502627, 0.20203003518643048, 0.6601660842617179, 0.4916850040359273, 0.19796169526908935, 0.44648370385980196, 0.6428725784593616, 0.5729604131817649, 0.20856935606233673, 0.1838821157436683, 0.18006014809136395, 0.18736296829413945, 0.1764152973550257, 0.19729747145681553, 0.17459089131999883, 0.19889237650415348, 0.19243884091999464, 0.18552786330420257, 0.07926725694552439, 0.07271626568344813, 0.06309263380967367, 0.07958029805665678, 0.0777762166470296, 0.0788433757060566, 0.07429535575584101, 0.08402653944875949, 0.07312961033303722]}, "mutation_prompt": null}
{"id": "313dec56-9256-426b-b3e2-cf93589eae88", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation and Enhanced Diversity Mechanism for Black Box Optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {"aucs": [0.7829262836775208, 0.757625230177035, 0.742433823777809, 0.7810122530548849, 0.7719586289633724, 0.7479369143062713, 0.7579638102069373, 0.7639859588603789, 0.7427026920995703, 0.6070743523737151, 0.594086503009364, 0.5530902487880818, 0.5860310849584282, 0.5629054968304839, 0.6007994551075391, 0.6033694363464495, 0.5731559395188219, 0.5389414544728961, 0.11025516573738625, 0.1002088046257621, 0.09718553799317309, 0.11386519374872917, 0.10318131610312742, 0.09966146761213601, 0.10349572982505784, 0.1102490205140475, 0.09623543878199892, 0.10822792399114844, 0.09502734999654183, 0.09443535992278362, 0.1121387406501082, 0.09115992760363756, 0.09107155825873192, 0.11401911735098036, 0.11229801314163579, 0.094955941390925, 0.9288535485617976, 0.8927467075232504, 0.8983587603414795, 0.8846304077083483, 0.907807936686073, 0.9528710214622826, 0.917273534587856, 0.9833710563599636, 0.9148389522445087, 0.39982128592526545, 0.36691011408030494, 0.3843268338557213, 0.41514539984713905, 0.38501929858079975, 0.4074511757567113, 0.4005912678041472, 0.4289243480053164, 0.3779674974077146, 0.7403727524196456, 0.7057133971114583, 0.7234012880269938, 0.7869408391965298, 0.7222471084882485, 0.7259950281149011, 0.7459816183571177, 0.7035711444205833, 0.6803387275482251, 0.29192065763832664, 0.26810916369424465, 0.3070789613722197, 0.3081056830619937, 0.3522946336693179, 0.263920132178013, 0.3514796705551717, 0.339650737453391, 0.4145042652569444, 0.4134974086575999, 0.049344148935588916, 0.2301489300218782, 0.34177579004902126, 0.31122005836147104, 0.32657547659152253, 0.3463520904419334, 0.35012468545996467, 0.29711123983170673, 0.31046363473847205, 0.2856086873762279, 0.26068255157939324, 0.3346472242721792, 0.3173795062429797, 0.30179731831730716, 0.3059590071439229, 0.30120345627611234, 0.29166947808791455, 0.5313360110546657, 0.43319152793745885, 0.4715985513297897, 0.4569865608993344, 0.4028674651685291, 0.4564595065828876, 0.5434929416798435, 0.45696070028071145, 0.47595759897318524, 0.14538883970999794, 0.09654208515493756, 0.11336208309690776, 0.2138003906352416, 0.11318781286138269, 0.13124252747120768, 0.13133029429061038, 0.10355612327448904, 0.17260457524787076, 0.28274957329213646, 0.29136827042619606, 0.25918938508204803, 0.29216674298278755, 0.2741226881786323, 0.28263183955219096, 0.2697574229944999, 0.2590468210919449, 0.2511749503806068, 0.6549679261790402, 0.6604526087969906, 0.6461284999852459, 0.6391541978832669, 0.6507175656585977, 0.6420472167505827, 0.639084228951013, 0.623092857552169, 0.6278267391968095, 0.08442874288497892, 0.08513406987884287, 0.09769353320245333, 0.10816158721171398, 0.10306076695887223, 0.08798422108214599, 0.0887245217873619, 0.09684875488474387, 0.08277646877518696, 0.17723693622328496, 0.13678182148955642, 0.14241861829299451, 0.14202089983952215, 0.13610391378455766, 0.1322747133246217, 0.15034359885261606, 0.12722226976554685, 0.14903418916733968, 0.3583283069139337, 0.3444653708474724, 0.33123834081067516, 0.36834676623724494, 0.34721712426564066, 0.3436944863936203, 0.3805108403961103, 0.37429342100477536, 0.36083494300091745, 0.27916871005401434, 0.2853989864435874, 0.26041743574780185, 0.27520198977612886, 0.27639562719307975, 0.2629814112379911, 0.3152392696643138, 0.2888007849704245, 0.2930809762074469, 0.19386696873644638, 0.20068571988950812, 0.20528951410758023, 0.19077320818115562, 0.19821595251117086, 0.19821754478340603, 0.17780196323558028, 0.1713126009747482, 0.17898379190119718, 0.22717664752701439, 0.18713041523330642, 0.1963082062051471, 0.17829980275723756, 0.1869238747609423, 0.18916778855970173, 0.20263716127467168, 0.18284835851226167, 0.1900965866558718, 0.16718756515263156, 0.7250753265721206, 0.744400209773306, 0.17147996677936095, 0.4247768075110121, 0.1856685741962938, 0.6020145768187327, 0.4468536266178874, 0.6775464175363277, 0.7572873491502627, 0.20203003518643048, 0.6601660842617179, 0.4916850040359273, 0.19796169526908935, 0.44648370385980196, 0.6428725784593616, 0.5729604131817649, 0.20856935606233673, 0.1838821157436683, 0.18006014809136395, 0.18736296829413945, 0.1764152973550257, 0.19729747145681553, 0.17459089131999883, 0.19889237650415348, 0.19243884091999464, 0.18552786330420257, 0.07926725694552439, 0.07271626568344813, 0.06309263380967367, 0.07958029805665678, 0.0777762166470296, 0.0788433757060566, 0.07429535575584101, 0.08402653944875949, 0.07312961033303722]}, "mutation_prompt": null}
{"id": "e66a2465-5c66-4cf0-a9ae-3c3c8c594443", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        quantum_factor = np.random.normal(0, 0.1, size=self.dim)\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3) + quantum_factor\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def entropy_based_selection(self):\n        probabilities = np.exp(-self.fitness)\n        total = np.sum(probabilities)\n        probabilities /= total\n        idx = np.random.choice(self.population_size, p=probabilities)\n        return idx\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            selected_idx = self.entropy_based_selection()\n            self.population[-1] = self.population[selected_idx]\n            self.fitness[-1] = self.fitness[selected_idx]\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies and Entropy-Based Diversity Enhancement for Robust Black Box Optimization.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {}, "mutation_prompt": null}
{"id": "5345a299-80fc-4a90-abee-c4c531ddee1a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation and Enhanced Diversity Mechanism for Black Box Optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {"aucs": [0.7829262836775208, 0.757625230177035, 0.742433823777809, 0.7810122530548849, 0.7719586289633724, 0.7479369143062713, 0.7579638102069373, 0.7639859588603789, 0.7427026920995703, 0.6070743523737151, 0.594086503009364, 0.5530902487880818, 0.5860310849584282, 0.5629054968304839, 0.6007994551075391, 0.6033694363464495, 0.5731559395188219, 0.5389414544728961, 0.11025516573738625, 0.1002088046257621, 0.09718553799317309, 0.11386519374872917, 0.10318131610312742, 0.09966146761213601, 0.10349572982505784, 0.1102490205140475, 0.09623543878199892, 0.10822792399114844, 0.09502734999654183, 0.09443535992278362, 0.1121387406501082, 0.09115992760363756, 0.09107155825873192, 0.11401911735098036, 0.11229801314163579, 0.094955941390925, 0.9288535485617976, 0.8927467075232504, 0.8983587603414795, 0.8846304077083483, 0.907807936686073, 0.9528710214622826, 0.917273534587856, 0.9833710563599636, 0.9148389522445087, 0.39982128592526545, 0.36691011408030494, 0.3843268338557213, 0.41514539984713905, 0.38501929858079975, 0.4074511757567113, 0.4005912678041472, 0.4289243480053164, 0.3779674974077146, 0.7403727524196456, 0.7057133971114583, 0.7234012880269938, 0.7869408391965298, 0.7222471084882485, 0.7259950281149011, 0.7459816183571177, 0.7035711444205833, 0.6803387275482251, 0.29192065763832664, 0.26810916369424465, 0.3070789613722197, 0.3081056830619937, 0.3522946336693179, 0.263920132178013, 0.3514796705551717, 0.339650737453391, 0.4145042652569444, 0.4134974086575999, 0.049344148935588916, 0.2301489300218782, 0.34177579004902126, 0.31122005836147104, 0.32657547659152253, 0.3463520904419334, 0.35012468545996467, 0.29711123983170673, 0.31046363473847205, 0.2856086873762279, 0.26068255157939324, 0.3346472242721792, 0.3173795062429797, 0.30179731831730716, 0.3059590071439229, 0.30120345627611234, 0.29166947808791455, 0.5313360110546657, 0.43319152793745885, 0.4715985513297897, 0.4569865608993344, 0.4028674651685291, 0.4564595065828876, 0.5434929416798435, 0.45696070028071145, 0.47595759897318524, 0.14538883970999794, 0.09654208515493756, 0.11336208309690776, 0.2138003906352416, 0.11318781286138269, 0.13124252747120768, 0.13133029429061038, 0.10355612327448904, 0.17260457524787076, 0.28274957329213646, 0.29136827042619606, 0.25918938508204803, 0.29216674298278755, 0.2741226881786323, 0.28263183955219096, 0.2697574229944999, 0.2590468210919449, 0.2511749503806068, 0.6549679261790402, 0.6604526087969906, 0.6461284999852459, 0.6391541978832669, 0.6507175656585977, 0.6420472167505827, 0.639084228951013, 0.623092857552169, 0.6278267391968095, 0.08442874288497892, 0.08513406987884287, 0.09769353320245333, 0.10816158721171398, 0.10306076695887223, 0.08798422108214599, 0.0887245217873619, 0.09684875488474387, 0.08277646877518696, 0.17723693622328496, 0.13678182148955642, 0.14241861829299451, 0.14202089983952215, 0.13610391378455766, 0.1322747133246217, 0.15034359885261606, 0.12722226976554685, 0.14903418916733968, 0.3583283069139337, 0.3444653708474724, 0.33123834081067516, 0.36834676623724494, 0.34721712426564066, 0.3436944863936203, 0.3805108403961103, 0.37429342100477536, 0.36083494300091745, 0.27916871005401434, 0.2853989864435874, 0.26041743574780185, 0.27520198977612886, 0.27639562719307975, 0.2629814112379911, 0.3152392696643138, 0.2888007849704245, 0.2930809762074469, 0.19386696873644638, 0.20068571988950812, 0.20528951410758023, 0.19077320818115562, 0.19821595251117086, 0.19821754478340603, 0.17780196323558028, 0.1713126009747482, 0.17898379190119718, 0.22717664752701439, 0.18713041523330642, 0.1963082062051471, 0.17829980275723756, 0.1869238747609423, 0.18916778855970173, 0.20263716127467168, 0.18284835851226167, 0.1900965866558718, 0.16718756515263156, 0.7250753265721206, 0.744400209773306, 0.17147996677936095, 0.4247768075110121, 0.1856685741962938, 0.6020145768187327, 0.4468536266178874, 0.6775464175363277, 0.7572873491502627, 0.20203003518643048, 0.6601660842617179, 0.4916850040359273, 0.19796169526908935, 0.44648370385980196, 0.6428725784593616, 0.5729604131817649, 0.20856935606233673, 0.1838821157436683, 0.18006014809136395, 0.18736296829413945, 0.1764152973550257, 0.19729747145681553, 0.17459089131999883, 0.19889237650415348, 0.19243884091999464, 0.18552786330420257, 0.07926725694552439, 0.07271626568344813, 0.06309263380967367, 0.07958029805665678, 0.0777762166470296, 0.0788433757060566, 0.07429535575584101, 0.08402653944875949, 0.07312961033303722]}, "mutation_prompt": null}
{"id": "8479b0fc-05c4-4586-96ff-59112eb45618", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation and Enhanced Diversity Mechanism for Black Box Optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {"aucs": [0.7829262836775208, 0.757625230177035, 0.742433823777809, 0.7810122530548849, 0.7719586289633724, 0.7479369143062713, 0.7579638102069373, 0.7639859588603789, 0.7427026920995703, 0.6070743523737151, 0.594086503009364, 0.5530902487880818, 0.5860310849584282, 0.5629054968304839, 0.6007994551075391, 0.6033694363464495, 0.5731559395188219, 0.5389414544728961, 0.11025516573738625, 0.1002088046257621, 0.09718553799317309, 0.11386519374872917, 0.10318131610312742, 0.09966146761213601, 0.10349572982505784, 0.1102490205140475, 0.09623543878199892, 0.10822792399114844, 0.09502734999654183, 0.09443535992278362, 0.1121387406501082, 0.09115992760363756, 0.09107155825873192, 0.11401911735098036, 0.11229801314163579, 0.094955941390925, 0.9288535485617976, 0.8927467075232504, 0.8983587603414795, 0.8846304077083483, 0.907807936686073, 0.9528710214622826, 0.917273534587856, 0.9833710563599636, 0.9148389522445087, 0.39982128592526545, 0.36691011408030494, 0.3843268338557213, 0.41514539984713905, 0.38501929858079975, 0.4074511757567113, 0.4005912678041472, 0.4289243480053164, 0.3779674974077146, 0.7403727524196456, 0.7057133971114583, 0.7234012880269938, 0.7869408391965298, 0.7222471084882485, 0.7259950281149011, 0.7459816183571177, 0.7035711444205833, 0.6803387275482251, 0.29192065763832664, 0.26810916369424465, 0.3070789613722197, 0.3081056830619937, 0.3522946336693179, 0.263920132178013, 0.3514796705551717, 0.339650737453391, 0.4145042652569444, 0.4134974086575999, 0.049344148935588916, 0.2301489300218782, 0.34177579004902126, 0.31122005836147104, 0.32657547659152253, 0.3463520904419334, 0.35012468545996467, 0.29711123983170673, 0.31046363473847205, 0.2856086873762279, 0.26068255157939324, 0.3346472242721792, 0.3173795062429797, 0.30179731831730716, 0.3059590071439229, 0.30120345627611234, 0.29166947808791455, 0.5313360110546657, 0.43319152793745885, 0.4715985513297897, 0.4569865608993344, 0.4028674651685291, 0.4564595065828876, 0.5434929416798435, 0.45696070028071145, 0.47595759897318524, 0.14538883970999794, 0.09654208515493756, 0.11336208309690776, 0.2138003906352416, 0.11318781286138269, 0.13124252747120768, 0.13133029429061038, 0.10355612327448904, 0.17260457524787076, 0.28274957329213646, 0.29136827042619606, 0.25918938508204803, 0.29216674298278755, 0.2741226881786323, 0.28263183955219096, 0.2697574229944999, 0.2590468210919449, 0.2511749503806068, 0.6549679261790402, 0.6604526087969906, 0.6461284999852459, 0.6391541978832669, 0.6507175656585977, 0.6420472167505827, 0.639084228951013, 0.623092857552169, 0.6278267391968095, 0.08442874288497892, 0.08513406987884287, 0.09769353320245333, 0.10816158721171398, 0.10306076695887223, 0.08798422108214599, 0.0887245217873619, 0.09684875488474387, 0.08277646877518696, 0.17723693622328496, 0.13678182148955642, 0.14241861829299451, 0.14202089983952215, 0.13610391378455766, 0.1322747133246217, 0.15034359885261606, 0.12722226976554685, 0.14903418916733968, 0.3583283069139337, 0.3444653708474724, 0.33123834081067516, 0.36834676623724494, 0.34721712426564066, 0.3436944863936203, 0.3805108403961103, 0.37429342100477536, 0.36083494300091745, 0.27916871005401434, 0.2853989864435874, 0.26041743574780185, 0.27520198977612886, 0.27639562719307975, 0.2629814112379911, 0.3152392696643138, 0.2888007849704245, 0.2930809762074469, 0.19386696873644638, 0.20068571988950812, 0.20528951410758023, 0.19077320818115562, 0.19821595251117086, 0.19821754478340603, 0.17780196323558028, 0.1713126009747482, 0.17898379190119718, 0.22717664752701439, 0.18713041523330642, 0.1963082062051471, 0.17829980275723756, 0.1869238747609423, 0.18916778855970173, 0.20263716127467168, 0.18284835851226167, 0.1900965866558718, 0.16718756515263156, 0.7250753265721206, 0.744400209773306, 0.17147996677936095, 0.4247768075110121, 0.1856685741962938, 0.6020145768187327, 0.4468536266178874, 0.6775464175363277, 0.7572873491502627, 0.20203003518643048, 0.6601660842617179, 0.4916850040359273, 0.19796169526908935, 0.44648370385980196, 0.6428725784593616, 0.5729604131817649, 0.20856935606233673, 0.1838821157436683, 0.18006014809136395, 0.18736296829413945, 0.1764152973550257, 0.19729747145681553, 0.17459089131999883, 0.19889237650415348, 0.19243884091999464, 0.18552786330420257, 0.07926725694552439, 0.07271626568344813, 0.06309263380967367, 0.07958029805665678, 0.0777762166470296, 0.0788433757060566, 0.07429535575584101, 0.08402653944875949, 0.07312961033303722]}, "mutation_prompt": null}
{"id": "b29b8bad-204e-43a4-bd27-64a4fe9587a4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation and Enhanced Diversity Mechanism for Black Box Optimization.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {"aucs": [0.7829262836775208, 0.757625230177035, 0.742433823777809, 0.7810122530548849, 0.7719586289633724, 0.7479369143062713, 0.7579638102069373, 0.7639859588603789, 0.7427026920995703, 0.6070743523737151, 0.594086503009364, 0.5530902487880818, 0.5860310849584282, 0.5629054968304839, 0.6007994551075391, 0.6033694363464495, 0.5731559395188219, 0.5389414544728961, 0.11025516573738625, 0.1002088046257621, 0.09718553799317309, 0.11386519374872917, 0.10318131610312742, 0.09966146761213601, 0.10349572982505784, 0.1102490205140475, 0.09623543878199892, 0.10822792399114844, 0.09502734999654183, 0.09443535992278362, 0.1121387406501082, 0.09115992760363756, 0.09107155825873192, 0.11401911735098036, 0.11229801314163579, 0.094955941390925, 0.9288535485617976, 0.8927467075232504, 0.8983587603414795, 0.8846304077083483, 0.907807936686073, 0.9528710214622826, 0.917273534587856, 0.9833710563599636, 0.9148389522445087, 0.39982128592526545, 0.36691011408030494, 0.3843268338557213, 0.41514539984713905, 0.38501929858079975, 0.4074511757567113, 0.4005912678041472, 0.4289243480053164, 0.3779674974077146, 0.7403727524196456, 0.7057133971114583, 0.7234012880269938, 0.7869408391965298, 0.7222471084882485, 0.7259950281149011, 0.7459816183571177, 0.7035711444205833, 0.6803387275482251, 0.29192065763832664, 0.26810916369424465, 0.3070789613722197, 0.3081056830619937, 0.3522946336693179, 0.263920132178013, 0.3514796705551717, 0.339650737453391, 0.4145042652569444, 0.4134974086575999, 0.049344148935588916, 0.2301489300218782, 0.34177579004902126, 0.31122005836147104, 0.32657547659152253, 0.3463520904419334, 0.35012468545996467, 0.29711123983170673, 0.31046363473847205, 0.2856086873762279, 0.26068255157939324, 0.3346472242721792, 0.3173795062429797, 0.30179731831730716, 0.3059590071439229, 0.30120345627611234, 0.29166947808791455, 0.5313360110546657, 0.43319152793745885, 0.4715985513297897, 0.4569865608993344, 0.4028674651685291, 0.4564595065828876, 0.5434929416798435, 0.45696070028071145, 0.47595759897318524, 0.14538883970999794, 0.09654208515493756, 0.11336208309690776, 0.2138003906352416, 0.11318781286138269, 0.13124252747120768, 0.13133029429061038, 0.10355612327448904, 0.17260457524787076, 0.28274957329213646, 0.29136827042619606, 0.25918938508204803, 0.29216674298278755, 0.2741226881786323, 0.28263183955219096, 0.2697574229944999, 0.2590468210919449, 0.2511749503806068, 0.6549679261790402, 0.6604526087969906, 0.6461284999852459, 0.6391541978832669, 0.6507175656585977, 0.6420472167505827, 0.639084228951013, 0.623092857552169, 0.6278267391968095, 0.08442874288497892, 0.08513406987884287, 0.09769353320245333, 0.10816158721171398, 0.10306076695887223, 0.08798422108214599, 0.0887245217873619, 0.09684875488474387, 0.08277646877518696, 0.17723693622328496, 0.13678182148955642, 0.14241861829299451, 0.14202089983952215, 0.13610391378455766, 0.1322747133246217, 0.15034359885261606, 0.12722226976554685, 0.14903418916733968, 0.3583283069139337, 0.3444653708474724, 0.33123834081067516, 0.36834676623724494, 0.34721712426564066, 0.3436944863936203, 0.3805108403961103, 0.37429342100477536, 0.36083494300091745, 0.27916871005401434, 0.2853989864435874, 0.26041743574780185, 0.27520198977612886, 0.27639562719307975, 0.2629814112379911, 0.3152392696643138, 0.2888007849704245, 0.2930809762074469, 0.19386696873644638, 0.20068571988950812, 0.20528951410758023, 0.19077320818115562, 0.19821595251117086, 0.19821754478340603, 0.17780196323558028, 0.1713126009747482, 0.17898379190119718, 0.22717664752701439, 0.18713041523330642, 0.1963082062051471, 0.17829980275723756, 0.1869238747609423, 0.18916778855970173, 0.20263716127467168, 0.18284835851226167, 0.1900965866558718, 0.16718756515263156, 0.7250753265721206, 0.744400209773306, 0.17147996677936095, 0.4247768075110121, 0.1856685741962938, 0.6020145768187327, 0.4468536266178874, 0.6775464175363277, 0.7572873491502627, 0.20203003518643048, 0.6601660842617179, 0.4916850040359273, 0.19796169526908935, 0.44648370385980196, 0.6428725784593616, 0.5729604131817649, 0.20856935606233673, 0.1838821157436683, 0.18006014809136395, 0.18736296829413945, 0.1764152973550257, 0.19729747145681553, 0.17459089131999883, 0.19889237650415348, 0.19243884091999464, 0.18552786330420257, 0.07926725694552439, 0.07271626568344813, 0.06309263380967367, 0.07958029805665678, 0.0777762166470296, 0.0788433757060566, 0.07429535575584101, 0.08402653944875949, 0.07312961033303722]}, "mutation_prompt": null}
{"id": "802580c4-3c32-49c0-b871-635e26468645", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        # Incorporate fitness diversity factor for mutation\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        # Adapt diversity factor based on population fitness variance\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive and Self-tuning Differential Evolution with Elite Preservation, Enhanced Diversity Mechanism, and Fitness-based Parameter Scaling for Robust Black Box Optimization.", "configspace": "", "generation": 16, "fitness": 0.3587630090046678, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "9edb82b9-f1b2-4508-9b41-7af2165072f8", "metadata": {"aucs": [0.8132179278136914, 0.8435015316608158, 0.8610472642850696, 0.8633650554226227, 0.8636929951199476, 0.8459257885297639, 0.8569839793527563, 0.8689298691829981, 0.8601493832889955, 0.739419683617387, 0.7539495099674658, 0.7117170365980376, 0.7391219791416271, 0.7412150052583806, 0.7200988553386851, 0.732783486318074, 0.7205546847953075, 0.10405448383368843, 0.3234006868301116, 0.37574120333135497, 0.1677066776301408, 0.14287065827850876, 0.36057031164287234, 0.26893073913349486, 0.2535371732847723, 0.1633039651616931, 0.178535871334904, 0.15761050485341965, 0.12350248335565206, 0.11663150420647739, 0.1655122641151383, 0.1454759610915951, 0.13187396254714512, 0.1371636123825467, 0.15517186607540112, 0.14492620354315955, 0.7639420802063328, 0.8976312201521444, 0.3729596202395935, 0.7898841223654064, 0.9145242604849076, 0.785838497459183, 0.8687998031645371, 0.8561020230213402, 0.8119160594621022, 0.19078317888741358, 0.09210148362661963, 0.2461602659743648, 0.14465284825311941, 0.2186464728245502, 0.19789946795619706, 0.22335158043387437, 0.2967121504264465, 0.1716292004153558, 0.364290773262015, 0.3823566042790493, 0.20714441327090305, 0.8640267523720702, 0.273968691397908, 0.2659541356238153, 0.8432710580558962, 0.34097404054876457, 0.8643251700634059, 0.7420037538917642, 0.18577962794885894, 0.1429282854893954, 0.19387018971997072, 0.20027136516395072, 0.42963972379368476, 0.16032978444844703, 0.1692773146999047, 0.1528122213213381, 0.18632993382016705, 0.14115659332577013, 0.22465946735210562, 0.13658174362708486, 0.2424934232293222, 0.28895072610246597, 0.13536525560780754, 0.14642974227731143, 0.1643147008949749, 0.10726146092460076, 0.32304102608729923, 9.999999999998899e-05, 0.17091484151845127, 0.008463676517031726, 0.19627446936177506, 0.2078679752322916, 0.02735222301172413, 0.07433935406846626, 0.31634070522898905, 0.4566741908259634, 0.35807533717049855, 0.1484072399794808, 0.34329406112479754, 0.2226801010413061, 0.3538619539106389, 0.19089088865195603, 0.2652689046883162, 0.22706664315734193, 0.18273731966773543, 0.1729891323297008, 0.19354502144641583, 0.2441188284510768, 0.14972847180565385, 0.18160617861471784, 0.17534495652391924, 0.23269299125603493, 0.26165103141696133, 0.23747055825260455, 0.3415578948135204, 0.19448630009205847, 0.39313757310955466, 0.2343033738814393, 0.18152003458301902, 0.14273344602251326, 0.24044088764544924, 0.7589964659847234, 0.4883422545104009, 0.7924154950268896, 0.7464927833250988, 0.8142797177787799, 0.7932448589566425, 0.7862405130730404, 0.736109318344052, 0.7870590186361219, 0.10260426958921232, 0.16066406577606107, 0.10684741557928756, 0.24066503989650068, 0.10667023209439663, 0.13221500311310264, 0.13942392635178824, 0.13830376773572572, 0.10125715081503894, 0.18206086299717694, 0.18916035391635544, 0.450329434157164, 0.24042525690367056, 0.17220638115665932, 0.21291528729554976, 0.1587046739057345, 0.2204537998371684, 0.18885943608799582, 0.49188887366314404, 0.5330122507926207, 0.5052893193340612, 0.5771983236142239, 0.549411225827333, 0.5250395130459249, 0.5704886331120214, 0.5067685664903199, 0.5451025880526843, 0.4042925230200848, 0.41723359002089744, 0.4318901241190686, 0.44111562851247876, 0.24863727403386537, 0.4748081591960709, 0.25234438375303847, 0.5202966473688799, 0.4569731495144621, 0.2146481161937086, 0.21268184027772907, 0.23022077468920343, 0.23078457734550095, 0.21780669266547237, 0.20252428085493812, 0.21037349481061052, 0.2318325181299853, 0.23063621012119162, 0.19008729516168266, 0.5362174965290967, 0.5768640491064907, 0.5295119681015552, 0.37010693771841463, 0.4674161954205648, 0.24450585777505562, 0.24467962761132023, 0.5667036775189174, 0.8162338853344513, 0.7494609187596364, 0.8363700011242743, 0.8166828898146684, 0.3660098547195405, 0.834833897695464, 0.14027965921222807, 0.256998636696799, 0.8280809681593065, 0.8396358874323707, 0.18543808541985307, 0.20504372797626136, 0.8478036167078853, 0.2630111147730677, 0.16779335954705676, 0.16424177477843294, 0.1177522056411704, 0.20495976865870658, 0.17256022416997407, 0.18928845901298252, 0.20183071137170117, 0.18253734984147219, 0.19997007376175546, 0.19855973058394105, 0.21793534837756934, 0.18116516579846298, 0.19231323945772838, 0.08809207116756967, 0.08525553577682077, 0.09009843090385006, 0.08417825897407527, 0.08414560861175446, 0.08585907577394025, 0.11949836810309078, 0.0890932947222951, 0.07998653212248352]}, "mutation_prompt": null}
{"id": "e828850b-6404-4e31-8546-709134688ae0", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6  # Adjusted diversity factor for better exploration\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_tournament(self):\n        indices = np.random.choice(self.population_size, 4, replace=False)\n        best_1 = indices[np.argmin(self.fitness[indices[:2]])]\n        best_2 = indices[np.argmin(self.fitness[indices[2:]])]\n        return best_1, best_2, np.random.choice(indices)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, best, rand1, rand2):\n        mutant_vector = best + self.diversity_factor * self.mutation_factor * (rand1 - rand2)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        fitness_std = np.std(self.fitness)\n        self.mutation_factor = np.random.uniform(0.5, 0.9) if fitness_std < 1e-5 else np.random.uniform(0.4, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.6\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idx1, idx2, idx3 = self.select_parents_tournament()\n                best_parent = self.population[idx1]\n                rand1, rand2 = self.population[idx2], self.population[idx3]\n                mutant = self.mutation_de(best_parent, rand1, rand2)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveHybridDE", "description": "Adaptive Hybrid Differential Evolution with Dynamic Population and Adaptive Parameter Strategies for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 17, "fitness": 0.3304829892873522, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.8848427919702491, 0.8810865195315732, 0.8718042781338716, 0.8627939400187388, 0.8813175743100694, 0.8809130511003398, 0.8722588828688809, 0.8717932045109358, 0.8927414685726099, 0.8060008479078435, 0.7935180396194602, 0.7963046536456283, 0.760840804545743, 0.766264497404917, 0.7775152716792945, 0.6907809156209632, 0.7957889836769474, 0.7218313151826504, 0.1800219079386154, 0.15447975867884112, 0.16389545019523954, 0.736800654686451, 0.1831907918658876, 0.1556325615689339, 0.18016400882775108, 0.15168923645393972, 0.18171712446403687, 0.1232819306965679, 0.12462020303385712, 0.16697484928409034, 0.13839137763734488, 0.11886692797338128, 0.09066824592493594, 0.11336682702625445, 0.15957570765693418, 0.12251908528430266, 0.9699464111394042, 0.9666783206490535, 0.9604275020064313, 0.9855045621718536, 0.9767902963387717, 0.9632524173933429, 0.9669798058361877, 0.9718093749338693, 0.9647739128149464, 0.3072997506187707, 0.2861468620580816, 0.24633741094759465, 0.5033557805615638, 0.3565702220258682, 0.5219439042580291, 0.5301666968933512, 0.05466508265208758, 0.4668654941996895, 0.9071905985728997, 0.3908336886379066, 0.24754894868078348, 0.8838515127926284, 0.27821942167191094, 0.26945455303612076, 0.24086177330333547, 0.8625196529646523, 0.35600017949110196, 0.19929389513317164, 0.20401955903520874, 0.15674592979515378, 0.2274446616124297, 0.16700797192834926, 0.2693062355646829, 0.19477348915519344, 0.22696896361068597, 0.13078395541045118, 0.1993408589715674, 0.13992220195197713, 0.1882727046362903, 0.1553074020414308, 0.1439803600046995, 0.14284534812739424, 0.18013421924048711, 0.20356900312461046, 0.18271245557849347, 0.06523170418251323, 9.999999999998899e-05, 0.17591732563431162, 0.12007022329885164, 0.1074660109803206, 0.029311653922209358, 0.09720638653241254, 0.014094282369721767, 0.22503236890928757, 0.18505395594975294, 0.1375810621055189, 0.15530596062366875, 0.24639519058582715, 0.22585312229875476, 0.3059465828571337, 0.13608146511520613, 0.3275270141755149, 0.15200707136380465, 0.09181473444428534, 0.20408306814172394, 0.06627512260579316, 0.09226834637503378, 0.22875989439616018, 0.20455162904095336, 0.13290974319654014, 0.18245166647550326, 0.09633400482000998, 0.42591995372409586, 0.23527098722947437, 0.1742197551469189, 0.3482350535841945, 0.29131130569616404, 0.19275836923950673, 0.13212959091773613, 0.17281038488722866, 0.17188053300743544, 0.5625869333758955, 0.7204129041472045, 0.698703691858813, 0.586485814806639, 0.646269050164912, 0.570396122598998, 0.5700014566392095, 0.6416041276401274, 0.7847187066127239, 0.10421297014606279, 0.10730979911798, 0.15540062028428003, 0.10823134105588283, 0.07563856326028129, 0.12098211231449563, 0.11155150330497621, 0.15726129749251538, 0.11203851478822435, 0.1656662901122108, 0.27321058375228513, 0.14441319362383287, 0.15695058132349782, 0.1444477695420966, 0.11925739272623237, 0.14503212649280872, 0.18613784173963954, 0.13904925455180206, 0.36173999007575064, 0.5618070418819932, 0.43173574814001536, 0.5378463732101977, 0.33466267951275774, 0.32141829953660017, 0.621827782488567, 0.5665121360648377, 0.542349819885342, 0.34800163385617966, 0.4056608960044519, 0.3724880462996458, 0.39630805651893963, 0.2247624917400698, 0.30507888954903006, 0.3196703691829771, 0.31648789886596673, 0.30207890856931097, 0.18967130312088953, 0.17903947918837837, 0.18002814173255555, 0.1978519298605661, 0.15193832441220745, 0.15335736608009753, 0.2552702034601775, 0.20632050016767411, 0.20299335698625987, 0.771710325899992, 0.2393472188921324, 0.18899862859329586, 0.24747354018957524, 0.7195014290212112, 0.19709087921438484, 0.3522016594113707, 0.1848731368718992, 0.2462713027938186, 0.1564083816186037, 0.18552414255044203, 0.18707557325515578, 0.9089513519080696, 0.5533407644083201, 0.16754777494534323, 0.1419045173313228, 0.16796894740237256, 0.18513548145618575, 0.5195384066405553, 0.21114190326871762, 0.20693911716964553, 0.16616369796084907, 0.16652556357267878, 0.16579790617260093, 0.16487446990856003, 0.30591535777616186, 0.20406357515635887, 0.19646544382554898, 0.1589810639803676, 0.1701954550170216, 0.16174394506412004, 0.15392151903209128, 0.17051111698206312, 0.16667830753122437, 0.1746613890775348, 0.16011461290989248, 0.09580194591074376, 0.09023523374804787, 0.06652365868667587, 0.10133667035078853, 0.06542436406233043, 0.06670922427446091, 0.07179541100882814, 0.0704984017853123, 0.08272207466217829]}, "mutation_prompt": null}
{"id": "36233981-4b98-4785-b7e9-c24243a370e5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n        # Introduce fitness sharing to maintain diversity\n        average_fitness = np.mean(self.fitness)\n        for i in range(self.population_size):\n            sharing_factor = np.exp(-np.abs(self.fitness[i] - average_fitness) / (average_fitness + 1e-9))\n            self.fitness[i] *= sharing_factor\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Self-adaptive Differential Evolution with Elite Preservation and Fitness-Based Parameter Scaling enhanced by Fitness Sharing for Maintaining Diversity in Black Box Optimization.", "configspace": "", "generation": 18, "fitness": 0.1241924134977319, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.13.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.2405093336336941, 0.1876924550177791, 0.23121263502860434, 0.21368593677383774, 0.1857189797793234, 0.19588143599186725, 0.21555587821021827, 0.2103541806869934, 0.19055199763214126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06948936224066149, 0.045945336498575906, 0.06278664608351592, 0.06325670343701173, 0.05100496312927283, 0.05209155838685042, 0.045840869840902854, 0.05815818308120091, 0.04716456807485725, 0.05940503231121452, 0.042713479364095086, 0.057187998728341016, 0.0457680129905873, 0.044047169083340165, 0.04596311850039636, 0.06162989693811649, 0.025628936923578816, 0.06678710815744493, 0.9038226628724411, 0.8664053716138962, 0.9597423532219485, 0.12945445350936768, 0.14093394230331102, 0.09250274478756582, 0.15989956919533654, 0.8229375093170391, 0.11300861321933442, 0.09333806531501432, 0.05902375724338982, 0.08561290332897531, 0.08045653319079771, 0.05035645581428816, 0.1071880822501593, 0.11716257446672229, 0.1393715262545262, 0.1404570160748948, 0.1670820547933337, 0.16401709465850967, 0.14518693263670324, 0.1520804812325629, 0.2038526819448061, 0.15663789057585487, 0.1347273472759556, 0.15296338651786523, 0.14796049165086367, 0.06603675349232707, 0.049259464544288645, 0.03648751634131708, 0.08358519184277213, 0.09924508715834612, 0.09131918387233795, 0.06692662856245479, 9.999999999998899e-05, 0.06004722054457545, 0.032282850143256825, 0.03169949489532553, 0.06382314676302425, 0.1065422774302931, 0.020363637981403948, 0.07005141788262848, 0.07484986044311603, 0.02640792291803662, 0.039659695825202235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11381062765072025, 0.10125513392520702, 0.09430510541914372, 0.062272324109961086, 0.04826975301187941, 0.10949650515545017, 0.06622990364946324, 0.06372534194857238, 0.0791972026050114, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004983536740687522, 0.013250335335021957, 0.005339771828071771, 9.999999999998899e-05, 0.007933516658874984, 0.026892055469754816, 0.04353446844527464, 0.05797581405017249, 0.059359534163253014, 0.22901823742471505, 0.2352208920695562, 0.2478364366685475, 0.1968245106822918, 0.1971931860718339, 0.1974523972942931, 0.20740581644346712, 0.20147836859683876, 0.22611027981859366, 0.04979925864752133, 0.042389867490361444, 0.06207592298000586, 0.06125001989025236, 0.04292826902590663, 0.06651793855769861, 0.11331696081379228, 0.11085333609098469, 0.1092824198623713, 0.15277047925822784, 0.1334186422218967, 0.14492793289615624, 0.15502849566366517, 0.14681038070869146, 0.14273479551145596, 0.15609875462568346, 0.14768247401285994, 0.1817764612072612, 0.16863380378141468, 0.176706248510343, 0.17492668501000863, 0.19480267107507776, 0.17492578512603052, 0.1785333673069226, 0.18219069675844934, 0.20724559683172028, 0.18265602248570412, 0.1658886987057847, 0.15102253868078985, 0.16422874787116148, 0.12784046470082344, 0.12185912175779545, 0.13604071685796648, 0.1294515873237727, 0.13741009864258935, 0.12599942131557507, 0.20092452024918783, 0.16895592018041738, 0.16634273103094233, 0.17756726050283178, 0.15850711457553535, 0.1747594245500006, 0.19164923541591306, 0.17011798095993858, 0.16617162175510403, 0.16802377576964933, 0.17860435437061717, 0.17537216431557734, 0.16117283588997888, 0.16027885320458313, 0.15365937285804432, 0.1650677308418277, 0.17228010658567983, 0.1609717692823247, 0.1696602231322808, 0.17017139686284521, 0.15944730381591488, 0.3282827839216911, 0.14771329858367954, 0.31802795417243135, 0.15817832420360733, 0.14270897152539674, 0.2020349967980588, 0.21690833734835913, 0.16515779086770255, 0.14862533229931674, 0.15646613514946672, 0.16812805911193118, 0.12521721933253516, 0.1853785273066213, 0.19762058841295926, 0.15450603969705556, 0.18324465201029072, 0.19426158629026857, 0.19620134180737592, 0.20224312643663722, 0.17690414775110297, 0.21135353626842257, 0.17651329068220745, 0.19563410081406418, 0.1919588868384401, 0.07038440402074853, 0.07076266237473117, 0.07254115061330046, 0.064531433459873, 0.06370851826491142, 0.049944481421986486, 0.06483693191512507, 0.06258709846258703, 0.05319255132403866]}, "mutation_prompt": null}
{"id": "ca0dad52-b0b6-4b69-85a6-677b3e4d658a", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_best_and_random(self):\n        best_idx = np.argmin(self.fitness)\n        candidate_indices = np.random.choice(self.population_size, 2, replace=False)\n        return [best_idx] + candidate_indices.tolist()\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.7 if fitness_std < 1e-5 else 0.5\n        if np.random.rand() < 0.3:\n            new_size = np.random.randint(self.population_size // 2, self.population_size)\n            self.population = self.population[:new_size]\n            self.fitness = self.fitness[:new_size]\n            self.population_size = new_size\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_best_and_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ImprovedAdaptiveDE", "description": "Improved Self-Adaptive Differential Evolution with Dynamic Population Scaling and Fitness Diversity for Enhanced Performance in Black Box Optimization.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {}, "mutation_prompt": null}
{"id": "c71015e6-088a-409a-8ff2-7e7bbed33567", "solution": "import numpy as np\n\nclass DynamicPopulationAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        perturbation = np.random.uniform(-0.1, 0.1, size=self.dim)\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3) + perturbation\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-4 else 0.7\n\n    def local_search(self, individual, func):\n        local_mutation_factor = 0.1\n        perturbation = np.random.normal(scale=local_mutation_factor, size=self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        candidate_fitness = func(candidate)\n        if candidate_fitness < func(individual):\n            return candidate, candidate_fitness\n        return individual, func(individual)\n\n    def adjust_population_size(self):\n        self.population_size = max(20, int(self.initial_population_size * (1 - self.num_evaluations / self.budget)))\n        self.population = self.population[:self.population_size]\n        self.fitness = self.fitness[:self.population_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                # Apply local search\n                self.population[i], self.fitness[i] = self.local_search(self.population[i], func)\n            self.adapt_parameters()\n            self.adjust_population_size()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "DynamicPopulationAdaptiveDE", "description": "Dynamic Population-Sized Adaptive Differential Evolution with Enhanced Mutation and Fitness-Based Local Search for Efficient Black Box Optimization.", "configspace": "", "generation": 20, "fitness": 0.19103826742715824, "feedback": "The algorithm DynamicPopulationAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.3943365745587777, 0.38890335285122934, 0.40939733893146046, 0.3884367026726784, 0.39725909433045203, 0.39922747095466216, 0.41127616722302474, 0.4037870176821243, 0.4040766457256153, 0.05371739876293491, 0.06406714059386609, 0.05359020606138254, 0.03898992565206405, 0.029376797791023868, 0.030025260809781518, 0.07579585646218534, 0.018116217691352743, 0.03422964934051598, 0.10054041398735658, 0.09537600272566937, 0.09933061164643764, 0.08913080691469022, 0.09542795191426945, 0.09213864631793933, 0.10015202368571086, 0.11439260903054582, 0.10637038668204934, 0.08610450089350052, 0.08070981340438865, 0.0912642109325339, 0.08248598763453541, 0.08084823195164514, 0.08541781241447932, 0.09145646787424289, 0.08878030203452059, 0.08154318869057153, 0.7788616745065802, 0.7289148845334463, 0.8393135413065498, 0.7690727012824919, 0.7164582112538902, 0.7062846196090335, 0.8199741733904102, 0.7932198036331618, 0.7544569613692447, 0.19714587995765998, 0.19503724464699457, 0.18436033487538372, 0.21349474219098874, 0.18158908144497676, 0.23264319098927166, 0.22329012992429687, 0.20297656603242276, 0.21410201109533133, 0.3009115535381446, 0.345281700146402, 0.25605574735407266, 0.41294641387503217, 0.29986662127597874, 0.3106642265520303, 0.2792429611994134, 0.28398375099297857, 0.2708699203025564, 0.11034316091732121, 0.1264137277705507, 0.13708896248097135, 0.10888638987680677, 0.14028394582614423, 0.11404382541689628, 0.16641289725714536, 0.16094639660755694, 0.12103340723507405, 0.12716911133759146, 0.11844866632942597, 0.132414465454325, 0.1265870732001546, 0.14489054566640047, 0.14131170231129453, 0.14092125716024873, 0.09095167268268434, 0.15913725660370714, 0.02346599798180138, 0.023884526885914026, 0.01041411338612197, 0.03948336927091278, 0.016347316262314004, 0.01354061892955738, 0.026164383498758936, 0.0008312344040110053, 0.00840615099372044, 0.09973599755373197, 0.07221989405533769, 0.10393165902071633, 0.09329499488800752, 0.09304468063463012, 0.0862320532858003, 0.08045111141168604, 0.09092395656139729, 0.09786707453187082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09107715272216788, 0.08164983879702792, 0.0915164768383867, 0.0877656805863335, 0.09067111099841763, 0.09816167302691026, 0.08905625876373846, 0.09017057149938135, 0.10020855633252923, 0.37558331034199177, 0.3753442349122077, 0.37519811978998197, 0.37211902111457096, 0.38590447150381413, 0.3674560719026495, 0.35855357217293427, 0.35307385368629307, 0.37985244376173266, 0.08135343160013797, 0.12219315527297825, 0.09563160134175319, 0.09076885313710703, 0.09823106110299362, 0.0861631847955816, 0.0920706935688258, 0.08062224721863787, 0.09190942375993494, 0.15978857776667665, 0.14452002420293752, 0.1776412513977268, 0.17478494979582504, 0.1888036368049818, 0.1439488534921366, 0.17959504307239327, 0.15162244318574447, 0.16318687699893986, 0.2674783954703853, 0.22295517512549723, 0.2495725136938559, 0.26742809395849465, 0.2367309093118407, 0.23705388206986622, 0.2505844295058659, 0.26266315339333945, 0.2413441849723197, 0.18705752820676913, 0.17170534419390948, 0.20247940925973662, 0.1973317408251528, 0.193493700407239, 0.18092030988722996, 0.17836822864883872, 0.20595085253988776, 0.20522276612492252, 0.20032955254376505, 0.19829777554333883, 0.19274923136000122, 0.1798495935932558, 0.19233773538368637, 0.17992238495382917, 0.19930063021820565, 0.21453484489502428, 0.1804376871522254, 0.18598096618846727, 0.19147871639109282, 0.18583861045353, 0.19623039728862446, 0.178099070417572, 0.18223915067964747, 0.17806072943434215, 0.18124314889516835, 0.18763697353150655, 0.24361814472543541, 0.22603699849849213, 0.30102944059831194, 0.1781659270095226, 0.18266308369139306, 0.18033930153553224, 0.3290740190379372, 0.18850466600300675, 0.4288833774746026, 0.3943263023960425, 0.18982184580239003, 0.18368140606189887, 0.3474328658010144, 0.18499362031074984, 0.42884719627924595, 0.1934324664365703, 0.28533305993740354, 0.1851154502529606, 0.17553821741703013, 0.17342236455742222, 0.17618224488753154, 0.17396640198070745, 0.17686653542626374, 0.18240549290959485, 0.1820479923519115, 0.1742788855812214, 0.17428117813865807, 0.07191650177063424, 0.07266640156263893, 0.0752581358512644, 0.07921799036192112, 0.07080962992715889, 0.07122107293620361, 0.0766583539892165, 0.06243019723088239, 0.07917241994904156]}, "mutation_prompt": null}
{"id": "59ab0f92-70a0-4c6a-a56e-b928c762c1df", "solution": "import numpy as np\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.quantum_factor = 0.1\n        self.learning_rate = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def quantum_mutation(self, vector):\n        noise = self.quantum_factor * np.random.normal(0, 1, self.dim)\n        new_vector = vector + noise\n        return np.clip(new_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.quantum_factor = 0.05 if fitness_std < 1e-5 else 0.1\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                mutant = self.quantum_mutation(mutant)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                else:\n                    self.population[i] += self.learning_rate * (best - self.population[i])\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridQuantumDE", "description": "Hybrid Quantum-inspired Differential Evolution with Adaptive Parameter Control for Enhanced Global Search Efficiency and Convergence.", "configspace": "", "generation": 21, "fitness": 0.26662994831758424, "feedback": "The algorithm HybridQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.4973214557256094, 0.4803755500601393, 0.4801942106651398, 0.4710971812995417, 0.48545658335108155, 0.4764557610362845, 0.4962488512759706, 0.47558628538026937, 0.4833122640086136, 0.1402173542670796, 0.0870731745619796, 0.07919846730075863, 0.13055238861336893, 0.15041498163252198, 0.1864543999788446, 0.09369335733930928, 0.053590697620916394, 0.07930833753977928, 0.11715013215173808, 0.1032202480335429, 0.19783596077600285, 0.1607982643002348, 0.13200417710476564, 0.19741197583155567, 0.12086643958361909, 0.1221752230335218, 0.20774703646358084, 0.12079234343239043, 0.10369417768283407, 0.12694880441588607, 0.12046287619217677, 0.09865654985210037, 0.1048487862069385, 0.11609748584646384, 0.10183019056193976, 0.09503595722248626, 0.9446598425555964, 0.9115010259914408, 0.8751781765679929, 0.9152026067453636, 0.8945118397125764, 0.9328492328734151, 0.9315711875359568, 0.9030746229181414, 0.9223190643138688, 0.3117297276479236, 0.3218499717883231, 0.3022577902608621, 0.3036656581095777, 0.3160795159227213, 0.34667709240034883, 0.316565123321225, 0.31406496853293575, 0.30930418306184904, 0.634403095828162, 0.3781201219024122, 0.6936144712476218, 0.753558399780065, 0.5385849802330562, 0.722344740716367, 0.5173847334991821, 0.6814054678997384, 0.7340233757611221, 0.1707198300434809, 0.1862653842600125, 0.16860569419597027, 0.1690281333272442, 0.18990654405913476, 0.17074712695846206, 0.16576133979677543, 0.1655042007727392, 0.18442653708402068, 0.18586929894966997, 0.16902014643434182, 0.16697701134253407, 0.162184195793023, 0.17418211046084597, 0.1654223097349764, 0.17852733769134632, 0.17935809078446618, 0.17144023163481303, 0.07568344359175028, 0.0877156456918019, 0.051867983204155976, 0.12685624635421422, 0.08153532948531339, 0.048870060751676325, 0.03734821166592117, 0.027709399569994964, 0.10396654217124757, 0.11661054398687754, 0.15848607977398332, 0.17401706874206468, 0.11813194235575974, 0.17350501778387917, 0.1316370638198956, 0.15044881215317563, 0.1832173994321914, 0.06339235344170613, 0.03384267291259513, 9.999999999998899e-05, 0.03392699338331384, 9.999999999998899e-05, 0.0001985332320382227, 0.0021046094608414556, 0.01116197735709834, 0.06056344970378669, 9.999999999998899e-05, 0.13476059321674727, 0.13886121300333998, 0.12609157709598207, 0.14212815965908498, 0.1347580441276789, 0.12945669111378844, 0.13642316167437274, 0.13884915349149884, 0.12870729210917797, 0.4468568343082181, 0.43764379345530613, 0.42622538280555344, 0.4512655010323109, 0.4473260662912103, 0.4662736755448015, 0.44307607835859475, 0.44317020922578865, 0.4287927443192312, 0.13320380483157335, 0.1313803814578407, 0.1219583847710124, 0.11013503992860174, 0.13882584324730285, 0.1086759027362304, 0.14627239979301854, 0.1515975428222004, 0.15425394879134524, 0.27915434679600426, 0.19041128334653223, 0.23242068785444125, 0.1704507255122939, 0.29941581914673665, 0.2154206709613995, 0.18702206124053056, 0.18009783828040582, 0.2818603112089103, 0.31192440667651977, 0.3101884882934306, 0.3168480728515134, 0.3087148706812811, 0.3200303116833656, 0.2999770619433021, 0.29910383060591583, 0.32824199835857093, 0.3170739743183125, 0.24802873072824827, 0.25067256506966207, 0.23667298542568027, 0.26568054257509777, 0.25409673989223447, 0.25294107560269674, 0.2576492855527205, 0.26998237181069396, 0.2461667452943922, 0.20689413879869345, 0.2504097418272544, 0.20484459003677835, 0.1942446713301006, 0.231073527638874, 0.2179808234160151, 0.20076009482040214, 0.21488554678290062, 0.21064382904378798, 0.23021770542281206, 0.21466867711842297, 0.18449692847973798, 0.21697755415789544, 0.21260913026801576, 0.19749540406845367, 0.1908905248936429, 0.2031335914718091, 0.19843466109248087, 0.18352086546149526, 0.19456083049065542, 0.18192138713865458, 0.19382678624318728, 0.708608283504019, 0.7314891873803913, 0.776226987976246, 0.73295474244951, 0.7239430449473858, 0.7050552186820654, 0.21049844964683384, 0.7076633006902651, 0.45167231134056496, 0.20929766678711548, 0.16420272562388472, 0.21009211000318995, 0.49078240912841653, 0.6220904905347486, 0.1948966466995924, 0.19414839105245396, 0.18394002688724553, 0.17891577282222482, 0.18038019570130093, 0.18520742952741498, 0.1913548274139778, 0.19397761689573134, 0.17834235177792923, 0.0873942767720931, 0.09100716546905219, 0.08339334161392487, 0.09179512395256739, 0.09272466335357621, 0.09178507584041651, 0.08689946149645589, 0.08816324236883955, 0.09378621650802432]}, "mutation_prompt": null}
{"id": "3a5a62fe-6a43-4cfb-a9c7-2aff6db37b04", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.85\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_best(self):\n        indices = np.argsort(self.fitness)\n        return indices[:3]\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, best, rand2, rand3):\n        mutant_vector = best + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.95)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.6\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_best()\n                rand2, rand3 = self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(best, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "DiversifiedAdaptiveDE", "description": "Diversified Self-Tuning Differential Evolution with Adaptive Elite and Fitness-Based Mutation for Efficient Global Optimization.", "configspace": "", "generation": 22, "fitness": 0.08404792628189857, "feedback": "The algorithm DiversifiedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.14445871586004655, 0.1582914518043954, 0.256811177492263, 0.11828949231797647, 0.2218831892804537, 0.14764859585646573, 0.11929271432660993, 0.14242245850684154, 0.16714507202475837, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03464815593425197, 0.02985204575116207, 0.040687322828063754, 0.047308422226883695, 0.055841851290863276, 0.08275632375536357, 0.0476482873270363, 0.051245143141520955, 0.07814311354871428, 0.02389438891093487, 0.03850126553766131, 0.04212227439305638, 0.07912027183793491, 0.03865224068905049, 0.024415198805509353, 0.0351184031424695, 0.038293707424138845, 0.033020857849119456, 0.06795417953097638, 0.09272208990343367, 0.06403308153714882, 0.08838371681525403, 0.10685536049469957, 0.06594499368390316, 0.11345239556838738, 0.11343338519437052, 0.0558768088925794, 0.12640644756684383, 0.014211554524797054, 9.999999999998899e-05, 0.027633528268084184, 0.01653328765106521, 0.05670558403213055, 0.06630049706984975, 0.06172902554954107, 0.06721302251168415, 0.1504935385621835, 0.14410109339893684, 0.09658816548486593, 0.1370686439154548, 0.1639349210737111, 0.11864235291046421, 0.07601673393056829, 0.11596156844534511, 0.04803762097736253, 0.03835899233165074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012570716111347413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05599910260662855, 0.03666097538536017, 0.05115116273958542, 0.05129416299109979, 0.002784289887051039, 0.0033827458609350103, 0.06446110771221925, 0.0996290529547732, 0.038183938321977084, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03146842720206655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012621450609983875, 9.999999999998899e-05, 0.12916811959846486, 0.2238203643578791, 0.19412424304485776, 0.18415967649746667, 0.12706153539069842, 0.12612941409416467, 0.2817873598653369, 0.1226109075673939, 0.16315559933276658, 0.050041499583947546, 0.03787801213162789, 0.06790029183343027, 0.0949716393636596, 0.008828889751607338, 0.06568961969472553, 0.04713713416463983, 0.049744510941270526, 0.09831365028175809, 0.12427401439264085, 0.11020319640897347, 0.17687054017206283, 0.13993863569615927, 0.2038469544463697, 0.1229945099778964, 0.12283206996351348, 0.12093095139507859, 0.1298726780558922, 0.16431381772368148, 0.18223099307659396, 0.18632320310473516, 0.14779853704945012, 0.20563922462029927, 0.18852730551193653, 0.18447100512276748, 0.18504576357653246, 0.2070223547304788, 0.16942054356195257, 0.07378426127933435, 0.1838000010991041, 0.12718773494170998, 0.07600669716338504, 0.09940952933009861, 0.12336815837123327, 0.1393481841283376, 0.14460200397761858, 0.21125685490635837, 0.13312539514570743, 0.1670486327950621, 0.21017709409296992, 0.173916837201761, 0.14831847858422897, 0.1695422515581375, 0.19248817149064257, 0.21539240785248726, 0.14447225474468706, 0.10665700707659731, 0.14990039409694822, 0.17411788588766552, 0.03152518757739542, 9.999999999998899e-05, 0.16922610840661056, 9.999999999998899e-05, 9.999999999998899e-05, 0.1075391440645479, 0.1057964162430628, 0.08244837719327114, 0.22013400823103813, 0.17045779908019354, 0.12092478239352988, 0.11913207262218206, 0.11235743129261044, 0.35181944249085095, 0.19059418690078644, 0.1651006680352417, 0.07236112961828056, 0.11003243381708139, 0.1452004878644264, 0.10562896638722463, 0.1030804672753266, 0.06239082708852717, 0.1266374268852154, 0.16462444633353657, 0.15963711724118912, 0.18177126690509982, 0.1767412938288171, 0.1835596526778298, 0.17520638094996233, 0.17931418556914125, 0.17608886909563282, 0.1769062003984292, 0.057956736781045626, 0.06903719997035673, 0.06429313220732513, 0.05123906237991138, 0.05653545533481996, 0.06223136462605616, 0.05940789544261349, 0.05792645958465292, 0.06277712821762238]}, "mutation_prompt": null}
{"id": "87848651-1bb0-460c-99d7-f83c1f682ade", "solution": "import numpy as np\n\nclass HybridParticleEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocity = np.zeros((self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n                if self.fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best[i] = self.population[i]\n                    self.personal_best_fitness[i] = self.fitness[i]\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)\n        self.crossover_rate = np.random.uniform(0.75, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.7 if fitness_std < 1e-4 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        global_best_idx = np.argmin(self.personal_best_fitness)\n        global_best = self.personal_best[global_best_idx]\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                self.velocity[i] = 0.5 * self.velocity[i] + 0.5 * (self.personal_best[i] - self.population[i]) + 0.5 * (global_best - self.population[i])\n                offspring += self.velocity[i]\n                offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                    if offspring_fitness < self.personal_best_fitness[i]:\n                        self.personal_best[i] = offspring\n                        self.personal_best_fitness[i] = offspring_fitness\n            global_best_idx = np.argmin(self.personal_best_fitness)\n            global_best = self.personal_best[global_best_idx]\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridParticleEnhancedDE", "description": "Hybrid Particle-Enhanced Adaptive Differential Evolution integrates particle swarm-inspired velocity updates with diversity-driven parameter adaptation for improved exploration and exploitation in black box optimization.", "configspace": "", "generation": 23, "fitness": 0.2984565994311507, "feedback": "The algorithm HybridParticleEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.780612922244035, 0.7620231562779435, 0.7740990391040288, 0.8108955808607317, 0.7883719629438962, 0.7905928029441345, 0.824619338124972, 0.7891991761497472, 0.7726117806144449, 0.6266002121492331, 0.6251724997730987, 0.5908018543036243, 0.04607833267142525, 0.5900527229390777, 0.5888456058035765, 0.6246426863215955, 0.611950811077574, 0.5865385867624218, 0.12425601255978436, 0.13949835032153057, 0.12397665904727762, 0.1326508150370297, 0.11773572536414811, 0.11556924223868026, 0.13843041769192588, 0.11777486722050123, 0.11185601250210697, 0.12519268038223186, 0.1034558851049645, 0.08465533814583082, 0.11610847383750333, 0.11124408137264441, 0.11474090958047711, 0.11121231165139545, 0.11743385015617624, 0.10759119986413301, 0.9863604303367792, 0.9494805178122858, 0.9854207897439553, 0.9768741840127205, 0.9810367081473248, 0.9768632409892287, 0.9860271402038897, 0.9845744367436031, 0.9881420993600596, 0.22905305148727606, 0.29242554006419264, 0.20212553770315222, 0.2640977083753234, 0.27940425262416235, 0.2474884988873911, 0.2634461208497292, 0.26997580291113876, 0.26691276745076076, 0.6677769783732279, 0.6719765105238632, 0.5299498588921243, 0.6927244050100829, 0.6121845714393097, 0.19874545445849456, 0.1252026104468349, 0.7417798468190767, 0.7291139550543659, 0.3220234404380061, 0.2724834979351095, 0.2581561583033618, 0.2781390104263435, 0.23793319723975015, 0.27328502576742, 0.28841027790671625, 0.25103001603142683, 0.2715573953401086, 0.2770991108626264, 0.2527916360879344, 0.23349048229096359, 0.2152792793138778, 0.28134236454125916, 0.2704332165369767, 0.2533135698650518, 0.10748345552637639, 0.17369309420576173, 0.14672990557325372, 0.09793287880140411, 0.0987045178683631, 0.16454794895110658, 0.10899154438332082, 0.11571322487645397, 0.10900815720664492, 0.1070350391328333, 0.11515633126913905, 0.2210873959258839, 0.19232597512247207, 0.18188665282570982, 0.18483064589050924, 0.20642526016704454, 0.17979994516582343, 0.24944268073790687, 0.2603406898958327, 0.2232208747082799, 0.032335909975924726, 0.043093267657573264, 0.05171676716671081, 0.06867606018948058, 0.053571084764125976, 0.10658823678122975, 0.08923899558946702, 0.047317896563310535, 0.1052275775879774, 0.19881107893105343, 0.19799202859743592, 0.20672662062943825, 0.2368976845857531, 0.21810884834326605, 0.2179838384674887, 0.21733562550900587, 0.21377794119764848, 0.20645724611016736, 0.5806935086114846, 0.5580906919836564, 0.586209635863419, 0.609301543816839, 0.559353452055197, 0.5510829611747164, 0.5513439002607905, 0.5616178969852186, 0.5554648378827604, 0.0948771390596479, 0.0874543510003043, 0.09144368945017545, 0.0939960162328678, 0.11001388352492669, 0.08095272880162907, 0.08614831231956088, 0.08553153624515619, 0.09472998273884081, 0.1563699550477453, 0.17565617344873552, 0.2018507612504422, 0.24335813683481988, 0.20478663914703088, 0.20612999085471606, 0.1506627519178011, 0.20010065019091938, 0.18340447904649082, 0.30200627667171487, 0.3284138169233357, 0.2902694612580359, 0.368350460368142, 0.31925285791296476, 0.3338640155202295, 0.3754296344803657, 0.35942953678859535, 0.3407674061847261, 0.2413879794673517, 0.21083437702286834, 0.2343825619575779, 0.23669501586067743, 0.22851892168190213, 0.1686314636155566, 0.2957424994438196, 0.2637321214021454, 0.26323101561929274, 0.1883982531271785, 0.20247536981596337, 0.18380258256430837, 0.19374418441621022, 0.17474356129564161, 0.1785762424451044, 0.20336582632591627, 0.1836247046445153, 0.17916173589074136, 0.30759921763768894, 0.2836145054363388, 0.1987734382178965, 0.3635448224998885, 0.19206530797895383, 0.19363649048451903, 0.23293719892121956, 0.2060560454779956, 0.19821148030392066, 0.7844587650275012, 0.19979794494333525, 0.14716979688848764, 0.17652839817652, 0.19385429988574132, 0.19232564882082748, 0.14172616034088514, 0.15892231253980738, 0.2024399300755637, 0.6845079810432606, 0.20893503751761178, 0.11205675103561519, 0.6836011728395992, 0.16612001076574778, 0.5643811230636461, 0.20842539065973353, 0.20204731813489984, 0.2068628720832031, 0.20699953284815087, 0.1803854785172565, 0.1911548058779644, 0.19532430883352858, 0.19886198619995044, 0.17701780653553012, 0.1925901927079957, 0.17348882096309914, 0.20151397688154982, 0.08257564606250367, 0.08319534827280495, 0.06780841422588946, 0.06381664213549543, 0.07416089522025138, 0.06932959910433312, 0.058890211606006826, 0.06902108719426647, 0.07119828705843356]}, "mutation_prompt": null}
{"id": "c12e1d66-cbe9-4e24-b963-49f420608524", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased to enhance search capabilities\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        # Adjusted parameters for improved stochastic adaptability\n        self.diversity_factor = 0.6\n        self.mutation_factor = np.random.uniform(0.5, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        # Improved diversity adaptation based on fitness variance\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.7 if fitness_std < 1e-5 else 0.6\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "StochasticAdaptiveDE", "description": "Stochastic Adaptive Differential Evolution optimized with dynamic crossover and mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.35786448802777643, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.8083639791821058, 0.7928573402678395, 0.8003171248484658, 0.8007086133265962, 0.8134512683457342, 0.8125504808093593, 0.8240454058783229, 0.8209811946392245, 0.8281200055583757, 0.646767579324658, 0.672396630096769, 0.6436158155867158, 0.6595208524172036, 0.6660131333840467, 0.670704497606927, 0.663431442390384, 0.6802600045350198, 0.659821991157737, 0.1310451961346134, 0.13269395134268436, 0.13861836304355457, 0.2009255284392032, 0.16162546560643154, 0.1597025729695042, 0.1302790773818735, 0.15056593993144762, 0.21006637320991128, 0.12783917700015823, 0.1281878137041551, 0.12733377199338014, 0.13819907951585575, 0.12453435577586591, 0.13812096664932383, 0.13971389338931572, 0.17947241969562133, 0.17731399139882198, 0.9365513622258288, 0.8789507679779104, 0.8977974960536826, 0.9344352997946355, 0.8982288528182223, 0.8303874849961561, 0.8956830057056242, 0.8791206122528437, 0.9239582786507234, 0.3217410689646537, 0.31191819006599253, 0.4819596037586277, 0.36320893839562673, 0.41147172893279416, 0.4226303388621573, 0.4159114725223202, 0.2757874122069157, 0.28744504458177744, 0.743434574304903, 0.7840225332289263, 0.691352867557108, 0.7448389802331807, 0.7784292565580126, 0.7904743990880394, 0.7376689083293233, 0.7548458906041087, 0.7737364435520404, 0.3301086895511448, 0.14330853249746656, 0.21190961724267343, 0.18573147221544173, 0.16545715562280872, 0.26314576404469314, 0.183476650374377, 0.12217366206450897, 0.28188065010415875, 0.21904106585943517, 0.14831726282825497, 0.1935744172113697, 0.17918550221359564, 0.18465122644007792, 0.27100185471222016, 0.16618231145926443, 0.4399457474487444, 0.147647956824689, 0.3014775104036046, 0.3272438204485201, 0.2660540927221128, 0.2562449280491961, 0.08824769639543995, 0.18366360294642914, 0.10651558920502302, 0.31974452030378064, 0.25749989191852085, 0.5231597420551619, 0.42227596518157984, 0.4446299673785158, 0.40202437434170024, 0.45682640510402517, 0.26532088739329973, 0.5449620433505796, 0.4808687650899447, 0.4824747117399142, 0.10079508588507868, 0.148490398711432, 0.11810557545487466, 0.19529470121852988, 0.17783299735954639, 0.11904195591716071, 0.12691446695824415, 0.096897118929415, 0.23389816556587717, 0.2835626822902122, 0.2914299115757062, 0.23099774623558944, 0.2996560336469133, 0.2770465231937502, 0.25909353701845717, 0.27724984881303216, 0.2905872218815232, 0.20082114985317567, 0.6568429865403521, 0.7041765000998003, 0.6746232503984992, 0.6787777677111051, 0.6797719233011097, 0.6811466353846772, 0.6920407493021722, 0.6896881526654824, 0.7019756740411511, 0.10621776328317423, 0.1080618006744467, 0.10459239080273741, 0.09913566881182656, 0.11354055757972692, 0.10212189778633507, 0.10525100358545847, 0.121642804618324, 0.10203103145399328, 0.13835909328745544, 0.15564573127916714, 0.16402384712007367, 0.16121486569045917, 0.13416488217101596, 0.15631611762669617, 0.16409937702377553, 0.15480331370590794, 0.1435226694695897, 0.4560720671534797, 0.43135871129320835, 0.43109556395922766, 0.4675353072709908, 0.42205268284745934, 0.4544869437302511, 0.49857087529144717, 0.4703583891411993, 0.4610535634500236, 0.30205320975502603, 0.3360208351829801, 0.3279434919473897, 0.35542923352968603, 0.3247180700323704, 0.29907352274681154, 0.38953839829946135, 0.38120225765167515, 0.3111270265978563, 0.2202497149213285, 0.2150726664475422, 0.18832196936088375, 0.22410225258494698, 0.19921331849125856, 0.2017281089067462, 0.20100487863875593, 0.20444710857976245, 0.26874219021203793, 0.4315499154921295, 0.33142826993728225, 0.19565955725602302, 0.26454020688919855, 0.2025598622754552, 0.2004839041618104, 0.2084446392782705, 0.19300486017788432, 0.1952957478939641, 0.6720443709785693, 0.1654386205011984, 0.7588610890182323, 0.7691443249435543, 0.18402410251488288, 0.16559547737933067, 0.6775976262392551, 0.1660810797372404, 0.5887567094402301, 0.4042541436341719, 0.2844310865188673, 0.20068826724012778, 0.644293428413675, 0.20153243810115207, 0.2807713716164062, 0.1996669897346386, 0.7465332241590031, 0.20695630719639202, 0.17692638217521073, 0.1776391967325215, 0.17691624243310144, 0.17458512177576035, 0.17278527423397938, 0.18968076306647152, 0.1850910662020181, 0.1973160979883144, 0.18881793783231537, 0.09139959872574632, 0.08262253359306071, 0.07653530730895397, 0.07879553396901573, 0.09070137615294793, 0.09110776377043261, 0.078710605630681, 0.08858248180780537, 0.08467241442397266]}, "mutation_prompt": null}
{"id": "8e4a71fd-31c8-4811-ad2d-e908e72806a1", "solution": "import numpy as np\n\nclass HybridEvolutionaryDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_probabilistic(self):\n        probabilities = np.exp(-self.fitness / np.std(self.fitness))\n        probabilities /= probabilities.sum()\n        return np.random.choice(self.population_size, 3, p=probabilities, replace=False)\n\n    def crossover(self, target, mutant):\n        if np.random.rand() < 0.5:\n            return target + self.crossover_rate * (mutant - target)\n        else:\n            mask = np.random.rand(self.dim) < self.crossover_rate\n            return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n        if self.num_evaluations / self.budget > 0.5:\n            self.population_size = min(100, self.population_size + 1)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_probabilistic()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridEvolutionaryDynamic", "description": "Hybrid Evolutionary Algorithm with Probabilistic Selection and Dynamic Parameter Tuning for Enhanced Convergence on Diverse Optimization Landscapes.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {}, "mutation_prompt": null}
{"id": "a0dae09f-534e-42a5-9069-d16648bde886", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.stochastic_factor = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        stochastic_adjustment = np.random.uniform(-self.stochastic_factor, self.stochastic_factor, self.dim)\n        mutant_vector += stochastic_adjustment\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n        self.stochastic_factor = np.random.uniform(0, 0.2)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "StochasticAdaptiveDE", "description": "Stochastic Adaptive Differential Evolution with Dynamic Fitness-Based Mutation and Crossover Mechanisms for Enhanced Black Box Optimization.", "configspace": "", "generation": 26, "fitness": 0.27397650839219756, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.552999295603681, 0.5658738512730546, 0.5750663739861279, 0.5623953270790905, 0.5676699725417331, 0.5818388362009274, 0.5664491373651177, 0.5731954574605634, 0.573219093622911, 0.15402571335435422, 0.218766415147848, 0.1447840783954022, 0.051126023915708196, 0.17991341241707937, 0.1082530902161678, 0.14866858362348612, 0.1619228240727345, 0.14504340696738816, 0.19359687352417732, 0.14385580881090843, 0.15126932521642789, 0.13412268112022752, 0.14512695373673634, 0.17383941786736956, 0.14618651908778757, 0.14048700856539398, 0.15576436985905728, 0.12103364416281492, 0.11675000653406475, 0.12802414820053987, 0.11249370508662904, 0.11916293450068893, 0.13128010572945403, 0.12763280764734586, 0.12397732936123718, 0.14565893756847437, 0.9047776777368716, 0.8854014778921742, 0.9385054772856177, 0.8983071662435328, 0.8754403358555408, 0.8994105034585156, 0.907453727541453, 0.8907628404750103, 0.897861936429984, 0.3420474426429285, 0.289991080857694, 0.3360191547367637, 0.34418426233599975, 0.3335298269288912, 0.3127765002219455, 0.315310718673785, 0.3252382180524893, 0.3623674149949133, 0.8058530601596662, 0.6897895459400444, 0.8005419494040635, 0.7134967593681885, 0.7517026784112281, 0.8016251572103508, 0.7366646582293557, 0.8235639086448697, 0.21937956232505562, 0.1855884610622478, 0.2089685002628987, 0.1897220684257942, 0.21766885211830433, 0.17697781210727503, 0.18041976125474302, 0.18221404184406853, 0.18409739121708424, 0.18198352307293675, 0.16484652744907757, 0.20376031186121368, 0.16326056695765745, 0.15816415489408298, 0.1815236109711461, 0.21805560549239367, 0.16788894814948685, 0.16623443023022444, 0.17370713157164697, 0.07128463149932907, 0.06277249757164338, 0.0012845279399034126, 0.03801763745005138, 0.11102621634500298, 0.05979794190474219, 0.05945910299762713, 0.08280037965201192, 0.10604953271824635, 0.17682391559323662, 0.1637197147338535, 0.17633062886114437, 0.09964378239340987, 0.09665273158022991, 0.15878286262401597, 0.14112412698450627, 0.16081417437301881, 0.15023908914999196, 0.027107379045701263, 0.010282813685584036, 0.06973450112772628, 0.00495828651967456, 0.02752642007833017, 0.016065513633318318, 0.009440906890674894, 0.027976258046490732, 0.046184373266856316, 0.13048151479928016, 0.15844036944854512, 0.15124315244866016, 0.1356290733646187, 0.1562253737679905, 0.1679897425680421, 0.13236917041923701, 0.15987660819307825, 0.1594231661760085, 0.49127682152566854, 0.4994252875585644, 0.4617893376944805, 0.4783094718750661, 0.47306924826270447, 0.4728612143367884, 0.46459005997923, 0.4800243609553979, 0.46807777122643524, 0.12372141789969848, 0.11166322412113971, 0.09996052764842789, 0.10694966561209662, 0.11914329375455068, 0.11441255663768313, 0.12578015954281052, 0.14282422538201367, 0.12422550005090505, 0.23389008636698172, 0.1678566653186615, 0.15039521496877228, 0.2555277202132089, 0.172989160891173, 0.17017380533754944, 0.19411464650377852, 0.24705823315670272, 0.2552268562000235, 0.33552390669140186, 0.33763169398822257, 0.3446221255663221, 0.3343035492633608, 0.33492863974956444, 0.3455850119495165, 0.2557263218885961, 0.35115784020468277, 0.35109279744745503, 0.2778083091255955, 0.2572299368901111, 0.2551769259898303, 0.2687115921499973, 0.2733068126264526, 0.25975447568201626, 0.2752051120202422, 0.3027846816920001, 0.2666061937919846, 0.2243460981808596, 0.2118077833103752, 0.23141251928552475, 0.23513667110989167, 0.20022643521831207, 0.1905107402932994, 0.2088310501657874, 0.20146794058059336, 0.20851004624405722, 0.2007077526909229, 0.20969692524036154, 0.2962701293172093, 0.36372001372328444, 0.19112427063464166, 0.33335146900833046, 0.19885691735655653, 0.3178092658714453, 0.21519976174586808, 0.18522499296378114, 0.7809338764345042, 0.18464624984273514, 0.7192285206140043, 0.19848716054386273, 0.8252586881982367, 0.1503630154698996, 0.18299506018242195, 0.7348280730634498, 0.7070710497819795, 0.20997807078007025, 0.6819250716498515, 0.20454981481999224, 0.1635878771770749, 0.16653933550922395, 0.20857665300220019, 0.2069483215824799, 0.1532136187464177, 0.17653300204756506, 0.18797146651981256, 0.1800705235265455, 0.1905613397948832, 0.1919967991163568, 0.20369023647518048, 0.18854250767980507, 0.19020955986068466, 0.17911669008059505, 0.10047095697974395, 0.07954293028879889, 0.085813920790764, 0.09022916715552531, 0.08528744814511702, 0.08319846693380517, 0.08717639518752718, 0.09131057093945494, 0.09523380244142754]}, "mutation_prompt": null}
{"id": "931f9772-fdc9-4fff-bbfd-f6f84e99da00", "solution": "import numpy as np\n\nclass ImprovedEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adaptive_gaussian_mutation(self, individual):\n        noise = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.adaptive_gaussian_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ImprovedEnhancedDE", "description": "Improved EnhancedAdaptiveDE using Local Convergence Enhancement and Adaptive Gaussian Mutation.", "configspace": "", "generation": 27, "fitness": 0.3597977156678714, "feedback": "The algorithm ImprovedEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "802580c4-3c32-49c0-b871-635e26468645", "metadata": {"aucs": [0.8195861842464156, 0.8198940481621527, 0.8201661471119283, 0.8148347214960023, 0.8295779008585662, 0.8102131759142494, 0.8190797846520134, 0.8131965321909802, 0.7938458526727525, 0.676259813110558, 0.6509542265089197, 0.6433007673792926, 0.6664135714207993, 0.6653441828449015, 0.6704609736482332, 0.6292086204878353, 0.6171605824954378, 0.6289617235429741, 0.1597269275283434, 0.17579012990603682, 0.13077186299700716, 0.1536616449534267, 0.17969725037439677, 0.13087862879270484, 0.12584568830128662, 0.15188089588080989, 0.1406992975014919, 0.12131296519911994, 0.11693442529705245, 0.11029085013968365, 0.12361609002769769, 0.10466315018739403, 0.1211703081445854, 0.16015007933519942, 0.15050685647903306, 0.11633105428923207, 0.8633531512998203, 0.831422301534048, 0.9084187729466605, 0.8550759619594746, 0.822456527936219, 0.884293975387978, 0.8662922908838695, 0.8071251498610528, 0.8721718342177753, 0.3289981214395328, 0.38231048299957715, 0.33567434606435675, 0.30787433765312544, 0.3193861553892562, 0.3251362379864777, 0.41256783759303217, 0.3492346205715776, 0.3033541802045362, 0.82017004900788, 0.7864492484724698, 0.8309446960678175, 0.8407143036461163, 0.8577527047611988, 0.2549140779457286, 0.8243412619403557, 0.8383066248303045, 0.8236563396267778, 0.13036707359811373, 0.1356086336952096, 0.3218481994375153, 0.26252964876146456, 0.18124973198076, 0.1929164617492537, 0.19316028333430824, 0.22477847901198178, 0.28396752843371864, 0.23947584126064236, 0.17611390018908624, 0.2009022603268723, 0.17502113471938718, 0.1677195765851226, 0.1721010474649285, 0.26405060543802816, 0.19579299892690094, 0.23579503947128078, 0.08082374213731891, 0.13198372536441383, 0.2708377302860481, 0.19454956034473403, 0.040625340647891584, 0.0765714666103875, 0.3382005556685018, 0.00033911345307913177, 0.28349291553205735, 0.3596897761374712, 0.36991211967545334, 0.646685185886964, 0.1462619017905954, 0.1929217208947137, 0.24149739922301228, 0.3555255216730838, 0.3016688866225007, 0.4261510432755832, 0.12421864452006082, 0.1653145383181216, 0.15217543285752577, 0.09606495495682044, 0.1595185214340361, 0.21382644059406264, 0.1119360695917605, 0.1838015554109903, 0.08076151827587696, 0.36341658655841624, 0.3581619877961507, 0.26415176905595494, 0.3186283340949273, 0.279772770109174, 0.2279813536279467, 0.22387018113880575, 0.14038713843083483, 0.14046706149147925, 0.7495312055101263, 0.5783992984558106, 0.763940866229765, 0.6699761038667784, 0.5161922107230108, 0.5174078595676377, 0.7223428439972335, 0.740561998583058, 0.6555280351609503, 0.13105692705318484, 0.1333858601609692, 0.1132516623717511, 0.12959683007310263, 0.11583775067725488, 0.14959235141727734, 0.14038960731352923, 0.14562631623853117, 0.13491851357481177, 0.17484182257711456, 0.3085037785402188, 0.1738879279310941, 0.18825762597771922, 0.16417105691876677, 0.17851420213533142, 0.18506543078505766, 0.18944129656045583, 0.22086397312434625, 0.45830603720871455, 0.46043805661643167, 0.4873904282004451, 0.4843169684110843, 0.4669560524628251, 0.49705074857728404, 0.4638388784480193, 0.45861275363138887, 0.4557951253833086, 0.35633866941373293, 0.37997827402493844, 0.3140114863879573, 0.31130237691622054, 0.35516608770937275, 0.35400516655627234, 0.4051065735108942, 0.4433684744566343, 0.4015932718913122, 0.2074507198693839, 0.2147641521657463, 0.19697392290490268, 0.2716327507837192, 0.20633039855822577, 0.2284228468633811, 0.2007905989159008, 0.21386940112839514, 0.19742843213317696, 0.2038992108045341, 0.21689488546848468, 0.3336555865333277, 0.3009453908089448, 0.22487552462166782, 0.21960341700165253, 0.2081141291076447, 0.5141841830286504, 0.3619112390147925, 0.1803513743350681, 0.18321914372207193, 0.6601704598321576, 0.72024119383857, 0.771706462893073, 0.19594638559500255, 0.7271690905909817, 0.6084414673392797, 0.6965840702645811, 0.6780290984822956, 0.7630073455619191, 0.8209639623000977, 0.20325637370521177, 0.19662714730574704, 0.7144405045661137, 0.622047668063588, 0.20911871967327755, 0.2101552839423544, 0.19655194705936174, 0.18788182332518977, 0.18811927857365107, 0.18284614868940896, 0.18979217641872015, 0.20381293377659626, 0.19812292349133087, 0.17167320372859263, 0.179864301473878, 0.07714856304823903, 0.08956067453086813, 0.08644879324841892, 0.07354078018300969, 0.08296373327652695, 0.10496761754391737, 0.0939705851924224, 0.07444104299772025, 0.07634521646987613]}, "mutation_prompt": null}
{"id": "b7f124be-5ae8-4778-8efe-f2e031de863a", "solution": "import numpy as np\n\nclass ImprovedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def multi_strategy_mutation(self, individual):\n        if np.random.rand() < 0.5:\n            return self.adaptive_gaussian_mutation(individual)\n        else:\n            return self.mutation_de(individual, individual, individual)\n\n    def adaptive_gaussian_mutation(self, individual):\n        noise = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.multi_strategy_mutation(self.population[i])\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.multi_strategy_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ImprovedHybridAdaptiveDE", "description": "Improved Hybrid Adaptive DE with Dynamic Population and Multi-Strategy Mutations for Robust Optimization.", "configspace": "", "generation": 28, "fitness": 0.08454083091479898, "feedback": "The algorithm ImprovedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "931f9772-fdc9-4fff-bbfd-f6f84e99da00", "metadata": {"aucs": [0.19445881268437804, 0.14256507553953357, 0.16863257611735438, 0.20089978522277574, 0.1755040521587492, 0.21520257826171096, 0.18454057359190712, 0.1426437837606951, 0.1095830467412865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010796945835630511, 9.999999999998899e-05, 9.999999999998899e-05, 0.02899942454109372, 0.03125911831434347, 0.03340950890696204, 0.02752693268160289, 0.019032200622152606, 0.0295948141813005, 0.029098101551738864, 0.06681637172795996, 0.05613857468870487, 0.021466085752107178, 0.0038433556385601975, 0.02582764329592102, 0.053901650705988846, 0.03113179560533119, 0.012277239513948324, 0.02735730060008279, 0.04349978619794892, 0.011798616166876164, 0.0645887478113184, 0.06772812152787755, 0.07311227867400372, 0.06911439093904359, 0.06348920040719164, 0.058650263120113455, 0.07303042576096686, 0.06583516878801088, 0.06058274305664402, 0.11955925595335537, 0.043275293950152616, 0.024201456410453237, 0.12288216533189156, 0.061395634375871144, 0.10172249220376794, 0.04050976860622102, 0.03955190635975159, 0.07757779146506616, 0.12008229362404976, 0.17305347601270293, 0.06443217833237158, 0.1733013587197051, 0.11488526189833115, 0.005776023314197465, 0.0611964408779031, 0.1113722791461752, 0.0350013958101304, 0.08160082335658903, 0.06993420966310204, 0.006069759884360426, 0.015647705757919406, 0.029340879708819045, 0.00266694113655197, 0.0322216413194677, 0.08726616829945377, 0.022342214619137435, 0.03956631655305942, 0.027310742816414324, 0.013238110015470705, 0.015295432838961065, 0.005705717639128527, 0.07400605253235848, 0.04993294818922045, 0.0032055971887426926, 0.03815172932082733, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09431937852480554, 0.06246326125495816, 0.07611546442480777, 0.05431760139273878, 0.05370261469902993, 0.06665134713894583, 0.05555697037092122, 0.06031095483220905, 0.04637583197621864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009137876553368174, 9.999999999998899e-05, 0.02403236816116927, 0.0020053180192884934, 0.00032599429164781313, 0.025589173434207857, 9.999999999998899e-05, 0.021103822438240938, 0.009823561217949472, 0.16819722172206875, 0.25220071982537495, 0.2032565055841542, 0.1759354770576903, 0.13780260894047225, 0.14397856480734395, 0.31160994413923815, 0.134950121714428, 0.1936960379241175, 0.05186466007199675, 0.019837908790507952, 0.03850207479948076, 0.04413199187206951, 0.02598189023239561, 0.03723275582314656, 0.01922986054837217, 0.01124804448364014, 0.05003514797074182, 0.13221117403397853, 0.16767290937180912, 0.1661953629608668, 0.15366721365543767, 0.19660389716049653, 0.14422958175372713, 0.1501918036638421, 0.13450479605242127, 0.15523897869188896, 0.12514494123123754, 0.11873413629417395, 0.16215591438701704, 0.14381817822215348, 0.13154901523309803, 0.13848706477185846, 0.1594244534190815, 0.18992106413665122, 0.15005834361205705, 0.06224077674701278, 0.05023322098260086, 0.10483767083047535, 0.11527396991081018, 0.07261699279377021, 0.0856654056121926, 0.09250733610020545, 0.1162381664060893, 0.08001552429966197, 0.15422322022970547, 0.13472992677056883, 0.17346284125486744, 0.17946027245738172, 0.12899679520378882, 0.12773363982232933, 0.14749959515275368, 0.12854511087648457, 0.12784659832110923, 0.15665809320101576, 0.14650730075422125, 0.1412038900078323, 0.13696277897382203, 0.10510205846873177, 0.11867807534538755, 0.11303673419552596, 0.0864864523922344, 0.09385787057309114, 0.13404698540594184, 0.15277880345466732, 0.20875102134028312, 0.18556851787509276, 0.18953625644361005, 0.1881734341721908, 0.24031028486491213, 0.15449701506707592, 0.14952619178611037, 0.2805214475649146, 0.16336091358264804, 0.10627470611160683, 0.12203263022959876, 0.10932171812066904, 0.12351371570905922, 0.14964000483963158, 0.1265964894387469, 0.14200003750575485, 0.1650037939028891, 0.18397983132803675, 0.17327595806284513, 0.17750325416701795, 0.17478440577648746, 0.17799918180491836, 0.18207207320269003, 0.178845229281978, 0.17138143008891604, 0.03251739684513266, 0.03566984119254646, 0.04876903327769089, 0.035694974370274246, 0.04713366525685414, 0.04449363096423187, 0.04389643903495055, 0.053413983544734256, 0.03568365793723338]}, "mutation_prompt": null}
{"id": "1f3ac949-2f8a-4344-bb92-3e8a3c225521", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def quantum_superposition_mutation(self, rand1, rand2, rand3):\n        alpha = np.random.rand()\n        mutant_vector = alpha * rand1 + (1 - alpha) * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adaptive_gaussian_mutation(self, individual):\n        noise = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def complex_adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 5e-5 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.quantum_superposition_mutation(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.adaptive_gaussian_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.complex_adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Parameter Adjustment and Local Search Refinement.", "configspace": "", "generation": 29, "fitness": 0.1608282644078771, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.11.", "error": "", "parent_id": "931f9772-fdc9-4fff-bbfd-f6f84e99da00", "metadata": {"aucs": [0.41633394760109943, 0.34429887427319095, 0.3749633883101162, 0.24701001370382936, 0.2714456968877107, 0.2414494271389318, 0.3383405503135196, 0.323838288667447, 0.23094915456314424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058380772424057814, 0.009151300626826564, 0.048140502316547096, 0.010267032713106139, 9.999999999998899e-05, 0.005744095992045173, 0.10483884946566047, 0.08972606981788045, 0.08217650295751933, 0.08651359022734217, 0.08201307131939883, 0.09673374571115179, 0.10793214566595322, 0.10370696113164324, 0.08845419797173859, 0.06983041868710971, 0.0858709718694638, 0.06311098819763516, 0.0789738353123508, 0.08828514344518457, 0.06877791437501968, 0.08727466658136818, 0.08282226262836356, 0.07850748977825461, 0.09118631977522729, 0.10394692005621886, 0.09474883413390944, 0.10529692584505024, 0.11582309567439186, 0.09295804158748155, 0.13972258634644963, 0.10114922212535382, 0.11248321196092348, 0.1112504342483519, 0.21515936196566465, 0.08799775850815217, 0.08448197999572582, 0.1283241687503912, 0.10919353747334226, 0.10376250113861096, 0.0914365581850558, 0.17183917884643685, 0.21467310493353042, 0.3385489253697759, 0.23338587928716725, 0.18019637049645776, 0.26710465614158274, 0.2236405565950087, 0.231381088772042, 0.2110105780978686, 0.21107082897784968, 0.13206450867203134, 0.18869760908893307, 0.1716470120523481, 0.1275595314700405, 0.10682851600720877, 0.0783835238170757, 0.15299735060496245, 0.1582338870206884, 0.13723444145691133, 0.25240952892770196, 0.2283717017560053, 0.24530116492235277, 0.2557104639454242, 0.24074863071284403, 0.21639004138978302, 0.2514221640384733, 0.23808294713816358, 0.20349055453660092, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020700768322785557, 9.999999999998899e-05, 0.002655629125763337, 0.11098700379296023, 0.09560681585957831, 0.11725056777362175, 0.10971621449376068, 0.07078173277323785, 0.09162193830498255, 0.07854017992453932, 0.17143907450420248, 0.09161395281176266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06202373127919325, 0.049306467550758626, 0.017910176492013652, 0.01284639863367465, 0.02554093566998361, 0.051075690747531044, 0.039334558560747634, 0.034931620911038075, 0.02652691327666179, 0.33170000928433785, 0.3204749041461684, 0.3427415488614298, 0.30766941278306503, 0.28950256494674653, 0.2612258152541539, 0.42495504786129024, 0.3092314260993838, 0.3628849927979283, 0.08279581588178953, 0.055510046530884205, 0.07062215847355857, 0.09415145746293907, 0.06992461087155466, 0.10640855417205641, 0.10131021701067144, 0.09025928788665893, 0.09148583785717723, 0.20011708321731148, 0.2062599268658225, 0.19980566807168176, 0.19427763400809883, 0.18476227519422928, 0.19582392365667523, 0.1959062797357477, 0.1963305722073453, 0.20721002193085947, 0.21624108598007596, 0.20903535273412122, 0.19295846428600094, 0.2407722457696907, 0.2629313342086892, 0.22987450021146383, 0.20404787532230617, 0.2150509970171055, 0.20522970797614037, 0.1697426630393546, 0.18446618235433287, 0.14962340261311058, 0.1946383177602966, 0.18656336849536292, 0.20122689088695078, 0.1776217800576746, 0.16936443285835534, 0.15063535442486609, 0.21691438423246123, 0.2460210818087024, 0.26551591211850867, 0.21759366525266655, 0.2382577705689486, 0.23868136808109774, 0.2322889944804799, 0.22657498474696547, 0.2161349286560892, 0.17359913757896395, 0.17722721797762986, 0.17285001528786215, 0.17708172161718472, 0.17584455056577464, 0.19076563326192586, 0.18104296189677216, 0.18721582343358034, 0.1881894752076798, 0.18155909068130238, 0.1818340743376069, 0.31333570547943623, 0.5626512665189418, 0.4759662347605851, 0.38866767948725534, 0.4208539823055748, 0.413432413894964, 0.492612407975747, 0.3219540664180205, 0.4525600743005028, 0.4344765564428499, 0.21795592056067237, 0.19513660355819717, 0.29635843534752926, 0.18090297632484642, 0.3290391604105316, 0.19378792895469654, 0.18490041775861332, 0.19033454840017516, 0.18750823478354606, 0.201995275329114, 0.19433888184958537, 0.17339867124991126, 0.21963356734020867, 0.19265977348768204, 0.20172740725811078, 0.10721339827844278, 0.09584495188684505, 0.09523036557357334, 0.08190490345349988, 0.09183568762581218, 0.08970920461453658, 0.10945104269301265, 0.10275357871251423, 0.08459150387927605]}, "mutation_prompt": null}
{"id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.divergence_control = 0.2\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.6\n        self.divergence_control = 0.1 if fitness_std < 1e-5 else 0.2\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "EnhancedDE with Stochastic Adaptive Mutation and Divergence Control for Balanced Exploration-Exploitation.", "configspace": "", "generation": 30, "fitness": 0.3655450258931991, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "931f9772-fdc9-4fff-bbfd-f6f84e99da00", "metadata": {"aucs": [0.7959390651216595, 0.8039217100614483, 0.8090407289612194, 0.8015659098721307, 0.7968870596315858, 0.79832646643865, 0.8080310673526054, 0.8015571657983864, 0.7887526052073026, 0.5984183201675981, 0.6350668561161856, 0.6337461336470889, 0.6320194016152172, 0.6535670928418298, 0.6185327329529793, 0.6277294060423932, 0.6673607356208703, 0.6279596636042617, 0.12570705402329718, 0.1256749047771214, 0.14924791824724493, 0.11703980437790851, 0.14012935354417244, 0.1649889178705931, 0.1509973423690275, 0.14706657359784936, 0.1397211631863129, 0.1086971125013062, 0.09142019072482621, 0.12124134199529524, 0.12692464243954216, 0.11425605112335246, 0.11584493412717456, 0.11420951017364556, 0.12337228560252766, 0.10896764397722158, 0.9007140125705057, 0.8707219967096731, 0.8968938413082761, 0.8962247819868133, 0.8621385342811095, 0.8779293666010674, 0.8858815128072138, 0.8495076146016173, 0.8449130271694094, 0.3951207255918481, 0.41970314745001946, 0.39349397408081954, 0.4068634878658116, 0.34808131733279135, 0.5006119603738703, 0.32394674487254704, 0.4850032990196258, 0.43330218544033605, 0.700274292914866, 0.7571289076169678, 0.7543718777900058, 0.811250516433951, 0.8273538794073664, 0.8142954576581618, 0.7616196814386216, 0.784514445250702, 0.7966943646544515, 0.16021298675540652, 0.20391595368183346, 0.1863586669195777, 0.19637390828063195, 0.17643336720079172, 0.339479044768353, 0.13906291270968174, 0.14095421588962076, 0.21355530823890823, 0.1594174307865045, 0.2294804658175228, 0.14757897743144444, 0.18515328629781214, 0.1899594367165598, 0.23659518597226814, 0.1660003675532047, 0.15534471557787033, 0.17172578157356055, 0.2831912917376279, 0.14549055354740137, 0.2635552366862406, 0.19777693329078394, 0.4807027072378044, 0.06064412284573395, 0.3604178443280993, 0.3147190872043316, 0.22206288624738746, 0.5251503416050538, 0.6221041095459556, 0.343578254138194, 0.24667645470354704, 0.48437532491916757, 0.07912959004594755, 0.5501110997134708, 0.6083554831368142, 0.6066559725901193, 0.22875672967848049, 0.21272181235677667, 0.1533250962199938, 0.21289803189155698, 0.18725228429679963, 0.22515410278395043, 0.14435313795496896, 0.10852893690451038, 0.14076569747059786, 0.3274482932403152, 0.22054368883263864, 0.30804312199377437, 0.2834726198713209, 0.294695453008498, 0.3895991711937785, 0.15345730915573763, 0.3690265914148224, 0.2214675024000704, 0.6405369461542744, 0.6851156307476285, 0.7270947721684803, 0.6916682493255963, 0.5420357513912455, 0.7054211397430329, 0.7051180759817001, 0.6820306171995603, 0.6867875372123992, 0.10545998874844698, 0.11544940656267899, 0.12620061840098884, 0.11687629783658215, 0.11320156089951305, 0.12597839568989389, 0.12014316575135886, 0.11429641134112756, 0.10642346351493193, 0.1775185340046339, 0.1738546502304511, 0.17512919534860483, 0.18583807868027458, 0.19674557258773862, 0.17984514607273994, 0.1740882554354788, 0.20700850161004825, 0.17068867793010545, 0.4367420228025961, 0.4383490488914126, 0.423243821566612, 0.44569765373342685, 0.4296205996690604, 0.4265697856015679, 0.44331199482071115, 0.48329050316397926, 0.4634370449951155, 0.36016803384829543, 0.37102429045812346, 0.3764310485393716, 0.3176223028055468, 0.319177280834239, 0.3558775927809952, 0.3958225795341189, 0.40498403580164, 0.3855470330917995, 0.19917988856663238, 0.18358673777140078, 0.212544959883601, 0.19544069511606565, 0.19326356941887357, 0.18906810900844995, 0.23373817616836512, 0.20358829841181492, 0.1962089804921684, 0.26762969820139837, 0.35434409704460335, 0.200680549540577, 0.3277831916915257, 0.2071234999437448, 0.21875742571469092, 0.20627625844113207, 0.2379458175909941, 0.20406366872972725, 0.7934502324061585, 0.8046545500073525, 0.19243416052478157, 0.8148630661577315, 0.18120243107927947, 0.7612084666565695, 0.6866197189216471, 0.5985258678822558, 0.7428053416422746, 0.7371153329194657, 0.20464470023427406, 0.6599379838195565, 0.20325653372492958, 0.1990332659088997, 0.16390351139640025, 0.23220196646776947, 0.5058771295783107, 0.20813550149948445, 0.17504030742282772, 0.18197736476756576, 0.18176078630525583, 0.18497262582936524, 0.20071836112464725, 0.18862964175768682, 0.18859338314970875, 0.19224712934985733, 0.19739511245223518, 0.08612253776019174, 0.08360695489979098, 0.0946720667624118, 0.0763348361124988, 0.08378653786314139, 0.07838463677169949, 0.09412319747355691, 0.0879405387024772, 0.07656217305094837]}, "mutation_prompt": null}
{"id": "fbc5c855-056c-4bb4-ac0f-bcb5e04e4ad8", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_threshold = 1e-3  # Changed value for diversity threshold\n        self.mutation_factor = 0.8      # Adjusted mutation factor\n        self.crossover_rate = 0.8       # Adjusted crossover rate\n        self.local_search_rate = 0.2    # Adjusted local search rate\n        self.divergence_control = 0.3   # Adjusted divergence control parameter\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3) + self.divergence_control * np.random.randn(self.dim)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.15)  # Adjusted noise scale\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 0.95)\n        fitness_std = np.std(self.fitness)\n        self.divergence_control = 0.3 if fitness_std < self.diversity_threshold else 0.1\n\n    def introduce_random_walk(self, individual):\n        step_size = np.random.uniform(0.01, 0.05)\n        walk = np.random.uniform(-step_size, step_size, self.dim)\n        return np.clip(individual + walk, self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n                if np.random.rand() < 0.5:  # Introduce random walk with a probability\n                    random_walk_candidate = self.introduce_random_walk(self.population[i])\n                    random_walk_fitness = func(random_walk_candidate)\n                    self.num_evaluations += 1\n                    if random_walk_fitness < self.fitness[i]:\n                        self.population[i] = random_walk_candidate\n                        self.fitness[i] = random_walk_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Diversity Preservation and Controlled Random Walks for Improved Global Search.", "configspace": "", "generation": 31, "fitness": 0.2121703223930367, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.4603709528982103, 0.4488047357327548, 0.4750381063721446, 0.45567211312498135, 0.47433967034238145, 0.45202911567751425, 0.4451415696920913, 0.4631476633309929, 0.4779906449341049, 0.08321177516131628, 0.04883890154516757, 0.07391090072865425, 0.07050395252558861, 0.09761601662379249, 0.06603579780261792, 0.07246890285643026, 0.06812485667033852, 0.07870044244806718, 0.09806807964609121, 0.13498343301314653, 0.11619367807954928, 0.12535466071639145, 0.11961944456420393, 0.12394768233154319, 0.15358860693077547, 0.12263113977320661, 0.11465836298587162, 0.09329331896283855, 0.09442843166765691, 0.09400894962655715, 0.10351606743758335, 0.09833306888483917, 0.12003577734905735, 0.11122866912425033, 0.09735485720626325, 0.0970471309504839, 0.9048211905621332, 0.8691774257259106, 0.920102247759025, 0.8748367295784343, 0.8846853160357545, 0.8908788508155709, 0.9104829804484825, 0.860984192404939, 0.9259100805348967, 0.23193971650946066, 0.2125118220349308, 0.19970222975427465, 0.22440870727041973, 0.19224427370068897, 0.2143988717336941, 0.21068481547291296, 0.22321262320395785, 0.22095415183312328, 0.27748970678449825, 0.3042746742647865, 0.27796595226318566, 0.2920392243269333, 0.3131931694923398, 0.2616626252670452, 0.2711039095446467, 0.5718938441215297, 0.2688720543695071, 0.16689764355332115, 0.1422126371463841, 0.13417918797106632, 0.16198191977485166, 0.19701684203644665, 0.13958302491555663, 0.1671685863698381, 0.16374665432440338, 0.1524010117755903, 0.13472808931869407, 0.10637707571513544, 0.1780635214552565, 0.1431709777233673, 0.18960584513959833, 0.148565346084639, 0.15510897664118806, 0.16691982518156978, 0.13319829135281835, 0.007827103391737311, 0.04788722003781132, 0.025094636503549594, 0.017481318430441206, 0.03101189026715767, 0.012357010264462787, 0.017531588690829047, 0.011506366722230599, 0.04228691524064232, 0.08565123034634436, 0.12016924122499495, 0.1108803685294264, 0.07283950968851005, 0.09812655445794605, 0.17722507761182138, 0.08039994613676171, 0.10560085920458329, 0.10192758258877255, 0.015485728826826195, 0.0013496638660762672, 0.03222438184611587, 0.03316594334439982, 0.012699113032116793, 0.010249987514113656, 0.013440333269240323, 0.015313110807550379, 0.009083660402869453, 0.1094207311399561, 0.10661495657834674, 0.09784067992412204, 0.10761475195329007, 0.10587703742493904, 0.11173600698269859, 0.10964152380803571, 0.1096266186527648, 0.10778750357664235, 0.3836318536104145, 0.38411568306931465, 0.4040130724531248, 0.4027804475280168, 0.3917226262480934, 0.3728282853645808, 0.4010361746194251, 0.3841197588629217, 0.3810102606882847, 0.1304440763238035, 0.11635115744266755, 0.10696272221802405, 0.125566645153794, 0.1103501841518566, 0.10945057994704765, 0.09604032353897474, 0.1074092591346727, 0.10116594383706745, 0.17238890753037028, 0.1759147904916355, 0.2030222512712433, 0.21404932278828015, 0.16113171957148464, 0.18118635526890636, 0.1992528407870473, 0.15720487182095189, 0.18610243382966773, 0.2459750053858385, 0.26803536038059206, 0.2395562614274932, 0.23481025498986574, 0.22603334939179243, 0.22902009631216347, 0.25420638781996363, 0.2604664928244579, 0.23629901288991417, 0.17955373558402987, 0.1703952512671456, 0.1811303012929275, 0.1753579969630482, 0.17808201712970773, 0.17164776719678154, 0.1948970641574359, 0.19885828107919046, 0.1993839256929678, 0.18575481799386995, 0.1904167620062578, 0.20141095554636756, 0.21561509241379473, 0.20303569432269497, 0.1909333291355476, 0.1929475921448066, 0.20596057206930674, 0.2106736773781016, 0.18064165763203888, 0.1922626860749027, 0.21538960036700283, 0.20971447502973528, 0.19437483538547762, 0.18555759413738115, 0.2075164029643749, 0.20981611847705128, 0.18856108007470063, 0.31263639439612534, 0.2046070085280537, 0.2568692110332298, 0.29065502749111316, 0.34056199145230226, 0.2962136458665914, 0.2414273701729639, 0.22329659085157327, 0.5368822340545871, 0.28146750869073534, 0.1942872827498794, 0.3557413288465262, 0.2369482962393642, 0.18668685921614392, 0.30562476126763294, 0.32154583168510464, 0.19953768925720528, 0.1993582819271975, 0.19265904316474336, 0.2114943030707851, 0.19586715488238526, 0.185458486329812, 0.20164041655719056, 0.2264293279941162, 0.2099116036968477, 0.19568024576246124, 0.19342604261690677, 0.08480052043841935, 0.07798982893449069, 0.0956984214745511, 0.08310879165150231, 0.08239774106205333, 0.08368694509535768, 0.09359774091433459, 0.07698845015381972, 0.07349273458102668]}, "mutation_prompt": null}
{"id": "91b6efd1-ec55-4979-ab5f-5bde5620de2b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.divergence_control = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def levy_flight(self, individual):\n        beta = 1.5\n        sigma_u = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return np.clip(individual + 0.01 * step * (individual - self.population[np.random.randint(self.population_size)]), self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.2 if fitness_std < 1e-5 else 0.7\n        self.divergence_control = 0.15 if fitness_std < 1e-5 else 0.25\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    if np.random.rand() < 0.5:\n                        local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    else:\n                        local_candidate = self.levy_flight(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridDE", "description": "HybridDE: Integrating Lvy Flights and Adaptive Differential Evolution for Robust Global Exploration and Exploitation.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {}, "mutation_prompt": null}
{"id": "b347e06c-06f7-455c-883e-754df61434e6", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted for improved exploration\n        self.mutation_factor = 0.6  # Slightly increased for stronger mutation\n        self.crossover_rate = 0.85  # Tuning for better balance of exploration and exploitation\n        self.local_search_rate = 0.4  # Increased probability for local search to exploit good solutions\n        self.divergence_control = 0.3  # Enhanced to maintain diversity\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.3)  # Extended range for noise scale\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # Increased lower bound for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Increased range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.2 if fitness_std < 1e-5 else 0.7  # Enhanced diversity control\n        self.divergence_control = 0.15 if fitness_std < 1e-5 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "EnhancedDE with Adaptive Differential Evolution and Intelligent Local Search for Robust Global Optimization.", "configspace": "", "generation": 33, "fitness": 0.3024546594008865, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.6900783641520536, 0.6746838170860272, 0.7016367530716303, 0.6715864532884626, 0.689648707563623, 0.6723443428208089, 0.6993018483180753, 0.6987396875735972, 0.6818919722354572, 0.46662428718462334, 0.4520014622285383, 0.45637838197176517, 0.42421953493985054, 0.45934454444007344, 0.43585937425583354, 0.45576947052880956, 0.4500468347788058, 0.4747138345809645, 0.11538989458086146, 0.11318865032722492, 0.11554643665137332, 0.11797298386360455, 0.12388151473265063, 0.10620119021593655, 0.11060610833221451, 0.11212932344660642, 0.12015665773516426, 0.10018222881887617, 0.09656164508358289, 0.10300133345703621, 0.10625954247793978, 0.10225553868173687, 0.09667431298499962, 0.09424813827062206, 0.1079655491554109, 0.09524504766262676, 0.8701877908169519, 0.9337327240954449, 0.9304288941776013, 0.9373812717126632, 0.8955742964656791, 0.8809184136850164, 0.9231173268676505, 0.8822814323857008, 0.9374618685504749, 0.35678861513661153, 0.332336225430909, 0.33188882006914877, 0.357384163251956, 0.3407253329255906, 0.3194562017214654, 0.34621607909114516, 0.3228810473518181, 0.32217009276343456, 0.6751166536872618, 0.6236373352213732, 0.5987848706088104, 0.6434923048603245, 0.5915407159386792, 0.6675530885223099, 0.6678431991489763, 0.5903510946527999, 0.6806610189231607, 0.1979164662459163, 0.19382256015314658, 0.18360433582380953, 0.18695486395099714, 0.17099457447595068, 0.16606091054877448, 0.181547552567081, 0.19884787338715593, 0.21749535735594083, 0.15921185980485264, 0.18637914785751075, 0.18293736212210543, 0.17149094971513057, 0.20689767673861958, 0.23997161572567205, 0.18795981700784714, 0.1747267071302886, 0.1648724074054838, 0.12957006819356542, 0.14174366811992167, 0.15618784280470577, 0.15670638998242647, 0.14079368689418092, 0.1379079358072418, 0.14617644241422023, 0.1878158342583961, 0.16400320784803757, 0.25269756419040157, 0.273777669756034, 0.2571054648076039, 0.26494714817868215, 0.22325170547064388, 0.2674815943239497, 0.2946241616865408, 0.3025991628339372, 0.29156952892962995, 0.048788519304717504, 0.06442323233130287, 0.05062335880975044, 0.07272724042225909, 0.06875805276809877, 0.049188503232539205, 0.06572589406861717, 0.0882266576437516, 0.061861706151736695, 0.16586896742166246, 0.17668200934908296, 0.19802346877229748, 0.19286469666232375, 0.20638297816001572, 0.20644147301143312, 0.1773997353702631, 0.1680032628134921, 0.17681065173354304, 0.563462498264026, 0.5388756731480402, 0.5172451645783195, 0.5360331913492706, 0.5461947370742948, 0.508353929243804, 0.5225063725889498, 0.5175863640059751, 0.5375525886911434, 0.10400381214118426, 0.10301884841942754, 0.11220801060530505, 0.10973525057606492, 0.09842026934141546, 0.11912133756831667, 0.10780976867518222, 0.09361697814598824, 0.1065873298616592, 0.15999895872932268, 0.18763182283344038, 0.22569767935731044, 0.179835223796862, 0.18474268689071283, 0.17037734069981525, 0.1612359482723834, 0.18310991966724643, 0.16923444609783822, 0.3080074649207757, 0.33530151315810097, 0.3024570536463902, 0.33263923520926797, 0.3221559113750153, 0.32702252347291905, 0.3547683733960525, 0.3241497174523139, 0.3378330576016305, 0.24090777827498555, 0.23410227891391566, 0.24753372522787886, 0.24343448421950098, 0.2316010549228098, 0.2377563391278278, 0.24946641119151913, 0.2720247407804024, 0.2423375862939754, 0.21642775976080753, 0.1866642402031593, 0.19185703320816172, 0.21592371316229764, 0.19691552059739692, 0.187637970870841, 0.22249372240570542, 0.19561676729873378, 0.19163347399613884, 0.1985744606249572, 0.19216600673032558, 0.19710996204776632, 0.19622079035967355, 0.21714154700690458, 0.20456996018303164, 0.19825252790607373, 0.19515737385563847, 0.18592441096779733, 0.33222505478988984, 0.5787054440867091, 0.44780605363449555, 0.35901571462632365, 0.560002732505127, 0.6749511651252253, 0.5015657768934269, 0.5199298994542805, 0.6216712072068076, 0.6606913462075544, 0.5167606530000448, 0.5248525151585874, 0.19651823591960682, 0.43123832677960294, 0.18956559181332855, 0.49466447771640043, 0.45444556347745946, 0.19398117303159745, 0.1771878462545139, 0.18763669628280577, 0.1797353139022465, 0.19461287044122189, 0.19005867991430003, 0.1839572011984445, 0.22008068569783767, 0.18510476346562632, 0.18631952614007286, 0.08186358159792873, 0.08842563366640876, 0.07370030506073677, 0.08197158965640261, 0.07092886948957056, 0.0821634832964252, 0.07912577584307257, 0.07641319990668494, 0.08264866825300399]}, "mutation_prompt": null}
{"id": "5cf6ef81-082a-4190-a24b-f0ac8c82173c", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.divergence_control = 0.2\n        self.adaptive_learning_rate = 0.1\n    \n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(len(self.population), 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.6\n        self.divergence_control = 0.1 if fitness_std < 1e-5 else 0.2\n        self.adaptive_learning_rate = 0.1 + 0.2 * (1 - fitness_std / (np.max(self.fitness) + 1e-9))\n\n    def reduce_population(self):\n        sorted_indices = np.argsort(self.fitness)\n        cutoff = int(0.8 * len(self.population))\n        self.population = self.population[sorted_indices[:cutoff]]\n        self.fitness = self.fitness[sorted_indices[:cutoff]]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            if len(self.population) > 20 and np.random.rand() < 0.1:\n                self.reduce_population()\n            for i in range(len(self.population)):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "EnhancedDE with Dynamic Population Size and Adaptive Learning Rate for Improved Convergence.", "configspace": "", "generation": 34, "fitness": 0.3554626691667194, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.8321018705908572, 0.8860187830969303, 0.8723716413722193, 0.839785372865038, 0.8693316153203495, 0.8904062629364959, 0.8709291225307075, 0.8681208239924628, 0.8781161400713184, 0.7164197271267545, 0.43666124698726294, 0.3853661071163551, 0.7150262038993621, 0.7693211815941714, 0.6585639913190131, 0.7570253208196631, 0.7634587557025176, 0.3060458512616139, 0.33677134739488257, 0.17537839280566025, 0.13348952291316674, 0.11222045523887703, 0.1559748435577163, 0.19080508518436623, 0.19664538920956298, 0.24777203637725964, 0.14411212347226043, 0.13723411306085986, 0.09018075312663565, 0.14131970374620306, 0.12221538047596803, 0.15638728963680937, 0.1405529589586174, 0.1512034556803341, 0.13247767152708223, 0.12548038603262845, 0.8922315003556327, 0.9056358005706985, 0.8911203663910898, 0.9063904373046401, 0.9241158614381714, 0.894818834703854, 0.8829284946055397, 0.9265529530285594, 0.9012365627859102, 0.3128877362306185, 0.3981742022011736, 0.3271084576802483, 0.37291072682303705, 0.3752804825615761, 0.34206627105961107, 0.31699215288245164, 0.3154900778368307, 0.32030823945402265, 0.8107622164402044, 0.2239320293323307, 0.8722442415027759, 0.8509900182076426, 0.5812209636156315, 0.8589434572100989, 0.8127122004503848, 0.8556293948520803, 0.5279142704305538, 0.16683460687101903, 0.24215017925733395, 0.15211250915595753, 0.15135306225593959, 0.17854911667304696, 0.164391829940306, 0.25623072952947124, 0.18036952163605546, 0.1502529551440115, 0.14661648241178482, 0.13080285083270138, 0.2642785409529633, 0.3016855685072828, 0.18028113750268226, 0.12910261687063507, 0.16539427933679107, 0.16627640270222688, 0.3294588277487548, 0.15501589948112993, 0.10885885346116297, 0.05535849059351783, 0.16431348171583882, 0.03706492442084186, 0.06693048211320018, 0.17274652954124026, 0.13388437314981494, 0.18101755719244006, 0.4835858154016348, 0.30747771130208934, 0.41904122040943426, 0.18649892983828353, 0.3041655759450409, 0.17541821909271804, 0.2765104371395084, 0.28540825683532156, 0.1672904897120545, 0.13459831357216012, 0.20957782354114252, 0.16370668259892396, 0.12167166801128748, 0.11332510123404504, 0.11206231438393532, 0.18581620518242392, 0.1939194173053742, 0.2709031414468561, 0.18248258311685916, 0.15353344927569212, 0.33058741883837317, 0.27110023243340875, 0.30364618222542605, 0.3623200169523456, 0.23433027221763336, 0.05742387565548268, 0.15452119474762527, 0.7265946499601277, 0.6853757686709967, 0.6624130225731744, 0.63212954704657, 0.5779944971263569, 0.5370693790759313, 0.602827503570077, 0.6616181083299781, 0.5572758532162276, 0.12011531818101706, 0.13847786909142867, 0.17233198589314924, 0.12753990207745114, 0.14201016805181876, 0.16867447229055066, 0.12219327562623561, 0.14127517351269436, 0.13801930620359326, 0.18958838969377434, 0.27351970917787627, 0.25793968339920426, 0.27426827247655916, 0.3016836455511418, 0.2535678642610504, 0.2738771782169501, 0.25585917281516235, 0.45289581476120333, 0.43848501248325733, 0.5492101047122652, 0.3832630190471681, 0.44510919944478866, 0.37694260125389734, 0.47632982174078176, 0.35763237051727637, 0.5335919682535573, 0.49660047759518944, 0.380573269908582, 0.2734781660822708, 0.34135106859663733, 0.44393783396250963, 0.3696277287561224, 0.40476949209653956, 0.276546585714214, 0.29150106962060673, 0.4143646827033445, 0.21236788776617677, 0.21341394690315507, 0.2273625334689534, 0.21446808388977046, 0.22036148060959226, 0.23387745025042972, 0.2262978635041103, 0.21740729980773787, 0.200163554916287, 0.21244265860319278, 0.30864794511740623, 0.23630701541381116, 0.3443318894454501, 0.24120800358100203, 0.20732138415741486, 0.23725459225800571, 0.21987794922326132, 0.23659175268904897, 0.7549822967828234, 0.7830419206384056, 0.7757196697298276, 0.8384652522708866, 0.1969880356142777, 0.8669725620609182, 0.8087318466611486, 0.17079740216764816, 0.20845438983499942, 0.792453071363225, 0.20695883453473785, 0.14876296545183598, 0.16797911213116, 0.1664107434312938, 0.866898189409682, 0.12369956094157153, 0.8284847508923798, 0.20724469130730916, 0.19354725950973128, 0.18456688593631987, 0.1863908556610463, 0.18143218967380048, 0.1809996579296037, 0.17490393698821483, 0.17134180884298023, 0.19018692916425828, 0.18731434743694886, 0.08974857751533238, 0.08815352340920601, 0.09118251410751121, 0.09313298824602456, 0.09029657422935577, 0.09884906147260919, 0.08489488987094596, 0.08808062426782504, 0.08357209121085252]}, "mutation_prompt": null}
{"id": "a5e5db51-5e9b-4477-9250-0b346985d837", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = np.clip(20 + dim, 50, 100)  # Dynamically adjusts population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.divergence_control = 0.2\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n    \n    def adaptive_local_search(self, individual):\n        local_rate = np.random.uniform(0.1, 0.4)  # Adaptive local search rate\n        noise_scale = np.random.uniform(0.05, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        if np.random.rand() < local_rate:\n            return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n        return individual\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.divergence_control = 0.1 if fitness_std < 1e-5 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                local_candidate = self.adaptive_local_search(self.population[i])\n                local_fitness = func(local_candidate)\n                self.num_evaluations += 1\n                if local_fitness < self.fitness[i]:\n                    self.population[i] = local_candidate\n                    self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDE", "description": "AdaptiveDE with Dynamic Population Sizing and Enhanced Local Search for Improved Convergence.", "configspace": "", "generation": 35, "fitness": 0.22350253611545604, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.5268184362270296, 0.4815893122949042, 0.5413074628639993, 0.5235498005974855, 0.5319581428192166, 0.5671427970693479, 0.5359409201253111, 0.5196801031879215, 0.5230704620048473, 0.2520592308194731, 0.23920284026751393, 0.23833193180421208, 0.23972599007425865, 0.21689761870161983, 0.23986876098838517, 0.25919763989524947, 0.21971809732773284, 0.2560049507653088, 0.09897828718888702, 0.09096382054412477, 0.09638090620492823, 0.09919523949982467, 0.10179649450781891, 0.0958956545931976, 0.1077447932653568, 0.10085405503491096, 0.09969913250582707, 0.08045376699329865, 0.08237865486632034, 0.09097012002342908, 0.09187327412069168, 0.07430382338700259, 0.0762334293252761, 0.08939013728231182, 0.08629002417761311, 0.07796006744379735, 0.8423427353504915, 0.8379913429379391, 0.9479234478614504, 0.8453263346662976, 0.8838214656371246, 0.9076542659318413, 0.8003591695005118, 0.8277534765544118, 0.8488320304669967, 0.2398196602300382, 0.21574275720759561, 0.21342961795847815, 0.21946808135276596, 0.1825879342251464, 0.2508292249653238, 0.23338039230143126, 0.21843821446767264, 0.21243428023215283, 0.3144551033413523, 0.27229984727088485, 0.5361742475387976, 0.44147857359428266, 0.2729332469554663, 0.519244344013961, 0.4094363734292963, 0.30267496038610675, 0.44965883581317145, 0.14201652635139306, 0.1045963349100959, 0.13840573284925706, 0.1304895095499634, 0.15605612413919534, 0.15670140764925, 0.13104796186482048, 0.18019727726499746, 0.12904305468796995, 0.18043871038113868, 0.1326078284886011, 0.13792429449864918, 0.14250388707903006, 0.18777469812183067, 0.15033020789950058, 0.14187274636026936, 0.11187254697793847, 0.14145726214583831, 0.07114053496565631, 0.03814792517357002, 0.07623679019920238, 0.08097622870092569, 0.05769354466429033, 0.05272851573591064, 0.0712813362008956, 0.056391049402490845, 0.08053262904833514, 0.20675815958963206, 0.1679077033519103, 0.1726322371524548, 0.22497377547922648, 0.16093325869174313, 0.209761314518768, 0.19433704617830927, 0.16788320297977366, 0.18857526963169757, 0.00702134428281187, 0.00030210451107726133, 0.0006069472712142421, 0.0347350516961229, 0.0001136676450053109, 0.008560243545422286, 0.026896931276955027, 9.999999999998899e-05, 0.008890142422831149, 0.1062233352760199, 0.09455294694396088, 0.10816572607980923, 0.09580016988425544, 0.12643115476572753, 0.125806371418139, 0.11213667671194694, 0.10556343765281906, 0.12462577881612358, 0.43263765176062585, 0.40186849165602856, 0.427005481996783, 0.4068695990090273, 0.4140827096979659, 0.4403912244721647, 0.42072144741887396, 0.4052904660669835, 0.4382431929657653, 0.08800088040351917, 0.10269586811529885, 0.10227663458269731, 0.08074343389032457, 0.0753455944298419, 0.08739649594811616, 0.07454917317465026, 0.08079368277810739, 0.0862566937751057, 0.14270656485149957, 0.15657123683119678, 0.1459803989151549, 0.17781510462087768, 0.1655517490729388, 0.14601897695086485, 0.2101699226864795, 0.14702983786990953, 0.19882388695098785, 0.2529528117759857, 0.24844174656357632, 0.2609676682511206, 0.2458510697746562, 0.22840042374063774, 0.2608408003759676, 0.275457033387018, 0.26588894579550737, 0.2489439217895546, 0.18368018907169648, 0.18583387654535122, 0.1842340394204549, 0.19551800709952982, 0.1637025779685125, 0.20796927618544359, 0.2013418311205838, 0.18471593543077314, 0.21044643564897436, 0.1967793978291419, 0.17332681986128484, 0.17247977111247725, 0.1854555758200498, 0.16999346812710303, 0.18047503953615962, 0.22124395601208013, 0.17670477244170957, 0.18120664291850663, 0.16687089049332504, 0.17059647352865304, 0.19070965876384394, 0.16879796180063955, 0.177664730221179, 0.17820312207542754, 0.16932858216219615, 0.17576114670071352, 0.18035357662058382, 0.19745903758419858, 0.3971589521583495, 0.17171160918065165, 0.334431089768785, 0.2587139896952715, 0.3174503219803435, 0.16582582132613932, 0.1883751443232594, 0.25798205924647577, 0.3931796172557913, 0.29008919486140317, 0.26166434826283036, 0.2708607459376231, 0.3481288848196957, 0.23691352592841897, 0.18631997985004534, 0.4668573585228204, 0.19304979130413036, 0.1918063274967008, 0.17702579676232766, 0.20410248200181236, 0.17949323807080741, 0.18139883345573804, 0.17916362436539335, 0.18073519476905153, 0.17887212399856123, 0.18682603724800528, 0.07273938067042818, 0.06470550902321826, 0.07776011258146209, 0.07049405551399957, 0.06744249346713915, 0.0696397559857671, 0.07195215474582894, 0.06549641563078401, 0.06307341020884727]}, "mutation_prompt": null}
{"id": "b12fc40f-0362-4265-adaf-1d0115893452", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.divergence_control = 0.2\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < np.random.uniform(0.8, 1.0)  # Adaptive crossover rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        scale_factor = np.random.uniform(0.4, 0.9)  # Dynamic mutation factor\n        mutant_vector = rand1 + self.diversity_factor * scale_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_adaptive_mutation(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 1.0 if fitness_std < 1e-5 else 0.6\n        self.divergence_control = 0.1 if fitness_std < 1e-5 else 0.2\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.stochastic_adaptive_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDE", "description": "EnhancedDE with Dynamic Scaled Mutation and Randomized Adaptive Crossover for Improved Convergence Performance.", "configspace": "", "generation": 36, "fitness": 0.3639682160480177, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.8106492581986375, 0.8213266022359854, 0.7992915011753216, 0.7869649130539083, 0.7905434640432774, 0.8031078607240052, 0.7999430196327165, 0.792892546558502, 0.7845434451247664, 0.659993506183659, 0.6581283630250963, 0.6223707313928564, 0.6477905471714502, 0.6320214842990626, 0.6613561075977863, 0.6254462245039014, 0.6220191780220997, 0.6411539762908917, 0.1278649604649238, 0.20722179298405052, 0.14011555219668193, 0.12137918255103686, 0.11909151774315396, 0.14499865602442263, 0.13635141925469796, 0.12299343093209847, 0.13209777990042437, 0.10891073518128414, 0.11204892870179284, 0.10869977045624035, 0.10735034158006962, 0.10783757629030055, 0.12013824411333296, 0.11926608926667304, 0.11358963391870058, 0.1003056835316033, 0.8729127821596852, 0.8614740988044249, 0.8376446386534337, 0.8747908164019774, 0.9120860502911096, 0.8844528720833293, 0.874069211273181, 0.9170787576963404, 0.9065916954190492, 0.5041598540993518, 0.44404734455604655, 0.4306556565713169, 0.4368725853170662, 0.4306243284854554, 0.4089291727254297, 0.35401915916085, 0.3542145276846905, 0.39234492527985676, 0.8011852547132805, 0.8059347107814739, 0.7834252663935779, 0.8022262209068511, 0.8183041143543311, 0.8154193402608434, 0.2077994542772924, 0.7595742984601412, 0.8201026094224001, 0.1966373406620885, 0.1689295280284563, 0.180551712885879, 0.20523792669626784, 0.15505146184701024, 0.20584855399720614, 0.12859132958586683, 0.19255371023795576, 0.19098586997213274, 0.18489047223256105, 0.20359650697335163, 0.18231382236187388, 0.46446143556905095, 0.16020961763624486, 0.20811851121410163, 0.16048341946541855, 0.20778696256221107, 0.18557481982742197, 0.4339207810545681, 0.5058661354997074, 0.3558403232495573, 0.46148966313231465, 0.2610733941588306, 0.41083156729887715, 0.44225884869825993, 0.46413226292585097, 0.21478520365289744, 0.210901245905595, 0.3399197492179752, 0.5281459689439896, 0.2475169236414314, 0.5129691625475683, 0.5709699168260232, 0.5691915702100838, 0.31078491770715877, 0.2877812070853243, 0.14644619476622833, 0.12813051449351898, 0.0651843959672388, 0.11586182777905685, 0.22618108654749947, 0.11997042252250234, 0.17889681731992368, 0.13815455373389263, 0.137684992676953, 0.2974268935167007, 0.32534251526675595, 0.3367609076745143, 0.33589189880784265, 0.3610057068980467, 0.33761831603233505, 0.34136638746168235, 0.24943874972218905, 0.34338869999468147, 0.6824981194786344, 0.6868834576914505, 0.7047145504510167, 0.695676510873234, 0.6265811032187878, 0.7124434834300897, 0.7127128216919982, 0.7048047760179957, 0.7074450740853299, 0.12672956049578532, 0.11445259610580338, 0.12250977688712206, 0.1040864528822758, 0.09575740594974635, 0.1147378888297439, 0.11003186956653277, 0.11828650487970915, 0.1067393598547649, 0.18733559720180282, 0.18950548991356087, 0.19897198244213676, 0.18414424758623027, 0.18034604519097264, 0.18618939014510538, 0.18980378148751098, 0.19899533019448723, 0.20359156669013057, 0.4020338857438258, 0.4197020914924444, 0.4231519365914308, 0.42080666799502875, 0.44785471564800206, 0.4002748923984971, 0.4531556057562931, 0.47359725094001637, 0.4705455137000488, 0.34311334947617844, 0.3299019883252591, 0.37100664955679596, 0.35169550516415016, 0.3175002091000171, 0.36313972620938184, 0.37623180435420844, 0.39264643679681266, 0.3778935020085811, 0.2072761348366483, 0.19457157328467278, 0.2009521328276095, 0.23237403054578476, 0.20045105411815156, 0.2008361980565686, 0.2066183927770091, 0.20055466656335774, 0.19003656083588916, 0.1909422061630045, 0.21732216398034399, 0.21953638725350189, 0.21370225155262956, 0.21930574372178702, 0.36966392065410136, 0.22272904577276598, 0.26243254110046155, 0.2878627951812224, 0.17989181617611993, 0.20058796985009297, 0.16278479328300166, 0.8204685823287903, 0.19264650705252395, 0.7843374298773252, 0.1970987664440933, 0.1921985464318111, 0.7388107075971091, 0.28536786072831455, 0.5866913195807275, 0.8307522680134684, 0.19712083260679458, 0.7219450171719356, 0.5130262493238893, 0.1501893933334011, 0.38903707193931614, 0.4667634240246076, 0.1898106548179288, 0.17799513903410702, 0.18134195631731287, 0.18876338622092292, 0.19245786201511528, 0.19527812362445585, 0.1805622159142154, 0.1838738553920337, 0.18505722662325474, 0.08720544450539769, 0.0834362095117056, 0.08186127089636552, 0.08323019876880389, 0.08009706021894492, 0.10923198196524497, 0.07910740338899924, 0.08385020045095681, 0.09116515196742547]}, "mutation_prompt": null}
{"id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "solution": "import numpy as np\n\nclass DynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "DynamicAdaptiveDE", "description": "Dynamic Adaptive Differential Evolution with Self-Induced Diversity and Local Intensification for Robust Exploration and Exploitation.", "configspace": "", "generation": 37, "fitness": 0.3736141044868283, "feedback": "The algorithm DynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "5f1d3aaa-c0bf-4f82-9960-72550d83e2b8", "metadata": {"aucs": [0.8322792255731695, 0.807373644229336, 0.8142638109983146, 0.8141853926869407, 0.8018757272821795, 0.8094233720103126, 0.8136593512749375, 0.8158095844112536, 0.7765082311282008, 0.6772822756117703, 0.6311101342850605, 0.6532202961655532, 0.6636560751634878, 0.6838854915281826, 0.6575601415003904, 0.6629101344208894, 0.6568799545069555, 0.6416450014500912, 0.13743346099352183, 0.13929138046074518, 0.17531496433592308, 0.12387691307335247, 0.12131780119590163, 0.1393095197932902, 0.14060135267716034, 0.11151102114888667, 0.13580444561578697, 0.174238700193299, 0.10667015329217189, 0.12343501635525278, 0.11721590022552464, 0.11774992996365541, 0.11057434172598879, 0.14901677569541405, 0.12658872167307822, 0.11280189459650958, 0.8770171991872541, 0.8777883965807134, 0.9444964276987671, 0.8728934203669549, 0.880933768221687, 0.9073340240276482, 0.9287707708429463, 0.8939697391975404, 0.8705571427334193, 0.48729827462781816, 0.398008493212217, 0.36946294375357336, 0.4469860728920477, 0.4147735205837303, 0.40562633896965294, 0.3886997645381379, 0.4357716377613563, 0.4337799281749424, 0.8311219544939907, 0.7847084104781656, 0.7367009390560431, 0.2676555020562047, 0.8049163995258568, 0.2683099890613587, 0.7098601288068874, 0.7988007738375151, 0.723095318153588, 0.15352486168022772, 0.151881298691544, 0.14902257451932932, 0.15205454116373363, 0.4414789013118853, 0.20991643964663476, 0.20398732269294706, 0.21275327831455648, 0.18815599952556117, 0.4584625300777496, 0.14867153566238722, 0.15545395520013805, 0.37346215765119806, 0.1772928535417515, 0.17813297032031328, 0.21428490621212404, 0.25138369564681107, 0.17963206293889922, 0.35191409418237707, 0.24730340134312323, 0.3105706718659237, 0.19576688729609237, 0.3787955394703576, 0.34833153006335416, 0.28444334839897967, 0.39062720661593975, 0.34805540395715584, 0.49841953092590463, 0.5147562110720838, 0.4901156882643808, 0.40545015312626065, 0.21636299027297878, 0.4820942298165637, 0.5581458917765068, 0.5157635360223267, 0.545102737716267, 0.08791372331566094, 0.09481673856414363, 0.15409257328333792, 0.14223526068922798, 0.19218689565669678, 0.10989868472095676, 0.1409756411137818, 0.15131410577885474, 0.16272714596146032, 0.29088454614836423, 0.3131508061473375, 0.29028605379898276, 0.32121815449740354, 0.34593093561146593, 0.3340036012054174, 0.2880278353438116, 0.28644565807545697, 0.22894496362889072, 0.6896152878832708, 0.7186949071748159, 0.7076484294847244, 0.7094119136524952, 0.7280207162998837, 0.6718356209010596, 0.6785043847281838, 0.6134213442782501, 0.6905861761520755, 0.14276634467945482, 0.11322922058926199, 0.11863888881414475, 0.12375874765885597, 0.1098151194247563, 0.12216488894322153, 0.12292804667163504, 0.1088790211773899, 0.10728038175250221, 0.1922988057287185, 0.17212205489958965, 0.1745050972164749, 0.19276991577051372, 0.16969680548583987, 0.17165507069972008, 0.18386782413097358, 0.18617768789096945, 0.18383455625862122, 0.4592080293973393, 0.4546857475160586, 0.4210624508990273, 0.4320598155464248, 0.45301365124604553, 0.42893721005794827, 0.48468162036666995, 0.4792227735906587, 0.4819464506690312, 0.32854107460430726, 0.31858527745534093, 0.31539259340433967, 0.3569683244520325, 0.3488808847863226, 0.3088375807371967, 0.34338387257283154, 0.39009801687230306, 0.3378117372015189, 0.1943038764760383, 0.20586056785411488, 0.22114026321579416, 0.21402274701927793, 0.22918669450601326, 0.22099356761029298, 0.19390679163070368, 0.2141950505521324, 0.24292933613307133, 0.29094258658079597, 0.32167741217952384, 0.4271826479755436, 0.2708567119156702, 0.2913149914823533, 0.20613276627259147, 0.20676983011109973, 0.19350030721882416, 0.20733129167501263, 0.7689212441352444, 0.7131472049377303, 0.195612790237088, 0.7726951731799938, 0.7274055858540034, 0.6040625882659489, 0.7739241207082843, 0.7186009457605933, 0.6417301409906269, 0.676924647574173, 0.206615307068849, 0.557164412109346, 0.2031854288182533, 0.6247990032605443, 0.1926989960224953, 0.20618653365316097, 0.7010836734222057, 0.20677135782784628, 0.20448887497203927, 0.17760858409834945, 0.17988164916761507, 0.17947280463898718, 0.18908405544139872, 0.18828818028792815, 0.2200454186936589, 0.17017863504027142, 0.1833014187220855, 0.08021466855097492, 0.08472949301493904, 0.08589920321443534, 0.07939699855349969, 0.10121318930020184, 0.07957898800628138, 0.08064239059971146, 0.09011880950130557, 0.08304056678507332]}, "mutation_prompt": null}
{"id": "85a8786c-6179-485c-be4b-e310c68565ba", "solution": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.local_search_rate = 0.2\n        self.adaptive_rate = 0.35\n        self.quantum_probability = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def quantum_superposition(self, individual):\n        if np.random.rand() < self.quantum_probability:\n            quantum_shift = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + quantum_shift, self.lower_bound, self.upper_bound)\n        return individual\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.7)\n        self.crossover_rate = np.random.uniform(0.75, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.75 if fitness_std < 1e-4 else 0.6\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring = self.quantum_superposition(offspring)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution integrates quantum superposition and adaptation mechanisms for enhanced exploration and exploitation in black box optimization.", "configspace": "", "generation": 38, "fitness": 0.34866100021881075, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8185100959478537, 0.801139840595944, 0.8276000034253505, 0.8028526520919406, 0.8203228950958111, 0.8199960552991998, 0.802426617151728, 0.8190755277535645, 0.807612588340207, 0.6235350970933429, 0.665124059036333, 0.6458397252566047, 0.6570978017049464, 0.6825342275501596, 0.6792378267166589, 0.6394423309806738, 0.6869651103266688, 0.6472523287924761, 0.142524166360541, 0.1516110732362631, 0.1344740270022694, 0.1217976309650054, 0.2917755401136578, 0.134358553786733, 0.13682034191919779, 0.2016150299558438, 0.14015764046378043, 0.13751956849606228, 0.12472388316920702, 0.16246175090108372, 0.12091065474469798, 0.1347752831367448, 0.12555230226816982, 0.12772638394723712, 0.1906394180671589, 0.11682496766690453, 0.9389265932324834, 0.8854616959049507, 0.9424834259214538, 0.8717033160157728, 0.8867952335693737, 0.9662097917028597, 0.9347031804696146, 0.9356203525937786, 0.9137635659650352, 0.40803947851601474, 0.345520678905766, 0.4743841580544258, 0.2610205354558106, 0.3189646266651446, 0.35915065241520094, 0.29196060560478143, 0.2858564493253759, 0.29306560345729127, 0.7590030093161672, 0.8134188473103721, 0.7875972539035392, 0.8465316097158232, 0.3492070767963623, 0.8177058378071971, 0.8002241001989431, 0.23132458410595313, 0.8069246497304621, 0.471134213527831, 0.19740277301278586, 0.25906582552826807, 0.2648017544415878, 0.17488051360840073, 0.331250788261897, 0.17291111090856937, 0.1275286766485968, 0.15239025650332916, 0.16250180686206217, 0.19647251951683864, 0.22444323137926225, 0.14112661460305076, 0.17272396629827103, 0.19223385355347622, 0.18471992529650338, 0.1507332204458529, 0.16009723261040687, 0.24554293613541212, 0.19378007314811518, 0.15940289862571044, 0.12928316567091347, 0.1781117390401612, 0.15466161189695782, 0.3186219299065297, 0.12179281780288298, 0.26042789503236186, 0.18560092322630917, 0.11527128808298925, 0.2607245042845886, 0.10979813466590271, 0.291420286167144, 0.06544005402603126, 0.20102401298820338, 0.4869561452587302, 0.23245789346265455, 0.2135539652568904, 0.150696631264295, 0.11407544099910505, 0.08208594019602589, 0.09732925173813123, 0.09291756782542271, 0.09339764074229984, 0.26896193262022716, 0.08127278925756198, 0.25650817096935075, 0.29412682760204656, 0.1911075092373079, 0.1713726591846696, 0.40935669638657624, 0.11118202726163329, 0.1507166407830215, 0.25974799144644745, 0.13611798452161017, 0.4791935795917879, 0.7707966792585935, 0.6848490038296782, 0.6487158700986371, 0.7578531198614953, 0.6074918273162331, 0.739486450175971, 0.7408125390855378, 0.5308347412854877, 0.13396213820174852, 0.13942281552111213, 0.12462048611141419, 0.11800921728695124, 0.126561123267818, 0.16498588742305997, 0.11352165375263124, 0.13403696254419173, 0.11149393196876844, 0.18730735702755497, 0.17474424864052274, 0.19833049682332005, 0.16782356180981983, 0.31469404089662145, 0.16920057169070513, 0.16853237131075238, 0.3002984136894796, 0.20200506457796696, 0.4402621626431963, 0.4217458135834168, 0.4721806655283429, 0.4684635256191759, 0.4129741339089823, 0.4188779121304448, 0.4807571411682787, 0.5113406734597723, 0.48395719900774525, 0.347296375830875, 0.36214040829949123, 0.2934981573682405, 0.39234073357101806, 0.40967482879268147, 0.38153800667995996, 0.3628764299866386, 0.4315912748952596, 0.22733178075363258, 0.21260727222719644, 0.21027451663244734, 0.216418503076361, 0.19827854689553548, 0.20312422195449198, 0.2066883817858427, 0.2291643232572973, 0.1869434892909385, 0.19578157489666703, 0.39682906527542994, 0.22915944067480276, 0.5434990854775559, 0.2739924812814165, 0.30555508827046063, 0.2255873154849255, 0.1935756776205002, 0.2809578256636521, 0.26837516832734887, 0.18866656468335574, 0.8782684763650974, 0.19201686261983797, 0.7794636577224733, 0.19481890443929606, 0.19410952479945087, 0.7901197590088251, 0.1745421489305109, 0.7295877116218807, 0.7193406949321177, 0.20832421593220074, 0.7702874829164248, 0.1675089861811082, 0.6815799048564802, 0.1642845751406783, 0.2046750297387836, 0.2729494930579063, 0.5513763820794273, 0.19291055404584134, 0.1883791394594433, 0.17570474388800816, 0.18291331818448076, 0.18478701553244348, 0.19740309776415732, 0.18474389046707507, 0.18210682729679362, 0.19289081974282107, 0.07970809970016413, 0.09316301417192485, 0.08524910413723441, 0.09082078876093469, 0.09421248604152332, 0.07813852856561299, 0.08492851611263996, 0.0901899448843877, 0.0756982573727002]}, "mutation_prompt": null}
{"id": "936a79b2-51d5-455b-957f-e5f0d8f646f2", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(mask):\n            mask[np.random.randint(self.dim)] = True\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def guided_local_search(self, individual, func):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        candidate_fitness = func(candidate)\n        self.num_evaluations += 1\n        return (candidate, candidate_fitness) if candidate_fitness < func(individual) else (individual, func(individual))\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.75, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.6\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate, local_fitness = self.guided_local_search(self.population[i], func)\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Guided Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 39, "fitness": 0.3152056240608108, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7381023621758922, 0.7049108968651806, 0.6789017599695502, 0.7120867208429404, 0.7009386296149964, 0.7173528759475072, 0.730364780487756, 0.6916305124355755, 0.6949905283755902, 0.5097356736553279, 0.5391722219078424, 0.47079159709615337, 0.49897355160688983, 0.45190645004834573, 0.4683624146790366, 0.45913871181065746, 0.5179593777641044, 0.4771040439735348, 0.11005151399614643, 0.12249371457180547, 0.12708227683480222, 0.1146756586758565, 0.1077257460956158, 0.10500780959558709, 0.12467877853809384, 0.10866538431078188, 0.10894109609628888, 0.10513346744316221, 0.10904949784837192, 0.10104774579086062, 0.11078188887632678, 0.11011986781508964, 0.10429877020974221, 0.09574222804616839, 0.11175142343804345, 0.10331748114399819, 0.8672209188082515, 0.7869762423481844, 0.8568536561581017, 0.8870377822451802, 0.8224756718382628, 0.8281997883222939, 0.8305347368748653, 0.8316618420494822, 0.8205958969988272, 0.3656706206589203, 0.2534501481167697, 0.31442652259407555, 0.268253671570011, 0.3025414553542751, 0.432386598801876, 0.2896137719947085, 0.2556345449776911, 0.36946705753727616, 0.7160031516008278, 0.674248613633645, 0.6129343132391702, 0.7547210821576336, 0.6781752693771822, 0.6754069033553821, 0.7206965225827521, 0.6851886972697071, 0.6220700214551852, 0.21835113719788468, 0.17831890853058774, 0.16780205342284715, 0.16699235369388676, 0.17706732628140598, 0.25386866712167344, 0.22040307390545566, 0.18102299811186973, 0.19404630594756433, 0.18751751744806155, 0.23050596388304845, 0.16079927212262468, 0.16871855933464397, 0.36870558093807626, 0.2486476919813546, 0.20377074060196165, 0.17368142377123275, 0.14736397223078257, 0.1627521345708256, 0.18804090985357502, 0.18443305959218814, 0.25429580210910463, 0.24376579754921035, 0.2471527976718706, 0.2637524144565362, 0.23389842457627197, 0.23044511771376652, 0.3660774852866412, 0.35999956193886196, 0.31567751006762623, 0.36030176657821056, 0.29027038704686314, 0.3214091375780216, 0.33514327799601895, 0.3899517274715837, 0.408271612680041, 0.16688292059254783, 0.06670110344864111, 0.05061726134284106, 0.09330747448847598, 0.06806688108722536, 0.0819246920259451, 0.14361550713678484, 0.12816469736942038, 0.08756656890994763, 0.24238351251705792, 0.21128442273635073, 0.19268972761652325, 0.17269032391061923, 0.26087699374152284, 0.2256063456187929, 0.23712112422410792, 0.19894657626911594, 0.21470506733155204, 0.5829971119664803, 0.5913503951032103, 0.5545393344207314, 0.5546086710933866, 0.5277402902521744, 0.521330327134815, 0.5524097226064657, 0.5930857513966891, 0.5738236613779046, 0.11830957227768191, 0.10666937539145671, 0.09667147016900635, 0.12320531957580183, 0.10045663570472474, 0.09811432585899982, 0.10640867819073374, 0.10351864771230579, 0.10105347326747838, 0.16288742987099336, 0.1768696941472908, 0.18023301011584192, 0.17292113354016914, 0.15759232153204217, 0.16209920681450263, 0.18520364433868342, 0.1905434035918807, 0.1871090168331524, 0.3523444779199326, 0.3464561975805084, 0.37317327686904356, 0.3583028262174075, 0.3433834460353349, 0.3414078595404364, 0.40252789524936083, 0.378962346789131, 0.366949488495551, 0.2819922316800181, 0.2723169343529779, 0.2685262672465897, 0.26217365846866025, 0.29480415713285557, 0.282510194363644, 0.2624212755461002, 0.29496762242418273, 0.2815587218141061, 0.21421759020667863, 0.1985118840623954, 0.17535830745022973, 0.19793259026414556, 0.19429040817405074, 0.18949932315670426, 0.18807863224771948, 0.21262005364593284, 0.19533117439875292, 0.18934239983257095, 0.25358416178055954, 0.19999015913638418, 0.18774924029653972, 0.20608973077919923, 0.18857568659121848, 0.2731636397703323, 0.19036548612988768, 0.2169335491890999, 0.19084573934925642, 0.4756867824751244, 0.6278595445078741, 0.6131738889457119, 0.19017690585328617, 0.7099702211207006, 0.6479630904870313, 0.48926698895482645, 0.16763207136748737, 0.7195054666821292, 0.19927101510908518, 0.6388511734873543, 0.6542224513948036, 0.5397793747608315, 0.35979813190678667, 0.1952375957651017, 0.20143301131218994, 0.20777967472275172, 0.17880717954505398, 0.18875440014033207, 0.18093592821666782, 0.18461750980392178, 0.18817137150497287, 0.1720962461183142, 0.18969253527731966, 0.1780322803820109, 0.17820263827329996, 0.07505895708928578, 0.0763403565632883, 0.07280586994780369, 0.07246385151256163, 0.08102204602540475, 0.0744548238228192, 0.07596807467115196, 0.07960060937535274, 0.07896583940659296]}, "mutation_prompt": null}
{"id": "dfa6e60b-b647-4057-af19-fbc1ad8a224e", "solution": "import numpy as np\n\nclass EnhancedStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.2)  # Altered noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.7)  # Altered mutation range\n        self.crossover_rate = np.random.uniform(0.8, 1.0)  # Altered crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.65  # Adjusted threshold\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.35  # Adjusted threshold\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedStochasticDE", "description": "Enhanced Differential Evolution with Stochastic Adaptation and Population Learning.", "configspace": "", "generation": 40, "fitness": 0.3612311871379949, "feedback": "The algorithm EnhancedStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8232620935912828, 0.8168120210186761, 0.8063425442137943, 0.8111982374718439, 0.8142753171756649, 0.8157091246397951, 0.8130550298611846, 0.8136502378793276, 0.8055692041152056, 0.7015837594162697, 0.6579468900643002, 0.6995636019258404, 0.6727897741857928, 0.6668073861715018, 0.6145462681125005, 0.31734470318077435, 0.6614815187109877, 0.6508233366217886, 0.12435615772120978, 0.2404431006811013, 0.10488968554599165, 0.1251428611090869, 0.10586715065093522, 0.11845282239945276, 0.11591022506611681, 0.11168603681537914, 0.12759707086936178, 0.13445603138308815, 0.11769525182911544, 0.11461116216976319, 0.10388584813267976, 0.11534257534697645, 0.10368089055180008, 0.1258451757489467, 0.12547917886773352, 0.1072943665420053, 0.7617609161352817, 0.8935667683527168, 0.9505766338465964, 0.8575577899051776, 0.8363669915858332, 0.8900306056538791, 0.8671386848615938, 0.8654309213823375, 0.8753963599445509, 0.41490645787166114, 0.38506125860210993, 0.45010209340258367, 0.3781225195862121, 0.32337882540752283, 0.406124087013906, 0.37886576911777714, 0.3928886143349395, 0.3147028056534378, 0.8430586255821735, 0.7729138196240627, 0.7919428418427477, 0.8453066622568164, 0.8022130957648949, 0.20559891160013133, 0.819570128290024, 0.8610044582077987, 0.596770790412867, 0.15758605469160214, 0.17082397448441933, 0.15781511650116464, 0.22984063393381637, 0.5306006719627183, 0.480780616815203, 0.17237224526406159, 0.15205168993344176, 0.13994561271767159, 0.1213445026615303, 0.14295654638475896, 0.3383542823057769, 0.17761457325553287, 0.13187761525877517, 0.1778408791279673, 0.16333227611443868, 0.155775852990496, 0.16153273851079608, 0.2402077944492721, 0.4142335125415183, 0.39673544544192096, 0.17770363516157994, 0.24587999835100183, 0.06595500257551135, 0.057259613556963074, 0.38551164931979454, 0.4752270189898614, 0.25281553151958747, 0.20550652623823806, 0.3229082178234558, 0.15544126348232623, 0.32115833356850243, 0.18021393189729296, 0.5956738542532358, 0.35863745601244246, 0.6118622143214387, 0.15536156538667234, 0.2047897255139407, 0.09636086866933635, 0.22253299706938312, 0.1329430637968455, 0.2695979984291931, 0.21526417402042575, 0.2534287344567372, 0.17625913344642463, 0.15931659688811428, 0.261903594785859, 0.3768512593255059, 0.21463758423533463, 0.3007495862741689, 0.29209947730538144, 0.32822957600771174, 0.36052852316566886, 0.30540475525233046, 0.7682149691569381, 0.7119209957637861, 0.7205799041819205, 0.7290105456257072, 0.7018883089825961, 0.7191603212443136, 0.7380993519963885, 0.7573220165375861, 0.6479674166338572, 0.12010428484777891, 0.13177584061987602, 0.10457565989789708, 0.10730968302110355, 0.0931421554578401, 0.14741889820638732, 0.11548893843587904, 0.11180424736108452, 0.10003194269116533, 0.1997528801183941, 0.1779765967845891, 0.17397377126019142, 0.16470681059802905, 0.1687574709981149, 0.1564756285647616, 0.31865322290715625, 0.1492728245595858, 0.17668251000188306, 0.4584602806634902, 0.46654420864931767, 0.4482252216881145, 0.47652581550903106, 0.46466156810110115, 0.43955344454341927, 0.4786358084082877, 0.4570416458190252, 0.4636445942066243, 0.37819251311487856, 0.40467334685804623, 0.3647806151511682, 0.4197336717185409, 0.38110540431179596, 0.3431799750707746, 0.39449550160843583, 0.41915889823955055, 0.3690442711587556, 0.1985045491833205, 0.20535201967033834, 0.17982393620659154, 0.19634963897401614, 0.20906784063516204, 0.1950064798015313, 0.21495336769762652, 0.214824628865954, 0.2140653579677343, 0.1994053475465496, 0.3437738006411297, 0.21998343417230548, 0.33114931805322456, 0.21525409874003543, 0.1981924356311947, 0.5160731513609167, 0.21914294495804365, 0.2043676679720643, 0.821662467702474, 0.2036244448341472, 0.720865116145675, 0.808718001169682, 0.19251102662566077, 0.1944310852660608, 0.1401688635602546, 0.7145903204840277, 0.16871293988969205, 0.7881734979538434, 0.20577914357816784, 0.7924342078925497, 0.20660218748997727, 0.6744840874366039, 0.747204728886537, 0.20779738541460424, 0.2038926264806108, 0.20890176730758714, 0.1826573148751517, 0.1811709306047573, 0.17877861438275144, 0.18824858082027007, 0.17721178920695746, 0.18567468949513133, 0.17481527411082154, 0.18097181233741366, 0.1848446637434591, 0.07952111849615162, 0.0826423664270407, 0.08396786927441646, 0.0816311236286823, 0.08350331636716035, 0.08018971913549044, 0.09328059272987432, 0.09128422304554318, 0.08258435318069746]}, "mutation_prompt": null}
{"id": "03b4c83f-6dcb-4762-962a-d457462dd224", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 50\n        self.population_size = self.initial_pop_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def random_restart(self):\n        new_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            new_fitness = func(new_population[i])\n            self.num_evaluations += 1\n            if new_fitness < self.fitness[i]:\n                self.population[i] = new_population[i]\n                self.fitness[i] = new_fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:  # Random restart strategy\n                self.random_restart()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with Adaptive Population Size and Random Restart Strategy for Improved Exploration and Exploitation.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {}, "mutation_prompt": null}
{"id": "68737d8e-0743-4413-a8b8-23c787c97ab8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.65\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.35\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.75 if fitness_std < 1e-3 else 0.65\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with Adaptive Noise and Dynamic Parameter Adjustment Balances Exploration and Exploitation.", "configspace": "", "generation": 42, "fitness": 0.345970910522923, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7849456283852898, 0.8119751507762002, 0.7732437599097244, 0.8023639067758015, 0.7836801694018516, 0.7708717281157837, 0.7777453259522136, 0.7664385314316833, 0.7700550262110468, 0.6454854952614676, 0.6225390335882912, 0.6108598636775284, 0.6432176308334792, 0.613732838928291, 0.6020664074102816, 0.6088966739882535, 0.6444694736436731, 0.6103597478676648, 0.12821916422885293, 0.12844034361791656, 0.11622252384448983, 0.1374419563141146, 0.12738921194547315, 0.12998417844451937, 0.15502205152271142, 0.12610786882595726, 0.11285382012285294, 0.10816416015341457, 0.12304124680748807, 0.11137007853728631, 0.12083746390949668, 0.11176378842610679, 0.10813321959551392, 0.12101656768809776, 0.11930237752881878, 0.11567898031583845, 0.909745456191712, 0.9130494719498233, 0.9163714246044812, 0.8795897247299702, 0.9223126882029119, 0.912826875490868, 0.9116525459292323, 0.9090486873936553, 0.9130789099664706, 0.4051874880055676, 0.4539381613950849, 0.41170054371835463, 0.3739670900363026, 0.4126128658564294, 0.37217545162504306, 0.4171330250743447, 0.3736950283275883, 0.39399842913559324, 0.7258532469361878, 0.7052366850469907, 0.6583865509501122, 0.6896512541253721, 0.7266662816787, 0.6831117336046786, 0.6817274712360898, 0.7408031607412198, 0.7257712093437347, 0.1670641091736197, 0.36381831292994393, 0.16776252664738256, 0.14735484942243982, 0.18106100764868072, 0.17420763667224548, 0.153340115389896, 0.2093521118088012, 0.32870661499936915, 0.21478235195445683, 0.14856212909946243, 0.1741745772316028, 0.1466618693570566, 0.19597802660495323, 0.16448697952381297, 0.16194685549086119, 0.1991186324713735, 0.14388556436191358, 0.21020145593122097, 0.12897640166774127, 0.25000190440698433, 0.20480639234908438, 0.31915285955199424, 0.19021833609181904, 0.18425542049884702, 0.2265508350051807, 0.2329927883553894, 0.3174646661322349, 0.43162592684635204, 0.3628802418421092, 0.31708477713759775, 0.34495916684310857, 0.34861643393410713, 0.3598477932676203, 0.316896840926429, 0.36973050054360945, 0.04898258779116005, 0.1272055652586761, 0.13632638142170672, 0.14985831097146618, 0.08692681612524189, 0.13493357824043484, 0.11520221031265443, 0.12116584254041296, 0.11259712966207114, 0.22224326893667123, 0.23610313085725243, 0.2361742487881615, 0.23607394269065873, 0.2446831374453462, 0.2588419299574526, 0.19356511737460347, 0.24919706408313824, 0.22931452515125583, 0.6075680691481798, 0.6118466016853362, 0.6107011085216099, 0.6117453217171269, 0.6073160175684996, 0.6057303783602928, 0.6541967932597608, 0.5874766270549912, 0.6186671275387023, 0.10330304757771536, 0.09499765255225012, 0.09985648401698222, 0.09809481978918688, 0.10234605412069997, 0.09252886509034874, 0.11058233161283226, 0.10858811705194493, 0.10739350451929441, 0.17608181327111672, 0.15706080322935723, 0.1564286800099064, 0.18119448431553586, 0.2101339526029502, 0.25063499078701923, 0.19217366590461948, 0.1905005132201122, 0.16888904415147532, 0.37334797028590716, 0.37027598328080524, 0.3944299751148769, 0.36380888643645326, 0.3957928829277919, 0.3756801044779685, 0.4034688872142106, 0.41263814254754194, 0.37088266379494406, 0.2766370140735108, 0.3046570116815127, 0.2807755116794691, 0.28784154336236567, 0.25602449424327123, 0.2792639932198029, 0.2939046309661788, 0.32459458161325694, 0.3136831336510174, 0.197552102239829, 0.24631363824967678, 0.22422911770278842, 0.18699343357890452, 0.20590113699393298, 0.20290120433361447, 0.2105639810978801, 0.19518187681948007, 0.21610152991240206, 0.20267741228945746, 0.30368477374894143, 0.18248165515707138, 0.21417400255228802, 0.3434561314059327, 0.20118022571048855, 0.26424168413251714, 0.27530113433671954, 0.2220521623526931, 0.4356859841567572, 0.5607576837861485, 0.5886536199176085, 0.7705158553686071, 0.677754986559911, 0.45054267711945517, 0.5768954347978473, 0.49288117872810433, 0.7346516180477898, 0.6800844767243945, 0.28160321933056554, 0.6362430720761678, 0.567763208398494, 0.3934571594951837, 0.5083177395159849, 0.4755235935961132, 0.15122046161384806, 0.3227707733211874, 0.19686035788034317, 0.199741203904377, 0.17280713583065077, 0.18136495535190267, 0.2124502502098088, 0.18296867991600518, 0.17323058810048186, 0.21561171975170335, 0.17973344790777368, 0.07993307859359033, 0.08598033455484966, 0.09128931172298871, 0.07963541375004757, 0.08331616769809846, 0.07848957849427951, 0.08316065675603712, 0.07957640992706272, 0.07836450317218513]}, "mutation_prompt": null}
{"id": "da4afc7f-ed79-4a77-9532-795ef844a73f", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.mutation_type = 'rand/1'\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        if self.mutation_type == 'rand/1':\n            mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        else:\n            mutant_vector = rand1 + np.random.uniform(0.4, 0.9) * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.01, 0.10)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.2, 0.7)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.6\n        self.adaptive_rate = 0.4 if fitness_std < 1e-3 else 0.3\n        self.mutation_type = 'rand/2' if fitness_std < 1e-3 else 'rand/1'\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive DE with Adaptive Mutation Strategies and Improved Diversity Control for Optimized Search Performance.", "configspace": "", "generation": 43, "fitness": 0.3368338313918092, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7946971429519178, 0.7811251906758638, 0.7655468925748525, 0.7701852591062812, 0.790484445317352, 0.7778322721209878, 0.7774657691443951, 0.785445205080253, 0.7818663604330581, 0.6594240809903894, 0.6723895638926987, 0.6315271408631724, 0.6433283713387009, 0.6712475029333764, 0.6141570115915476, 0.6444324059093223, 0.6319086499486632, 0.6260497157161491, 0.3254089616310126, 0.15722881258130472, 0.2586609786038081, 0.31608650893906476, 0.2836589039653262, 0.17026410628441246, 0.22511384022274727, 0.42491316019955194, 0.41137398970670624, 0.1611893201066783, 0.13866641114134348, 0.14284622387374368, 0.1365957671681295, 0.1494603716630869, 0.15047668603723052, 0.16488633838744604, 0.1452960069439423, 0.17300617331392498, 0.8697415279017306, 0.8633430106092521, 0.8563854642856518, 0.8211223977797935, 0.8421264493213797, 0.8780290464259161, 0.8979234794435131, 0.8514598084343039, 0.8906375451726706, 0.4263985332718253, 0.3099211821937533, 0.35115212268046736, 0.3810969873222969, 0.1757397874475819, 0.41928083905187374, 0.291230791912248, 0.22960938047055146, 0.38963513483788403, 0.2160355222612459, 0.7834892987997529, 0.7282073893268941, 0.8189257348500195, 0.8590312314172384, 0.7188371961982618, 0.722510179386471, 0.7201334183057231, 0.7444838390650099, 0.293292347165492, 0.15362749544257348, 0.15030507563056095, 0.238429493774324, 0.1643057713682472, 0.27362799270085303, 0.12303726947358262, 0.14514008460615002, 0.19379065661885952, 0.1618753635161786, 0.18321021664666248, 0.16186159928163857, 0.24015596110681814, 0.15395412696129973, 0.22339934671200068, 0.18784938404519036, 0.13008980792866898, 0.14482732335750648, 9.999999999998899e-05, 9.999999999998899e-05, 0.09958889407164684, 0.10884391663050486, 0.03188692216053679, 0.0015486607368642158, 0.08669775932763113, 0.0997799966412023, 0.35580464694588354, 0.36340770709585457, 0.10167823178957647, 0.2927007248667658, 0.21889883086144057, 0.09364909972581681, 0.0626551211686478, 0.31514046553620356, 0.196175595655545, 0.3218788410113331, 0.10011974846326066, 0.05779354858154784, 0.1298735367724021, 0.07307641993527125, 0.11139644252805758, 0.0813355160957201, 0.17265664007419312, 0.13555885912367271, 0.12662073671413965, 0.20715092439978589, 0.14918374272127422, 0.18083124549358986, 0.16835759173308218, 0.1676549448283693, 0.18003216983754922, 0.24231503368419616, 0.13313933592168326, 0.1785469921193943, 0.5927349239857302, 0.6201203600165348, 0.5945129760801691, 0.5956290705808802, 0.6109550621944109, 0.6145691935626997, 0.6064006137414493, 0.6138674382872736, 0.6191995412466147, 0.11298175569492741, 0.15066928067182472, 0.16381045708611985, 0.1242230331020503, 0.10743369275352121, 0.13766659833354367, 0.13205197052471318, 0.1083659203886076, 0.13093670921119704, 0.19357792389521078, 0.20690214666164497, 0.2029353652240916, 0.18570111972813053, 0.17185803397567956, 0.21105757859263574, 0.15839267681798608, 0.2126763786556518, 0.2084027442985915, 0.44057480596868626, 0.3873888586028663, 0.45657687666006264, 0.43795777933510693, 0.46020986713082046, 0.45107671017762974, 0.41603648132818616, 0.4558049722401156, 0.46492777720238443, 0.2718175852053787, 0.34846138179486597, 0.3362983687611424, 0.35564223061636235, 0.2078853534198336, 0.3122552481853732, 0.34685164743977037, 0.40501846586401824, 0.31447580747092985, 0.19048719235086065, 0.20596024708223448, 0.22723272793567717, 0.21463776965327197, 0.191382585138404, 0.22401986287996956, 0.2146948147523493, 0.20721310967535045, 0.23012902468653262, 0.3586676363532081, 0.23741883475053183, 0.23790117896573282, 0.441777631272281, 0.599480494355455, 0.21501620017804257, 0.4622125467168917, 0.36912829220205223, 0.5036334678123744, 0.7827077081679079, 0.1377620107843055, 0.1753175128684532, 0.8060405407725999, 0.7602281580063097, 0.19028452406785124, 0.7797652427981451, 0.1663640116937477, 0.6850620130607071, 0.7131325950279679, 0.20855561425828906, 0.20471657945460664, 0.16844031327225362, 0.2052496228930697, 0.24706232441836296, 0.1620050030462793, 0.16664235688428453, 0.5802550014823156, 0.2113456338328037, 0.18324836307626946, 0.19325230360338752, 0.23767983815043414, 0.18545745802869928, 0.187004801142441, 0.20793861633308708, 0.1857725102240947, 0.18575169627850852, 0.08653015747595416, 0.08805531603813377, 0.08726667393534515, 0.08545153322679377, 0.08577166913580692, 0.08967697152996845, 0.08634367542546584, 0.08661710686494895, 0.07577472477356273]}, "mutation_prompt": null}
{"id": "6e86cac2-8994-497b-97b4-90f66eca0ab8", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def feedback_driven_adaptation(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9) if np.min(self.fitness) < 0.1 else np.random.uniform(0.3, 0.6)\n        self.crossover_rate = np.random.uniform(0.8, 1.0) if np.std(self.fitness) < 1e-3 else np.random.uniform(0.6, 0.9)\n        fitness_improvement = np.mean(self.fitness) / (np.min(self.fitness) + 1e-9)\n        self.diversity_factor = 0.8 if fitness_improvement < 1.05 else 0.7\n        self.adaptive_rate = 0.25 if fitness_improvement < 1.05 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.feedback_driven_adaptation()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution with Feedback-driven Self-Adaptation for Improved Convergence.", "configspace": "", "generation": 44, "fitness": 0.3299488800770814, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8272627653301321, 0.8105704117211108, 0.8314610055509326, 0.8084621695729893, 0.8124852713513588, 0.7898503991437793, 0.7629685870986643, 0.7729528235031727, 0.7682924327097104, 0.6195075664728559, 0.5788068626702759, 0.6056682564616604, 0.6250852765105492, 0.5827552444593956, 0.6037557298296969, 0.5773898805399847, 0.5798634303901558, 0.6013111987926785, 0.12327764019265164, 0.12264141608850221, 0.13585448109642861, 0.26893469747051135, 0.15042663703701165, 0.24862099837662233, 0.41105261888890454, 0.15566586290053452, 0.13581335596174904, 0.11497585514950648, 0.10511387424797503, 0.11279783437463042, 0.12073270379253243, 0.1357841271851703, 0.1206484239884903, 0.13862223116950967, 0.12886427870145123, 0.12023675411414603, 0.921880171890918, 0.8914871057422075, 0.8985538590046096, 0.8642577182140703, 0.8816811430457526, 0.927710265164668, 0.9021091607874934, 0.8959057905556748, 0.8944750040377536, 0.35246423918146796, 0.37283199444423987, 0.3486159208345341, 0.32350788491050075, 0.3685448326771106, 0.321839046136737, 0.3672077756019506, 0.3812341954366355, 0.36356567140411755, 0.7439008719444209, 0.763596915304225, 0.6495410393988783, 0.7722962533625043, 0.791266291324338, 0.6641305232448271, 0.621057649731384, 0.7449165718469171, 0.76473184935776, 0.34893160109960497, 0.16806382863531255, 0.19456599905545557, 0.1855669819426473, 0.18491776361108037, 0.18379967844614697, 0.28675365396241215, 0.21894863749209115, 0.23243853236628087, 0.20904532083832128, 0.18317821916383714, 0.15274552239773598, 0.16637745646031343, 0.2177908340690048, 0.24811187474465402, 0.15092408294443072, 0.17638968778645026, 0.1536053897698847, 0.16914546735242497, 0.19946747053507619, 0.11526119610697516, 0.08082879405020627, 0.09653621888796693, 0.041040976922319894, 0.13023132860185926, 0.15553760187982135, 0.11263945963731836, 0.2789520327797925, 0.27111006275294003, 0.2383613595393721, 0.21135728017670952, 0.2699160347166186, 0.23954614276986663, 0.37169230626694094, 0.39543307958045004, 0.35505468716205046, 0.05740102385188983, 0.05681479896052044, 0.032147918189934344, 0.11236847258257143, 0.0800722039272449, 0.08332923756796606, 0.10144935742846306, 0.08742753769808242, 0.15331277314770464, 0.20733825262258054, 0.2529234273522436, 0.20732315421122627, 0.20812828079627466, 0.21274814498466998, 0.18737032156232958, 0.16733718657167918, 0.17820367955598382, 0.17424249520525392, 0.6222298424504804, 0.6233748711517437, 0.6017151141837922, 0.579298964690756, 0.6352684837776787, 0.6026591723435993, 0.6935061471340596, 0.613788249474956, 0.6672700244161238, 0.1491078690317238, 0.11471709791242957, 0.1196422519057172, 0.10417921427774168, 0.10152712258908292, 0.12565945645995213, 0.1071061195531865, 0.09828561947457115, 0.10085127186110898, 0.18450286536507943, 0.2046385694635403, 0.18286210425424798, 0.168662408284024, 0.17585796398729603, 0.18504461037832542, 0.20912029482115546, 0.16955112692547558, 0.179521917209586, 0.32883547349730446, 0.3104868597856427, 0.3397073847325711, 0.4119251909592583, 0.4450017949696927, 0.42091307649680976, 0.45750188822145377, 0.443230698910973, 0.42332331522148625, 0.25294675513119613, 0.26847335215711776, 0.25442648250549116, 0.2949673196546846, 0.31641996494489566, 0.2803117379834211, 0.31706544592525576, 0.36127104280082334, 0.3115976395976734, 0.19745827161654572, 0.19947560734868364, 0.18371522872487955, 0.20403470159015547, 0.21565867553439488, 0.20646495511865504, 0.21226410927860206, 0.1936056600434245, 0.21086564393290275, 0.22319178133155348, 0.21433866296778192, 0.1962113669246417, 0.23428631897550245, 0.23752322579760976, 0.23427546488728845, 0.4618062946952812, 0.4011526305034352, 0.21344508576301746, 0.6973138685128812, 0.18123061615100655, 0.18598752355048043, 0.6984593659250187, 0.6442223531085548, 0.1900048302133076, 0.5612266976859387, 0.3647421307933819, 0.45516913594976305, 0.3993353480195465, 0.1978656586584654, 0.26854538882390144, 0.44211857498271034, 0.19506326731649082, 0.5160342486600824, 0.4902336995673383, 0.20338931378245928, 0.20669083469302818, 0.18941425960166947, 0.1742416017333528, 0.18436816962353741, 0.18582612505572538, 0.1951453708916806, 0.18163951839194148, 0.1835453904379497, 0.1890592849268602, 0.1799424111457727, 0.08227445568924707, 0.0893984277719867, 0.08328045362479064, 0.07897176663063787, 0.08438618465147596, 0.08478020031142275, 0.08668171865641183, 0.08463176199174272, 0.07958259905937048]}, "mutation_prompt": null}
{"id": "983443e6-e305-4b4c-b2e9-93f5a19ca38c", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6  # Adjusted for balanced exploration-exploitation\n        self.mutation_factor = 0.5  # Lowered for finer local search\n        self.crossover_rate = 0.85  # Slightly reduced to increase individual diversity\n        self.local_search_rate = 0.3  # Increased for more frequent local improvements\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)  # Slightly reduced to prevent overshooting\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.7)\n        self.crossover_rate = np.random.uniform(0.75, 0.95)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.75 if fitness_std < 1e-4 else 0.6\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35  # Increased adaptive rate flexibility\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution with Self-Organizing Mutation and Adaptive Local Intensification.", "configspace": "", "generation": 45, "fitness": 0.3488411107453374, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7804801816734572, 0.7871002275648988, 0.7634028575959569, 0.7504577444554715, 0.7779375646012828, 0.7673252182810646, 0.7824177006314903, 0.7762266109464321, 0.784554717477699, 0.6030021844543075, 0.5933404813800549, 0.5887563563555861, 0.5915925304172267, 0.5958969789618702, 0.6224135249585563, 0.6300298199720762, 0.6277058153820454, 0.5608613931382177, 0.11005017699305175, 0.12536234348483466, 0.13428386113537805, 0.11867432804091427, 0.12312181989003568, 0.12720206626152286, 0.1509426612410527, 0.12891825476123142, 0.13891413482688408, 0.11026862627221412, 0.1109990369918823, 0.11318689266101478, 0.11583945535510298, 0.11618955478821791, 0.12546129474086543, 0.12356804613400996, 0.12218856709536408, 0.12504312009340535, 0.7884997917858961, 0.8630294078438717, 0.886688470324672, 0.8883931779676273, 0.8564305270883469, 0.8666381304706416, 0.8641673976595109, 0.8899563880836151, 0.893693836197399, 0.37120880627807684, 0.31866894604713436, 0.38506031049635925, 0.38946582966291377, 0.3488198121082392, 0.4251482435675633, 0.34404754684064764, 0.2916074249489391, 0.3063114533267469, 0.7799659915428236, 0.7557050633763126, 0.7534591483153595, 0.7638515310550684, 0.7361464452306471, 0.782460385755948, 0.7731763076275682, 0.2376438903407161, 0.7484165888614196, 0.24808093274585064, 0.17253927076666276, 0.15906758340871296, 0.16678099255011092, 0.1362382498421839, 0.15846652938533823, 0.18244984556631727, 0.4230134120213789, 0.17019385345149562, 0.16569940334833022, 0.329046459494615, 0.22000359756870536, 0.13478525583959322, 0.45990974407722063, 0.1846437084555198, 0.14034916157504063, 0.1604826515063087, 0.1539485948059064, 0.11627149425146222, 0.19953600798302018, 0.11873354205840791, 0.28142042038079973, 0.3383623035565837, 0.30798743735814094, 0.12974572640446258, 0.23215024641735937, 0.10139043475545328, 0.41641204252974173, 0.42480825627681473, 0.4595093841135296, 0.12289378950809482, 0.4111951217251162, 0.38738358724575905, 0.41232596769511964, 0.3308107426034671, 0.37572563816419247, 0.1835501232197312, 0.10456072592192356, 0.1515142613153777, 0.0891037508345417, 0.189287113555746, 0.09702170032766733, 0.13332832175089915, 0.14581778687196312, 0.0979984043558052, 0.24771683364940367, 0.23056725919337817, 0.23533527984961156, 0.2415399706515291, 0.2649145603002381, 0.29244279809485063, 0.16321905771512957, 0.26862716847803736, 0.24039469706608052, 0.6405750676743044, 0.6428450712574072, 0.6410659470437372, 0.6374499653926374, 0.6448505973704597, 0.625913254518819, 0.6528606477050691, 0.6592912171945442, 0.6832209255294168, 0.1440082604072912, 0.10403855381932736, 0.11163815478943051, 0.1190895690395597, 0.10429410754302293, 0.11724624244311055, 0.11405663821015366, 0.1255202158753287, 0.11576447791526534, 0.16168596639325916, 0.16651033799120307, 0.1843230013670717, 0.17888245440920325, 0.15545883521525827, 0.18722262105872522, 0.20183414691730173, 0.1908945175212351, 0.18244190078132938, 0.40250638428613705, 0.41225040160412085, 0.421603623135026, 0.4040736900984879, 0.40771961802306955, 0.40052041305446395, 0.43992987065524014, 0.44370690239163524, 0.4210813238164144, 0.31085461457268315, 0.3213831070787566, 0.2956304443628255, 0.3158997873941718, 0.32060317452655185, 0.3090137097910476, 0.3405804183728045, 0.35455018490371226, 0.3270926154818863, 0.232699388190715, 0.2085216718942593, 0.190377818125805, 0.22659761753214402, 0.1963188829479079, 0.21432458021028855, 0.19990849070057437, 0.23744022352035365, 0.19990051604080883, 0.1932610985160984, 0.439202962851033, 0.22556127863569386, 0.18516975266308877, 0.23765706502670092, 0.3510942284018813, 0.19951223434431897, 0.20718965233787934, 0.2990935958929887, 0.6646360451505937, 0.70725392942578, 0.6774104975012418, 0.7949972256577824, 0.19632568369255488, 0.5521030831260167, 0.5903960609897096, 0.76004462351865, 0.6361027697938167, 0.2948943667176672, 0.6286697684780315, 0.20592882053218653, 0.31462859285858236, 0.4852384308618979, 0.6248150776283059, 0.5178246393466193, 0.2094603317778262, 0.37125273067706055, 0.18407399174271666, 0.18640077660262755, 0.18943207310718113, 0.17858900554220802, 0.18746102916982677, 0.20353053992241243, 0.20321965835758005, 0.19536002518838824, 0.18391539163639103, 0.10555938204946191, 0.08739979671490561, 0.0894899569462928, 0.07975537955425482, 0.0757097795515328, 0.08685275382228441, 0.1074681538180896, 0.08297692303360527, 0.0830103853262888]}, "mutation_prompt": null}
{"id": "5bbc240d-4257-43d8-a977-987ae4878652", "solution": "import numpy as np\n\nclass AdaptiveDEWithProbabilisticRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def probabilistic_refinement(self):\n        if np.random.rand() < 0.5:\n            self.local_search_rate += 0.05\n        if np.random.rand() < 0.5:\n            self.population_size = max(20, self.population_size - 1)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            self.probabilistic_refinement()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDEWithProbabilisticRefinement", "description": "Adaptive Differential Evolution with Probabilistic Strategy Refinement for Improved Convergence.", "configspace": "", "generation": 46, "fitness": 0.3467638475085869, "feedback": "The algorithm AdaptiveDEWithProbabilisticRefinement got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8078383982062209, 0.8033887553975767, 0.7968407833088693, 0.807910087659737, 0.8051284392440232, 0.8089205858703871, 0.8130348832715903, 0.7994188460881081, 0.7981609277237932, 0.6427774562267704, 0.6543273307042696, 0.6416462431753811, 0.6654252189112551, 0.6409505779867846, 0.24659578975660912, 0.6268975669299055, 0.6816215704812764, 0.6790542193722381, 0.13123386259388992, 0.1485290528510299, 0.14345886185004275, 0.13012647956865497, 0.13149201010321065, 0.1747292617863444, 0.15773460363083724, 0.12126959795806846, 0.11857038929340213, 0.1290861279348302, 0.14177513747343296, 0.2454730984712813, 0.1268489475895207, 0.12869630409691635, 0.13107746433531775, 0.13565273629188723, 0.12559350016343473, 0.1309661451328895, 0.917309495666322, 0.884813371575012, 0.8800057950051385, 0.9128583406688376, 0.8916291920943773, 0.9123582556029096, 0.8645519469547761, 0.8940767668727712, 0.9342878423915074, 0.3737204121287443, 0.3017842262041205, 0.33430516440614033, 0.3392687412168972, 0.3814585038393139, 0.3842546664805515, 0.3390503155291351, 0.4058697651595129, 0.353567934517625, 0.7565470567050037, 0.7843498895231066, 0.82272509155824, 0.742463967772625, 0.7647448180823422, 0.7905890255589176, 0.711360498566386, 0.6099929070486776, 0.8160908154804365, 0.1498533939013712, 0.15409999118604012, 0.15141439541542734, 0.2734791937293831, 0.16773602890860984, 0.15807670714859068, 0.1972160008953311, 0.18123286669921979, 0.21547292371418802, 0.49484594136521054, 0.5681154835951692, 0.18814353849360632, 0.17203101198128368, 0.18418166407169934, 0.16078217999013755, 0.18036175723495962, 0.24329220405329965, 0.14000918004686358, 0.013029176444289803, 0.24996209778242784, 0.08983335013006277, 0.15201618903986924, 0.1429689612938173, 0.09980605011872923, 0.051624026890910724, 0.13829546065661924, 0.19729910213448443, 0.3080315999623614, 0.24243649612972973, 0.3020501095550595, 0.3392397953244932, 0.22081247299113083, 0.2233807669328176, 0.3109017419391079, 0.30615783814392494, 0.252767739218398, 0.10588720510291605, 0.10212470696312614, 0.16102025687079657, 0.1253513667494437, 0.18746112174753793, 0.09984200382402164, 0.06018846865117211, 0.12442581776063821, 0.15470540127163313, 0.26881224662344316, 0.2636417996523913, 0.23270624293042697, 0.23411903677344825, 0.2678662456203502, 0.2603584598431531, 0.2902013413634654, 0.23277292471728217, 0.30169379897975046, 0.6325594850235243, 0.6379293901416366, 0.6548253222396152, 0.6122137108712695, 0.6274969859939208, 0.5506494128716144, 0.667524553526178, 0.5906831225843958, 0.5325978986627299, 0.1141386859192064, 0.13637277146477267, 0.12688889918175406, 0.11294360813160387, 0.25034078443093266, 0.1344040281612051, 0.11400413472708693, 0.12823773787302017, 0.14135037831508124, 0.20203994248213797, 0.2077054716882003, 0.21203338551510975, 0.1981317536093511, 0.182006370640301, 0.16983566378894754, 0.21274899480321663, 0.19221935949248892, 0.23747983676130902, 0.40049389949428105, 0.43174793885212026, 0.3921192987556912, 0.4905519761030126, 0.4634138710762119, 0.42209798563113554, 0.47988324886964795, 0.4671532156483881, 0.478299740393482, 0.4020219533305761, 0.32978555883508265, 0.2902434476880835, 0.3566286127409226, 0.3440667031757575, 0.38528594865719, 0.3477063353055796, 0.2774178755045462, 0.3276002231072668, 0.19563863550282967, 0.22416638370370934, 0.24118891266988673, 0.22856215223767873, 0.2215528437042117, 0.19719227115029903, 0.22629040293610725, 0.22997601290194902, 0.19902688060429163, 0.2411194373191976, 0.38305668589597863, 0.27901414057131646, 0.3791828043463411, 0.2189389967592289, 0.27685438148758645, 0.21063469081863584, 0.31603589992430325, 0.28642312409739057, 0.8071530495106275, 0.6941661653029603, 0.7834673349143324, 0.6644079454769629, 0.1911960041072589, 0.17200755152360858, 0.7064874998948085, 0.19080256362663695, 0.1962669233199693, 0.7453436191877147, 0.2070008854295442, 0.7611497534474428, 0.1670215623281951, 0.44012719700351244, 0.45615395471085407, 0.2103545754185948, 0.1959603354671402, 0.203814430954121, 0.20403117153738226, 0.1793117256893786, 0.17801764329819503, 0.17118595194643116, 0.18005782877529586, 0.19768085608827834, 0.19586542669461138, 0.1850905358789251, 0.20171172537553517, 0.08796650489796032, 0.08857728335943449, 0.07662564831414198, 0.07853842009383971, 0.08356612496800175, 0.0737038133024851, 0.07688539836516084, 0.08114240580163423, 0.07699511653042534]}, "mutation_prompt": null}
{"id": "aeaa2f45-ac3c-40f1-a8f6-052bc1425eed", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.75, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-5 else 0.8\n        self.adaptive_rate = 0.3 if fitness_std < 1e-5 else 0.4\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with Adaptive Mutation and Efficient Utilization of Function Evaluations for Improved Convergence.", "configspace": "", "generation": 47, "fitness": 0.3502002195677366, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7550712610261378, 0.7786265803082435, 0.749772260350174, 0.7632211115273916, 0.7762634050205305, 0.7700759287564773, 0.7727571791898532, 0.7902367804833302, 0.7638875103835787, 0.5445470127932506, 0.5974551522448448, 0.5633015214929021, 0.558444479353762, 0.5802174495927026, 0.5950592133689983, 0.5387020683923728, 0.5954483905820201, 0.5924789720902521, 0.11286956667588688, 0.12116323648616767, 0.10504025802078487, 0.1175944264665888, 0.11939157838695869, 0.11285490217621752, 0.10172947766943541, 0.1020801631486069, 0.11324232028679526, 0.1161287991499621, 0.10270463854907574, 0.1253509985493949, 0.10282416042903297, 0.1047347400601315, 0.10365832970221023, 0.11211406484682485, 0.11103454322670425, 0.10066311768848468, 0.8908543720584072, 0.9555552933800198, 0.9066113867187676, 0.8758028591846192, 0.8644618769718162, 0.9065587654968973, 0.8907753804077562, 0.9040381008624648, 0.94534518605962, 0.40887067242927755, 0.40825680176991774, 0.41130408920655415, 0.45602843266619597, 0.40368175498652903, 0.40320984318797914, 0.39822561134221834, 0.39975039197626117, 0.45266059231981104, 0.7122702942482221, 0.7284386250740364, 0.6930049491298634, 0.7190724848327357, 0.7650369815712166, 0.6992872708510294, 0.7192751900612943, 0.7321841312550622, 0.731540527524257, 0.2124536696208219, 0.2338456908862271, 0.20689436063703381, 0.25833335679099234, 0.19972553893092182, 0.23523757334899997, 0.23601340292827244, 0.3773780843665462, 0.2972589456102186, 0.18789977668317104, 0.3255676781358524, 0.17590296379721027, 0.16129885538382127, 0.1819880227291214, 0.1895632539010308, 0.3010725388210952, 0.19131537760338901, 0.21822979852427538, 0.2790400118933348, 0.2597996711560737, 0.24766056893786081, 0.29957955728777896, 0.3123809353544563, 0.28679899746656734, 0.24053507431812438, 0.28308845653865, 0.24562223078218182, 0.3801791541652446, 0.4396212963324738, 0.42250866072682525, 0.3784835155977133, 0.41941873197611135, 0.3762078200379818, 0.4160009554944297, 0.4593967193995372, 0.44909932468652014, 0.10941154705388867, 0.0756528157850127, 0.08767722308003101, 0.1656788619329307, 0.21258477550656718, 0.10286106692568997, 0.09407991581927544, 0.14273760917008438, 0.16589688798069802, 0.2415570105920769, 0.27924486252523095, 0.27266418937785, 0.2586226061066139, 0.26310989567670773, 0.27146240065122107, 0.25383641529785117, 0.2260744423720964, 0.24338660197056583, 0.6097954663671872, 0.6464301787178337, 0.6634052870159431, 0.6456876993422824, 0.6364244753982632, 0.6284646282862152, 0.6243976387325034, 0.6587024423521749, 0.6215889955410363, 0.09739205760501723, 0.10199062298804507, 0.09864876397349598, 0.1027345996867669, 0.1072873279446116, 0.10841191334759837, 0.12075364287402213, 0.09130356553715735, 0.09331939388557153, 0.1672167944842584, 0.18461636174286622, 0.20391858742856261, 0.16262391646627383, 0.1798511791910491, 0.17836110911075798, 0.17433054416645066, 0.18340584851794417, 0.16955807507505982, 0.34995181558277455, 0.34643557169251604, 0.3750440702337352, 0.36569785539771293, 0.3755980522643271, 0.3601283035367574, 0.40580009579977006, 0.3907390623953386, 0.37194124058771294, 0.28446834202858673, 0.2753221595982208, 0.29712096109429476, 0.24989665410420348, 0.28557670278007663, 0.29023936980799225, 0.293427155099629, 0.3172666914916741, 0.27543592725683996, 0.2120747781851703, 0.19907371914230354, 0.19642713568902193, 0.19678613069203799, 0.2269211485499959, 0.21098612673416195, 0.20398443994566728, 0.18274961631930997, 0.1786849669243893, 0.20889184437493824, 0.2153004429537254, 0.18865003045322914, 0.18936381475650277, 0.1960415450821411, 0.1851015620984121, 0.2068333828318809, 0.19266274003791573, 0.19756483530157543, 0.7006833706655352, 0.17933353022901177, 0.6297039070881862, 0.7033957476472437, 0.6114279264853049, 0.6777343755332137, 0.6656431907134859, 0.1891797585073719, 0.7351095255815789, 0.6063321601563617, 0.19947322693358915, 0.20374576983048198, 0.5928226831749241, 0.3607801584444347, 0.6634854670310468, 0.5766892344483314, 0.6369910405461338, 0.19647417664085742, 0.195578987072072, 0.18051099540691995, 0.17544221096543955, 0.1870888062353897, 0.2064238637207455, 0.18138330294753446, 0.1837554383764427, 0.20063122625913732, 0.20300527774441757, 0.07699507715507314, 0.07668567243959556, 0.09612565311953736, 0.07980002695108834, 0.07612007442326596, 0.08518915280616968, 0.0800463546538307, 0.08149268632627737, 0.0843708010434151]}, "mutation_prompt": null}
{"id": "dd2a0903-dab5-4bc4-955f-bf779caf50d1", "solution": "import numpy as np\n\nclass ImprovedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Increased diversity factor for enhanced exploration\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate for balancing exploration and exploitation\n        self.local_search_rate = 0.3  # Enhanced local search rate for adaptive intensification\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)  # Wider range for mutation factor\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.8\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            # Reduce population size progressively as evaluations near budget to focus on exploitation\n            if self.num_evaluations > self.budget * 0.75:\n                self.population_size = max(20, self.population_size - 5)\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ImprovedDynamicAdaptiveDE", "description": "Improved Dynamic Adaptive DE with Adaptive Population Size and Enhanced Diversity for Efficient Optimization.", "configspace": "", "generation": 48, "fitness": 0.3024576327605035, "feedback": "The algorithm ImprovedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.6908391851038036, 0.709295945096867, 0.6775654091403025, 0.7088712041372744, 0.7060749938519492, 0.7192885366236369, 0.698523044342917, 0.7033015122027219, 0.6871237775800891, 0.4868398287394349, 0.5148970989644854, 0.46267720192229145, 0.4503990491511206, 0.4812694361203551, 0.47437002892655633, 0.4735628413951424, 0.4781277443364591, 0.4946381884265083, 0.11981815641352733, 0.11596574063751741, 0.11228188948205975, 0.11995722799327979, 0.11646617870390019, 0.10762604017464406, 0.1339874971604097, 0.11987823633643457, 0.11393040218046058, 0.10821449899140168, 0.10437184023720625, 0.10242269061149234, 0.11364165789604597, 0.11033412480235183, 0.10877194866843276, 0.11234735430202325, 0.10533371016185977, 0.11431380897856747, 0.8771789123107239, 0.928693773464947, 0.8674657764712499, 0.9018907059453695, 0.9095270650363327, 0.9074091714701493, 0.9365429950183737, 0.9501599027107831, 0.9120329246804131, 0.31475767410734357, 0.3415998498623388, 0.3613162318641715, 0.30676013718027617, 0.3417057439488923, 0.33013463732601545, 0.3195467610469692, 0.39034814423831043, 0.3485516838816338, 0.5174356934460098, 0.6428716127077929, 0.567932118410897, 0.5535524038831197, 0.6577743953804013, 0.6838585816952958, 0.5731140880372264, 0.659588917167691, 0.6223431314436323, 0.1872412356057409, 0.17776258415242197, 0.19455547840811793, 0.22828953358049098, 0.19056595838781254, 0.19719773673867236, 0.15184760262492947, 0.23944858288789195, 0.17657176067227387, 0.1584304030487068, 0.18999281329390705, 0.1638652953301042, 0.18900744244625134, 0.16304395165616747, 0.21529263657239317, 0.167897376178487, 0.16356726113891562, 0.16803243607830842, 0.16911653705341245, 0.17432939373168843, 0.1507112169188275, 0.1705102313561334, 0.15583152105768716, 0.19472860784127988, 0.13889181484465685, 0.1627606588427799, 0.172571485460706, 0.27403377199628043, 0.3184146492895381, 0.27747243150598055, 0.26448977443820154, 0.2949228003312926, 0.32244118521082943, 0.2874280945566482, 0.31535344171886703, 0.30081739118470263, 0.0728931573093603, 0.06727750383963627, 0.04111931970747684, 0.06852514133259424, 0.046014502474322594, 0.07416804665517518, 0.09750220865028147, 0.09838297484246561, 0.06929801425116844, 0.1573016276487249, 0.18248762084697123, 0.185679438940339, 0.19447441593480586, 0.20642641546140184, 0.1878221501649041, 0.18343040257045162, 0.19196307133081092, 0.196201743753336, 0.5159319581861714, 0.5387476310231574, 0.55259228742682, 0.5335127496467902, 0.5251801165012409, 0.5693035555599812, 0.5471175190022268, 0.5332264201288823, 0.5390282634832739, 0.09860712393324778, 0.09796034620031935, 0.10488892480475531, 0.10272934542913859, 0.11027634570313771, 0.09389699374408988, 0.09508268000639197, 0.08901997687617436, 0.10501393259257152, 0.17291429022408844, 0.1786725323260283, 0.1824587112119328, 0.2159380459263066, 0.20776341185863978, 0.17044422074430388, 0.2095072283419317, 0.18596236345014394, 0.21020661819285702, 0.3316822332181779, 0.3293387832858, 0.3670241338013056, 0.3164606166256031, 0.31150326274144224, 0.355948728869528, 0.3313477184582846, 0.3381048964697687, 0.34833870427200386, 0.2563759618714645, 0.2412141959196097, 0.2609023685305757, 0.2509371458179147, 0.2542563341009022, 0.22020274952448748, 0.2611868976312407, 0.2630159078634653, 0.256079205939152, 0.20256476520326538, 0.18442567426323075, 0.19977096209384138, 0.19766597753757487, 0.18326993242992462, 0.20866471310131518, 0.1906627830187868, 0.1893683962447409, 0.21882548736704377, 0.21626571564111063, 0.19035981007259994, 0.18662649463672898, 0.21973557080674322, 0.21873106766466366, 0.20704707287930946, 0.1874154549723943, 0.18804177050925708, 0.18834134396838342, 0.33574851689925456, 0.19705910352303735, 0.17309285307857136, 0.5270553661119751, 0.5930619452201924, 0.4617655916379062, 0.4715476194032886, 0.3853867219426721, 0.5045614048352683, 0.6061808202503132, 0.5062133365179838, 0.19347266887883563, 0.4300181555161443, 0.4869285059498695, 0.585546126371435, 0.5221489598061351, 0.19985472819834948, 0.20198708841877833, 0.18655878846965346, 0.1869800010988414, 0.204933340890733, 0.18727233573150492, 0.17535812851899368, 0.20006222043701494, 0.18869290813042594, 0.1900647481323683, 0.18025974984281257, 0.07793793989026088, 0.07567888305596537, 0.08010144418350773, 0.08135609127908161, 0.07358551414491399, 0.0968667330687456, 0.07618237444928944, 0.07452251812003163, 0.08529510000313967]}, "mutation_prompt": null}
{"id": "4004f60b-e885-4da1-a66f-29116f1cb048", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.main_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.secondary_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func, population):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func, self.main_population)\n        self.evaluate_population(func, self.secondary_population)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.main_population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.main_population[idxs[0]], self.main_population[idxs[1]], self.secondary_population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.main_population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.main_population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.main_population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.main_population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.main_population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dual-Population Strategy for Improved Exploration and Exploitation.", "configspace": "", "generation": 49, "fitness": 0.1708780412890171, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.33730902175637856, 0.32403599203632216, 0.3268750477832123, 0.2977555527998197, 0.29075200942438284, 0.2693386367759397, 0.29903905000546005, 0.2877215717230154, 0.2557705060619079, 0.02530158391057935, 0.012348982316298884, 0.0009594372529442285, 0.00549044663797571, 0.005705442461624077, 9.999999999998899e-05, 9.999999999998899e-05, 0.002206641617204297, 9.999999999998899e-05, 0.08283034522757293, 0.09500900111297583, 0.1019044988629354, 0.10098755429009465, 0.07588785077166793, 0.06917735678211301, 0.08477314687228632, 0.07891475864218733, 0.07722212452895894, 0.07583976362585532, 0.0792042304872781, 0.07219572552477149, 0.07397867206122644, 0.07509684880334355, 0.07920387738286139, 0.0807133396327614, 0.07898855013753003, 0.07719505880935917, 0.9732729017933031, 0.9622105420477605, 0.962286008871204, 0.9577895349722962, 0.9660093434020426, 0.9818931795944771, 0.9502085313633709, 0.9636668122594549, 0.9059687677478391, 0.11689548206520017, 0.09443622402347174, 0.09534898790787794, 0.13963051720428554, 0.09660120629893676, 0.14721610726397227, 0.12388563494246574, 0.06896637051955001, 0.1380768943649433, 0.19846556922211123, 0.31385166132973863, 0.2067559373030704, 0.19253356933898147, 0.18897512536182948, 0.19007364579007635, 0.15909651362945498, 0.15305598568120238, 0.16015577615105392, 0.10976469910060693, 0.10901342864444774, 0.10990992093448826, 0.1001343744883445, 0.09600511751327445, 0.10891474066734042, 0.08495867795619505, 0.09980214135837029, 0.08968969917133818, 0.09948005475390787, 0.11507369054133121, 0.130356986858558, 0.10678078544736058, 0.1091976127008304, 0.0996561582693426, 0.09391176715743133, 0.1430326964689963, 0.1271105577881999, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011063255267984573, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05983112061740581, 0.07161881503695111, 0.07117053035074294, 0.05955078991381302, 0.056199391711121094, 0.017988071758300084, 0.07648091871260854, 0.08286477023614702, 0.04511472348284917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040049431688901294, 0.03535315652232163, 0.04408367560219628, 0.026687135780396387, 0.04550982098753287, 0.03125399059349476, 0.04275457377288916, 0.042932738779916324, 0.05244712750354319, 0.29414918473671947, 0.3110619058560392, 0.3303521328886522, 0.2945742490190425, 0.2841769992280232, 0.25384273315167394, 0.3095374283074468, 0.3087370587089914, 0.32804264438413666, 0.0682716143054084, 0.0919145075678518, 0.06630757577713775, 0.09414188710919702, 0.08106291680546807, 0.08176554956365711, 0.10218814490560468, 0.07178244644449983, 0.0790124028344883, 0.16318347630359242, 0.1659153190452224, 0.1785082293441972, 0.1790323948617244, 0.24185899530908728, 0.1836674053028512, 0.1804501125972483, 0.2161218174157311, 0.20390106019553422, 0.2184265378404716, 0.2198254936115711, 0.2011960784430582, 0.2241873158918003, 0.2397968963620658, 0.21248474482226687, 0.2135005066890806, 0.22791309744441623, 0.21397697315179698, 0.15757169879382904, 0.1767846986569912, 0.16309553832922863, 0.16432358730812635, 0.17755798482566554, 0.16881805824993512, 0.14805588966753946, 0.1715475516100844, 0.1427434465791324, 0.19767086879598006, 0.20341202837449668, 0.1827776292264961, 0.18931327762170114, 0.20950219068452525, 0.19462550576509974, 0.17589419944514117, 0.18738078217029486, 0.18718587111474239, 0.17672863472568878, 0.1746846261717827, 0.1859295683479647, 0.18830957722894603, 0.18473892195204844, 0.17180666070652717, 0.1732710528522593, 0.18585666780336474, 0.18798903993241778, 0.22033724504548813, 0.16998787695239248, 0.18903834118675644, 0.228623793094045, 0.306850959623714, 0.3864697932255533, 0.2909369243906529, 0.17592487874132623, 0.1852368626798948, 0.29211803626058663, 0.18933451248862398, 0.20634565031213192, 0.25621182133343035, 0.18059722494044528, 0.2331411968477789, 0.23982587424164648, 0.24405501656609896, 0.20279226314405963, 0.1819646301864487, 0.18767437278919963, 0.18405741117331698, 0.18207036529549891, 0.18084701606118758, 0.18524893201691062, 0.20248645655571185, 0.17537262787108865, 0.17215131065879363, 0.07370437067940916, 0.06897051906358609, 0.07956472132174863, 0.07214219882569706, 0.07838476388314519, 0.08097184909848931, 0.0685105787050736, 0.06361433045256504, 0.06779481755644523]}, "mutation_prompt": null}
{"id": "e57fd9b9-bd68-4e8f-9c49-e45ea733a416", "solution": "import numpy as np\n\nclass AdaptiveWeightedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def weighted_selection(self):\n        selection_prob = 1.0 / (self.fitness + 1e-6)\n        selection_prob /= np.sum(selection_prob)\n        return np.random.choice(self.population_size, 3, replace=False, p=selection_prob)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        weight = np.random.uniform(0.5, 1.0)\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3) * weight\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def enhanced_diversity(self, individual):\n        if np.random.rand() < 0.5:\n            noise_scale = np.random.uniform(0.1, 0.3)\n            noise = np.random.normal(0, noise_scale, self.dim)\n        else:\n            noise = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.75 if fitness_std < 1e-3 else 0.7\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.weighted_selection()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.enhanced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveWeightedDE", "description": "Adaptive Differential Evolution with Weight-Based Selection and Enhanced Diversity Mechanism for Improved Convergence and Robust Search.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {}, "mutation_prompt": null}
{"id": "2dacaf3b-3b62-4b0e-9d31-d0f791450252", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.65\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.35\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 4, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.adaptive_rate\n        offspring = np.where(mask, mutant, target)\n        return np.clip(offspring, self.lower_bound, self.upper_bound)\n\n    def mutation_de(self, rand1, rand2, rand3, rand4):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3) + \\\n                        self.diversity_factor * (rand4 - rand1)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.2, 0.9)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.7 if fitness_std < 1e-3 else 0.65\n        self.local_search_rate = 0.35 if fitness_std < 1e-3 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3, rand4 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]], self.population[idxs[3]]\n                mutant = self.mutation_de(rand1, rand2, rand3, rand4)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive DE with Adaptive Learning Rate and Improved Crossover Strategy for Optimal Exploration and Exploitation Balance.", "configspace": "", "generation": 51, "fitness": 0.2586390320490002, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8090031692907628, 0.7804543640628954, 0.7830048382484078, 0.7735294129466077, 0.7616151307338234, 0.7677221966528471, 0.7788613341376429, 0.7912909576580965, 0.7700543806279057, 0.5959341138825704, 0.6161715012662918, 0.5752649597343653, 0.6132593600870698, 0.6195135247275193, 0.599315911494767, 0.5901342983499687, 0.6178487294059272, 0.5756455255787978, 0.27395963914416344, 0.32772420098933264, 0.32793571420713885, 0.32342075310049745, 0.17506274603533944, 0.333291937254241, 0.2668469728456848, 0.30684671421934595, 0.21035489440018995, 0.1414441024404679, 0.13590562844034726, 0.15324386153154623, 0.12814904826494222, 0.1570820454608849, 0.1325128497093332, 0.13997291042935978, 0.1393060913177755, 0.15558348720324755, 0.7924671560345163, 0.7991284037858455, 0.7909839143774379, 0.7870352056090074, 0.8398424023558, 0.8169430284799551, 0.8295273155340008, 0.7758997517496917, 0.8114510109155195, 0.22960158715427648, 0.18408147254680818, 0.22084206986245347, 0.2656612518694508, 0.2463192107363773, 0.2430946922884205, 0.22243436891388624, 0.1868749661818183, 0.2140931090368564, 0.23527902503166853, 0.20472887832390962, 0.21345143130680821, 0.3200075931154217, 0.34284400327956777, 0.3679698080804248, 0.2571716535904651, 0.35885776365241506, 0.29199461407679606, 0.19440247733148452, 0.20486691750019836, 0.16569078049875519, 0.18046970272111063, 0.18937972888406396, 0.1974271629971528, 0.21228846834360315, 0.18289162310610185, 0.1862212255477943, 0.14622119355940288, 0.14541351280526105, 0.1283574861132002, 0.1523701374156059, 0.153473204168445, 0.14481841805692597, 0.13290062934399116, 0.16694233217430376, 0.1562849829097388, 9.999999999998899e-05, 9.999999999998899e-05, 0.009589015185638372, 9.999999999998899e-05, 0.010003422972479359, 9.999999999998899e-05, 9.999999999998899e-05, 0.012982488879995202, 0.0028992447313276326, 0.1486307899984779, 0.16275931229452167, 0.09921591632883597, 0.06277475915626496, 0.09158327946391531, 0.08275260010240215, 0.1424477920480418, 0.11091968256236528, 0.12368766991261126, 0.007373568402118669, 0.041776073371560085, 0.010067785319478051, 0.024403665416547704, 0.01759576647182881, 0.008661240067713849, 0.014621690491322448, 0.03977193682138602, 0.01593922876423126, 0.10166816120577238, 0.12332416268252033, 0.11071465561681448, 0.12763634325485274, 0.158904229330738, 0.10959076645908028, 0.1059654745107429, 0.11990065177319209, 0.08800387269289056, 0.5102783125609396, 0.48245814513466523, 0.4767193170609836, 0.46067247784900833, 0.4578277136386667, 0.452057502711646, 0.48371740703954225, 0.49088055616660087, 0.4690956489528416, 0.11831242813466647, 0.10642083232594979, 0.08839978046057417, 0.11315026495757863, 0.11253329990767358, 0.09851696345647509, 0.09922865543117931, 0.08473496596315022, 0.10696263505708248, 0.22882904015957917, 0.17097317719604121, 0.15602034502409168, 0.18291293124068442, 0.20950279181392362, 0.16268978738062911, 0.16478536332882743, 0.1797085067775459, 0.16188481277648203, 0.24154002789612128, 0.2370594812537815, 0.24992365243892267, 0.28079163394898987, 0.26551259233226254, 0.2823103076698985, 0.26909136844704284, 0.27877671897605183, 0.2651844998587082, 0.1758803560605091, 0.19389388585570033, 0.1861086237744327, 0.19194946013407943, 0.20811507274537766, 0.21099258500413853, 0.18934930770523983, 0.19260292832667103, 0.18031647014913488, 0.22306996688818148, 0.20915097441377428, 0.2094734429371048, 0.20930848931972246, 0.19882863531146389, 0.23647724764196154, 0.1957794460891863, 0.21984935947293371, 0.1993282305469578, 0.2102244115864491, 0.21020090787442092, 0.20487829274455094, 0.21347220505898679, 0.2266047992131367, 0.2021998160265953, 0.19676169471115745, 0.2236724672852567, 0.19783510274109273, 0.2607223564109026, 0.22114236778512364, 0.26336394451730816, 0.4616468142703877, 0.31047602521296835, 0.3304343891119865, 0.4314335799160405, 0.3751858508950925, 0.2683865584321271, 0.33075073550701306, 0.21895923221600655, 0.25899971475141936, 0.28725321969750406, 0.22734067264879054, 0.26974526146590316, 0.27693323584385743, 0.2552730696307409, 0.25138395340573383, 0.18544396159934773, 0.198136570347059, 0.1865074347677218, 0.22740254637005064, 0.18812068149130767, 0.18029723249401508, 0.18001896609851353, 0.1861414358595428, 0.17813618873800297, 0.07568707575803968, 0.09559140313721814, 0.0833010120778025, 0.08846282429471974, 0.07888864019684949, 0.07166072111784083, 0.07599027288370741, 0.07319554855896981, 0.07489107659089222]}, "mutation_prompt": null}
{"id": "9621117e-d4d5-4bcc-9024-cb7afae6b65b", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n        self.entropy_threshold = 0.5\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def entropy_declustering(self):\n        entropy = -np.sum(self.fitness * np.log(self.fitness + 1e-9))\n        if entropy < self.entropy_threshold:\n            self.population += np.random.uniform(-0.5, 0.5, self.population.shape)\n\n    def oscillatory_mutation(self, individual):\n        oscillation = np.sin(np.random.rand() * 2 * np.pi)\n        return np.clip(individual + oscillation * np.random.uniform(-0.5, 0.5, self.dim), self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.oscillatory_mutation(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.entropy_declustering()\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive DE with Entropy-Based Declustering and Oscillatory Mutations for Improved Exploration.", "configspace": "", "generation": 52, "fitness": 0.2210218104104437, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.23.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.32584700378503617, 0.2974648257966256, 0.3073559198973643, 0.3038748008186911, 0.2658221335617411, 0.2900096370951677, 0.8123455881816263, 0.8106641711712612, 0.7962269850246083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12196526547188313, 0.12360057117961265, 0.18522989178539906, 0.07529544836965818, 0.07374087666274409, 0.09582792777917293, 0.0759263959354699, 0.09931830983303969, 0.09137613898165053, 0.14063855847434947, 0.13282901862553376, 0.1284041275554153, 0.05748840928525556, 0.07170173938132374, 0.05827095731226184, 0.08549932562108786, 0.08450502610055699, 0.0667011737016856, 0.9357209630450725, 0.8929421086847116, 0.8982280181302699, 0.8813773101354173, 0.887582578118715, 0.91193079084072, 0.8910453356530054, 0.9194516155427919, 0.9161775201443874, 0.15418344680768636, 0.16174184051146023, 0.14526024231347, 0.13433165967594962, 0.1574629625501267, 0.15244276557665126, 0.40919735963452897, 0.3352233829761897, 0.3363653543339389, 0.18423751984486758, 0.22760073468423847, 0.20494084210963948, 0.2134342003551517, 0.19646334436788904, 0.21778030906996448, 0.16626898511363453, 0.1986871292915141, 0.21455524265500825, 0.10893925101864477, 0.11019818747343124, 0.06653006552161445, 0.43122030089157715, 0.1364422672712733, 0.20906745053002984, 0.07389933147072392, 0.09983271160656126, 0.09886239419211873, 0.08031729090970674, 0.09369737571170011, 0.10752539744582246, 0.1053730056982618, 0.08488764198826071, 0.08796485551710753, 0.05113352128273596, 0.08488058622830796, 0.07462336524944146, 9.999999999998899e-05, 0.0015651179616972266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.24799623385951142, 9.999999999998899e-05, 9.999999999998899e-05, 0.07385505609450971, 0.04942297450223487, 0.07652646395812246, 0.4224192903305045, 0.31922518891132956, 0.04156247376488298, 0.0868018922823166, 0.05441828948578309, 0.06137292311307596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015410232877957397, 0.034676785292369616, 0.019690608478005966, 0.025985870089318852, 0.33466515694102605, 0.22907505812331042, 0.27867572831800314, 0.3212533331277808, 0.25797881615334795, 0.7123347414242602, 0.7244671653153734, 0.6910975152708473, 0.7196907786254277, 0.7201419630503734, 0.6404549830897655, 0.2786442718807969, 0.28553714153583665, 0.27792322944725334, 0.0886038565377314, 0.08642743262104835, 0.07602423222844357, 0.09291921367433442, 0.06820633721466651, 0.08020093931227346, 0.10565586682642247, 0.11361951738914067, 0.12415573247612943, 0.13609035331563069, 0.13164778404552924, 0.14479614788414275, 0.16770807580121472, 0.1631359216828998, 0.1913250619456378, 0.16222518746196624, 0.15157079507932214, 0.12192386450329828, 0.42597022336065815, 0.42066961260619484, 0.4354009128473656, 0.24148243218612298, 0.23457382074203137, 0.23704539091217147, 0.20970808677412955, 0.21905596947089145, 0.2160133633806881, 0.36130883518558954, 0.29073872193415773, 0.3482966761783429, 0.14521422485793023, 0.1634799228796997, 0.14946089307877064, 0.13848956910010368, 0.15273719367286465, 0.1522440085252723, 0.2121526717015938, 0.25522216840473044, 0.20964888327880038, 0.20725678487784893, 0.18100089878138337, 0.2122075160545427, 0.18619867868008788, 0.18469479182634319, 0.18064206622153955, 0.20891268304553867, 0.2115529600441809, 0.30693736713102726, 0.16849013486696962, 0.17231928606179558, 0.16809064473446256, 0.17182430689409234, 0.16929717940642586, 0.18124890671539362, 0.16550196103302928, 0.17601843888172064, 0.2710223358186634, 0.8206840825234507, 0.1851763513106225, 0.7390987173098124, 0.18439167160014902, 0.4001897053377923, 0.7279022987174314, 0.7908156343038371, 0.4409555036426692, 0.20354274169295072, 0.24073637427534988, 0.2999921535695659, 0.17522506255390313, 0.3680378542370273, 0.6599891368173326, 0.205118838419457, 0.1647775235500769, 0.17994344221633551, 0.18080785851398185, 0.20044778987161482, 0.19195308035293202, 0.19348121217965386, 0.18836800424097577, 0.18699585721797407, 0.17960809634161834, 0.06023013993690218, 0.06637216853675709, 0.07052492738244132, 0.0647344181418561, 0.06666658272062087, 0.07379304711507717, 0.07082682155674525, 0.06105056438258216, 0.11657847306578573]}, "mutation_prompt": null}
{"id": "ec160c05-03a6-411f-be2a-1252c5d9598e", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutation_factor = np.random.uniform(0.4, 0.9)\n        mutant_vector = rand1 + mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.4\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution using Adaptive Mutation and Crossover Strategies for Improved Exploration and Exploitation.", "configspace": "", "generation": 53, "fitness": 0.2772916086261396, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.6786693464847511, 0.6695981152556887, 0.6780435373025835, 0.6704437870722343, 0.7026415030949082, 0.6804706541209538, 0.7137322420934982, 0.7079065261238435, 0.6937011773118384, 0.45161635657942945, 0.46251434723418705, 0.4621140675205132, 0.4122412041167509, 0.4257452672349401, 0.48304888828656645, 0.3973285507073335, 0.45923801059055147, 0.463336724084202, 0.11100634703214984, 0.10984347982067433, 0.10296990060725242, 0.12045343339101489, 0.11300058237101662, 0.1038328140645921, 0.11720002804994378, 0.11062000922514037, 0.11334029570800319, 0.0977190951909539, 0.10480512261871555, 0.10071099600471445, 0.11145448177996564, 0.11291599489932524, 0.1031744658251188, 0.11258848286532208, 0.1095670617868918, 0.10161914911816416, 0.9168355641541397, 0.939528161112846, 0.9651016785937669, 0.94710416541002, 0.9027326099711361, 0.9287081997579517, 0.9548586147412017, 0.9298026983469532, 0.9399188974999122, 0.3160235828750828, 0.31178106150591944, 0.3112106494375133, 0.28793384363739816, 0.3153726884168938, 0.29889856878298493, 0.2795308383257984, 0.30692524660274345, 0.3230893173321838, 0.5814821394407077, 0.4901279994535849, 0.5449202264326396, 0.5979625624543221, 0.5204954724588932, 0.5553385233260573, 0.5060445594941656, 0.6266858466099381, 0.6128139175035909, 0.1928704735845409, 0.17247422915315602, 0.18899839662887852, 0.21263835819475285, 0.15234085808676812, 0.17309460143751187, 0.20224085104770306, 0.22645197261291583, 0.18516337232454794, 0.18166842569186037, 0.13062246922091758, 0.1662198780205728, 0.20274986318905164, 0.21703623918686066, 0.17989201474418182, 0.18218140813035766, 0.17179292527181989, 0.20604261408818425, 0.11594816412611308, 0.12071954388664219, 0.12752910253406557, 0.12289516483512253, 0.08835484136556293, 0.12934223144167156, 0.09206019618502737, 0.11034753479789783, 0.12871906602686756, 0.18996899326692784, 0.22993525235247092, 0.2610213897132335, 0.1988262936347417, 0.2345578340437685, 0.2518320297396496, 0.2488426589298519, 0.2273070453588787, 0.2708775800266804, 0.03362515290940371, 0.03120289061754189, 0.0550086352733371, 0.03235300106405281, 0.025352950747455583, 0.08279032185990909, 0.0534808144940454, 0.04957693438206934, 0.03107982759414285, 0.15513604339965092, 0.1536374232220069, 0.16750195579707816, 0.16493390478137682, 0.16274738298876124, 0.160501765457285, 0.16147270671603198, 0.1650107664287238, 0.1888575472667302, 0.4748474701547548, 0.5076357036826138, 0.5352393665856516, 0.4844802673051888, 0.5069324631889507, 0.5259795575379779, 0.5039370157310707, 0.49625337376319123, 0.5156974952821685, 0.09428877433077032, 0.09234073806091803, 0.08868860994786387, 0.10193493783444063, 0.09083918153935533, 0.09324109839336947, 0.10602490363033068, 0.09322026312176968, 0.0857359127286299, 0.1552076143903932, 0.16273436009814068, 0.17326188206102233, 0.17415555782559644, 0.188910595149964, 0.1817414266450431, 0.1668924184187519, 0.20010296052994125, 0.17853062316931778, 0.2879737937155774, 0.2975656941214927, 0.29359252395421476, 0.27710017012374677, 0.28197497152788675, 0.2715725030927203, 0.292463574759144, 0.3341327510296387, 0.31923295880342195, 0.20746087445536643, 0.2227441721984068, 0.2081857537306948, 0.21738597158419626, 0.20717280010546568, 0.20666731326573884, 0.22493294313913226, 0.23058389840701832, 0.2233363846020584, 0.21640811049492736, 0.21148906861074068, 0.18679928673235036, 0.20452872192169158, 0.1801270976264423, 0.18326507797464542, 0.20611833423678405, 0.19791869840478082, 0.20346982196981356, 0.19018217199969478, 0.2294295914857888, 0.1819636433613928, 0.20881010054884597, 0.1872924849080062, 0.19295691438042428, 0.18163503691648453, 0.20909625479161886, 0.19152990482678833, 0.25257600716916784, 0.17253147839314809, 0.5250280556677247, 0.31435811392850244, 0.35886302569596007, 0.6564712944793663, 0.3685226455029339, 0.2743108988695757, 0.24791432922440038, 0.48233711462954876, 0.1995711004041767, 0.4706235367406897, 0.3026199226048273, 0.22949742943464702, 0.1840322482967861, 0.2008087678153354, 0.20457750424392307, 0.20661953581606796, 0.18534824606597122, 0.18928181073870942, 0.1724955731497454, 0.1927443040908352, 0.19455416519347069, 0.18831883755874457, 0.18070553361840047, 0.17124772926690857, 0.18673292236064376, 0.06884756103532075, 0.07889292237317769, 0.07859828304549121, 0.07312509666751499, 0.07844494735171015, 0.0744277512188184, 0.07602518743423858, 0.07479645308943472, 0.08490960802447156]}, "mutation_prompt": null}
{"id": "e64108f6-e300-496f-9a25-ce7232838d61", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.global_search_rate = 0.3\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def stochastic_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 0.95)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-4 else 0.8\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.global_search_rate:\n                    global_candidate = self.stochastic_diversity(self.population[i])\n                    global_fitness = func(global_candidate)\n                    self.num_evaluations += 1\n                    if global_fitness < self.fitness[i]:\n                        self.population[i] = global_candidate\n                        self.fitness[i] = global_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution with Stochastic Parameter Adjustment and Global-Local Synergy for Improved Search Efficiency.", "configspace": "", "generation": 54, "fitness": 0.3114140430354303, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7540020787415871, 0.7206152158509441, 0.7478795059895735, 0.7668025337123673, 0.7689298934586982, 0.7604037599034195, 0.7524265468727714, 0.7609757460638393, 0.7337834030945571, 0.5568947379135061, 0.5831778501232311, 0.5517741241334665, 0.5176944500673519, 0.5405505706180718, 0.5379279192503481, 0.5499082274376286, 0.5478165432540283, 0.5453216928102236, 0.13091701813213463, 0.1267563490642597, 0.11584566512188998, 0.12492100765882608, 0.12015714839737335, 0.14125114406067008, 0.11485319194391375, 0.11624057627357431, 0.1147315710738358, 0.10895840265108125, 0.10955828235686782, 0.10477413322691354, 0.10821036332535727, 0.10573946846928006, 0.10237577822257393, 0.12005907705158858, 0.11146790818861485, 0.1214120540106316, 0.9189934709294659, 0.9040697573947359, 0.9111608398434684, 0.9314732283099445, 0.9469993330975259, 0.9203910542913537, 0.9182084438594221, 0.9242339132960925, 0.9192269129398118, 0.388115456858937, 0.403572132170271, 0.35717414712835593, 0.36257325634235615, 0.3526791576164948, 0.3694687203084518, 0.36437204893905817, 0.35801998175687855, 0.33678176946808436, 0.5344784388266003, 0.6986090088517852, 0.5806669413468892, 0.6146308837956711, 0.6101383501818229, 0.6593909924859646, 0.6044756457313036, 0.6107180939000044, 0.6684504775677689, 0.1708791755352419, 0.20916656786277243, 0.17432969964019607, 0.2253190524284453, 0.29006150041993073, 0.22470279092510537, 0.2278569343732172, 0.17023282393175798, 0.17651420492708636, 0.20225795607639196, 0.20756835264825235, 0.156360374143662, 0.19370535973282788, 0.20774991411987986, 0.18832626956672793, 0.19176585703038573, 0.27782465454204497, 0.21787456151086304, 0.09657751774393875, 0.1483840343744941, 0.12703185148681773, 0.14260568387450423, 0.14871627524902176, 0.10694043246332297, 0.10446833443196668, 0.15527882648073665, 0.1267128277884545, 0.22581548164917642, 0.27080526050209586, 0.30050612382754405, 0.219999977524031, 0.2577811996400926, 0.24292229808027976, 0.3009900992750586, 0.3120969777876783, 0.3116759433987497, 0.03335733509451588, 0.05341087634771535, 0.061411518826176015, 0.04999588089229379, 0.05637572173639238, 0.058652823441116, 0.08501666163348365, 0.07833275530204353, 0.054403488514928044, 0.16516490571971698, 0.16766266372761096, 0.18131766320109455, 0.17418979198035667, 0.20664660609379304, 0.20276705516335203, 0.171786456227213, 0.18959988370357506, 0.19059014715333034, 0.5439641015152277, 0.563134162517376, 0.5820879288971247, 0.5576984652028731, 0.560322297835314, 0.5370977017714302, 0.5515587305383052, 0.5323037671421487, 0.5646845596862229, 0.10477934249990706, 0.0911971349210926, 0.10000084564953882, 0.0927151283874087, 0.09831079329377246, 0.09650623567339789, 0.10592441540886288, 0.0811186672797245, 0.11525211488290732, 0.17878277672092846, 0.2066425163990675, 0.15555545227329892, 0.1852498417543268, 0.23006647626142462, 0.16783935741014777, 0.2520617019635504, 0.1949921953264836, 0.16341493415508246, 0.3308937187605264, 0.33766389737369995, 0.3592681216811754, 0.31507182305499404, 0.34158980984034093, 0.3287131936490466, 0.36833426939015856, 0.3881632194832254, 0.37684524006176334, 0.2289526655628895, 0.27559638900279515, 0.2385684750659669, 0.24067460118139983, 0.2316843294532508, 0.24601541723690235, 0.27503055367384455, 0.28650935993250604, 0.24290436790626768, 0.18613809573128615, 0.19247839852127424, 0.19729883426569594, 0.20302783280703174, 0.21067122517743242, 0.18916970845317382, 0.19558897090063587, 0.19910007160772691, 0.2100063974353028, 0.22692228786599578, 0.20279923845954817, 0.19578337969473614, 0.19225898300591204, 0.19688252738334688, 0.203882840364218, 0.19086090034988923, 0.21744396464682747, 0.19393037338189512, 0.5110830512329687, 0.4652541392315771, 0.18398146948866112, 0.48374879531679804, 0.5112704960419341, 0.3182465824371741, 0.5367769727034877, 0.4596956448174748, 0.6631580243474744, 0.46197874428497476, 0.4813709642345433, 0.3912109787799575, 0.39935107873157205, 0.1962462719840139, 0.3235684860347595, 0.5167359677765324, 0.5966385996969615, 0.2743638695502292, 0.17770234696704956, 0.18191337994372214, 0.19713660747658612, 0.17754294387634095, 0.19066700340439724, 0.18224052120343515, 0.18978522969542821, 0.20053141189107138, 0.20755780692601022, 0.07971091325908897, 0.08026219002180002, 0.07037018097578807, 0.07969020457706777, 0.07440800834084293, 0.0762970471700326, 0.07633905428425336, 0.08383850608831511, 0.07810084961601838]}, "mutation_prompt": null}
{"id": "a2c6cf16-a1b7-4998-a475-3ffb2deea319", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.2\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with Adaptive Hyperparameters and Diversity Injection for Improved Convergence.", "configspace": "", "generation": 55, "fitness": 0.3468406614545231, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8146939178173187, 0.775703366943731, 0.7782986334802156, 0.7893897307369415, 0.7972454356639811, 0.7835063329139502, 0.773458354787478, 0.7688007340602087, 0.7717443161779187, 0.6470999497721803, 0.6017731219071614, 0.6072558567018773, 0.6333234408322111, 0.6235812073278089, 0.6369391671895399, 0.6486566569208582, 0.6231872563580751, 0.6573664516062443, 0.11689612388120696, 0.12881424910904193, 0.11941056894570845, 0.12470532576271165, 0.14253307937483672, 0.11589068775235578, 0.11348355474013405, 0.12760263185400833, 0.13585615960053643, 0.11475427144402262, 0.11924627548990663, 0.11107724776555827, 0.1030650768834821, 0.11640393381458858, 0.10894032242331142, 0.10895828613842928, 0.1193328118358069, 0.11331224302900011, 0.9233712109426504, 0.9094771091295569, 0.9156455385835895, 0.9022396344344213, 0.8899544832581544, 0.9269288990245119, 0.8888283364033677, 0.9550159097818032, 0.9212465055542614, 0.38926079314139805, 0.4367913213769381, 0.392697670794116, 0.4247815497029598, 0.4256191832292314, 0.44171834456537173, 0.41482800030067835, 0.4047943847609805, 0.39303943765436633, 0.7244618346338583, 0.7568991657724985, 0.7361705467709942, 0.7611164196049895, 0.7721920064894345, 0.7574270997215928, 0.7725161940132625, 0.7363738683174194, 0.6828603437900049, 0.17121647918710714, 0.17260724960171048, 0.15363494533111643, 0.2086884568844546, 0.16375065132946853, 0.29056087941559294, 0.17022381935262898, 0.22156868483556136, 0.1742415319030013, 0.17068911643658136, 0.3037347034282458, 0.16610966152522755, 0.18202499397477245, 0.2763602345975755, 0.1760424652304602, 0.19071325127586347, 0.16882444995763557, 0.2265475892541614, 0.25704254034514074, 0.2614758334621, 0.2764721802717338, 0.3005299102357386, 0.24991935490119754, 0.2234371106311882, 0.2518044324839661, 0.2904700727960521, 0.24827531356176813, 0.4515099740569628, 0.4082631335535376, 0.3809142317928975, 0.39247524579881554, 0.3939071434582716, 0.2841522759104922, 0.4486815447884773, 0.42867989758341873, 0.40653890158130235, 0.0829444626989343, 0.08120943068008035, 0.10494756778096248, 0.14172662719216678, 0.09126686969470776, 0.15898995976263763, 0.20050543237129959, 0.14737168375395027, 0.15448325398143747, 0.2715336684841234, 0.22570046039178082, 0.21814189719553356, 0.25765130459414987, 0.2538711479874305, 0.2428197151621514, 0.24723059909783396, 0.25648666014400323, 0.2560306252702289, 0.6506766635849071, 0.6214167347201509, 0.6631379079237267, 0.6260718476116773, 0.6037309612274353, 0.6156636649645949, 0.6513875557813391, 0.6262102782964067, 0.6479057394673511, 0.10129419251251404, 0.10127380988751833, 0.0991059233899545, 0.10839610535250743, 0.09822136713016849, 0.09818398654204064, 0.09778126615277438, 0.0949424006652918, 0.09625358023779151, 0.1487183079042983, 0.17100810713222603, 0.1997781862340845, 0.17859712603031042, 0.18618756179419627, 0.1630436329862056, 0.16945812864062648, 0.17299052112728663, 0.17577483150611917, 0.4066659535146572, 0.39008766657791794, 0.363793293069802, 0.4189586741632936, 0.36469748617851605, 0.40914512904743683, 0.413966881648125, 0.4501630823078613, 0.41315115761044374, 0.30308045264852757, 0.2787582375647134, 0.27009779791582633, 0.3063186036768816, 0.28948032753797104, 0.25190618362174033, 0.3501305847480606, 0.33859282796470613, 0.31548946326851557, 0.20810177898841564, 0.1868923116825566, 0.19019214156275188, 0.18880016480944117, 0.19028354640924294, 0.21781114640943433, 0.2053675304318212, 0.20019945217373558, 0.19901729648297728, 0.26148559065267074, 0.20612834299545313, 0.20845133076498534, 0.19008066881143604, 0.18532447925339257, 0.19361457555689432, 0.19450194517321695, 0.23365016556536622, 0.19374372123617878, 0.18741609382328062, 0.5869239717248054, 0.6490005928661433, 0.6455897854432262, 0.1840395503388761, 0.5985555147311126, 0.5689278436863232, 0.20241026787031746, 0.6216421908282473, 0.6312399519702695, 0.20392521310559952, 0.662806571684589, 0.20690495079793914, 0.1972096442673389, 0.5880426369469796, 0.6966870196377917, 0.19882590565735214, 0.3402508057444473, 0.18006519107311358, 0.18153444570980992, 0.1848287979693155, 0.17329304346228125, 0.17344171213312654, 0.18232838308551602, 0.17421711667455142, 0.17176056164316145, 0.18143394518753153, 0.07327341875691673, 0.08384416952938845, 0.08599660394366404, 0.07948939310441328, 0.07855343141364723, 0.07654949836392311, 0.07867614266873646, 0.08563189406206895, 0.08336403367031375]}, "mutation_prompt": null}
{"id": "4253d851-697c-46ea-b02c-5e36ac33dcc3", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n        self.adaptive_population_size = self.population_size\n\n    def evaluate_population(self, func):\n        for i in range(self.adaptive_population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.adaptive_population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness[:self.adaptive_population_size])\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n        if fitness_std < 1e-3:\n            self.adaptive_population_size = max(5, self.adaptive_population_size // 2)\n        else:\n            self.adaptive_population_size = min(self.population_size, self.adaptive_population_size + 5)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness[:self.adaptive_population_size])\n            best = self.population[best_idx]\n            for i in range(self.adaptive_population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness[:self.adaptive_population_size])\n        return self.population[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution with Adaptive Population Sizing and Stochastic Local Search for Balanced Exploration and Exploitation.", "configspace": "", "generation": 56, "fitness": 0.33377114542956493, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.21.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.5487271483859999, 0.5515303666175049, 0.5426193758956455, 0.5298624701425179, 0.5369134344683637, 0.5307676497897169, 0.5538970489385254, 0.6190853974295079, 0.5327540758924993, 0.49730743525425136, 0.4155330903827986, 0.4489738648457373, 0.4642588254333828, 0.49867854849044946, 0.5319329077461076, 0.45605143732615006, 0.45781260096632326, 0.4489483472266076, 0.13743346099352183, 0.13929138046074518, 0.17531496433592308, 0.12387691307335247, 0.12131780119590163, 0.1393095197932902, 0.14060135267716034, 0.11151102114888667, 0.13580444561578697, 0.174238700193299, 0.10667015329217189, 0.12343501635525278, 0.11721590022552464, 0.11774992996365541, 0.11057434172598879, 0.14901677569541405, 0.12658830219478645, 0.11280189459650958, 0.8770171991872541, 0.8777883965807134, 0.9444964276987671, 0.8728934203669549, 0.880933768221687, 0.9073340240276482, 0.9287707708429463, 0.8939697391975404, 0.8705571427334193, 0.3758539535177523, 0.3613456599065905, 0.3238136838331156, 0.35444827348712926, 0.3514480205361379, 0.33380649238981097, 0.34287955300847905, 0.36966588613293494, 0.3611728926887441, 0.8311219544939907, 0.7847084104781656, 0.7367009390560431, 0.2674465843296251, 0.8049163995258568, 0.2683099890613587, 0.7098601288068874, 0.7988007738375151, 0.723095318153588, 0.15352486168022772, 0.1518779111565991, 0.14918306174401863, 0.15205454116373363, 0.43361181158472606, 0.20973240642680335, 0.2038834943125819, 0.21275327831455648, 0.18802052881437203, 0.3953917637102451, 0.14865930707873798, 0.15562585792346295, 0.3456791829508893, 0.17725996533259092, 0.17808471849949203, 0.2137245216830097, 0.250968364657715, 0.1794726049944977, 0.3453469520926705, 0.24601506130804496, 0.3016936746840203, 0.19576688729609237, 0.3429849652311081, 0.3149257129456914, 0.27734168464445785, 0.3463227852622377, 0.3389220305550721, 0.4211098041086061, 0.42279637916864266, 0.41729789803253703, 0.36340452673150947, 0.21636299027297878, 0.4215033138500366, 0.440371805870969, 0.397236788135771, 0.4532108258122768, 0.08791372331566094, 0.09481673856414363, 0.15409257328333792, 0.14223526068922798, 0.1921251571610233, 0.10989868472095676, 0.1409756411137818, 0.15131410577885474, 0.16272714596146032, 0.28524302549297587, 0.3117983799533508, 0.2851838575234772, 0.3119191263965124, 0.330788912044649, 0.336953416020797, 0.28990956930103073, 0.28469435873529614, 0.22902803022633145, 0.5097236936164042, 0.512965887852901, 0.5204988791076577, 0.5143394850033377, 0.509721819155629, 0.511748159912395, 0.5054335569302788, 0.4971016088419846, 0.48715957414475797, 0.14276634467945482, 0.11322922058926199, 0.11863888881414475, 0.12375874765885597, 0.1098151194247563, 0.12216488894322153, 0.12292804667163504, 0.1088790211773899, 0.10728038175250221, 0.1922988057287185, 0.17212205489958965, 0.1745050972164749, 0.19276991577051372, 0.16969680548583987, 0.17165507069972008, 0.18386782413097358, 0.18617768789096945, 0.18383455625862122, 0.4291065546559095, 0.4308345666664426, 0.40237231608200286, 0.4001273625366456, 0.405926053603617, 0.40290484487499256, 0.4188592969010472, 0.4306780897736442, 0.43114164085736184, 0.33066881123145053, 0.3184038964885253, 0.31539259340433967, 0.3529288346347377, 0.3372070726683505, 0.3088375807371967, 0.34312636793246876, 0.3734973045662905, 0.3300414813358157, 0.1943038764760383, 0.20586056785411488, 0.22114026321579416, 0.21402274701927793, 0.22918669450601326, 0.22099356761029298, 0.19390679163070368, 0.2141950505521324, 0.24292933613307133, 0.28259956714032886, 0.29669154067882797, 0.36003649674200144, 0.27415238680415, 0.28584069607784746, 0.20613276627259147, 0.20676983011109973, 0.19350030721882416, 0.20733129167501263, 0.6955327868534282, 0.7232703390679452, 0.19560776211879705, 0.6438273988685862, 0.6144265025336454, 0.5238767058703634, 0.6469025839370164, 0.6497505913895478, 0.6572130805594654, 0.6408068332309228, 0.20661391739339852, 0.4890810820936322, 0.20318556305123892, 0.5288813666990948, 0.19269705261286352, 0.20618431962509298, 0.5907242114281192, 0.20677012265339512, 0.20448887497203927, 0.17760858409834945, 0.17988164916761507, 0.17947280463898718, 0.18908405544139872, 0.18828818028792815, 0.2200454186936589, 0.17017863504027142, 0.1833014187220855, 0.08021466855097492, 0.08472949301493904, 0.08589920321443534, 0.07939699855349969, 0.10121318930020184, 0.07957898800628138, 0.08064239059971146, 0.09011880950130557, 0.08304056678507332]}, "mutation_prompt": null}
{"id": "95cf4909-5d51-447c-8728-2734308a772b", "solution": "import numpy as np\n\nclass StochasticGreedyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.2\n        self.adaptive_rate = 0.3\n        self.greedy_probability = 0.5\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n        self.local_search_rate = 0.3 if fitness_std < 1e-4 else 0.2\n\n    def greedy_search(self, candidate, func):\n        if np.random.rand() < self.greedy_probability:\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            greedy_candidate = np.clip(candidate + perturbation, self.lower_bound, self.upper_bound)\n            greedy_fitness = func(greedy_candidate)\n            self.num_evaluations += 1\n            return (greedy_candidate, greedy_fitness) if greedy_fitness < func(candidate) else (candidate, func(candidate))\n        return candidate, func(candidate)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring, offspring_fitness = self.greedy_search(offspring, func)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "StochasticGreedyDE", "description": "Enhanced Differential Evolution with Stochastic Greedy Search for Balancing Exploration and Exploitation.", "configspace": "", "generation": 57, "fitness": 0.29475724430974093, "feedback": "The algorithm StochasticGreedyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.6986882481752388, 0.6727671601136107, 0.7107063664537108, 0.7108571727861859, 0.7142836235562819, 0.6905651234251191, 0.6829536036862603, 0.6663811881402328, 0.657212252166632, 0.40996098195928843, 0.36221503222638685, 0.38015017790355676, 0.41292581772705816, 0.3988337993198344, 0.4292121473982422, 0.40816621639330963, 0.3820520238965338, 0.4171058670977068, 0.10677821788766251, 0.11216914251248766, 0.12282765856248357, 0.12134126967824654, 0.11073768680332507, 0.12413898339135687, 0.12151191287136776, 0.10609447273261141, 0.1136186587324377, 0.11352159903310366, 0.10663489011176042, 0.0892988468454341, 0.10895229480421642, 0.10255761034900224, 0.10012395181600076, 0.0953638832970437, 0.10791947112532585, 0.10482646098865278, 0.8265820489864304, 0.8561304497055175, 0.8658385436001909, 0.8566163325468107, 0.829769900850268, 0.8475285829360271, 0.8349754025821754, 0.8532411918129283, 0.8507385976392527, 0.3095119782469745, 0.305058120281562, 0.2782333540123493, 0.2980329009306457, 0.3332112095250196, 0.2794739957268053, 0.28817988457272714, 0.28104480325232184, 0.3084457744115875, 0.6544374403898838, 0.6622427228642334, 0.6763245581455084, 0.6641738817314883, 0.6118051670122466, 0.7194742371996401, 0.4847562292384199, 0.6908035749532946, 0.7195355407588935, 0.13637437951058762, 0.16376253888898118, 0.16554776305537067, 0.1779342492666901, 0.15569558595026278, 0.16920086035448278, 0.22417985242075633, 0.146869557862918, 0.15484715599949272, 0.1820031066128287, 0.11031895314949325, 0.13755591398795985, 0.16716884114884611, 0.16251669229593757, 0.25863899457533357, 0.16572042314653113, 0.2226958320641026, 0.1395910155026533, 0.1446242706451616, 0.15246228072736379, 0.14716975433214885, 0.20533780363362752, 0.07037187897042585, 0.14974613465291509, 0.12631160515804063, 0.16458144600744995, 0.23099852491868167, 0.2920470788318674, 0.3212781027369004, 0.33918857122043966, 0.2879123911851148, 0.29077402532820684, 0.27694299218312934, 0.35171191570363747, 0.29958658199670285, 0.3083820846977995, 0.07018750921860506, 0.040587480433677436, 0.06019312423715106, 0.06344012613816863, 0.06436581841753342, 0.07648560871796872, 0.1012277727844283, 0.08041590389197972, 0.0634758430363136, 0.1971134738195307, 0.18461651319180783, 0.2055870287571162, 0.17870140776502963, 0.1956815537947687, 0.19763095918460738, 0.1981238433577982, 0.170268512914452, 0.19272661536139168, 0.5176855918456907, 0.5520760615603834, 0.5145050687857491, 0.5534289163938544, 0.5307729903781433, 0.5092477877297794, 0.557990846990329, 0.5122570523703364, 0.5608849209487332, 0.106456750287107, 0.09546535309928661, 0.0975794113188787, 0.10768008182381195, 0.09967938717032998, 0.12507753697290502, 0.10034531489616005, 0.09517791048636481, 0.09719119068713067, 0.14515257712285823, 0.23092623219877328, 0.1660983626047613, 0.1556561688276844, 0.18447376482176858, 0.18016460478824825, 0.1629856031505753, 0.14535764809906393, 0.14677844859815503, 0.2999600219072468, 0.31308605970983105, 0.3289831177455319, 0.34615612631159387, 0.3421600899681303, 0.3055006796897082, 0.36265476041035294, 0.34958852641867877, 0.34066588700752276, 0.26601459287186846, 0.26604900796280306, 0.27966103286349375, 0.24358729380584798, 0.24990411287852132, 0.22217459440353537, 0.2726620727801754, 0.27828756418724654, 0.26679407365591346, 0.22825501632794787, 0.19369954023206315, 0.2004069695232551, 0.19420262698936286, 0.1859560544746497, 0.1780270129855489, 0.22054654010331365, 0.21138344686291877, 0.1958234761438299, 0.20445347223935384, 0.19282320307157408, 0.1964155777617017, 0.18655569932427152, 0.18254380549495086, 0.18317731963726525, 0.19547499412074598, 0.18350550075149008, 0.19025675133355946, 0.17861031643747538, 0.5566400876272359, 0.6753042803512439, 0.6769557836764508, 0.5020097197821701, 0.6403602700756511, 0.636559097555103, 0.159799309724024, 0.569815621674357, 0.22787571327657075, 0.19507586130758714, 0.5760698273290703, 0.16384213955313875, 0.4414778710787973, 0.6483739832948, 0.15938510348717316, 0.4614770544399338, 0.20417918901604293, 0.1829499232088848, 0.17941574088594714, 0.18420198966651902, 0.1752545378816176, 0.19166532389368784, 0.189356977251805, 0.17785592739842127, 0.1813147600378937, 0.2030066155411253, 0.06779577181489271, 0.08054540995855786, 0.07939772295500336, 0.08571270598182834, 0.08295017764633716, 0.07467541187679638, 0.07966439272412495, 0.0894553902422236, 0.0795440647128065]}, "mutation_prompt": null}
{"id": "4c1e2c92-2486-4195-bab7-6763254415b1", "solution": "import numpy as np\n\nclass EnhancedCoEvoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.elitism_rate = 0.1\n        self.adaptive_rate = 0.35\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def elitist_selection(self, func):\n        elite_idx = np.argpartition(self.fitness, int(self.population_size * self.elitism_rate))[:int(self.population_size * self.elitism_rate)]\n        return self.population[elite_idx]\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.8\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            elites = self.elitist_selection(func)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                if np.random.rand() < 0.5:\n                    mutant = np.copy(best)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedCoEvoDE", "description": "Enhanced Dynamic Adaptive Differential Evolution leveraging a Coevolutionary Strategy with Elitist Recombination for improved convergence and robustness.", "configspace": "", "generation": 58, "fitness": 0.11894294544604572, "feedback": "The algorithm EnhancedCoEvoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.13.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.2118208652690884, 0.1805282222524276, 0.3464306152024307, 0.1571442151025374, 0.1819101863920547, 0.28441812214278683, 0.25001152711571284, 0.297131184666367, 0.2499762463553553, 9.999999999998899e-05, 0.06306694505480914, 9.999999999998899e-05, 9.999999999998899e-05, 0.0171824612767274, 0.017085391372063663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07707678539745644, 0.10274024015193284, 0.06708609074171212, 0.05931603044807576, 0.06427051841471709, 0.09456988772979857, 0.08169979125943139, 0.06205608056010514, 0.09446750847548158, 0.05044561014646587, 0.05783295464809779, 0.0564942147861911, 0.06595144394249763, 0.0351156177756764, 0.07714580608657284, 0.07373932929026561, 0.036476866374128614, 0.03162516034105689, 0.11041705411949954, 0.8370049962604696, 0.11234456345153265, 0.9780519499577148, 0.11641474836783838, 0.25974117602107294, 0.17212728982906156, 0.14177429949025477, 0.9763247289967167, 0.06274794416174423, 0.21543745351728327, 0.047271284842147154, 0.10939699210454634, 0.11278097464977932, 0.2041438588702288, 0.12430197266049348, 0.05670378032863832, 0.13845389589902057, 0.12454626244917821, 0.2296780620583614, 0.1391219732849096, 0.1361446343330439, 0.1971056437451172, 0.16168234393043313, 0.13691026059853606, 0.10128372334137004, 0.12081419586472053, 0.04974019213333014, 0.12849118101284895, 0.10393527023278748, 9.999999999998899e-05, 0.020129421468741193, 9.999999999998899e-05, 0.00253412901901906, 0.04594521379984762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005285282994302309, 0.08745870658875743, 0.07822079125306569, 0.08669757192307448, 0.03759323034413187, 9.999999999998899e-05, 0.01223530910467363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004153081633550992, 0.04805135907369018, 0.06219209396567871, 9.999999999998899e-05, 0.0031602164841458835, 0.06528547855734668, 0.04856201674203242, 0.025574438990180748, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06734437804351201, 0.09626165148573895, 0.07039236876054711, 9.999999999998899e-05, 0.0154061395419689, 0.04294368716994523, 0.002533474601851604, 0.0053713882040842265, 0.07962524919937153, 0.3192696449298167, 0.3248398181417185, 0.26881554867427926, 0.22255385358125956, 0.3001795361085847, 0.3234447922390109, 0.3713964452135937, 0.27022684397455643, 0.2458621460410122, 0.06053187380626168, 0.03146419215553686, 0.04399920328875051, 0.05187672917092512, 0.018048101340369826, 0.08788929461687489, 0.043661308998464654, 0.04155423611105835, 0.09496140422715615, 0.13828285268946094, 0.18404871538565126, 0.11842175776965747, 0.10926134965681267, 0.11836353941809208, 0.10798713552628325, 0.16912216494035148, 0.08487091451270767, 0.07726393575557644, 0.14496272684462475, 0.21125016399058172, 0.20849901893817824, 0.17407676758234214, 0.21328745641882774, 0.14000230854556717, 0.16587774396506483, 0.2082663184287502, 0.19865590537196665, 0.10293539458659651, 0.19876159808234029, 0.15576504160456084, 0.14977522627646012, 0.158095284804038, 0.11642225607033141, 0.10698484445056311, 0.1296515946412672, 0.18684258161292633, 0.14498208766194443, 0.13626611351038487, 0.13345086981233123, 0.16210990006264603, 0.13761102153307492, 0.14399737684145808, 0.14921965469190113, 0.1750889410972759, 0.1261963614278906, 0.173965901696704, 0.19426384240012762, 0.1628494536855094, 0.1604137605708984, 0.15463466292104255, 0.17443358927916197, 0.18984983582892434, 0.15938497509158966, 0.16494337480034615, 0.11630160847422977, 0.5011336967636628, 0.12237514211519707, 0.16798697201541768, 0.1847436914735826, 0.16648648269376232, 0.14256420527076696, 0.11145602584736702, 0.1116607398861581, 0.22564012351005813, 0.208953697364326, 0.07251001534524115, 0.10292249521702634, 0.1648820966382809, 0.10916866382804835, 0.09880381518168802, 0.09816831170513085, 0.19567389256226475, 0.13480174570059533, 0.1302462502661248, 0.1941028375161995, 0.15775059456437335, 0.1356686855567757, 0.1413222307266755, 0.14969714796693134, 0.17378393566526662, 0.14689007985489466, 0.05333912627590143, 0.09765932503891905, 0.05129670284574661, 0.03902160708026059, 0.05067984805563197, 0.056468459334443444, 0.06643681177182392, 0.03803354422653826, 0.06510901037058081]}, "mutation_prompt": null}
{"id": "eb093acb-34f0-4988-adbd-c97e3e8b84d7", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.3\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i]\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.8)\n        self.crossover_rate = np.random.uniform(0.5, 1.0)  # Increased adaptability\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n        self.local_search_rate = 0.15 if self.num_evaluations > self.budget * 0.75 else 0.25  # Adaptive local search rate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                    if offspring_fitness < self.best_fitness:\n                        self.best_fitness = offspring_fitness\n                        self.best_solution = offspring\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n                        if local_fitness < self.best_fitness:\n                            self.best_fitness = local_fitness\n                            self.best_solution = local_candidate\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive Differential Evolution with Self-Induced Diversity and Adaptive Local Intensification for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 59, "fitness": 0.3442444711949015, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8174628895887032, 0.7835076255843039, 0.8054890392443469, 0.7953433964137663, 0.7852222317513227, 0.7880000536658271, 0.8036981991624479, 0.8016110521118945, 0.8027335558606534, 0.6307325970255215, 0.6248675779785744, 0.6203788390353902, 0.6708549849414329, 0.6251417012932898, 0.6433918268801999, 0.6378031908743513, 0.6278200668053562, 0.6467226744419923, 0.15362588905436203, 0.13003697430173544, 0.19197892945192452, 0.14146207395103516, 0.127017799119178, 0.14010118296167218, 0.21331325267148327, 0.13582475791601423, 0.12481687909561079, 0.12831853065146281, 0.11696588560137278, 0.13125386859882637, 0.13661311109329655, 0.13234378506308964, 0.12134611657130501, 0.1368229484237543, 0.12271879176830391, 0.12402620015407717, 0.9010837252053971, 0.9084385626532848, 0.9130795748785151, 0.9149218380337859, 0.9202437355009978, 0.9109049612478018, 0.9209182900655868, 0.9249845185080193, 0.8895199254064872, 0.4181783036485418, 0.44232755574937, 0.3575967945057118, 0.34596728057352644, 0.4445377663757255, 0.44945543482387207, 0.3274894014984129, 0.39315690176969165, 0.353079866388158, 0.7185020232532107, 0.7400706447337222, 0.6581766732343243, 0.8030845698607704, 0.7530175546336941, 0.7679978980418434, 0.724801228683136, 0.733115704941574, 0.7552782921394133, 0.20968519227068405, 0.24226682451800985, 0.16194461293553064, 0.17055377333430166, 0.173994142488627, 0.17883653538178534, 0.22136861073813507, 0.1734510855374254, 0.19921930947205546, 0.13857041440077078, 0.17636044834282805, 0.19312724708271378, 0.13915418256883427, 0.44389207248356566, 0.1748565626227746, 0.19875350641248368, 0.22067527334232506, 0.1747901885997618, 0.2436272247976562, 0.16726797272483507, 0.19801227937171362, 0.19352442374105816, 0.2669594593634027, 0.19298484362908797, 0.0839274482639234, 0.19595130216717804, 0.12296023460168948, 0.2849270232788139, 0.41922646132672603, 0.3435195415549669, 0.3119591994540748, 0.27795390818175725, 0.3054375123622185, 0.38864844245086616, 0.4609147255047463, 0.3920423525946817, 0.09364072994051531, 0.13312442929211588, 0.07791945285792368, 0.10004373840718639, 0.17615767235439395, 0.12111131207536052, 0.093747015260369, 0.1400097905853852, 0.11920679467266326, 0.15656721129029771, 0.21287543028008316, 0.23533911841736, 0.2021227673084861, 0.2759101108395381, 0.20627907202960283, 0.22073034022123772, 0.2421674646327796, 0.21360390331652623, 0.5923875636033535, 0.6419382463993151, 0.647454150107481, 0.6020861310308901, 0.6277950495349162, 0.6032637787805181, 0.5971726770844339, 0.621029601260247, 0.6012257572889246, 0.10665860127300097, 0.09741712266778102, 0.12240776437080203, 0.11019320472174765, 0.1048236961045681, 0.11816895852602849, 0.10970967120867448, 0.10220232486857128, 0.10146676699085966, 0.16872340573256694, 0.15852709807009246, 0.15991811958334368, 0.1852893737229343, 0.17938798370391473, 0.2120693339113474, 0.20300500721291537, 0.16401787471873397, 0.15956754779929816, 0.42279022568892455, 0.39393604399964366, 0.42267641032972747, 0.398559331717374, 0.4098928601409657, 0.4248106445676607, 0.44320239658057436, 0.45444028558812355, 0.4525697145349744, 0.3136980775096704, 0.2961148796120089, 0.29886853831022075, 0.2850235334451675, 0.30361542792707463, 0.2911118067663496, 0.3334856522841657, 0.34757783154750854, 0.32384852477892845, 0.20626353130902086, 0.20152834047358315, 0.1958117333157755, 0.19409146394133636, 0.20305852352180476, 0.20887109584432018, 0.2230723365413816, 0.19090329301094977, 0.22479019935478206, 0.19510980917589893, 0.3527207354262273, 0.2984964698201703, 0.43611680309104284, 0.20192311780882277, 0.20875588205779538, 0.24241214900102925, 0.2176820997520904, 0.2070998575895383, 0.19347181199928742, 0.18039445597680936, 0.5523442473283797, 0.7250278313828759, 0.5661804714565462, 0.633902496144219, 0.7282156848125882, 0.7417432727169317, 0.1728033935177793, 0.5297579379023891, 0.3858133622316203, 0.4525052944665937, 0.3922094113103849, 0.30630284786931516, 0.30612204753281325, 0.20289563598001392, 0.49309712480470114, 0.20617581061983048, 0.17627407340966328, 0.18738760590915615, 0.18250188589996819, 0.18423355663266705, 0.17670258122102933, 0.17997289475534706, 0.18293174873673723, 0.17751641120099393, 0.1887347065612004, 0.08803703920010997, 0.0758975170591446, 0.08527398594631086, 0.0807912554961997, 0.08663355815661578, 0.08196826566291515, 0.08788511696251444, 0.08852709491885002, 0.08253870852804124]}, "mutation_prompt": null}
{"id": "c3928aa4-c26c-4a67-a255-13d963842922", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Range slightly adjusted\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3  # Increased local search rate\n        self.adaptive_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)  # Increased noise scale\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic adjustment\n        self.crossover_rate = 0.8 + 0.2 * np.random.rand()  # Enhanced randomness\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-4 else 0.7  # Slightly increased\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35  # Slightly adjusted\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with Self-Adaptive Parameters and Stochastic Local Search for Improved Convergence.", "configspace": "", "generation": 60, "fitness": 0.37217626287572747, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7956516766186669, 0.7909832309586979, 0.7835792281041176, 0.7818728534113875, 0.7914813804769533, 0.7833410648652325, 0.7853146115761954, 0.7759644939137802, 0.787052101423958, 0.6130592717198036, 0.6491392117545172, 0.6304290954849057, 0.6045180662662871, 0.6359412384191904, 0.6202107508621211, 0.5905568853349221, 0.6030668002539872, 0.6182247279298186, 0.10956647150920562, 0.10007317325274201, 0.10930312470865122, 0.12209264815033471, 0.12184989319050965, 0.11371168968833878, 0.11359180790108281, 0.11860908393344871, 0.12903982696208316, 0.10406770068730131, 0.10179663918628012, 0.10408770864172334, 0.11834761317592435, 0.0971102520152981, 0.10621246733959055, 0.10735557072714041, 0.0994960407646065, 0.10586738466843837, 0.8732901803274632, 0.8695669501525991, 0.9087951813966391, 0.9297150210508093, 0.9007200481279163, 0.9076673604832313, 0.8831080577072252, 0.8890009787438037, 0.9170937579493155, 0.464079012862359, 0.42970170420547504, 0.37441689533368083, 0.440029173073364, 0.45650862615169585, 0.42177744123011673, 0.44496585206542194, 0.36251327495387375, 0.4335274054799443, 0.7725978922742381, 0.7283648568349845, 0.7744031080831311, 0.7336904172260208, 0.763743201140239, 0.7611673412996655, 0.7540922249471327, 0.7742899498006889, 0.7524965917759553, 0.1912816277123971, 0.17436251857258755, 0.16654826003562107, 0.20784470193348126, 0.12166842631318053, 0.19338455504388863, 0.1645276629330552, 0.21332692131398456, 0.174627882565083, 0.14140227360658209, 0.3933900646490084, 0.19294073568132797, 0.18570252742479532, 0.16972473094500906, 0.17824462632856575, 0.22940897953043726, 0.17693666602238778, 0.15135289739905167, 0.35322398559659574, 0.38218606976725455, 0.4039076614212479, 0.3823274157506533, 0.3817942817546909, 0.40051118305922795, 0.35183025215785046, 0.3236559525376089, 0.33339454872266727, 0.5117398299559386, 0.5698722675955541, 0.5698821834066238, 0.5048616868094065, 0.4735470313845128, 0.5324420343175202, 0.5259536528210007, 0.5696423299731769, 0.5210681185118318, 0.1857337819467576, 0.11753575423626339, 0.12279244091014951, 0.27724949519950415, 0.24196693097196798, 0.1543873209070118, 0.13525996278133645, 0.11065256460970962, 0.21171492769771794, 0.28177601750199865, 0.2955702782486469, 0.3121675434248615, 0.349408100071949, 0.31145835282872236, 0.3466658707845266, 0.30761358697346874, 0.31193000272167437, 0.30543391429562605, 0.6945080519549627, 0.6915205250575467, 0.7159951332464559, 0.6382303443064221, 0.6718037951140754, 0.6787432878777158, 0.6867303600954162, 0.6896060709899694, 0.7037856224695438, 0.0875500824151999, 0.10540277171208667, 0.09560326087140747, 0.10665825302099452, 0.10647893381570828, 0.09586646843097546, 0.098699390060212, 0.11319432795726625, 0.1145682096736177, 0.1640884829604885, 0.19433918233505498, 0.19075140832362025, 0.17726148757367077, 0.1607620255127955, 0.1669947374947346, 0.1884313230415331, 0.18188084638571156, 0.19364818952202267, 0.4118294637976976, 0.40889580360046185, 0.4074696430050473, 0.39049233840385167, 0.3994258990594013, 0.4045353805141483, 0.39723683220516937, 0.42698450809183264, 0.4331059427506586, 0.28687921059436694, 0.31460361869919184, 0.3252817887369188, 0.29768548311964027, 0.31210764785470024, 0.3171111454441582, 0.3172679530420065, 0.33457314753301126, 0.35138962200320145, 0.20022092523750246, 0.20253511348990183, 0.2015282348516204, 0.21748181844504988, 0.20349002508910208, 0.18735119163662317, 0.2129238312681797, 0.22547895269170382, 0.2185647527904706, 0.19696873024276806, 0.1980196732392705, 0.191949544927005, 0.21587931636763347, 0.1962139670109253, 0.20083346626492826, 0.2454801816308495, 0.1920433312073918, 0.1844482854246028, 0.6758442198201705, 0.7174772080148222, 0.6509559138626736, 0.7349488982965782, 0.5940859873486302, 0.7628058705808092, 0.7291697587185288, 0.4351955032145265, 0.6683586027733713, 0.7223410493472, 0.20564274616969103, 0.20131054828019534, 0.19889436027562435, 0.1607891639558766, 0.7587772596318417, 0.722857310300466, 0.19725021790685882, 0.6565426878695648, 0.18513306682006014, 0.1780497794828294, 0.19333721866580977, 0.1751888277472159, 0.18520143548258627, 0.187735938020146, 0.1772584271372687, 0.18524989303617523, 0.18557611736797996, 0.08944240571011286, 0.0810712671352829, 0.08587312766912714, 0.08945590807208115, 0.08882839913895857, 0.07839510179714726, 0.08409102275087876, 0.08004339177691477, 0.08378312426899537]}, "mutation_prompt": null}
{"id": "40bcfeb6-ae23-474e-9a70-3621702e9566", "solution": "import numpy as np\n\nclass AdaptiveDEWithSelfTuning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 5)  # Adaptive population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.3\n        self.epsilon = 1e-4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        fitness_std = np.std(self.fitness)\n        self.mutation_factor = np.clip(0.5 + 0.3 * fitness_std / (1 + fitness_std), 0.4, 0.9)\n        self.crossover_rate = np.clip(0.7 + 0.2 * (1 - fitness_std), 0.7, 1.0)\n        self.local_search_rate = 0.25 + 0.1 * (1 - fitness_std)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDEWithSelfTuning", "description": "Adaptive Differential Evolution with Adaptive Population Size and Self-Tuning Parameters for Enhanced Exploration and Efficient Convergence.", "configspace": "", "generation": 61, "fitness": 0.2542359885782843, "feedback": "The algorithm AdaptiveDEWithSelfTuning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.7472882297043493, 0.720167420425027, 0.7359561222434665, 0.7172602550653899, 0.7465736090183075, 0.7435023970469815, 0.7318226635159311, 0.7522404338733455, 0.7261591505676632, 0.48130328870158245, 0.47538277407159, 0.49215570229358374, 0.4926666621666016, 0.4626908641795894, 0.45002856807178815, 0.49632191840091655, 0.4722817651533173, 0.46404863856708, 0.10852694438834531, 0.11567688280995048, 0.12360169761127504, 0.11417515439305348, 0.11795398838125526, 0.13276493225735886, 0.11152456622881013, 0.11260040290710627, 0.12416522018787113, 0.11696297429266544, 0.09745831245944447, 0.11664949412614911, 0.1039935811070738, 0.1116925523081127, 0.10717728631250689, 0.10581365343506988, 0.10263727741492168, 0.11515657691615011, 0.9649737660574065, 0.9485307352286995, 0.9541620525487152, 0.9713826586178571, 0.961358657893536, 0.9745585020538712, 0.9707725476686471, 0.9482859797386053, 0.94874477963701, 0.29884123431192655, 0.27830173055782137, 0.29623644489050927, 0.28193294988236417, 0.3255551678082811, 0.31397777376033464, 0.3213005799649188, 0.3192142098962931, 0.3006060839583261, 0.4618847489092456, 0.4910590624282869, 0.45198901365103783, 0.515947263236112, 0.52506131205147, 0.5415381460948097, 0.48566800516273556, 0.43912815782610803, 0.5897849340328731, 0.1588127839487481, 0.15042830998704448, 0.14844999147471571, 0.1260262634250734, 0.15143916616289643, 0.1425727941480125, 0.16431911114192865, 0.15595729301065653, 0.14328023825495861, 0.11789133476359948, 0.29280065493067764, 0.1239750295767823, 0.1586432307621488, 0.1353847359055812, 0.15092042018104146, 0.1668926311359673, 0.11857558564783754, 0.15177533164099, 0.002250786786845871, 0.00430345582457814, 0.0018519732003428047, 0.0048348721932739425, 0.004273494725929972, 0.0005767517319887894, 0.016752095094400232, 0.005007056687262423, 0.003976261152695781, 0.09902051183350757, 0.09118985605149721, 0.10630482187767631, 0.10415415534748496, 0.0863740217650606, 0.07272119489556683, 0.09279873259376947, 0.10125027706121725, 0.10923481315429218, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10539429053072358, 0.09713556227535469, 0.11578269806387054, 0.10184726267247934, 0.12005316022053958, 0.11489788205774565, 0.09603087524247933, 0.08599498139192985, 0.10653097010095003, 0.5559841109771453, 0.5797311885169202, 0.5897000670749293, 0.5973036092908827, 0.6040490045903419, 0.6468348395495522, 0.6387143173319625, 0.5485807664156154, 0.5809378210085396, 0.09388364848030673, 0.08827815203960565, 0.08163578700092733, 0.08050400752908393, 0.08263590245017771, 0.07755647671919264, 0.07181063296759405, 0.08279269790661004, 0.09070003530626725, 0.1570306521941468, 0.13366134334425883, 0.13501742157347796, 0.1473794483583133, 0.13103318115256535, 0.14410684831211495, 0.16370513299613343, 0.1308290275103644, 0.13440936223293098, 0.2982867214706798, 0.3088504693717784, 0.2839410799985753, 0.291672943640354, 0.2755422685419806, 0.29341824230312064, 0.31789838536138737, 0.3528360864598834, 0.3450253208952573, 0.19659028739219087, 0.1916215639306994, 0.20246493064372795, 0.1813339876231872, 0.18410372601612668, 0.19957103163287204, 0.24507974512263386, 0.22114766239333727, 0.21835138651219033, 0.2051043432738313, 0.19325809253475057, 0.2174943546605771, 0.1871753033497765, 0.185117327896971, 0.19522558794597766, 0.20817619517605412, 0.20953771163048873, 0.19002026679873207, 0.18974442440574124, 0.19444287755552025, 0.2104585994142384, 0.19358467383675904, 0.18831224329998064, 0.20360804165270996, 0.18683034736283222, 0.18984040260206392, 0.18882249455825872, 0.15688035105097775, 0.1591268063166863, 0.2704077633892269, 0.17329730525598896, 0.1659488636240598, 0.17080541891116063, 0.19199538760355894, 0.19580639339920958, 0.2847833096210859, 0.26779775173946296, 0.19325186059362065, 0.15867423940407865, 0.22196325621778656, 0.1843674288819125, 0.2258492053739496, 0.2039210335280015, 0.2041546797002256, 0.2010404235735852, 0.1847238670916529, 0.19331864754106953, 0.17402257520267272, 0.1831958164205465, 0.1725401839624756, 0.18734372123099075, 0.1952870004340721, 0.19918574345922524, 0.1933546014211064, 0.07024967555115835, 0.07429327006769904, 0.06545463304518795, 0.07810578507663613, 0.07419747102166407, 0.07157271311027258, 0.06935400938897307, 0.06651006172574636, 0.08213148977491413]}, "mutation_prompt": null}
{"id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.6\n        self.adaptive_rate = 0.15 if fitness_std < 1e-4 else 0.25\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Stochastic Parameter Tuning and Dynamic Population Control for Improved Optimization Efficiency.", "configspace": "", "generation": 62, "fitness": 0.37930517770881905, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "71967d76-3dde-4a2b-ac57-533eba5bd9d3", "metadata": {"aucs": [0.8318352075148623, 0.841482961415721, 0.8153375147221269, 0.8065058821825534, 0.8433602764532249, 0.8237622165586138, 0.8115172505888366, 0.8457728303214269, 0.8119374634715596, 0.7053637354249817, 0.7102887041875616, 0.6826559882945071, 0.6832635912332432, 0.7430740336394721, 0.7053456599081265, 0.7030216084734193, 0.7387929466326462, 0.6944469196476273, 0.32479233850880396, 0.32271525327256445, 0.27980367713212906, 0.1504645505923038, 0.15725738054715965, 0.13586278578012245, 0.20059912238609168, 0.43019699073244466, 0.3618096376319724, 0.15584981703740175, 0.12885389719504514, 0.19595684571456695, 0.1282787584284042, 0.1461693335072427, 0.1425405455975981, 0.14148856599169723, 0.15249538025660947, 0.13817105432303634, 0.9119487151920728, 0.926318512860696, 0.9273413599680123, 0.9125863239081282, 0.891405374194265, 0.9225351443822715, 0.8927795268461393, 0.8867769492998934, 0.9030081625312983, 0.2989973936103306, 0.5032900713674842, 0.35689429825834684, 0.2888881175059004, 0.5286486166763854, 0.43973226220891326, 0.28440867446205387, 0.38887380181707587, 0.3978389073323396, 0.7604959863337091, 0.7950626014408041, 0.735802174234822, 0.7723701183169924, 0.8102589012028083, 0.7682256038867566, 0.526735054595015, 0.8098437435900561, 0.7968117326555622, 0.15627874424388533, 0.16325242022691822, 0.16170791422140451, 0.17843251916624703, 0.19443419900615266, 0.15617205473668305, 0.22318797676388402, 0.15202751579970009, 0.1750308793795049, 0.17670070019758155, 0.2625715701540483, 0.1741470940708939, 0.14260247509446689, 0.19371646163446732, 0.17647303132394243, 0.18413326760065152, 0.16434130408666736, 0.5435483012022032, 0.19801205135367117, 0.11231516510838024, 0.3006234219179813, 0.16980393582945108, 0.07975116403349725, 0.23162199726685317, 0.12057564807651466, 0.11687902835035169, 0.4278037501093457, 0.3542299139910805, 0.2833879423357708, 0.35503275785677635, 0.27264153433183436, 0.1551590697122105, 0.10201466681091265, 0.453878028294619, 0.6254198924086292, 0.20867040478685872, 0.092133197141955, 0.07089868968213764, 0.0903773631867576, 0.06978862581645884, 0.14759745221577014, 0.1623237684059874, 0.10594801429305511, 0.14700381997463297, 0.18030040105444645, 0.22559718106525384, 0.22451854585103914, 0.24631611501731743, 0.2348658679761395, 0.2663393532585885, 0.31850246424652673, 0.24699954297790316, 0.24104257178864563, 0.2501626547323632, 0.6376161052347102, 0.7565960140790814, 0.7283814328368818, 0.7065515680430434, 0.6907500911502082, 0.664389551288978, 0.7545763979242286, 0.6805444808463892, 0.6469808375350845, 0.11225489689538282, 0.11331171597980005, 0.11064864373069394, 0.1122637410224695, 0.13255138518508525, 0.12945924372059048, 0.11063487141272221, 0.10387872488254057, 0.10800331127335716, 0.1887269838517488, 0.1787312548816632, 0.27803501268057995, 0.17760152797021622, 0.20000476379803867, 0.24869210737696734, 0.19349436451628077, 0.20884041841531287, 0.20290546110069785, 0.5658979581197756, 0.5404893633433835, 0.5251511691957997, 0.5203914415464121, 0.5358350880369878, 0.5651485191795799, 0.4249219203254758, 0.5864146559817227, 0.6032813961023352, 0.3522405855582357, 0.43240048046034696, 0.3700856267561591, 0.37659506665973097, 0.38691533741031425, 0.3830314458089332, 0.4257220900503845, 0.4545793381437898, 0.3356566154525519, 0.20176484741464396, 0.2126500601568504, 0.19827390178974003, 0.22325471018328757, 0.20343203306227575, 0.19883105163609882, 0.2206965681574582, 0.19729005195179283, 0.2065834185387765, 0.2866491714363315, 0.5678734521602765, 0.42137835911639676, 0.22832496212602071, 0.5486044180406189, 0.4114008063730823, 0.594285262440577, 0.6267099566026046, 0.5480760742032111, 0.19045638214746785, 0.8393017535839113, 0.19407006536195426, 0.7977476278383466, 0.18531038587111226, 0.739076693339874, 0.16204080096572093, 0.7368985062074183, 0.7466825535501908, 0.7852577284077027, 0.738696680054199, 0.755870439190356, 0.35139233691370153, 0.16132268846885978, 0.4496988567732617, 0.20233007510193124, 0.15237791169060655, 0.19942076804312014, 0.1895602492862427, 0.20830044178296303, 0.18107083134601365, 0.18972617851049323, 0.18719310790776067, 0.18999623252704623, 0.19759897511087143, 0.17699342270089868, 0.1737305785953065, 0.09391503918020316, 0.0861751255748675, 0.09224202118233404, 0.08187910297664491, 0.08473595984401072, 0.08396658897218401, 0.08982208059076824, 0.08552684576069491, 0.0960279544382916]}, "mutation_prompt": null}
{"id": "0c1993b3-c7b2-4bea-80a7-55e7a271be73", "solution": "import numpy as np\n\nclass DynamicLearningDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.6\n        self.adaptive_rate = 0.15 if fitness_std < 1e-4 else 0.25\n\n    def knowledge_based_metamorphic_mutation(self, individual, best):\n        step_size = np.random.uniform(0.1, 0.5)\n        direction = np.random.choice([-1, 1], self.dim)\n        return np.clip(individual + step_size * direction * (best - individual), self.lower_bound, self.upper_bound)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                if np.random.rand() < self.adaptive_rate:\n                    mutant = self.knowledge_based_metamorphic_mutation(self.population[i], best)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "DynamicLearningDE", "description": "Dynamic Learning Differential Evolution integrating Knowledge-based Adaptation and Adaptive Diversity Boost for Efficient Optimization.", "configspace": "", "generation": 63, "fitness": 0.35896448916261037, "feedback": "The algorithm DynamicLearningDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.814584207366213, 0.7946778836486663, 0.7796966023511435, 0.8119024195613078, 0.8179185048052452, 0.7874891074572828, 0.8251891895113906, 0.8171654493298668, 0.7859506669819026, 0.6966707974144302, 0.7039354143207781, 0.6645313839648364, 0.6903001074814674, 0.6868262519430836, 0.6643961429129478, 0.6959566178328591, 0.6807111193669594, 0.6640398505196334, 0.3659065723891366, 0.15728959241775609, 0.21447755359280396, 0.14799630015614096, 0.29547326154951703, 0.33939738601885194, 0.14673156442465152, 0.16191297081369627, 0.20153226506587962, 0.13656625924702115, 0.15156493167167595, 0.1243283792119022, 0.1398378108282139, 0.13110095046785608, 0.13200059286185062, 0.11871339179248719, 0.14480932027522542, 0.22247330681916433, 0.9311435010136149, 0.886585636735417, 0.8697450458749557, 0.905849955327457, 0.8761796595738897, 0.8962751137052509, 0.8995498612514503, 0.9026413462050308, 0.9511601372919646, 0.3706537564202924, 0.572019626707324, 0.39582667209042055, 0.32002401968446104, 0.3228498688489486, 0.5058187440338762, 0.4307390602704507, 0.27466088210511974, 0.4359093505349252, 0.7709734241294647, 0.7700683972528052, 0.7445368358127894, 0.76648548024675, 0.7755928201741272, 0.7066852843464537, 0.7477787202532482, 0.768820624886039, 0.7120622112784769, 0.14517065258529072, 0.14780268925882278, 0.15862001142295634, 0.20101593389480998, 0.14703172278971088, 0.14152200246185387, 0.16999398956134615, 0.22276923700409612, 0.19882512694056054, 0.1852074062877811, 0.15402642904359054, 0.1690573479989631, 0.1575383708298005, 0.1824837043559373, 0.14197334845719578, 0.1524055325842959, 0.1809371826247993, 0.26227152167804324, 0.2116878546260701, 0.07554993476184824, 0.12864689175598254, 0.27836143718813733, 0.19293214015052873, 0.08809460025419757, 0.07434741267365974, 0.22436391094100994, 0.21784733068342665, 0.5107328724953958, 0.2025962249999157, 0.16763692808883568, 0.3441594443340431, 0.20862396594661003, 0.3127791907226457, 0.3403584799152516, 0.32586550583650364, 0.31049255920669905, 0.17401422247755705, 0.06217220369151222, 0.06217216905274958, 0.08804422222411612, 0.17765264486799337, 0.14250317916649724, 0.16659068157398338, 0.10461831523695508, 0.1158178461120829, 0.20653908015106803, 0.246495126866489, 0.3400495828169735, 0.24347640705861262, 0.2935127420188871, 0.30925047040180176, 0.2430250264114523, 0.19418606330671806, 0.30285133558243627, 0.6754840247855156, 0.6102575974303156, 0.6488996874938913, 0.5753783153271795, 0.5641952430497659, 0.6657819428960693, 0.7135121122729674, 0.5392121514212362, 0.665198440335536, 0.152532556453695, 0.1379202162567944, 0.11767630253664862, 0.11782626057130696, 0.11773153887908339, 0.11251003689346362, 0.12437326365005141, 0.1421464061412493, 0.10595866295881518, 0.22061920317546257, 0.19859614197055775, 0.22969013326424437, 0.1876512330177288, 0.20234560791937417, 0.18633981949494027, 0.1921468356174334, 0.18068930901333513, 0.1985613697347841, 0.5256358877231861, 0.5062005463551666, 0.4650255020775744, 0.3946493420388515, 0.46283371219792624, 0.45518901858985783, 0.5534722767296041, 0.5212496709852783, 0.45479317514827244, 0.3937288663744747, 0.4058432406367538, 0.35385289073732684, 0.313685323576981, 0.31246193146694534, 0.2771335409080715, 0.3840646448950945, 0.34943600092909954, 0.3192616206208706, 0.20001938333285552, 0.19967586982285535, 0.2119915114826345, 0.21219924146083446, 0.18870630170170932, 0.21526698865484328, 0.2378359851163716, 0.20635018465238797, 0.20074783766522064, 0.38982187769004994, 0.21752964109725903, 0.20181717663942522, 0.3495296142694848, 0.22274855503950852, 0.2862458907399036, 0.20773882809464017, 0.3153222408879828, 0.36961138867663457, 0.2002819584039348, 0.7590366789847339, 0.6574982275678102, 0.6831902489997024, 0.60291552300861, 0.19279191391857353, 0.6689927571898313, 0.16508769215972074, 0.7538046681971149, 0.6121255863111084, 0.7294504350126301, 0.19364330630384197, 0.4351406008311557, 0.664404501967061, 0.6944991418216452, 0.19561424486025147, 0.20425549185157166, 0.1979022422068325, 0.18430754274085492, 0.1741830800057682, 0.1871276818528661, 0.18633711285223542, 0.18897329945962327, 0.17516244728557517, 0.18148993853143747, 0.20530282252690224, 0.1971226477015533, 0.0781853862054388, 0.08018550189259332, 0.0887688482465202, 0.08629097881434267, 0.0814859680681278, 0.08935479295556303, 0.08293264758092411, 0.08286967698043013, 0.07931356844221937]}, "mutation_prompt": null}
{"id": "06a6f066-2dab-46fd-b902-fcda5d18e301", "solution": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.quantum_prob = 0.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.25\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def quantum_operator(self, individual):\n        quantum_noise = np.random.uniform(-1.0, 1.0, self.dim) * self.quantum_prob\n        return np.clip(individual + quantum_noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.quantum_prob = 0.9 if fitness_std < 1e-4 else 0.5\n        self.adaptive_rate = 0.15 if fitness_std < 1e-4 else 0.25\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    quantum_candidate = self.quantum_operator(self.population[i])\n                    quantum_fitness = func(quantum_candidate)\n                    self.num_evaluations += 1\n                    if quantum_fitness < self.fitness[i]:\n                        self.population[i] = quantum_candidate\n                        self.fitness[i] = quantum_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Quantum Population and Adaptive Parameter Tuning for Efficient Global Optimization.", "configspace": "", "generation": 64, "fitness": 0.35385185682456854, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.7879010872595735, 0.7448798158698076, 0.7233950292275607, 0.79040203104549, 0.7441906403546454, 0.7343121455891078, 0.7803215631454173, 0.7310335361549519, 0.7341535490607014, 0.6156901092217901, 0.589029638555282, 0.5506499607821964, 0.6484647975278928, 0.5695204797479483, 0.5559846443817992, 0.6265656372168895, 0.5683594035518904, 0.5392947765961406, 0.143684224748037, 0.11612239876592123, 0.11203039262019177, 0.250239751505804, 0.1805045620928959, 0.11287972903642263, 0.11025500809674682, 0.17951725193460366, 0.10752894251594114, 0.1904705701505609, 0.117090417325318, 0.1196080404122638, 0.1241454128763122, 0.1216081247777383, 0.12212229076559311, 0.11613802893192005, 0.11107527425649455, 0.11777964617692938, 0.9183944570380144, 0.9465427200980748, 0.933751455688616, 0.9244701871860546, 0.9020545630616976, 0.9291366663395156, 0.9620480165344545, 0.9267200765109367, 0.8954388912053147, 0.5120402124237786, 0.43113572169987624, 0.42011418008377555, 0.5249747211366171, 0.46447368502868314, 0.43296257297070906, 0.5434977448063955, 0.4637448807431359, 0.42177850443205833, 0.6761478259568456, 0.6570997026560761, 0.5392880137909266, 0.6954821515686022, 0.6524989851475156, 0.6251679711021999, 0.722959110861894, 0.6537653052708612, 0.6377035252528285, 0.19395937284035059, 0.2516513769151433, 0.16096772434286455, 0.22008397652759815, 0.22246484000953903, 0.18699980304459796, 0.2510623092330938, 0.29906897351206074, 0.3064731706445398, 0.30775307972323507, 0.2408800206684577, 0.21501242074832094, 0.28247930574092406, 0.31711586518254076, 0.2118098576716244, 0.36887773546987124, 0.2798102189144771, 0.21367130461103578, 0.2679276474006824, 0.27104876917505927, 0.23897916594777124, 0.35908290754726346, 0.2760184181809515, 0.25955258447056917, 0.34828003633986615, 0.22207396146926073, 0.20544726361137033, 0.4365429878349719, 0.36608949720171746, 0.4047591532027536, 0.4399162184796601, 0.3000199551888979, 0.3470628104371971, 0.39206316850384926, 0.43594682518258265, 0.40045679277768986, 0.13174256988881183, 0.08340417517743204, 0.16544143531163313, 0.10776270881776306, 0.10488325339713211, 0.12173311882022897, 0.13252615904524523, 0.15818594027811173, 0.09805874626163058, 0.26878476432296283, 0.22892239136074066, 0.25979452833633243, 0.3493052672330229, 0.26941176558814817, 0.26079417612280054, 0.2826651923309682, 0.27204517592191924, 0.23636272997493146, 0.6421465311794892, 0.6243873666615009, 0.6138487202317939, 0.6800538626458577, 0.6090221111919008, 0.6249080619817619, 0.6665376460095067, 0.6250369399844453, 0.562978573954267, 0.09814715128715834, 0.09363120649250345, 0.07849156043581551, 0.0863221346293831, 0.09546631625328661, 0.10328794267710217, 0.09708582590673209, 0.08859401204203043, 0.08521332134923687, 0.16395104115511272, 0.1611114792547631, 0.1505580551680259, 0.1413132619961187, 0.19633572343562078, 0.18085539435143905, 0.18024263419589448, 0.1676297494436514, 0.1670662903513288, 0.4134458631243664, 0.3433840451471183, 0.36481420399151065, 0.3860336138608168, 0.36491793423807617, 0.3850737696650359, 0.44550893654744617, 0.3960708827939269, 0.3849031141634697, 0.31366380189567566, 0.27851574042968874, 0.2333846665456224, 0.29695056111272455, 0.27269907804587146, 0.26102246147651487, 0.3212005522864777, 0.2723457239718381, 0.29517257128239993, 0.1908770546257399, 0.18449554012722913, 0.20622172829653174, 0.18752562485685687, 0.17484415140330367, 0.19901062664425628, 0.17929940106122522, 0.18508433175524852, 0.19058922112713272, 0.43545546609252783, 0.2091214156372846, 0.22656529939236647, 0.21382697302346565, 0.25794758772088966, 0.26778809268678727, 0.19919432012229776, 0.18428955392026847, 0.1833267849163065, 0.6290220862481002, 0.5147459294905469, 0.6160746217798556, 0.638046206135513, 0.5407186294902234, 0.5946074264381453, 0.6266250373954716, 0.6010676672437314, 0.4368583371350575, 0.6971771102123063, 0.20080927423933037, 0.5789172465918333, 0.6419699813599085, 0.3641406493866647, 0.46868722682546227, 0.660373734920012, 0.20362807097459068, 0.19818314279887916, 0.18740999149155702, 0.19216692812935332, 0.1779949464792897, 0.1833678216551211, 0.18576015245060984, 0.19125361604750624, 0.18215402710770956, 0.18376121287578062, 0.19670104793715992, 0.08263249817851359, 0.08043279667837577, 0.07813148236728995, 0.08433800540859249, 0.08610794147354295, 0.07619698753716331, 0.07998211095219343, 0.0793486594749162, 0.07024048312603404]}, "mutation_prompt": null}
{"id": "aa32c626-ac7a-42da-841e-1d32d0a3049d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.25\n        self.adaptive_rate = 0.20\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        feedback_factor = (self.fitness.mean() - self.fitness.min()) / (self.fitness.max() - self.fitness.min() + 1e-9)\n        adjusted_mutation = self.mutation_factor * feedback_factor\n        mutant_vector = rand1 + self.diversity_factor * adjusted_mutation * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)\n        self.crossover_rate = np.random.uniform(0.5, 0.9)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-3 else 0.25\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Adaptive DE with Dynamic Diversity and Feedback-Driven Mutation for Enhanced Convergence.", "configspace": "", "generation": 65, "fitness": 0.2904797416606131, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.5618590643287493, 0.5780941747415307, 0.714492686663919, 0.7428944894873193, 0.8377828333459703, 0.7592050722767733, 0.8472148938258709, 0.8657337907188203, 0.8294703097474423, 0.14837727362441733, 0.06818486623372921, 0.24938582856490055, 0.5617629568585528, 0.21057957153956575, 0.5375656454171844, 0.4443814974557704, 0.22788411059433444, 0.3913497122795696, 0.36688522400764545, 0.16590130014627358, 0.14547389719981607, 0.17048310226482877, 0.22739717240104618, 0.2857288762730258, 0.23659526610208859, 0.17430637101587565, 0.3278392788905641, 0.1433504537049688, 0.09062840835188812, 0.3697680779223761, 0.1555190205542829, 0.14743121187890373, 0.16697633251480237, 0.16549575834284247, 0.14673972500932908, 0.171422423001648, 0.9009000810602533, 0.9047161730394503, 0.8445201264613301, 0.9306810698821486, 0.8857567827423211, 0.8826463287164006, 0.8949258309338188, 0.8924619508698923, 0.8672630969076132, 0.2962169039459074, 0.32025336456272413, 0.30185546379848605, 0.2982414156722184, 0.21667221066989728, 0.31517786975083595, 0.25830776650501386, 0.25313034426352465, 0.27024959997543263, 0.3696854989892109, 0.36406713218244, 0.6913440177827526, 0.2144321664621025, 0.2727215812695959, 0.26104683900814185, 0.2915485237623803, 0.38221080624371695, 0.22940451334517042, 0.12394886018938378, 0.31949729530466264, 0.18698725473247235, 0.15848062358355341, 0.17690881067377717, 0.13347002263954966, 0.18725159893635146, 0.1932780954399802, 0.19553089215519837, 0.1465351684499403, 0.10298389533226382, 0.11414434606647506, 0.12078788820666053, 0.21594563957517598, 0.1679539409497749, 0.14238899175921482, 0.12549589698225705, 0.14031969878850903, 9.999999999998899e-05, 9.999999999998899e-05, 0.06546697000689305, 0.04697302793986624, 9.999999999998899e-05, 9.999999999998899e-05, 0.02940602239065848, 0.03394179137107689, 9.999999999998899e-05, 0.26798871805978053, 0.07847749499874046, 0.1250656583423364, 0.08258300820389108, 0.0724802999049955, 0.23611615907264094, 0.11489887836733903, 0.19372422283438184, 0.15271575778821023, 0.10146817207764092, 0.1369503841059111, 0.20484721483009238, 0.08912688257355694, 0.201600802171088, 0.16002625753432898, 0.13518619801641585, 0.1871189288042543, 0.048043937963773375, 0.1146041800898775, 0.21839545863702325, 0.38235798090149853, 0.23693872173511765, 0.12413464254364648, 0.2399495037092808, 0.21592001178389353, 0.28101497892228344, 0.13834468489666163, 0.46644553361614094, 0.5029788198743319, 0.45825313552920444, 0.5086138218952218, 0.4722098087500789, 0.5558590957262821, 0.4914562213090502, 0.4918588212892455, 0.4438492336788731, 0.12556666113917914, 0.15352799308108356, 0.1228232011163054, 0.15395232246572155, 0.1306348424350361, 0.14521034232005947, 0.09740758507407077, 0.12535701531004428, 0.12330007784299146, 0.23574923207864373, 0.19131584966833193, 0.2007695996036456, 0.22121659486051615, 0.18841808815045857, 0.20003464134597704, 0.2755968317315871, 0.1588444725269601, 0.25305572394204, 0.4152514541444461, 0.24520704140291405, 0.4360514743363948, 0.3927812145822289, 0.4764440748868657, 0.3399199617770915, 0.47775884581555006, 0.45097319803987646, 0.33960926578966477, 0.33086626385576723, 0.2689198662994471, 0.3424649713437493, 0.2256408216090856, 0.28529568382210735, 0.3081319056831292, 0.27989936172260377, 0.3464191811726146, 0.32681452385786913, 0.20286654173834062, 0.21944892304692654, 0.1991979503390957, 0.1985085632886291, 0.2259569444438987, 0.223201004863405, 0.2155209938316519, 0.20991837976600713, 0.22410931014176727, 0.21731871256856583, 0.23269798069299563, 0.21770595070919474, 0.3570177342309827, 0.20571613144544698, 0.24016978270822376, 0.1951513664258634, 0.25022277570566487, 0.24280828300460688, 0.6729283874145637, 0.18291787487019795, 0.6966514562157269, 0.19648070746923518, 0.19552825361756565, 0.6287210515423755, 0.18144483569504688, 0.7207965860043528, 0.8033073862717309, 0.5062625900861355, 0.20615845274760025, 0.3951595855778247, 0.3951087832689324, 0.4284861510824046, 0.456106258101008, 0.5010658982539081, 0.45349152092718936, 0.20482421806149698, 0.19322737654251843, 0.21078159818050946, 0.2008385879104525, 0.18822725464677392, 0.22284917213989186, 0.19819442167044632, 0.18585662227840394, 0.18227583070881304, 0.19608419058992377, 0.08546523537223183, 0.08573967561447937, 0.08839337229383204, 0.08868093888604267, 0.08131066010343146, 0.0816092504418684, 0.08605265666274331, 0.08211410234344152, 0.08731724321381285]}, "mutation_prompt": null}
{"id": "0c3547ea-f9c9-481e-9d0b-d2ec51589eea", "solution": "import numpy as np\n\nclass StochasticGradientEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        gradient = (rand2 - rand3)\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * gradient\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.25)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.9)\n        self.crossover_rate = np.random.uniform(0.6, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.6\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "StochasticGradientEnhancedDE", "description": "Stochastic Gradient Enhanced Differential Evolution with Adaptive Diversity and Dynamic Population Size for Robust Global Optimization.", "configspace": "", "generation": 66, "fitness": 0.3698363823752163, "feedback": "The algorithm StochasticGradientEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.8298240249864662, 0.8315907606664666, 0.8162939152296874, 0.8172783208500598, 0.8444654632608555, 0.8119408151211657, 0.8179291314506224, 0.8529491629249905, 0.8081378392465459, 0.6769466310122195, 0.7321926111986305, 0.7036670957751017, 0.69604036444516, 0.7147327347174963, 0.7048978291592446, 0.7093603278024305, 0.7241205482996687, 0.7043274078876345, 0.41414349850675736, 0.2536375317298293, 0.39628024465480494, 0.26828960073714136, 0.15839416470356105, 0.18253207705363916, 0.16229858409657594, 0.4704278639458431, 0.19644203825392792, 0.13182776729871037, 0.1430902104126831, 0.4424565113494785, 0.25342996832857356, 0.14485008454710824, 0.1299261897269558, 0.419388305929451, 0.14911714274369592, 0.15886325292161907, 0.908009889729503, 0.9263556844836098, 0.9463723386550962, 0.9039274664079001, 0.9016819310354206, 0.9153816502045033, 0.9156500976158369, 0.896876879820424, 0.9099812350327744, 0.3256067695822247, 0.3487044968173598, 0.29397544751481675, 0.409845732616562, 0.313938160224008, 0.28753574209982435, 0.3149655344449853, 0.4508333077822344, 0.3166404800662491, 0.7675489392369549, 0.7561738575869716, 0.8017102853519327, 0.7882258978528698, 0.8757261643267144, 0.6425752684875832, 0.7734561225262282, 0.8708700409596838, 0.7610804246198841, 0.18159563011322366, 0.2593823384859546, 0.14544935024638495, 0.16368676338089538, 0.192011595388886, 0.17193907549480647, 0.23860342486716501, 0.14807617056669808, 0.18959402486703913, 0.15879835598295922, 0.15760033929126127, 0.2821194755106238, 0.14539190386150747, 0.17553527980524208, 0.20175405990902218, 0.13505366993639578, 0.17342005376803504, 0.2271406688402673, 0.19745952816125, 0.3513149986840234, 0.22689135362469892, 0.15857689935801988, 0.06775626167531923, 0.0910023848697229, 0.10337182517519672, 0.11471630897655194, 0.19196727369383504, 0.4605821373561786, 0.4090368808771413, 0.1462909849448395, 0.3240359178804252, 0.30338696783644614, 0.21668686082892852, 0.436049893342662, 0.27394047010478173, 0.21932641574987854, 0.0871188876327409, 0.09746390571354058, 0.19069134503508256, 0.0880136642928987, 0.15937847105983916, 0.11386802711914401, 0.19042130360059373, 0.16747334122765645, 0.14892531202674364, 0.2678380669699565, 0.3278217568486146, 0.2153519986733834, 0.2540629754143824, 0.2746824038522685, 0.31498665798830194, 0.28702727149467977, 0.17375566491074956, 0.251712097059288, 0.6038428230797523, 0.6980930204781377, 0.7634138818741154, 0.6506430720347409, 0.7340122161075476, 0.7215084308679094, 0.6537098904851761, 0.6527797736314207, 0.6757715271966239, 0.11760144600158651, 0.1228473302565184, 0.11227123055236954, 0.10464980692212755, 0.1189647686222346, 0.13203846311524614, 0.12611518642822028, 0.15949729010124758, 0.11053197900155065, 0.2533730393291035, 0.19995789261865105, 0.22197419799643348, 0.170940095921841, 0.20037428608520658, 0.23708595495566165, 0.2223645383807279, 0.20311528627781394, 0.1771631987908655, 0.4498799280773085, 0.5544116824946604, 0.45616057180650404, 0.5412580042035433, 0.560118779263734, 0.4927803888679192, 0.5369021809628891, 0.6135450615564164, 0.5349329576799173, 0.3235719278071739, 0.4246662541569679, 0.36423839605315456, 0.3148190898702, 0.28518977469880347, 0.30653918821258885, 0.34446443564954166, 0.463619525078086, 0.4255253361132003, 0.21176209764194387, 0.19565178463610977, 0.20551299486513286, 0.20243298189692183, 0.21398599107889593, 0.19589300106209573, 0.23814166948957805, 0.22871976845145114, 0.19260672937074275, 0.20558199719857684, 0.4156275420112344, 0.46417810635775314, 0.49837332288421654, 0.5409955109544643, 0.20348749295134516, 0.22321428375258434, 0.496858232720361, 0.19398630564185237, 0.1927248823524811, 0.8004334835701203, 0.19544408876095432, 0.8175182779064707, 0.1929735794739682, 0.7252438971776851, 0.15839173454781763, 0.16407005022166488, 0.7095419605150706, 0.773426362858376, 0.7379720856110796, 0.40536152150049987, 0.16520936102144512, 0.20027798682107023, 0.16675656274237427, 0.5872239597400791, 0.15259995364877954, 0.20145037224286033, 0.18627849213242775, 0.18661842428995934, 0.17377124532240829, 0.1777602323471903, 0.17522019135050415, 0.19621701259469337, 0.19496389163243966, 0.19219700508308213, 0.18592539818315346, 0.08284366288456402, 0.08235020291097628, 0.08149148983374221, 0.08944844827001774, 0.08136689067970415, 0.08354043462504146, 0.09370300785025598, 0.08258068460442902, 0.08160927467555379]}, "mutation_prompt": null}
{"id": "62498fbb-9b74-4bba-aa6a-00b42b6beab8", "solution": "import numpy as np\n\nclass FrequencyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased population size for better exploration.\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted diversity factor for improved exploration.\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9  # Higher crossover rate for increased recombination.\n        self.local_search_rate = 0.35  # Increased local search rate to exploit solutions.\n        self.adaptive_rate = 0.3  # Higher adaptive rate to quickly adjust parameters.\n        self.success_count = np.zeros(self.population_size)  # Track success frequency of each individual.\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.4)  # Increased noise scale for greater variance.\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # More aggressive mutation factor adaption.\n        self.crossover_rate = np.random.uniform(0.7, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                    self.success_count[i] += 1\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n                        self.success_count[i] += 1\n            self.adapt_parameters()\n            if np.random.rand() < 0.1:\n                self.population_size = max(30, int(self.population_size * 0.9))  # Minimum size adjusted.\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n                self.success_count = self.success_count[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "FrequencyAdaptiveDE", "description": "Advanced Evolutionary Optimization using Frequency-Based Parameter Adaption and Hybrid Search Strategies.", "configspace": "", "generation": 67, "fitness": 0.35586056243859027, "feedback": "The algorithm FrequencyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.7432993011208318, 0.7362030333767055, 0.7787428808493394, 0.7364026870885483, 0.7448260679056641, 0.7852160552059495, 0.7342890868344172, 0.7466379239145846, 0.7870614909443149, 0.5438409518142754, 0.5543827729714401, 0.6181780348332154, 0.557823846492126, 0.5876095423937823, 0.6349566654729197, 0.5306332447280488, 0.5597349209247627, 0.6435640914155996, 0.11746279669902282, 0.11391653897571574, 0.12115377911726444, 0.11058543583913183, 0.11296770833761971, 0.11017111855584827, 0.11422337183771925, 0.10161528005560772, 0.1358046646926132, 0.1015385640204588, 0.1224077375525141, 0.1403453982597992, 0.10456348232773505, 0.09328608687386564, 0.1214294712135836, 0.09224067987175966, 0.12119822650899492, 0.1033053268454982, 0.9064100269985365, 0.8897475952925016, 0.8973907447807925, 0.9002662557924096, 0.9004132098302453, 0.8973265185425101, 0.9391818188061134, 0.9114225831007622, 0.8869154279005009, 0.3821196990620992, 0.45971425329571236, 0.5215122875354619, 0.378702544494372, 0.4071073701929021, 0.4726301401221146, 0.44801288102635917, 0.38642434381936985, 0.46031457016162514, 0.6442738239823607, 0.6863081887465577, 0.6890769205219542, 0.6591257397455745, 0.694892458323185, 0.7375408988478118, 0.663270814417011, 0.7109959982047767, 0.7192518166239116, 0.18142025316358668, 0.18327554368067056, 0.19782756020486325, 0.1480347304143368, 0.2551780876353582, 0.37751566678473425, 0.2123949772699153, 0.20900966754257388, 0.2349204781881835, 0.16554385103485425, 0.19891131291094977, 0.16405770678357656, 0.18298929084074433, 0.17983869561139143, 0.27234836875987267, 0.20879457504339693, 0.22098611494070497, 0.19380794387078937, 0.2632613702539165, 0.27863371156924643, 0.39223758286740007, 0.32697421010888916, 0.29142041640523253, 0.40872725083413675, 0.29957362781370755, 0.32434661159998046, 0.3021080349809969, 0.4063097148336611, 0.43700787301072774, 0.49367244530785426, 0.34168310016196046, 0.41807248532576824, 0.447476034277965, 0.45655584955930495, 0.45751601668018815, 0.5557963663264462, 0.12751676954579783, 0.15025114039431864, 0.16177757022421047, 0.12069148705321497, 0.14023518051551886, 0.19168291472044308, 0.09039030274477777, 0.09696436856022994, 0.16216354272090372, 0.23113313086718845, 0.2489531702295884, 0.31051034962046253, 0.26684712383047804, 0.2785987801387694, 0.3231508796759409, 0.24567737144023472, 0.25598517675460786, 0.29320196382383434, 0.5992621614939813, 0.6114684232660295, 0.6889740835439992, 0.6068785644393686, 0.6155157538917667, 0.6874065828113982, 0.6266031777740272, 0.6431944155194536, 0.7047619378976733, 0.0972115028902728, 0.09415985955252204, 0.1073915892170536, 0.10254042192523516, 0.09322158639106781, 0.09542520019637035, 0.09377238505390673, 0.10776232736220592, 0.09829115107254893, 0.18774875007452074, 0.17568788693373516, 0.17633869364885546, 0.16366045280953712, 0.15904096412776003, 0.1760307797460482, 0.17266648330066803, 0.20196368671916398, 0.17932067466895973, 0.3662900024605481, 0.35056947358812074, 0.3790980396189578, 0.38663362968105563, 0.3934396532277632, 0.41569794185395625, 0.4053152859378665, 0.37795787138025316, 0.4674682190449224, 0.25315451060772753, 0.2921565776264584, 0.3447554448292266, 0.2722567095186277, 0.3078639118961859, 0.3335439582365316, 0.2645842664356418, 0.3077643577409399, 0.3281402549851846, 0.2218578097006163, 0.2384335863163487, 0.18097769425539179, 0.21937831821864218, 0.18154707903077094, 0.21207324019403184, 0.2026122379406471, 0.18502476440080695, 0.1999873549498512, 0.18330761291822806, 0.2892421267514401, 0.1976675342788825, 0.3523984218342382, 0.18848330669263158, 0.1950705626364947, 0.18266042695612383, 0.1869521559210896, 0.21736075366282526, 0.702819656246956, 0.6706195549628776, 0.712635010131625, 0.5999056349003932, 0.6237584627076038, 0.5989282582254738, 0.5835002305126891, 0.18788938816465028, 0.5125241276898329, 0.6312432670639803, 0.5648067740321976, 0.1639425995863505, 0.3931014705634941, 0.5333240025015427, 0.16861083092238782, 0.44611027756387645, 0.6471505825297388, 0.6488347008111623, 0.19246336454551527, 0.18311032979321995, 0.17735535885668086, 0.22094765739942634, 0.1872616964188546, 0.19115378017764106, 0.19077578795082284, 0.1935797521242475, 0.18716688551268879, 0.07608671758444585, 0.07484373983579062, 0.08258494836049945, 0.07531848549082754, 0.08083859975193008, 0.076959328269123, 0.08400638955515638, 0.07549467798876408, 0.08227862084867144]}, "mutation_prompt": null}
{"id": "df940f75-86de-4faa-9845-d042cca220e0", "solution": "import numpy as np\n\nclass OptimizedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.6\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.3\n        self.adaptive_rate = 0.25\n        self.elite = None\n        self.elite_fitness = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)  # Adjusted noise scale\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.3, 0.7)  # Adjusted mutation factor range\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Adjusted crossover rate range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.5  # Adjusted diversity factor\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3  # Adjusted adaptive rate\n\n    def preserve_elite(self):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        if self.fitness[best_idx] < self.elite_fitness:\n            self.elite = best\n            self.elite_fitness = self.fitness[best_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        self.preserve_elite()\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            self.preserve_elite()\n            if np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n        if self.elite_fitness < np.min(self.fitness):\n            best_idx = np.argmin(self.fitness)\n            self.population[best_idx] = self.elite\n            self.fitness[best_idx] = self.elite_fitness\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "OptimizedAdaptiveDE", "description": "Optimized Adaptive Differential Evolution with Dynamic Mutation Strategy and Elite Preservation for Enhanced Convergence.", "configspace": "", "generation": 68, "fitness": 0.32456956775341683, "feedback": "The algorithm OptimizedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.860803165358005, 0.8342857197150234, 0.8353118406788658, 0.8385682676354291, 0.8543701710156131, 0.8431806564846809, 0.826035496832666, 0.8565103090350616, 0.8175557634296677, 0.019417545027153538, 0.7680495787060915, 0.5903598468393669, 0.31505095418524964, 0.579613046290832, 0.18021810224027845, 0.30131671828129003, 0.7522572505077123, 0.11016248900500158, 0.15557956912729665, 0.5058665755293379, 0.3691401838302809, 0.16405644611104508, 0.3096335778087529, 0.5672444653143651, 0.23037330416289237, 0.16662999900918896, 0.34300732896179886, 0.13952837019990383, 0.11277285978188889, 0.1350675320762491, 0.16820535935133119, 0.1352804759919929, 0.14487117190591503, 0.13774836307306182, 0.17176365959177908, 0.12290551832157759, 0.9173806863773799, 0.7870410901932148, 0.8839492920581722, 0.8778097468673641, 0.8939594537804627, 0.8660724395451449, 0.8913564054571661, 0.881060534636221, 0.848715254514303, 0.334278172565607, 0.3148116635895172, 0.30356384412369364, 0.37911502739366865, 0.3190056623644473, 0.325483767015332, 0.31175694779451535, 0.2763752570246212, 0.3380382082405585, 0.8330829612970656, 0.5073599208666892, 0.5265743937058763, 0.8309253090612161, 0.3469342568863861, 0.8273752464447992, 0.17068199718828203, 0.5199205483117342, 0.8113613880548198, 0.1913788812859064, 0.12562481107508572, 0.22490341751574916, 0.213473982547694, 0.1726317708983397, 0.3030916865283072, 0.1505396280890604, 0.12504482376133252, 0.14521160100007002, 0.20038455843495573, 0.3318956181602709, 0.14790841257380383, 0.18874743388669013, 0.1786523920979196, 0.12930479564199648, 0.15987628912636664, 0.18532094007396216, 0.15466134912338425, 0.1481349689730036, 9.999999999998899e-05, 0.09824855976900071, 0.13190746475101967, 0.090314460273344, 0.029637541334333606, 0.05054021760602101, 0.06243998730201272, 0.07561051010436859, 0.2629705522136232, 0.13919496062892556, 0.2911308428337842, 0.10712135051907468, 0.1398735048810582, 0.049545783954477285, 0.19383038417140952, 0.2125822498930805, 0.1534831168420986, 0.10953406312392666, 0.0629501044070987, 0.1003012711296215, 0.07397409543310185, 0.17573120218900407, 0.14067819681745553, 0.18203145143576072, 0.07523969667796426, 0.11802477207230799, 0.26726364788485957, 0.14473957894978617, 0.3634636666032458, 0.13402609643752295, 0.19599805848182306, 0.13746222650230444, 0.2287788493998486, 0.19852873775476187, 0.12825483277998395, 0.524369984570247, 0.6831444015468331, 0.5451117322221802, 0.5652253154538658, 0.5469873117956212, 0.6179264991025847, 0.5107264287637274, 0.6356786923356323, 0.635110895716996, 0.13062684375152034, 0.13028893391181884, 0.14498427612466325, 0.1446163709652295, 0.13737467740451081, 0.16613128216475093, 0.1322592310110462, 0.14664378846795212, 0.13677952068091093, 0.2541784257208871, 0.3083532283159519, 0.22116205260377642, 0.23509009505117784, 0.28357871053193107, 0.22568359630508394, 0.20753010401300376, 0.22548297767150238, 0.24417768781536953, 0.39960167892736154, 0.4968767081141272, 0.3791162023125666, 0.42479991435690034, 0.3560732840815143, 0.4504181911149253, 0.49158100220387524, 0.43177622135965543, 0.43421413014571264, 0.2635429525201023, 0.4666571534019671, 0.34940559269597093, 0.34323932343539765, 0.20554019058412454, 0.41705233636633665, 0.24648737798472575, 0.3177317764630573, 0.41447124094552545, 0.20877077702760893, 0.21017966767176077, 0.2106622062521768, 0.22067277503110683, 0.22833101866794014, 0.20553346643517256, 0.23176865347557296, 0.2279757829857295, 0.2211241692820336, 0.21275476082978717, 0.2169437636293815, 0.2321687784681331, 0.19812459238416413, 0.23773018790563383, 0.23632509541180502, 0.20039881401982818, 0.19628394619923684, 0.20467476182389455, 0.19853241348613526, 0.18241732921751186, 0.826607790126038, 0.8214101304072465, 0.19797459680521823, 0.8355838183593889, 0.18042142973853403, 0.715069753872134, 0.8384435443164628, 0.44253279033271875, 0.20668494153271844, 0.39470144563660414, 0.4914278207187879, 0.20554130547035843, 0.5894028515788821, 0.4196341091947696, 0.5905385023262555, 0.16345470509232385, 0.17061057184309047, 0.18588989498441, 0.18513206302379226, 0.17769115181224027, 0.18181934578463665, 0.2004316039091304, 0.18120978672431298, 0.21549082297259015, 0.1858474540912204, 0.08925977897764148, 0.08401586960467067, 0.08926057970854928, 0.0848523039643293, 0.09494015971927783, 0.0876297918550556, 0.09138349725307238, 0.09597168566020631, 0.08794888337731332]}, "mutation_prompt": null}
{"id": "89af3550-dd33-45cd-a94c-c8fd4626c172", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Slightly increased\n        self.mutation_factor = 0.6  # Adjusted for balance\n        self.crossover_rate = 0.85  # Minor increase\n        self.local_search_rate = 0.35  # Enhanced exploration\n        self.adaptive_rate = 0.2  # Modified adaptive control\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.15, 0.35)  # Enhanced noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # Broadened range\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Adjusted range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.95 if fitness_std < 1e-4 else 0.7  # Modified condition\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3  # Adjusted rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.15:  # Slightly increased reduction chance\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Randomized Local Search Intensification for Enhanced Convergence Performance.", "configspace": "", "generation": 69, "fitness": 0.3921179394578385, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "a65a194b-15c9-41f1-a9c2-2c88d192406b", "metadata": {"aucs": [0.851558990208267, 0.851339156788812, 0.8412127934198192, 0.8457943487973808, 0.8498801613550245, 0.8374282813289611, 0.8423936078808862, 0.8538853231614123, 0.8243171949318011, 0.7418093139119175, 0.7788554167513038, 0.7105978565638564, 0.7490707843031397, 0.784107613442353, 0.7150404779866686, 0.752771184623299, 0.7674706205326123, 0.7179321247735995, 0.42168474724535543, 0.4149202140085294, 0.3620484992714019, 0.23320240204355103, 0.15028819940275207, 0.15084121527749905, 0.1919287795118908, 0.15705705664956426, 0.2989149982610918, 0.25409040517750614, 0.1492776067896049, 0.31473131763773443, 0.12385236411529421, 0.1241224995574497, 0.1192102436033039, 0.12059414307889926, 0.12441069930656812, 0.13520143749162872, 0.9373820106588975, 0.9238526914435236, 0.8957036116059425, 0.9143630541034644, 0.8884192295526705, 0.9113266843960929, 0.90669705338759, 0.9067366574624588, 0.9156979935036059, 0.6507069433198442, 0.4076904855401806, 0.6270919115659765, 0.5783644192782558, 0.6096926629960144, 0.444473353356738, 0.5016768542383769, 0.634022675044862, 0.47605874830246786, 0.7994174694889631, 0.8457032563351425, 0.7971308896036282, 0.358739145402857, 0.8443764434709901, 0.7827116855427615, 0.7909554616360794, 0.8382185673226127, 0.7849204393466733, 0.27051995365835046, 0.21344145472794673, 0.1708609288791444, 0.13303267750568193, 0.19479486023323578, 0.3432145995642297, 0.20204403981487795, 0.1316449898691211, 0.1835605046178782, 0.18090399968920134, 0.1454611176393864, 0.15014663725485167, 0.1518078341757746, 0.20914793972398482, 0.15884340796321617, 0.20399256545893618, 0.17523529772599156, 0.15649947484144344, 0.14913622861447906, 0.08588990230895144, 0.34451716601599613, 0.3012865247977855, 0.012779721034614333, 0.491455187386981, 0.28203620865128454, 0.12793583774334671, 0.35618709444865826, 0.2373773543735016, 0.4877024129302673, 0.29577229469195754, 0.16246857395210335, 0.3191766339633516, 0.3863404893119122, 0.6617813702108778, 0.370347822844161, 0.390327802218567, 0.16128689296201282, 0.08664351766953349, 0.3002824666917233, 0.1122469375903754, 0.18792265173860168, 0.09266355908612312, 0.22398149108002463, 0.16652793177920144, 0.17744268293593612, 0.22765960060366774, 0.4670543586684228, 0.31343421225327417, 0.5038145123380882, 0.36428644226185924, 0.3401727201828548, 0.3195539482216935, 0.24994607088564658, 0.1762064887854271, 0.7604873024109672, 0.7753829853197423, 0.7425038088537284, 0.782659807095963, 0.6145853301344766, 0.7375366455771297, 0.7647379951069602, 0.7568804237443277, 0.7661852206064893, 0.1000067288018407, 0.11411925275471424, 0.1072516531970985, 0.12075829312091668, 0.10962246960006561, 0.11445430484714181, 0.11917982439914265, 0.10225133505568851, 0.12203484828371569, 0.43094500541538794, 0.2540776922760767, 0.22957005249878726, 0.2656412246445281, 0.21984232476230536, 0.24333435047895613, 0.18204120558119996, 0.34238853103301614, 0.17328233844117635, 0.49461812294799556, 0.5373979611715991, 0.4640871851088295, 0.5473759236698575, 0.5704776001337151, 0.5013811107965531, 0.5339906166569754, 0.6384333378439975, 0.4672148402069294, 0.3966321333513425, 0.33899915882387566, 0.43001283535885015, 0.36508285236850857, 0.36888790591188036, 0.3485504259260319, 0.39003104782214093, 0.49719580900525184, 0.4394862077048134, 0.1986776230789037, 0.19430776145174344, 0.21476015626495926, 0.2340097005096612, 0.21257551409514708, 0.20536501322559841, 0.21278535008741672, 0.1811241841623673, 0.20262118878067836, 0.2061315760540411, 0.2276408942343464, 0.21731912408153764, 0.20300374548085687, 0.5393429323036485, 0.2179452405017921, 0.2196096061557955, 0.22185838901022226, 0.4836367955246631, 0.1757953642427712, 0.17394460152930602, 0.1511454456650192, 0.7609317025977291, 0.8198890200709592, 0.7568679462297363, 0.17872637777935885, 0.18517907568801362, 0.7987386008191664, 0.7677610827553207, 0.20935435177693074, 0.7799734647971588, 0.7543468231723681, 0.20510785533199016, 0.7451234960572191, 0.20025010128552845, 0.16339711827067316, 0.20482896601247935, 0.18747471961604856, 0.1862351122338558, 0.17924264804067536, 0.1826173540742989, 0.1767866082991184, 0.2000355530266128, 0.1856867783498498, 0.19039374127415287, 0.19667327312080474, 0.08885622507550084, 0.08136459659082962, 0.08103978040347393, 0.08700147729628682, 0.0843838222048986, 0.08074480717493171, 0.09216713272076327, 0.0775462899220487, 0.09076291385923874]}, "mutation_prompt": null}
{"id": "b338999d-fffe-453a-8d75-47a7f35025a1", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.75  # Adjusted for enhanced diversity\n        self.mutation_factor = 0.5  # Slightly reduced for balance\n        self.crossover_rate = 0.8  # Minor reduction for exploration\n        self.local_search_rate = 0.4  # Increased local search rate\n        self.adaptive_rate = 0.25  # Modified adaptive control\n        self.dynamic_population = True  # Enable dynamic population adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)  # Adjusted noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.4, 0.8)  # Broadened mutation range\n        self.crossover_rate = np.random.uniform(0.6, 0.95)  # Adjusted crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.75  # Modified condition\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35  # Adjusted rates\n\n    def dynamic_population_adjustment(self):\n        if self.dynamic_population:\n            self.population_size = int(self.population_size * 0.9)\n            self.population_size = max(25, self.population_size)\n            self.population = np.resize(self.population, (self.population_size, self.dim))\n            self.fitness = np.resize(self.fitness, self.population_size)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.2:  # Adjusted reduction chance\n                self.dynamic_population_adjustment()\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Population Adjustment and Self-Adaptive Crossover for Improved Optimization Robustness.", "configspace": "", "generation": 70, "fitness": 0.3633439744444247, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "89af3550-dd33-45cd-a94c-c8fd4626c172", "metadata": {"aucs": [0.8249762359113234, 0.7858908605024661, 0.8364119457225205, 0.8186070061975452, 0.7809987658467307, 0.8152001242718941, 0.8309288555398425, 0.785093802307088, 0.8095878328491602, 0.7063495285512784, 0.652477406320392, 0.7190713697380036, 0.6859092744729104, 0.614944620841261, 0.7361852480879838, 0.6911098453949203, 0.6484844364495632, 0.737588580751201, 0.4890326058651262, 0.20810718858301192, 0.16215191312084754, 0.36638319334137437, 0.2324327882161914, 0.23569291393265457, 0.18034382810991723, 0.2510927635838698, 0.22157960467314375, 0.11497034832094033, 0.14300945666919884, 0.13413070551163087, 0.20846593206667863, 0.19347098603969548, 0.20142340810764314, 0.154062945145644, 0.12473324288456822, 0.13981872385525895, 0.8867761562566682, 0.8644551161952811, 0.949703621505382, 0.8687603650080962, 0.8895227576931164, 0.901759590339889, 0.9143484537042809, 0.895541033584868, 0.913315685447879, 0.5436814894960842, 0.5121332443593478, 0.3148888627569719, 0.5668422557334551, 0.5105619355621646, 0.6120392183924309, 0.30026609595251386, 0.3030643750609815, 0.5350791603878073, 0.7216178003038476, 0.7076270425987874, 0.738852172424027, 0.7389305954339966, 0.6746884349753479, 0.7705921614701102, 0.761564403072612, 0.7153389888944879, 0.7524670751114558, 0.18958148247573559, 0.19925138018944122, 0.16700855056911934, 0.15398779333737744, 0.18393791235220747, 0.15834827347874958, 0.1489554557290772, 0.19444864934520734, 0.15345385666500877, 0.31545068480632255, 0.2346730090502489, 0.2377891312170929, 0.15246944877662005, 0.1488204309350396, 0.31774169805303276, 0.16741188796139572, 0.15235662009854745, 0.143658106769476, 0.15212367421632933, 0.09728421317941016, 0.3022788582189795, 0.20758736182234483, 0.26059059436290066, 0.19630858250518224, 0.2341894121671103, 0.3031208171677434, 0.18975077138251895, 0.3376521100943254, 0.42736635890019625, 0.33770274019888324, 0.1318264413554776, 0.3359190463670817, 0.22002540087111877, 0.3023004389551375, 0.4608786203164953, 0.47701109871696934, 0.17211340426855937, 0.17851992103586434, 0.09104441778280892, 0.11951482865629581, 0.12952385078649642, 0.10948939421735471, 0.17342337850522893, 0.14049621925199685, 0.14075263588058062, 0.25554039771409076, 0.2722280902056805, 0.19243098945645765, 0.29099927264890135, 0.311666850763788, 0.3616478959061966, 0.21113517567583018, 0.20295821047786233, 0.29833293981515907, 0.6662326653459887, 0.6540753395688987, 0.6942931401569306, 0.6512609657537003, 0.6377575833515746, 0.6985155856579709, 0.610687058604981, 0.6463481046029762, 0.5942381180940818, 0.13089385845500434, 0.10981958037944584, 0.1193746962338591, 0.1257730065682845, 0.11702747731519425, 0.10911007848517418, 0.10425889074349848, 0.11285365261251867, 0.10638770326653413, 0.18520786924135701, 0.2081821814143433, 0.19175927472499565, 0.16820611527865548, 0.15970033930302885, 0.1767834876428961, 0.18022461087000374, 0.1855622193872256, 0.210369263391195, 0.4350764613594499, 0.37323516699403125, 0.45520327406616656, 0.46639703796918264, 0.42025863875937053, 0.43286027860494336, 0.5612782471089555, 0.4702089719943814, 0.5585002120941251, 0.31549277446210466, 0.3042589250039287, 0.2885100524580473, 0.3395210864705722, 0.33049353724125585, 0.30684147384165994, 0.38135621118643925, 0.3521462033078636, 0.37695969737599355, 0.19718214830499559, 0.20685338984217583, 0.19400861349545506, 0.22451614289396038, 0.18640490574435553, 0.19949544725782287, 0.20294829591755337, 0.193329174892114, 0.19509448666515106, 0.26466481996833535, 0.25402587704459634, 0.18778569107557086, 0.515524058988565, 0.20383198457808982, 0.2358664880694049, 0.42664877453551475, 0.1976960510024688, 0.43680148077750947, 0.18025855552151893, 0.178385309331332, 0.20520882518229433, 0.7876779448455453, 0.6938202533035497, 0.7264050376754798, 0.4758737344126044, 0.4902791577254486, 0.7587116463431087, 0.7305039560879547, 0.19988734971741795, 0.16201885715779285, 0.19859197692671093, 0.19983343858551872, 0.6456975816632884, 0.20302508424923682, 0.6666645430660595, 0.20566260382186163, 0.17948056505594412, 0.17051932765612388, 0.18309349387371843, 0.18018823993217326, 0.1777944380053057, 0.1917452868830799, 0.18085750707051906, 0.19080349178089306, 0.1870787986820639, 0.08262379462007607, 0.07597110343836211, 0.07826602989365583, 0.08569903690670977, 0.08544398881096948, 0.0724281019950671, 0.08952750913191232, 0.08289559796134782, 0.082982199716232]}, "mutation_prompt": null}
{"id": "c7a16e43-65c6-41dd-ac74-62fa64889736", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Slightly increased\n        self.mutation_factor = 0.6  # Adjusted for balance\n        self.crossover_rate = 0.85  # Minor increase\n        self.local_search_rate = 0.35  # Enhanced exploration\n        self.adaptive_rate = 0.2  # Modified adaptive control\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        offspring = np.where(mask, mutant, target)\n        return offspring\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.15, 0.35)  # Enhanced noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # Broadened range\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Adjusted range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.95 if fitness_std < 1e-4 else 0.7  # Modified condition\n        self.adaptive_rate = 0.2 if fitness_std < 1e-4 else 0.3  # Adjusted rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.15:  # Slightly increased reduction chance\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Randomized Local Search Intensification for Enhanced Convergence Performance.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "89af3550-dd33-45cd-a94c-c8fd4626c172", "metadata": {"aucs": [0.851558990208267, 0.851339156788812, 0.8412127934198192, 0.8457943487973808, 0.8498801613550245, 0.8374282813289611, 0.8423936078808862, 0.8538853231614123, 0.8243171949318011, 0.7418093139119175, 0.7788554167513038, 0.7105978565638564, 0.7490707843031397, 0.784107613442353, 0.7150404779866686, 0.752771184623299, 0.7674706205326123, 0.7179321247735995, 0.42168474724535543, 0.4149202140085294, 0.3620484992714019, 0.23320240204355103, 0.15028819940275207, 0.15084121527749905, 0.1919287795118908, 0.15705705664956426, 0.2989149982610918, 0.25409040517750614, 0.1492776067896049, 0.31473131763773443, 0.12385236411529421, 0.1241224995574497, 0.1192102436033039, 0.12059414307889926, 0.12441069930656812, 0.13520143749162872, 0.9373820106588975, 0.9238526914435236, 0.8957036116059425, 0.9143630541034644, 0.8884192295526705, 0.9113266843960929, 0.90669705338759, 0.9067366574624588, 0.9156979935036059, 0.6507069433198442, 0.4076904855401806, 0.6270919115659765, 0.5783644192782558, 0.6096926629960144, 0.444473353356738, 0.5016768542383769, 0.634022675044862, 0.47605874830246786, 0.7994174694889631, 0.8457032563351425, 0.7971308896036282, 0.358739145402857, 0.8443764434709901, 0.7827116855427615, 0.7909554616360794, 0.8382185673226127, 0.7849204393466733, 0.27051995365835046, 0.21344145472794673, 0.1708609288791444, 0.13303267750568193, 0.19479486023323578, 0.3432145995642297, 0.20204403981487795, 0.1316449898691211, 0.1835605046178782, 0.18090399968920134, 0.1454611176393864, 0.15014663725485167, 0.1518078341757746, 0.20914793972398482, 0.15884340796321617, 0.20399256545893618, 0.17523529772599156, 0.15649947484144344, 0.14913622861447906, 0.08588990230895144, 0.34451716601599613, 0.3012865247977855, 0.012779721034614333, 0.491455187386981, 0.28203620865128454, 0.12793583774334671, 0.35618709444865826, 0.2373773543735016, 0.4877024129302673, 0.29577229469195754, 0.16246857395210335, 0.3191766339633516, 0.3863404893119122, 0.6617813702108778, 0.370347822844161, 0.390327802218567, 0.16128689296201282, 0.08664351766953349, 0.3002824666917233, 0.1122469375903754, 0.18792265173860168, 0.09266355908612312, 0.22398149108002463, 0.16652793177920144, 0.17744268293593612, 0.22765960060366774, 0.4670543586684228, 0.31343421225327417, 0.5038145123380882, 0.36428644226185924, 0.3401727201828548, 0.3195539482216935, 0.24994607088564658, 0.1762064887854271, 0.7604873024109672, 0.7753829853197423, 0.7425038088537284, 0.782659807095963, 0.6145853301344766, 0.7375366455771297, 0.7647379951069602, 0.7568804237443277, 0.7661852206064893, 0.1000067288018407, 0.11411925275471424, 0.1072516531970985, 0.12075829312091668, 0.10962246960006561, 0.11445430484714181, 0.11917982439914265, 0.10225133505568851, 0.12203484828371569, 0.43094500541538794, 0.2540776922760767, 0.22957005249878726, 0.2656412246445281, 0.21984232476230536, 0.24333435047895613, 0.18204120558119996, 0.34238853103301614, 0.17328233844117635, 0.49461812294799556, 0.5373979611715991, 0.4640871851088295, 0.5473759236698575, 0.5704776001337151, 0.5013811107965531, 0.5339906166569754, 0.6384333378439975, 0.4672148402069294, 0.3966321333513425, 0.33899915882387566, 0.43001283535885015, 0.36508285236850857, 0.36888790591188036, 0.3485504259260319, 0.39003104782214093, 0.49719580900525184, 0.4394862077048134, 0.1986776230789037, 0.19430776145174344, 0.21476015626495926, 0.2340097005096612, 0.21257551409514708, 0.20536501322559841, 0.21278535008741672, 0.1811241841623673, 0.20262118878067836, 0.2061315760540411, 0.2276408942343464, 0.21731912408153764, 0.20300374548085687, 0.5393429323036485, 0.2179452405017921, 0.2196096061557955, 0.22185838901022226, 0.4836367955246631, 0.1757953642427712, 0.17394460152930602, 0.1511454456650192, 0.7609317025977291, 0.8198890200709592, 0.7568679462297363, 0.17872637777935885, 0.18517907568801362, 0.7987386008191664, 0.7677610827553207, 0.20935435177693074, 0.7799734647971588, 0.7543468231723681, 0.20510785533199016, 0.7451234960572191, 0.20025010128552845, 0.16339711827067316, 0.20482896601247935, 0.18747471961604856, 0.1862351122338558, 0.17924264804067536, 0.1826173540742989, 0.1767866082991184, 0.2000355530266128, 0.1856867783498498, 0.19039374127415287, 0.19667327312080474, 0.08885622507550084, 0.08136459659082962, 0.08103978040347393, 0.08700147729628682, 0.0843838222048986, 0.08074480717493171, 0.09216713272076327, 0.0775462899220487, 0.09076291385923874]}, "mutation_prompt": null}
{"id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Increased for more exploration\n        self.mutation_factor = 0.65  # Fine-tuned for better adaptability\n        self.crossover_rate = 0.9  # Enhanced for better recombination\n        self.local_search_rate = 0.4  # Further exploration\n        self.adaptive_rate = 0.25  # Balancing adaptation\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.3)  # Adjusted noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.6, 0.95)  # Wider mutation range\n        self.crossover_rate = np.random.uniform(0.75, 1.0)  # Broader crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.75  # Recalibrated condition\n        self.adaptive_rate = 0.25 if fitness_std < 1e-4 else 0.35  # Fine-tuned rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.2:  # Further increased chance\n                self.population_size = max(15, int(self.population_size * 0.8))  # Adjusted reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with Adaptive Mutation, Crossover, and Dynamic Swarm Size Reduction for Robust Global Optimization.", "configspace": "", "generation": 72, "fitness": 0.4097149535017837, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "89af3550-dd33-45cd-a94c-c8fd4626c172", "metadata": {"aucs": [0.8859927937898525, 0.866305030997732, 0.849476730532138, 0.8761117681089736, 0.8714213210355879, 0.8494060117844111, 0.885606151902339, 0.873857230449676, 0.8494711962626584, 0.8007784287843657, 0.7843557680188844, 0.7451198355085236, 0.8161602464798621, 0.8042947492807639, 0.7763926016813649, 0.7916086798907289, 0.7830383127565478, 0.7748478481419672, 0.15842913842404382, 0.12702789182603502, 0.49131596478565465, 0.6107621836171506, 0.43262873462146356, 0.10631779474329284, 0.20488029473430502, 0.16042201966797898, 0.4909993402573697, 0.14351234177614647, 0.1278788322671317, 0.13243484215363754, 0.148308758696704, 0.14250762270677952, 0.11886661637231644, 0.13865909786003416, 0.2946599896252008, 0.1390628583083211, 0.9357631082196679, 0.923698592257445, 0.9331188553385755, 0.9329993907181644, 0.9193151557559444, 0.9019017355269613, 0.9294972857804022, 0.9178029097832581, 0.910474582444524, 0.6690703810004601, 0.6097445951107741, 0.6695947297276155, 0.6718560380630229, 0.649034681661522, 0.5974735190634246, 0.5547914002856096, 0.63791132586345, 0.5313454320776505, 0.8626473131273802, 0.832164300673877, 0.8246846110151957, 0.8791845688094361, 0.8641605024027985, 0.8533295084270992, 0.844720011429871, 0.826256985027221, 0.8583536279441967, 0.3521816469720024, 0.19445896364103032, 0.20653974411013254, 0.17093216197851402, 0.15018404966106558, 0.18834811472830104, 0.21545533160762265, 0.30461378559923513, 0.19736341114069222, 0.166764120495419, 0.1426995464508808, 0.19878799818447812, 0.17818702067564152, 0.534014349198849, 0.16200806363598697, 0.1465999146291913, 0.16165767436219636, 0.31395517757138847, 0.16047326717115595, 0.09104034851084974, 0.17649575426416164, 0.12137729278317477, 0.2447581469827479, 0.281198394493139, 0.04463035475517918, 0.17193483566195789, 0.13134770772422433, 0.445081271531259, 0.2872691583710234, 0.7432387538859087, 0.20556899600799738, 0.37156196618897386, 0.5167894932831951, 0.42560375310177, 0.2746243687488744, 0.45334805416692714, 0.2263669160232642, 0.15683341336397483, 0.03897651691288084, 0.07801620465442372, 0.23352423311204884, 0.1341452035597258, 0.17924889118848564, 0.14136395559920734, 0.1374491210372727, 0.4506219104437742, 0.31453500669619794, 0.3409645498846189, 0.38243511936243924, 0.25907139572411453, 0.30992110818879326, 0.2019306915153113, 0.21999042748084308, 0.2658680592728615, 0.6340019455636674, 0.5633655708411076, 0.7463131086543868, 0.8424425828497744, 0.6148976833923478, 0.603817158506085, 0.6692247886179368, 0.7268433731574278, 0.7940693914795565, 0.1010717559750689, 0.10643624927483653, 0.1264501342171619, 0.11835870086432099, 0.12921545953213465, 0.1234869093644465, 0.12993104881164586, 0.16322488226811804, 0.11914894657792885, 0.176905744226185, 0.18870632984662605, 0.21453990063891892, 0.21158273243009018, 0.19429202718587046, 0.18379760814922408, 0.33812199314290825, 0.5834547021240956, 0.23772372161491662, 0.6403763928365567, 0.5524139782509911, 0.5754368250029569, 0.5109931807756241, 0.5402555240844572, 0.5077862413717167, 0.6423309234274095, 0.6842741492176034, 0.5290628930359218, 0.2594646695993834, 0.4338376420217045, 0.43940218201203574, 0.40820516341302193, 0.3885554604076761, 0.39240148327188185, 0.5198648717871639, 0.5049832515258943, 0.41147634147222345, 0.19737590677587502, 0.17962650170313754, 0.18433800793706545, 0.21301331974353155, 0.20268747272046017, 0.21136271535266726, 0.19631232888410877, 0.21546775732690582, 0.19198195855453604, 0.23500660815585062, 0.23397011921822497, 0.6664555145432813, 0.20694972638376607, 0.639757497267675, 0.22513517708245068, 0.2402640521835726, 0.2043343438343761, 0.4757702378721055, 0.839367735686113, 0.8449689562499827, 0.18117163828598293, 0.8852600862809767, 0.1816498601822465, 0.7798754706240741, 0.1664024604683909, 0.7585755359783035, 0.7079190327376634, 0.7776790261349802, 0.20433374608604937, 0.7373713480744952, 0.6871881599652236, 0.19974435356445208, 0.16179291823712538, 0.20925473982026555, 0.21001042344119925, 0.2077792151082961, 0.184011819799638, 0.1910500934810544, 0.1920635177302903, 0.18411047708773198, 0.1938695327818638, 0.1806909313468824, 0.2118033001167844, 0.18399196073689816, 0.1845903311772359, 0.08489711504060327, 0.07702995973381055, 0.09095460815160772, 0.08781190619854784, 0.0825607440787608, 0.07398538419229117, 0.08679634962792881, 0.08961138061676921, 0.07973107751927677]}, "mutation_prompt": null}
{"id": "2bb5eedc-7938-451b-8e9b-0afde022a858", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Further reduced for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted for enhanced exploration-exploitation balance\n        self.mutation_factor = 0.8  # Increased for better search space coverage\n        self.crossover_rate = 0.85  # Fine-tuned crossover rate\n        self.local_search_rate = 0.5  # Improved local search probability\n        self.adaptive_rate = 0.3  # Balanced adaptation\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.25)  # Adjusted noise for better local optima escape\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.7, 1.0)  # Broader mutation range for adaptation\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Adjusted crossover dynamics\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.6  # Recalibrated diversity factors\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4  # Enhanced adaptation responsiveness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.2:  # Further increased adaptation interval\n                self.population_size = max(10, int(self.population_size * 0.75))  # More aggressive size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridMemeticDE", "description": "Hybrid Memetic Algorithm combining Differential Evolution with Local Search and Adaptive Strategies for Efficient Optimization.", "configspace": "", "generation": 73, "fitness": 0.34651234956645943, "feedback": "The algorithm HybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.912356318538187, 0.8967112073620837, 0.9276441118170174, 0.9114205275639812, 0.9059513630443804, 0.9258693128821808, 0.905839999810141, 0.649637242373131, 0.8800866285873601, 0.09808213711222613, 0.6867756622387666, 0.06594791868381855, 0.696922913363892, 0.847181610489562, 0.2559699909495463, 0.6395132810296255, 0.8600632029410535, 0.6938965075684183, 0.15301350460122343, 0.1392806665167996, 0.1439263600713102, 0.1643065405773021, 0.17995084897452307, 0.632842455953008, 0.7562469906995566, 0.5334348606951611, 0.16700246479519298, 0.11888598463923428, 0.12815990934033994, 0.11951549514615234, 0.14529085412323695, 0.12554683840331204, 0.09110978728181285, 0.13167080160804612, 0.08969150166899054, 0.13761944733802467, 0.945982076613977, 0.944096957761395, 0.9544823192657572, 0.9444288669794477, 0.9320451901503799, 0.970823991108534, 0.9454319446128635, 0.936845575444721, 0.969272335545361, 0.5478789026237445, 0.676691212312784, 0.32732978044653604, 0.49004583494521026, 0.5707761714513704, 0.3648806259506199, 0.41399357985300167, 0.5961560503913534, 0.534397428956914, 0.7806136851878867, 0.8753555539904978, 0.699639316344186, 0.2765852643337712, 0.37810241979428083, 0.1922576208964082, 0.38377791922870796, 0.3933282881827428, 0.39125212658277997, 0.16824433856702947, 0.13078350426711527, 0.1787976261987536, 0.16172129321665218, 0.2264281440978695, 0.1786057842639488, 0.2480704117929442, 0.12619191290055876, 0.18832117194226206, 0.18055522864107842, 0.15878891938572337, 0.20600170790541572, 0.191402847784917, 0.1464256140724436, 0.18783837687861737, 0.1781874870735881, 0.1689466695408206, 0.21788192660087724, 0.19793395559780924, 0.1278015159334156, 0.10462118991540559, 0.11401868165273776, 0.084497326613031, 0.023945903493302834, 9.999999999998899e-05, 0.042680625911586834, 9.999999999998899e-05, 0.15140991479295374, 0.2722512210949335, 0.1375310150332696, 0.19555481645966488, 0.0757264923451001, 0.14140111116907228, 0.13373531611186662, 0.21565691736887205, 0.17328051823146307, 0.2163518673342284, 0.09238481432860768, 0.2502845543601704, 0.10055999688599093, 0.10827870485140956, 0.12711548661122307, 0.27644725906486267, 0.16367775825054454, 0.09944998943890515, 0.2043749271890345, 0.3620070183788624, 0.2941604621584264, 0.32050869373329927, 0.4013695421180944, 0.20940374190664623, 0.33866178959372584, 0.3100514187801302, 0.12025296665483731, 0.5483965923084114, 0.5819947997135373, 0.5988035309131785, 0.5922056540400603, 0.7045555540874567, 0.56286514731552, 0.5643169028139791, 0.5380514362662538, 0.7259306993201455, 0.11674309797347271, 0.1155587977962681, 0.10617425711739703, 0.15479829116411714, 0.13750474399286927, 0.12523052057148543, 0.12000156707575138, 0.10803566181638746, 0.13069096317399276, 0.3500125634024477, 0.22531773880951722, 0.2074865010792486, 0.5272237056606688, 0.18788969009756717, 0.23779954271433534, 0.2747426275520569, 0.2803858474826272, 0.18002035091933177, 0.5452106441884, 0.3349157755452359, 0.6813690633846948, 0.4830148409457562, 0.5483258122676138, 0.45208590381366953, 0.47241145913158855, 0.6321981285655458, 0.17492098384090282, 0.31758493386832864, 0.4009851877725775, 0.23679023426580725, 0.23904527455297697, 0.36117752507555434, 0.28452583207814375, 0.49079925592030615, 0.512016106238765, 0.26887082957642106, 0.2173483493080316, 0.2194464880339132, 0.20324458913942756, 0.2359683072948141, 0.19840941960244585, 0.22805438674203948, 0.2058824395554355, 0.20483877718019172, 0.21694979472206422, 0.6615585070584858, 0.2069977383754199, 0.22420125276917546, 0.7939639229165387, 0.20703736964106012, 0.2214991922463655, 0.2313093758228052, 0.2477269665817342, 0.20316326074703672, 0.18429822052162004, 0.8690431374399942, 0.8955645877086069, 0.1776211158793911, 0.1963432254331161, 0.9308967779444911, 0.824147136214963, 0.16780514245985756, 0.17593450790354637, 0.7605751462489238, 0.21113440751242218, 0.16750398941639688, 0.8725712170711553, 0.20658484236797525, 0.20851731875629342, 0.16525194311098712, 0.15296713145192042, 0.2110698649729036, 0.19248938051929232, 0.18611132333261027, 0.19228391376912812, 0.19817394723599446, 0.18761235987958624, 0.17718693790809903, 0.2216495883497689, 0.18661862255828277, 0.18289267498934214, 0.08382099828537759, 0.07938271100622551, 0.08989215545280327, 0.08633860397382742, 0.10380810821845243, 0.08762904628127022, 0.08645068789239918, 0.08027458961037715, 0.09502066449254487]}, "mutation_prompt": null}
{"id": "2d9c7190-3729-4d21-9364-c4a4d7e59662", "solution": "import numpy as np\n\nclass AdaptiveDirectedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Adjusted for initial exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusting exploration-exploitation\n        self.mutation_factor = 0.75  # Increased for broader mutation\n        self.crossover_rate = 0.85  # Balanced crossover rate\n        self.local_search_rate = 0.45  # Enhanced local search\n        self.adaptive_rate = 0.3  # Optimized for stability\n        self.reduction_factor = 0.85  # Adjusted reduction rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        direction = np.random.choice([-1, 1])\n        mutant_vector = rand1 + direction * self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.15, 0.4)  # Broader noise for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 1.0)  # Broader mutation range for adaptability\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Wider crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.65  # Recalibrated condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-4 else 0.4  # Fine-tuned rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Increased likelihood to trigger population reduction\n                self.population_size = max(20, int(self.population_size * self.reduction_factor))  # Adjusted reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDirectedDE", "description": "Modified Differential Evolution with Adaptive Population Dynamics and Directed Mutation for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 74, "fitness": 0.3996393295860934, "feedback": "The algorithm AdaptiveDirectedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.8319947504030498, 0.8493580787343178, 0.810312853004851, 0.8241715906110983, 0.861215603880198, 0.8171713894120898, 0.825094002674822, 0.8481175038092028, 0.8194263706192628, 0.7300993006619704, 0.7694711427364608, 0.7250272599760496, 0.7202400688552864, 0.7560534322720329, 0.73167343200618, 0.7171039227782026, 0.7723796585484921, 0.7116088638382208, 0.3185125091236407, 0.24601119703820873, 0.14775028514774968, 0.4277851653105287, 0.3507368396849082, 0.1726991711881215, 0.16704069408183986, 0.5194992051436302, 0.11247991800261348, 0.1182434750974487, 0.12564569446560092, 0.1258417755986433, 0.11411038120896189, 0.12679799930854774, 0.11623967716619665, 0.23343943230162112, 0.12020891999626748, 0.11564116789607182, 0.9219664318331289, 0.9149925052311121, 0.9482672766968325, 0.9171822473378421, 0.9217220738127007, 0.9022750128960658, 0.9246975923613558, 0.9241336995313733, 0.8758364355506991, 0.6360772204517843, 0.6721914381212301, 0.5297770899536861, 0.5722289807242695, 0.5403100767326858, 0.6090086547146198, 0.30596803133008266, 0.4741844788476597, 0.5160888470773848, 0.7943020173409578, 0.8106383350013434, 0.8065900093157938, 0.8220920986846347, 0.8768227561453906, 0.786965473005131, 0.8352647839511339, 0.7991046439546605, 0.8034175703865091, 0.17460330751041964, 0.13001113530486597, 0.13636531203719537, 0.1639005772812736, 0.17395624708985102, 0.20336523904325132, 0.15334880550886942, 0.13873458748679568, 0.1353578585676738, 0.16866433657530178, 0.14364083841507747, 0.1610593482978847, 0.2366178062159291, 0.168729619024915, 0.19771275518149622, 0.16313959678442314, 0.15710868335891415, 0.17273570556997841, 0.264060398335601, 0.1242457448956582, 0.4620308421445729, 0.32121636775749585, 0.05269943306692637, 0.24169910419989937, 0.09806185477442508, 0.13990281379781522, 0.23394530735520225, 0.35468818544819547, 0.6358354947398668, 0.17321058138150003, 0.2887545485484062, 0.17634246377923812, 0.11392053063546159, 0.369756097072238, 0.518342777341671, 0.3430647099033072, 0.14327407023066496, 0.2049468459996533, 0.07622739133601031, 0.1942843319434232, 0.15379800726310655, 0.1501807321022638, 0.18112729862292032, 0.15727034025913833, 0.06530874414463939, 0.24036194162193936, 0.3263437172109268, 0.2148220178685707, 0.31499466441412516, 0.20904804552598621, 0.30413598594393887, 0.24461473135667178, 0.27568238302157344, 0.27617886985700546, 0.594337330798283, 0.7717015164037243, 0.5913245370278821, 0.5873427634625179, 0.688253416803519, 0.7375781721963687, 0.5893452596568327, 0.6684943897376671, 0.6790306133162102, 0.09504381722828026, 0.12616101126450407, 0.1187702649800978, 0.0929987087674401, 0.1069785201634319, 0.10971750792945023, 0.12473553797636139, 0.09739933071147244, 0.09899774253478866, 0.22626219744101295, 0.1808781524099029, 0.19232419214952023, 0.2546361555164065, 0.24270678674539659, 0.27826277916100595, 0.18253121063796907, 0.24519174979814484, 0.18387441219683942, 0.4152083269224346, 0.5456032571017322, 0.528306492024488, 0.5638935616014185, 0.5122489601553946, 0.5058056225495482, 0.5108394042265183, 0.6180105312044122, 0.5256755457072262, 0.3985877037285903, 0.3077475669052687, 0.3219859563262929, 0.38278820255701784, 0.46505540344830454, 0.294208969561347, 0.3762479000003567, 0.5366161658644513, 0.36827370334917486, 0.20575068355266501, 0.18318991329246492, 0.18394982801815818, 0.2119459359956396, 0.20274416245552906, 0.18859148897260003, 0.18307367121729867, 0.24007068290291644, 0.1964312677268043, 0.35246872886648783, 0.26637144991978323, 0.4901994249606564, 0.5053329406943317, 0.5829591243061207, 0.4322276491157828, 0.41925996231865426, 0.6577616037723966, 0.20863097804950093, 0.7761213444190691, 0.2051087107611168, 0.7132041075022502, 0.8005795210787215, 0.792672273440297, 0.7301909034327434, 0.7372476478087668, 0.7111733703462539, 0.7631183803348028, 0.6811668880595212, 0.7046038248694786, 0.7972389689932091, 0.2016910668430152, 0.3270329019645427, 0.6516222928781137, 0.8071472351114992, 0.20615573044266655, 0.7213133717846532, 0.1942786009537255, 0.1782630261660113, 0.20268860711076664, 0.18493783319381585, 0.19776648027945654, 0.18768646245882503, 0.1841244094703105, 0.18456952363827184, 0.17589156029850672, 0.08488014821782874, 0.0788381919728105, 0.08288064128191874, 0.07737108098344558, 0.07107451478302773, 0.08368573292256098, 0.07861013715387466, 0.08057274578842444, 0.06890846073847101]}, "mutation_prompt": null}
{"id": "5807cc10-7c20-446c-b899-cff47ae65a06", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.85  # Balanced for exploration\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # Wider adaptive range\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Adaptive range\n        self.local_search_rate = 0.3  # Balanced exploration\n        self.adaptive_rate = 0.3  # Improved adaptability\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.2)  # Focused noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.5, 0.9)  # Adaptive range for mutation\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Adaptive range for crossover\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.7  # Adjusted condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4  # Balanced rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Balanced chance\n                self.population_size = max(10, int(self.population_size * 0.75))  # Enhanced reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution utilizing Self-Adaptive Parameters and Adaptive Population Sizing for Balanced Exploration and Exploitation.", "configspace": "", "generation": 75, "fitness": 0.31941805573899484, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.8940385341615646, 0.9056228212285159, 0.5765085153081466, 0.8970497408612967, 0.897660433856604, 0.5912484149866142, 0.8836747225717276, 0.9078156037825128, 0.9006989183334475, 0.8159889454761244, 0.4148134484752606, 0.053075001251083664, 0.828401145835913, 0.3469800199581058, 0.13924909219804826, 0.13501087754038454, 0.46517432476453424, 0.13647314267371602, 0.33332582280170786, 0.14371908772860575, 0.17273317942141508, 0.15183697328878643, 0.1532199767365341, 0.17382607090652769, 0.2185269766117175, 0.142201849707275, 0.15344624754206493, 0.13844776012549032, 0.09257299921023898, 0.12642914523675153, 0.144195308838595, 0.15407612900902445, 0.17233284192955267, 0.13610581973639835, 0.10505466043390932, 0.10594461925153209, 0.9446503410554884, 0.9320963692448733, 0.9356212104790335, 0.9443382791411997, 0.948346822209388, 0.9183399232347496, 0.9461878272230851, 0.9222045766740455, 0.9264149797276442, 0.33067600799835395, 0.3946137692516899, 0.5352624140310707, 0.3968401130810567, 0.32991074199382175, 0.42058276571705133, 0.3423154087331658, 0.3575472621555956, 0.3574148323275823, 0.3771516728717512, 0.8811180080655194, 0.16724701466795266, 0.8714991882213763, 0.8897546266899481, 0.3701661338382417, 0.21905310910107556, 0.8753544282015874, 0.23077390347303905, 0.1875869749209843, 0.14933559713545708, 0.15397102372974192, 0.18947259976547504, 0.30549238384054367, 0.15787685291290632, 0.23546540481696854, 0.20524715698509188, 0.17536441647101053, 0.1402075947192758, 0.15137224633549562, 0.1846952959075968, 0.16179192495707106, 0.14322695688454457, 0.14508832372694158, 0.18327030797199073, 0.48529368059927114, 0.16468235172611223, 0.11865929811679177, 0.07288819406086622, 9.999999999998899e-05, 0.1144652016304546, 9.999999999998899e-05, 0.20171273077559604, 0.10053271512347606, 0.13750579035536825, 0.013158898907878247, 0.15483067398594907, 0.31840697021919284, 0.10146734838202787, 0.14045710527442956, 0.14468131679921958, 0.17332145673741395, 0.192224047148418, 0.18297068578536702, 0.14157653495431854, 0.07540561596843709, 0.3306091543611742, 0.07195400388814577, 0.1812160051749404, 0.09154310346574257, 0.15367962835346438, 0.034785075429070056, 0.09166154751875111, 0.26162900267280087, 0.18851596659589942, 0.20693870274002568, 0.11618886617405566, 0.2979101951552481, 0.2594146722798546, 0.06151408364486144, 0.15977685188321378, 0.2068860356824923, 0.20751015874776657, 0.4916634715030741, 0.5278264482151341, 0.4782702823692234, 0.5097263561385643, 0.5545157896832331, 0.45380618612687296, 0.605534934237535, 0.6196804331387191, 0.5367956929241148, 0.12054405474972396, 0.14819621013720374, 0.14605336727252416, 0.15234957493708623, 0.17461552794904744, 0.13631844627622924, 0.11462295626610708, 0.14721601005175167, 0.1220836142074826, 0.2224337218677741, 0.16168170712656105, 0.2777205265089512, 0.19885209971618034, 0.22389169884248605, 0.24785649385511244, 0.2653339585304215, 0.4062322914950841, 0.2910049700654538, 0.4220367927660519, 0.4210350238970767, 0.7340402457744564, 0.5893131123835267, 0.32313918945372533, 0.6148391631281247, 0.3490618474449747, 0.5865561589877115, 0.35057951185310343, 0.2739529583456397, 0.278177606432089, 0.3475387369307503, 0.36466326805065663, 0.2547477813497063, 0.3947926790169264, 0.26682820985523403, 0.3583458309864419, 0.2686763396674362, 0.2015104094541057, 0.2165563910827062, 0.19540016681039263, 0.21076580569347758, 0.22463607632004523, 0.20535825113252215, 0.20921110433859436, 0.19950018136754977, 0.20713612085988542, 0.20350780398124546, 0.21403811534981831, 0.18186113155268646, 0.21845747807621707, 0.22052678435231787, 0.23786908146231134, 0.35122388068358856, 0.23871627437029985, 0.5061639938942113, 0.8526961411202684, 0.19565316046838865, 0.15346455372256118, 0.8476040502958426, 0.17650357054211196, 0.8434196821639509, 0.8662835716324998, 0.18609846920858286, 0.1829560638986215, 0.6077188554609712, 0.20599744038756929, 0.6602758796819588, 0.2020844585562679, 0.5386903813394188, 0.45957923079880036, 0.20597982849760132, 0.20321391944493816, 0.20775393039481682, 0.19319217138750833, 0.18299231883013267, 0.18785187762556033, 0.19225561169806182, 0.17837621274665993, 0.18980783584027827, 0.18168228969604716, 0.18489325785649402, 0.18306072978566845, 0.08056551400097856, 0.08595710059129802, 0.07677587392560892, 0.0906676624550401, 0.08232284158840208, 0.0912253889350031, 0.08961556843143403, 0.08184239571133223, 0.07105223701664287]}, "mutation_prompt": null}
{"id": "c9a37ea9-ad11-49b8-9d57-18c478e6261b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDEStochasticCrowding:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.85  # Adjusted for exploration control\n        self.mutation_factor = 0.7  # Further fine-tuned mutation\n        self.crossover_rate = 0.85  # Slightly reduced for balance\n        self.local_search_rate = 0.5  # Increased for deeper local search\n        self.adaptive_rate = 0.3  # Balanced adaptation rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.25)  # Narrowed noise range for stability\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Adjusted mutation range\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # Tweaked crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.7  # Recalibrated condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4  # Modified rates\n\n    def stochastic_crowding(self, parent_idx, offspring, offspring_fitness):\n        if offspring_fitness < self.fitness[parent_idx]:\n            self.population[parent_idx] = offspring\n            self.fitness[parent_idx] = offspring_fitness\n        else:\n            if np.random.rand() < 0.5:  # Stochastic crowding decision\n                self.population[parent_idx] = offspring\n                self.fitness[parent_idx] = offspring_fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                self.stochastic_crowding(i, offspring, offspring_fitness)\n                \n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.2:\n                self.population_size = max(15, int(self.population_size * 0.8))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveDEStochasticCrowding", "description": "Enhanced Differential Evolution with Stochastic Crowding and Adaptive Local Search to Promote Balance between Exploration and Exploitation.", "configspace": "", "generation": 76, "fitness": 0.15354619145480922, "feedback": "The algorithm EnhancedAdaptiveDEStochasticCrowding got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.33164459016924264, 0.33931988901756327, 0.30431963350827484, 0.35252508838087204, 0.37376103143133, 0.3281132457217817, 0.37731873593158327, 0.30538831209250517, 0.330551973024803, 0.031233632225710628, 0.09171387377212337, 0.031243018857386562, 0.044968754773528796, 0.06824197038806301, 0.03937909745251056, 0.027235030473506616, 0.0475972372377329, 0.09264725643579386, 0.0858632930759593, 0.06147764953391821, 0.06754148384399272, 0.09059269812318616, 0.060920400926111284, 0.07478385232084006, 0.09168358368888052, 0.07447583885771913, 0.07131536245282499, 0.04591195810129378, 0.06339072684266589, 0.0549801309706901, 0.05424330813310574, 0.058598393833351525, 0.061305471788839716, 0.058581735519173894, 0.07176034699519096, 0.08063504846456782, 0.909950170606447, 0.872197833783608, 0.9226490286873881, 0.869244225139476, 0.8478033840689843, 0.8736898034767321, 0.8231573870360096, 0.850479602691047, 0.9158292370060976, 0.09109956253739349, 0.128793794944977, 0.1080989934061296, 0.09062068054298689, 0.11410466007281939, 0.1021138276902035, 0.12749624893089806, 0.14895667131627577, 0.1351851623964554, 0.17129820934919704, 0.12074028052598063, 0.12745990754606285, 0.18733147413426987, 0.16068205244398837, 0.15252394516279277, 0.1789930064521028, 0.1943123583249614, 0.16532291528702003, 0.07949089571430445, 0.0580622099987842, 0.040193608262046654, 0.07412050249972557, 0.07272334490560606, 0.08950204952925689, 0.04523560668708737, 0.06568662736249442, 0.06734499883963108, 0.036234104370913345, 0.039166775941208876, 0.08153846430174128, 0.06644210206207257, 0.06851707592449185, 0.036566662439968756, 0.023332227402549366, 0.10385228994834139, 0.035817161936327446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06577521942469988, 0.05625579041039197, 0.04292379632719334, 0.017134054132889598, 0.052174794557077964, 0.06200224707542312, 0.04458920470424743, 0.04009923013789718, 0.07787262194088085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037130273861217256, 0.058233558116893236, 0.025780702143569756, 0.038367743646098296, 0.01510197501246946, 0.030316498093313604, 0.050844168752113506, 0.06576096265601261, 0.06031307893464688, 0.2568123339675804, 0.2568123524557, 0.2841465078377615, 0.2901341741028497, 0.28191091939828417, 0.3094361491407439, 0.256263849947552, 0.30633800212062057, 0.2497046696760804, 0.08117746547650384, 0.0719264521014018, 0.06771773889782329, 0.06777185741516845, 0.08225293077672868, 0.07013280570767744, 0.0764543477651316, 0.06942466060731989, 0.08573181190897139, 0.15815587123584862, 0.13409444285739047, 0.16994179385377306, 0.1698313551186882, 0.16162201851630276, 0.14260188451240885, 0.13404571038396884, 0.1559044034029432, 0.1467374224181116, 0.1842871894571465, 0.2017702189195949, 0.18834634658181626, 0.1935921517726552, 0.19187960599932463, 0.1907500734109413, 0.20102947964040663, 0.19364061589923887, 0.20412822624250615, 0.12215439046038568, 0.12570069847496812, 0.13454381469262278, 0.1584706191077072, 0.14580564505540516, 0.12905909889109812, 0.13050965708621698, 0.15332099630419693, 0.13421349629439316, 0.1810151559654919, 0.18559037327648997, 0.15797714877083324, 0.1893860913215647, 0.18955954079393567, 0.17652398305354688, 0.17582545460079668, 0.170977767732012, 0.195679836891829, 0.18755047380781986, 0.16083184980257414, 0.17677161788248685, 0.16213598735571355, 0.16006877413358578, 0.14987702775133438, 0.15370503564195914, 0.1658985474618686, 0.15069347653477094, 0.2882842883548534, 0.18012817869508913, 0.31497126217407034, 0.1700014472000415, 0.16095570320538355, 0.15781479403666965, 0.15080026086876663, 0.14688386178065593, 0.20320973370348305, 0.11844441813667239, 0.16081247883773864, 0.15620690186984942, 0.15569916660649485, 0.1734519869550859, 0.20988040868668023, 0.2036036567521664, 0.1465189758632356, 0.1941045530156913, 0.17772352278073944, 0.18228002091180717, 0.1744612461150622, 0.1772883503388505, 0.18269533544332806, 0.19884644917905736, 0.1791270356092598, 0.1917268017078516, 0.1849207918193697, 0.05069136452948153, 0.06652571175955435, 0.06468928825991571, 0.05942052678513032, 0.0691445364388601, 0.060962714763506676, 0.05612315862636408, 0.06100099404744885, 0.06452232372748623]}, "mutation_prompt": null}
{"id": "25ee99c7-650e-4c93-b622-fca1e6a209b4", "solution": "import numpy as np\n\nclass AdvancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.85  # Balanced exploration\n        self.mutation_factor = 0.7  # Fine-tuned for adaptability\n        self.crossover_rate = 0.85  # Adjusted for effective recombination\n        self.local_search_rate = 0.5  # Enhanced exploration\n        self.adaptive_rate = 0.3  # Improved adaptability\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)  # Adjusted noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Narrower mutation range\n        self.crossover_rate = np.random.uniform(0.8, 0.95)  # Tighter crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.7  # Refined condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4  # Adjusted rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Slightly increased chance\n                self.population_size = max(20, int(self.population_size * 0.85))  # Changed reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdvancedHybridDE", "description": "Advanced Hybrid Differential Evolution incorporating random local search and stochastic parameter tuning for improved convergence.", "configspace": "", "generation": 77, "fitness": 0.3956186379279816, "feedback": "The algorithm AdvancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.8377656359045151, 0.8257408217880062, 0.8139202093115301, 0.8479231330923938, 0.832895771948716, 0.8218802534741663, 0.8492742462640368, 0.8189688748830734, 0.8253930109060931, 0.7550744307390752, 0.7570534920331847, 0.7210356176660697, 0.7155245009392612, 0.6929690985414301, 0.7066806109822702, 0.7420102368797218, 0.738094298139035, 0.702615433991892, 0.27797784387747104, 0.37345186189217583, 0.15422766666849563, 0.40636560676239464, 0.18162733088594984, 0.22584071220409296, 0.13353592205275067, 0.27551931041182, 0.32053949259539183, 0.13788867365420665, 0.11867101438273875, 0.13465878801319175, 0.3539795936747707, 0.12220831234496221, 0.1361359136533722, 0.14216650254595697, 0.11724559821314429, 0.12684410796090595, 0.9349600036355675, 0.9593917621087135, 0.8869429191635633, 0.9093082253557224, 0.9225169217716607, 0.918235093201429, 0.9237284338641898, 0.9079506303321949, 0.9514512518121978, 0.5919059127930664, 0.6245422612360008, 0.5609435477863327, 0.6662803325220534, 0.6029431785338915, 0.5803120845352889, 0.5355513654259769, 0.626399178544229, 0.6130739713175601, 0.8186476212035108, 0.8414136369667886, 0.780845001446802, 0.8288332838993279, 0.8423092967713424, 0.8042485177631206, 0.828792267515843, 0.7768564851816826, 0.8014123685103882, 0.23020331243211156, 0.26273626284147744, 0.1828054516676645, 0.20898138014623824, 0.12395425746383093, 0.16988903911358955, 0.5173917692988321, 0.207071900606412, 0.26641555325879884, 0.1262852798103089, 0.453647001511023, 0.17825233028874587, 0.1936634278126257, 0.18117468637550138, 0.1725554208647101, 0.197865326087185, 0.627518936105415, 0.15382003591235038, 0.5207447027207885, 0.132083104274892, 0.32467386662321573, 0.20989033359982423, 0.5514641387793292, 0.0775468146072591, 0.09390307080255911, 0.3205208362273161, 0.3318887068561839, 0.47887148986629724, 0.6523715357850276, 0.4429790702976609, 0.6242454460028952, 0.5924723639635285, 0.528328666567638, 0.4612188984221359, 0.2037685977438356, 0.29584221437694613, 0.18972906886639196, 0.12455345195441336, 0.10942690115651843, 0.17326966608590666, 0.21659617098679784, 0.15972206723086435, 0.2306053555626869, 0.23493844628094107, 0.1655996186669637, 0.22277905096216422, 0.36933086873340093, 0.3663807222260541, 0.4158759973471823, 0.43271975324155953, 0.3621756318714723, 0.35642514010908244, 0.40641941580910734, 0.219739147425684, 0.7449074963524691, 0.7283256355033936, 0.7519186025360026, 0.7212681443359087, 0.7747313157303856, 0.7351073992097172, 0.7570863540290733, 0.7472939529579629, 0.7565830615701192, 0.1332039975999454, 0.11120389262001407, 0.11921985270546065, 0.10515975398597344, 0.11733834049841008, 0.10270482546730453, 0.10095166026910662, 0.10776727558583388, 0.0886925883803249, 0.2504772717100624, 0.18466258797667456, 0.17850749635431706, 0.23804665775729295, 0.16929718055023146, 0.19862524950386928, 0.25671492352042236, 0.21903890819284166, 0.21232606366894802, 0.4797911501739289, 0.4510025967136386, 0.4865625500943337, 0.45542523803942103, 0.47874875260277383, 0.45667804904360754, 0.4748302187651797, 0.5822039205739458, 0.5246277166577014, 0.3789383955508857, 0.3821101348906043, 0.34673383436538774, 0.3197566870108062, 0.3913907589128528, 0.40775346994212314, 0.35894848472437546, 0.39137624246673974, 0.3747132844090538, 0.21784019865613657, 0.20062199003190007, 0.21589313113189823, 0.20446788854948728, 0.19998188207405843, 0.18956318941277284, 0.21443052553336417, 0.21894086546125568, 0.17701605256852204, 0.22839234132682074, 0.18660905398063798, 0.2974750446690323, 0.22795527322203513, 0.45742392319056113, 0.20743228028075422, 0.32378837054263376, 0.6008173463412005, 0.22382477428576775, 0.1793986619759078, 0.15951183373379263, 0.19958208136097844, 0.7247557722028929, 0.18350457883148596, 0.19378705363586146, 0.17921690952698377, 0.16572258437635823, 0.738286953023604, 0.2056919605344577, 0.20341159525449126, 0.7954734092485761, 0.1989451007368952, 0.7780935587295609, 0.7502757684894363, 0.20372671053949543, 0.20521705985812688, 0.20412428592106768, 0.17291234094556074, 0.18798839160494207, 0.1894908680665871, 0.16905312870632772, 0.1819545647828752, 0.20392928560799706, 0.18483036136994657, 0.18209832032982187, 0.18731925287338924, 0.08170814343175203, 0.08540133104087944, 0.0857372275449052, 0.07682823739406464, 0.08584811707649387, 0.07840987638400787, 0.0839195913591062, 0.0870252179023806, 0.07838836716669506]}, "mutation_prompt": null}
{"id": "171fa41a-bc86-4ddc-9c20-8ea134fa5bb1", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.85  # Slightly more exploration\n        self.mutation_factor = 0.7  # Adjusted for better global search\n        self.crossover_rate = 0.85  # Balanced recombination\n        self.local_search_rate = 0.5  # Increased exploration\n        self.adaptive_rate = 0.3  # Improved adaptive balance\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.05, 0.25)  # Fine-tuned noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Narrowed mutation range\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Adjusted crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-4 else 0.7  # Adjusted recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-4 else 0.4  # Adapted rates\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(self.fitness)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Further increased chance\n                self.population_size = max(15, int(self.population_size * 0.75))  # Refined reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybridized Differential Evolution with Adaptive Learning and Stochastic Local Search for Global Optimization.", "configspace": "", "generation": 78, "fitness": 0.40294796800520194, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.8918676927313253, 0.8410936417903997, 0.8931944496919255, 0.8875160725940551, 0.8415476107546556, 0.8739354968705553, 0.8834131375780561, 0.8380937047936566, 0.8777704505493458, 0.8251732277758366, 0.7379156685555576, 0.7735732756959974, 0.7907919292438342, 0.7500142090906281, 0.7911091608337525, 0.8093294890671368, 0.7476157640680026, 0.7939267316883856, 0.1631902527489847, 0.1585848786077786, 0.15207941864576402, 0.17551156358201625, 0.31457013305137205, 0.5775334197483857, 0.37236786527135, 0.37789647820123573, 0.49775207920924425, 0.14273634978891825, 0.2779682297960162, 0.15712027163458808, 0.15390945206689322, 0.1348744937810954, 0.1673974019813399, 0.14760863175176986, 0.15694833454808832, 0.14658766369629816, 0.9342942812330086, 0.8982114923644113, 0.9255060549415962, 0.9426055702067674, 0.8918341916062902, 0.9129714158414358, 0.9253806715311832, 0.9680307448450688, 0.9474378239686889, 0.7064327620240807, 0.501669181953327, 0.7210799365688947, 0.702716015869113, 0.6176213910791927, 0.6083439802428046, 0.6927237489082902, 0.6414869680220339, 0.6762419151599129, 0.5187458876097931, 0.8081477540817562, 0.7489623933656828, 0.8488029537245079, 0.826059285448618, 0.8806513457091845, 0.8682884707672971, 0.8213996462352356, 0.8191662435838396, 0.27301306474108533, 0.24323086773813207, 0.17883431599807487, 0.1791055653654472, 0.15842812889906577, 0.13175963640562716, 0.7414251744225138, 0.13741369846976048, 0.19009716986188063, 0.1940217442765153, 0.16695659967017296, 0.28646091544290064, 0.1670041103912996, 0.1693093200771093, 0.16659859288945422, 0.12841314011612903, 0.12117797796581731, 0.17103911434645347, 0.283707054074382, 0.13939373384697284, 0.05912072480325081, 0.18321080330495954, 0.20558154240927995, 0.17076133981657127, 0.22705156634628598, 0.12320657624188647, 0.059754258345685596, 0.13063120983966692, 0.21377504908717526, 0.20798707357525947, 0.13421795875294917, 0.4019936713669102, 0.15728862345500438, 0.18408297548814334, 0.259337864871222, 0.20385167904336832, 0.21100166620856176, 0.0790157562245215, 0.1262153148333367, 0.13626405462576818, 0.1505499597928861, 0.11027611901697565, 0.1862044522827091, 0.14183125317551604, 0.21689608533409144, 0.3880568883165163, 0.3074290952760643, 0.22378558590631292, 0.3533206164777204, 0.36863940380145, 0.20453659825857073, 0.3427729120807712, 0.26601740371466964, 0.14917131683225038, 0.6182602994676301, 0.615644093496583, 0.6041739172099991, 0.6560573168649613, 0.5170244772884837, 0.6631326733025019, 0.7118266151944823, 0.6344860605069595, 0.6935782631799277, 0.10230356498474413, 0.13631038650294414, 0.11583355132573947, 0.12593551324976904, 0.12149481201383572, 0.583363969277181, 0.12840935212030458, 0.11832944127818901, 0.10799056708867683, 0.16322582087289206, 0.2525094104808232, 0.24690114452384393, 0.34304631908808714, 0.2583096664499639, 0.23610466695739118, 0.3824791973473243, 0.18962968924956347, 0.22425608970154476, 0.5650517634969836, 0.4929590762509445, 0.5187372460410629, 0.3744508695750799, 0.5419597025567491, 0.521124119964248, 0.6035697438762173, 0.5619384599903587, 0.5876096283203192, 0.33833646726204336, 0.3872169680314701, 0.44150491936113656, 0.4539365398633236, 0.3529027926835163, 0.4442882099709262, 0.32895783198189066, 0.45007479169854436, 0.37526614277159986, 0.19997586800264477, 0.19588048014791126, 0.20225234114118196, 0.19759779531336052, 0.20674149269498243, 0.21476145798398316, 0.20472505994043533, 0.19184965226780926, 0.19408798271175032, 0.2118206499985833, 0.44498752850210643, 0.221790019811274, 0.4633104733290704, 0.5452693082005058, 0.22440232020906503, 0.2269022422346999, 0.22607281388256162, 0.22479052468813998, 0.8620599719922157, 0.765216826953588, 0.8244140277091881, 0.8818500986316452, 0.1911185813113121, 0.8444390672220258, 0.8750451933890245, 0.19941432706067563, 0.8544646045684259, 0.8851711116094364, 0.20199463951176244, 0.8066813770979282, 0.8314297510156189, 0.20054980491988572, 0.20119760942510145, 0.207211813852211, 0.7480139920946551, 0.16338759153221238, 0.17739497018323458, 0.185768522608178, 0.20566234457894061, 0.17532703382848447, 0.18016450074835288, 0.18358111772524455, 0.1868230138363568, 0.1768486794242221, 0.18224576447454688, 0.09197580384948978, 0.08762779515245056, 0.08279776282041418, 0.07883235862540483, 0.08323490314327375, 0.08069181747725473, 0.08072234946148238, 0.08052963413917147, 0.09659408108801015]}, "mutation_prompt": null}
{"id": "ad7b9520-4f9f-409f-8c14-d9200468b644", "solution": "import numpy as np\n\nclass DynamicSelfTuningDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.mutation_factor = 0.7  # Adjusted for improved convergence\n        self.crossover_rate = 0.85  # Modified crossover for better exploration\n        self.self_adaptive_rate = 0.3  # Enhanced self-adaptation\n        self.local_search_rate = 0.45  # Increased local search intensity\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.1, 0.25)  # Adjusted noise for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.85)  # Tighter mutation range\n        self.crossover_rate = np.random.uniform(0.8, 0.95)  # Refined crossover range\n        fitness_std = np.std(self.fitness)\n        self.self_adaptive_rate = 0.35 if fitness_std < 1e-3 else 0.25  # Adaptation based on fitness std\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Increased adaptation potential\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted population size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "DynamicSelfTuningDE", "description": "Dynamic Self-Tuning Differential Evolution with Adaptive Strategies and Guided Exploration for Improved Convergence.", "configspace": "", "generation": 79, "fitness": 0.38583925219737364, "feedback": "The algorithm DynamicSelfTuningDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.7976697511944796, 0.774614783042244, 0.8043461322686417, 0.7933146195104144, 0.813981587256417, 0.8080258904663371, 0.7959374549308944, 0.819822799125786, 0.8326945218552071, 0.6529683740909662, 0.6570784210439786, 0.6420633192235949, 0.6638024549045549, 0.6500648175991859, 0.6531099396877129, 0.6319752173531088, 0.6438410290308341, 0.6671781767473597, 0.10933303404862615, 0.11677925777274889, 0.13887256155893724, 0.12599997680760955, 0.10892821475196401, 0.10670115369821653, 0.1169220473356849, 0.11481412167805816, 0.11688541177924672, 0.1092028647339186, 0.12232074553078875, 0.10531678067905903, 0.10174120256404096, 0.12109849046154031, 0.09986765970633915, 0.09359357051640638, 0.09442039701005256, 0.1075117354734142, 0.9280375821618715, 0.9365081847132555, 0.930211738659448, 0.9197499151351999, 0.909223659106664, 0.9520090735610501, 0.9555542429511448, 0.9712692799272958, 0.9235285479430421, 0.5243789349068668, 0.47618376710951094, 0.5428527014690021, 0.5015507937951648, 0.48829167005735197, 0.4749014034214628, 0.5245663246977451, 0.5009199235914378, 0.5169604079746182, 0.8208164128443916, 0.701098638862196, 0.714663400684207, 0.7653518065614338, 0.733590361803463, 0.7479069293598348, 0.8136287364625205, 0.6452909162300156, 0.7429316726832563, 0.2937917882708464, 0.4547289875292839, 0.4018694989056021, 0.518867982087413, 0.33890562581069894, 0.36617164294964843, 0.4341614435132064, 0.4126325745975009, 0.35516790214258676, 0.45164135455998156, 0.2625769854995109, 0.3519820303565636, 0.3678096801226236, 0.3832577546590663, 0.38267618534487735, 0.3719251787367106, 0.4011391775933444, 0.37681976613116974, 0.33586947386804133, 0.3772370269657862, 0.33440451774212754, 0.39774727063723336, 0.30911620250531, 0.40702254810827165, 0.3958360684054272, 0.3806202712785651, 0.3742736337704362, 0.4535880928748388, 0.47518217878159796, 0.5165764221506786, 0.45046829241874553, 0.4954784894122053, 0.45707759233875256, 0.5486667420183985, 0.5026857792415698, 0.48623799582382754, 0.11153683313066554, 0.12102099007357303, 0.08703864668402317, 0.2913927258753387, 0.22077998231888807, 0.20060032588455312, 0.16112495420714112, 0.16116355720497488, 0.16621338402614638, 0.31998294379851144, 0.2953759714165345, 0.2946116354862758, 0.32610621208909785, 0.323626876341676, 0.33658476762349443, 0.3161415863713162, 0.3094551956543675, 0.2709284738772263, 0.6954647496516204, 0.7127441012617721, 0.6905927274072736, 0.6643903151116984, 0.6915751977544367, 0.6722477885732908, 0.6914841583426008, 0.682526423862579, 0.7022233837131939, 0.09997356701894555, 0.10975092739872694, 0.10571752183320371, 0.0920471584031557, 0.0976270710363073, 0.10215799459043717, 0.09507643129036059, 0.1152792092455891, 0.09612820666353128, 0.21185451279400325, 0.1804029547899174, 0.2048218524590507, 0.20920915255289152, 0.18878188293951892, 0.18873844969567022, 0.2724502537341196, 0.18908351855226113, 0.27110498858794085, 0.3673056180716907, 0.3620970598949973, 0.3732687648552314, 0.39851633042548773, 0.317347774501468, 0.3707390417459894, 0.3708539243407064, 0.37799270215302117, 0.39730730308399753, 0.3125914377153597, 0.27857216638884774, 0.26685884398136284, 0.31557866724015515, 0.2777669053827324, 0.2695990356298885, 0.296638769753109, 0.27854517791242617, 0.2995770117259463, 0.22127644775544608, 0.21050127254603923, 0.18665322719237054, 0.18940408975695167, 0.22857757873292328, 0.1864510901563794, 0.19562627703367397, 0.19218599026416627, 0.2122196734671986, 0.19300076952128953, 0.3993971920269034, 0.2062437083700719, 0.19587623940475274, 0.23601886870804278, 0.19748936215744117, 0.261087998305676, 0.18468137899588932, 0.19556313248641932, 0.20150067619877432, 0.7226957497393273, 0.6602450129031375, 0.6846192604126162, 0.7687210884721464, 0.7219220646489597, 0.18141618478427102, 0.1821206883004861, 0.6219509253761091, 0.16979504413584967, 0.2043674381650309, 0.6439489347556326, 0.652368524685758, 0.6973374916919571, 0.687471252962462, 0.209317727332599, 0.20048788511696725, 0.20816671639051787, 0.18092008281756045, 0.17642977696647122, 0.1893380329234866, 0.1920743414914079, 0.17687470863524268, 0.18777771070897242, 0.1861975948510921, 0.18201128162309088, 0.18964708165116595, 0.07246666074500807, 0.0750900035410188, 0.0789510454997222, 0.08580589940795758, 0.07735441222833539, 0.08157432073224702, 0.07427331904366419, 0.07693781764695284, 0.06956162577048908]}, "mutation_prompt": null}
{"id": "9af966f3-2272-4fa7-b1a5-7f61819b5127", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.85  # Adjusted for balance between exploration and exploitation\n        self.mutation_factor = 0.7  # Slightly increased for more adaptability\n        self.crossover_rate = 0.9  # Unchanged for effective recombination\n        self.local_search_rate = 0.35  # Decreased for improved convergence\n        self.adaptive_rate = 0.3  # Increased for dynamic parameter adjustments\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Increased noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Adjusted range for mutation factor\n        self.crossover_rate = np.random.uniform(0.8, 1.0)  # Slightly higher minimum crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7  # Changed condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-4 else 0.4  # Fine-tuned rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Further increased chance for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted population size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Differential Evolution with Adaptive Strategies and Dynamic Parameter Tuning for Versatile Global Optimization.", "configspace": "", "generation": 80, "fitness": 0.41734872977929255, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "d6ff2021-526b-4f05-9769-6f6746ddf4ba", "metadata": {"aucs": [0.8328763278985247, 0.8246050561083687, 0.8298739374949486, 0.8585303629149904, 0.8411229644520126, 0.8320000503677355, 0.8451134734235038, 0.8358938524525185, 0.8445230942773646, 0.7470372260333928, 0.7299220677300184, 0.740573204279653, 0.7469419669889471, 0.7133956763833427, 0.7462604326901876, 0.7569583853454034, 0.7237545646086401, 0.742666424749385, 0.14021153757817284, 0.10775183636538932, 0.23620834806674562, 0.12182675358648176, 0.3502267257343993, 0.5011824071110318, 0.2627706369648215, 0.2912658434944061, 0.32014570203416737, 0.12878472751129122, 0.123292778829736, 0.12491281401815235, 0.1398593107798186, 0.138942108312753, 0.11010032915778445, 0.12757271580794438, 0.09517047271371759, 0.13462656266907524, 0.9085802394194447, 0.9414215924263266, 0.9365397679532219, 0.9075395691271356, 0.9169575286027498, 0.9033636964383225, 0.8926928587638161, 0.8697716380365732, 0.9497330851485817, 0.6319823636932771, 0.6235005388558478, 0.5310650247856283, 0.4973601226060439, 0.5512698516298798, 0.6268711959319594, 0.42720556668760723, 0.5930294196196354, 0.5730008490464162, 0.8156809914983267, 0.8333419408735403, 0.4010681731503277, 0.848262991628926, 0.8092128349399421, 0.8220152921135313, 0.8478839650034602, 0.8326694083289886, 0.8121598676468254, 0.1767311700378934, 0.15944425745697066, 0.12424227382923314, 0.19930255977436084, 0.1855739714996193, 0.2720019042444314, 0.1551292156303643, 0.16524720728059528, 0.27564980771080894, 0.6640124213200276, 0.14510534450721113, 0.166205185146451, 0.17647708127094686, 0.14994331759523105, 0.19246627021275475, 0.1689680676623495, 0.17576500165452413, 0.20950742087619523, 0.13335666710123428, 0.21351235004714508, 0.34409985965303136, 0.5587113507415649, 0.24655904391738848, 0.09958576712440803, 0.354873268428897, 0.5614547141298813, 0.09764582453351578, 0.6436801807810096, 0.4618458090358044, 0.2825451152977968, 0.45287254239265795, 0.6776444335370715, 0.23598207187042997, 0.3067964065699703, 0.660696622885103, 0.35619058148101457, 0.21354125153476822, 0.3235501550656682, 0.21860618788262387, 0.23632124025892431, 0.3132586890167549, 0.3954887585972988, 0.20997833149021083, 0.33150196978299773, 0.17501522309591344, 0.30800595606253023, 0.43319012793469724, 0.316073608650424, 0.4216381151486095, 0.5659065407453476, 0.2646661537989201, 0.34327467697220837, 0.24911372470995208, 0.26546126562342864, 0.7298663361959015, 0.7880125637809473, 0.7906707498585526, 0.6854381429739134, 0.7013521087380967, 0.7849856214637905, 0.6058936544697016, 0.734144468266652, 0.8158317105981897, 0.11891010565394522, 0.09524879378577555, 0.11315079185029275, 0.09984827076498681, 0.11566798324175065, 0.131624297782856, 0.10795024871015335, 0.1142966269095832, 0.11725484260094676, 0.1663239715079129, 0.28028362314601973, 0.17812582126416732, 0.19671024470177756, 0.19607226328037874, 0.44799356088826137, 0.5998279058584121, 0.17261786871810414, 0.20313748073804672, 0.5399954128388382, 0.5446755581121687, 0.5443532894547066, 0.48403514570579653, 0.506851598283111, 0.5426504287791678, 0.6295459368447263, 0.5777552782194448, 0.5342940333658541, 0.34159469168943446, 0.4186534415214155, 0.4351232262645377, 0.39289041978152905, 0.45671669901809653, 0.46387243925497146, 0.4306190897319486, 0.4668563201517181, 0.5153604688728315, 0.23333492983379012, 0.22428482077009415, 0.1882097771754302, 0.19070937459509962, 0.19272640535890917, 0.2068659205700254, 0.20352156837203683, 0.18685789795386032, 0.2024305662915058, 0.2044148664349683, 0.6145540096921462, 0.22575544182969454, 0.22667343672771068, 0.21976197140270237, 0.21352500146711795, 0.21075704466163392, 0.5284885053206527, 0.19484479320795023, 0.7746584627060441, 0.17851861251360046, 0.8013392130199789, 0.8008909292587658, 0.7721721037672282, 0.19019923237912972, 0.18313070353265526, 0.6926377356150906, 0.8277954249022977, 0.8320837033946867, 0.6069682966453476, 0.7789023276701926, 0.7681355123231278, 0.20533900354311785, 0.7906427470078236, 0.20482989875166346, 0.7786627467130436, 0.2057118686355932, 0.19920360489817712, 0.17568623636897485, 0.188642277820667, 0.18851622163149928, 0.18205703728041767, 0.1950654976389169, 0.18726334685067925, 0.1729761716441821, 0.1789323886416465, 0.08110725658742379, 0.08095477253691008, 0.07874505993587355, 0.07725179969550389, 0.0750040677966961, 0.0851555085028205, 0.08204996195316794, 0.07719232427978273, 0.07860559207939855]}, "mutation_prompt": null}
{"id": "c9e36459-4093-4018-9d55-20ae6ae83699", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Reduced initial population size for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Tweaked for improved balance\n        self.mutation_factor = 0.75  # Fine-tuned for better adaptability\n        self.crossover_rate = 0.85  # Slightly decreased for more explorative recombination\n        self.local_search_rate = 0.45  # Increased for more frequent local searches\n        self.adaptive_rate = 0.35  # Fine-tuned for effective parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.3, 0.5)  # Further increased noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.7, 0.85)  # Narrowed range for mutation factor\n        self.crossover_rate = np.random.uniform(0.75, 0.95)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.75  # Updated condition for recalibration\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.45  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Adjusted chance for dynamic reduction\n                self.population_size = max(15, int(self.population_size * 0.8))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Local Search and Dynamic Parameter Scaling for Robust Black Box Optimization.", "configspace": "", "generation": 81, "fitness": 0.4179017427533043, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "9af966f3-2272-4fa7-b1a5-7f61819b5127", "metadata": {"aucs": [0.8792755967863722, 0.8515368651586559, 0.8751069968714505, 0.8822595222319579, 0.8616058975122434, 0.8588042148807906, 0.8761597329376752, 0.8623810601310163, 0.8714733034041583, 0.812069230529512, 0.7677597154168786, 0.7728383211350677, 0.8006040736641751, 0.760362238007217, 0.8058655289078218, 0.7920338977042225, 0.7688052923858748, 0.7973859751379392, 0.4276494244596085, 0.45056244710009385, 0.38359417869063694, 0.4261099480477428, 0.13340956494564815, 0.49776845754380694, 0.14815448216281057, 0.25135056188779714, 0.21508790101564623, 0.16584676092250394, 0.12697706977823164, 0.1239672295709201, 0.1502821795340371, 0.13810745962812432, 0.1505326379166394, 0.1343762586287368, 0.13317202667421535, 0.15186335971269094, 0.9285058505593525, 0.9144601060112616, 0.9198439281936848, 0.9384401096497502, 0.9230381996457189, 0.9284993260752726, 0.9370458068850682, 0.945211542092349, 0.91452219133475, 0.6797585849051434, 0.6202826522955567, 0.6307508944806385, 0.7067563825926967, 0.628386990628634, 0.6381354062297455, 0.6821621435280703, 0.6788523967623801, 0.6970090889489589, 0.8397987865315375, 0.8584884413439495, 0.8338515948414111, 0.8385367702078652, 0.7821008094807528, 0.8320164355756621, 0.8479586480917898, 0.8439682206739382, 0.8593289980847835, 0.2561339093909336, 0.1899143223075841, 0.19502333024703855, 0.1559904807252973, 0.1467582588164038, 0.1800127278159145, 0.2073539778533, 0.1702137237584015, 0.13441935993246368, 0.22324478084828092, 0.12418316182043876, 0.1910177892163697, 0.22512277878163656, 0.13794286648216691, 0.3210949747003249, 0.16876597824055695, 0.2524233864652833, 0.16884892076648395, 0.099114651305099, 0.30050725272233647, 0.21768302340540002, 0.12588252712489234, 0.18303098273728124, 0.06583951412928013, 0.12498138207036313, 0.3307149584110325, 0.5895783663956842, 0.20552845617933735, 0.19078669064996934, 0.1981541087134775, 0.1910860129797316, 0.37012258147755406, 0.4714354313525315, 0.4827173866569322, 0.232498642840118, 0.6755360281190955, 0.06253441284297456, 0.06894865902312453, 0.3068080161232781, 0.08130316812518557, 0.3384718674766777, 0.1877441027447544, 0.2045692306783763, 0.13275554495392716, 0.34318858098184424, 0.2713818875613586, 0.3387243307231099, 0.3525244408102658, 0.5065281897245659, 0.30534769931636485, 0.3331935514639186, 0.3124212998388298, 0.27192179048179366, 0.33267630743128673, 0.6981901075438373, 0.6834374518041544, 0.6588130286707337, 0.7264032653733727, 0.6704058815829743, 0.6528391128353299, 0.5982923694867575, 0.7052124777081344, 0.6914419973114508, 0.11340022295354102, 0.09391645300869256, 0.13408686989868634, 0.12880627682872836, 0.12127374666038937, 0.12914495554610161, 0.10584315838293878, 0.10259016053281034, 0.11740312966562727, 0.20372052253518558, 0.48077767355863354, 0.6834392625559902, 0.2684265068709719, 0.19329822639387162, 0.17449337654249375, 0.17829785996091563, 0.18265231999256415, 0.16764144725290986, 0.5095818244808261, 0.5841857363549723, 0.5132425431841922, 0.5527035846712263, 0.513531809863587, 0.521507642891659, 0.592039400777995, 0.6168352496759345, 0.6091025307556118, 0.34342691419975213, 0.36835963215195744, 0.41138746287399097, 0.37758623968373717, 0.2632167950007872, 0.3840807877706176, 0.4951729070134625, 0.48456726847406906, 0.4817025640925553, 0.2036974824766593, 0.2143053589229318, 0.2156504606951034, 0.204226177471444, 0.17914732959674673, 0.19903251879378525, 0.20329873890051176, 0.1984826849150284, 0.1977955082817746, 0.22756806679884556, 0.2108682648669431, 0.6272135848481242, 0.23414919360512254, 0.22258076990226794, 0.39255303579025014, 0.201562213638397, 0.6682330567019841, 0.22312726337306565, 0.7853229484090365, 0.7450164458561845, 0.727605285385533, 0.8710482778110519, 0.7243707033503438, 0.8355739094747541, 0.20646229976461483, 0.7822815337757, 0.7408233811038738, 0.6228662617621512, 0.20512399217603594, 0.20649521224304868, 0.8262288840658002, 0.2039351605402463, 0.7801848496371281, 0.20987740735210259, 0.8305577742915777, 0.20660789824930748, 0.20222934626555245, 0.1757009227503621, 0.17535100148265215, 0.1757477181014887, 0.21164010993247406, 0.19947416341284585, 0.1943958948442952, 0.18501083851356692, 0.1859118993087111, 0.08346414986668826, 0.07577026534145703, 0.0820776873395982, 0.0813480691748455, 0.08409672160279913, 0.0801626008776597, 0.07574027837669017, 0.09244100070869976, 0.07830555419686303]}, "mutation_prompt": null}
{"id": "701cd8aa-00c4-4074-b2a7-1f8d040a6316", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Reduced initial population size for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Tweaked for improved balance\n        self.mutation_factor = 0.75  # Fine-tuned for better adaptability\n        self.crossover_rate = 0.85  # Slightly decreased for more explorative recombination\n        self.local_search_rate = 0.45  # Increased for more frequent local searches\n        self.adaptive_rate = 0.35  # Fine-tuned for effective parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.3, 0.5)  # Further increased noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.7, 0.85)  # Narrowed range for mutation factor\n        self.crossover_rate = np.random.uniform(0.75, 0.95)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.75  # Updated condition for recalibration\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.45  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Adjusted chance for dynamic reduction\n                self.population_size = max(15, int(self.population_size * 0.8))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Local Search and Dynamic Parameter Scaling for Robust Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8792755967863722, 0.8515368651586559, 0.8751069968714505, 0.8822595222319579, 0.8616058975122434, 0.8588042148807906, 0.8761597329376752, 0.8623810601310163, 0.8714733034041583, 0.812069230529512, 0.7677597154168786, 0.7728383211350677, 0.8006040736641751, 0.760362238007217, 0.8058655289078218, 0.7920338977042225, 0.7688052923858748, 0.7973859751379392, 0.4276494244596085, 0.45056244710009385, 0.38359417869063694, 0.4261099480477428, 0.13340956494564815, 0.49776845754380694, 0.14815448216281057, 0.25135056188779714, 0.21508790101564623, 0.16584676092250394, 0.12697706977823164, 0.1239672295709201, 0.1502821795340371, 0.13810745962812432, 0.1505326379166394, 0.1343762586287368, 0.13317202667421535, 0.15186335971269094, 0.9285058505593525, 0.9144601060112616, 0.9198439281936848, 0.9384401096497502, 0.9230381996457189, 0.9284993260752726, 0.9370458068850682, 0.945211542092349, 0.91452219133475, 0.6797585849051434, 0.6202826522955567, 0.6307508944806385, 0.7067563825926967, 0.628386990628634, 0.6381354062297455, 0.6821621435280703, 0.6788523967623801, 0.6970090889489589, 0.8397987865315375, 0.8584884413439495, 0.8338515948414111, 0.8385367702078652, 0.7821008094807528, 0.8320164355756621, 0.8479586480917898, 0.8439682206739382, 0.8593289980847835, 0.2561339093909336, 0.1899143223075841, 0.19502333024703855, 0.1559904807252973, 0.1467582588164038, 0.1800127278159145, 0.2073539778533, 0.1702137237584015, 0.13441935993246368, 0.22324478084828092, 0.12418316182043876, 0.1910177892163697, 0.22512277878163656, 0.13794286648216691, 0.3210949747003249, 0.16876597824055695, 0.2524233864652833, 0.16884892076648395, 0.099114651305099, 0.30050725272233647, 0.21768302340540002, 0.12588252712489234, 0.18303098273728124, 0.06583951412928013, 0.12498138207036313, 0.3307149584110325, 0.5895783663956842, 0.20552845617933735, 0.19078669064996934, 0.1981541087134775, 0.1910860129797316, 0.37012258147755406, 0.4714354313525315, 0.4827173866569322, 0.232498642840118, 0.6755360281190955, 0.06253441284297456, 0.06894865902312453, 0.3068080161232781, 0.08130316812518557, 0.3384718674766777, 0.1877441027447544, 0.2045692306783763, 0.13275554495392716, 0.34318858098184424, 0.2713818875613586, 0.3387243307231099, 0.3525244408102658, 0.5065281897245659, 0.30534769931636485, 0.3331935514639186, 0.3124212998388298, 0.27192179048179366, 0.33267630743128673, 0.6981901075438373, 0.6834374518041544, 0.6588130286707337, 0.7264032653733727, 0.6704058815829743, 0.6528391128353299, 0.5982923694867575, 0.7052124777081344, 0.6914419973114508, 0.11340022295354102, 0.09391645300869256, 0.13408686989868634, 0.12880627682872836, 0.12127374666038937, 0.12914495554610161, 0.10584315838293878, 0.10259016053281034, 0.11740312966562727, 0.20372052253518558, 0.48077767355863354, 0.6834392625559902, 0.2684265068709719, 0.19329822639387162, 0.17449337654249375, 0.17829785996091563, 0.18265231999256415, 0.16764144725290986, 0.5095818244808261, 0.5841857363549723, 0.5132425431841922, 0.5527035846712263, 0.513531809863587, 0.521507642891659, 0.592039400777995, 0.6168352496759345, 0.6091025307556118, 0.34342691419975213, 0.36835963215195744, 0.41138746287399097, 0.37758623968373717, 0.2632167950007872, 0.3840807877706176, 0.4951729070134625, 0.48456726847406906, 0.4817025640925553, 0.2036974824766593, 0.2143053589229318, 0.2156504606951034, 0.204226177471444, 0.17914732959674673, 0.19903251879378525, 0.20329873890051176, 0.1984826849150284, 0.1977955082817746, 0.22756806679884556, 0.2108682648669431, 0.6272135848481242, 0.23414919360512254, 0.22258076990226794, 0.39255303579025014, 0.201562213638397, 0.6682330567019841, 0.22312726337306565, 0.7853229484090365, 0.7450164458561845, 0.727605285385533, 0.8710482778110519, 0.7243707033503438, 0.8355739094747541, 0.20646229976461483, 0.7822815337757, 0.7408233811038738, 0.6228662617621512, 0.20512399217603594, 0.20649521224304868, 0.8262288840658002, 0.2039351605402463, 0.7801848496371281, 0.20987740735210259, 0.8305577742915777, 0.20660789824930748, 0.20222934626555245, 0.1757009227503621, 0.17535100148265215, 0.1757477181014887, 0.21164010993247406, 0.19947416341284585, 0.1943958948442952, 0.18501083851356692, 0.1859118993087111, 0.08346414986668826, 0.07577026534145703, 0.0820776873395982, 0.0813480691748455, 0.08409672160279913, 0.0801626008776597, 0.07574027837669017, 0.09244100070869976, 0.07830555419686303]}, "mutation_prompt": null}
{"id": "6cc09f7c-a76f-4b75-a605-62a28a5c0dc7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Retain initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Maintain diversity for exploration\n        self.mutation_factor = 0.8  # Tweaked for adaptability\n        self.crossover_rate = 0.8  # Adjust for balance\n        self.local_search_rate = 0.5  # Increase for enhanced local exploration\n        self.adaptive_rate = 0.4  # Adjust for better parameter adaptation\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.4, 0.6)  # Enhanced noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.7, 0.85)  # Maintain range for mutation factor\n        self.crossover_rate = np.random.uniform(0.75, 0.95)  # Maintain range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.75  # Keep recalibration condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Optimize rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Refine chance for dynamic reduction\n                self.population_size = max(15, int(self.population_size * 0.85))  # Refine population size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Improved Local Search and Parameter Dynamics for Superior Convergence in Black Box Optimization.", "configspace": "", "generation": 83, "fitness": 0.3790924046991067, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8557692687634733, 0.8275507996663919, 0.8424195147676055, 0.8554731471612077, 0.8085928434224972, 0.8577099860820169, 0.8606666364588551, 0.8226195304792132, 0.8516923049701559, 0.7462281186206028, 0.7017919116171314, 0.7622366551350295, 0.7441359708452984, 0.7169962078684778, 0.7688277095095736, 0.7519462261183869, 0.7214783055767028, 0.7643973470269706, 0.1507961740311019, 0.24987592647321466, 0.12687113972907504, 0.13012413009505908, 0.2823995019893577, 0.48062033761678036, 0.4044201482509048, 0.3169563553036002, 0.15852597462408868, 0.15365880514783692, 0.13334050924275287, 0.1333376222409124, 0.12811228290115872, 0.1300388678242811, 0.10727550256837526, 0.12259814475725994, 0.11655976310641747, 0.13260676053692044, 0.921743776457104, 0.95730837466491, 0.9239511574514835, 0.9419182543323427, 0.9251847292944916, 0.9206707296447436, 0.9507964659392548, 0.9368701421718311, 0.9258742268604763, 0.6690452110404541, 0.6346884459440649, 0.6475023350884013, 0.6478566316144773, 0.5723987292758846, 0.6145249208507144, 0.6411734986641806, 0.5101303448420339, 0.6462450621094287, 0.7670917075080323, 0.3613664461752385, 0.8041926663375042, 0.8451642826446057, 0.8203956469278779, 0.8159671865142121, 0.776411290070301, 0.7636581641999565, 0.8374066986355146, 0.143989846442517, 0.20066659260879383, 0.17518181842863434, 0.1246062425170823, 0.12204802808622683, 0.1930317783207437, 0.16494699923083844, 0.22897247562955614, 0.38267090672271564, 0.14597303438893672, 0.18197456733220574, 0.1686875882424681, 0.16928624033023043, 0.1749816556031979, 0.28377633305751226, 0.18175514514654667, 0.18201100884478172, 0.16639079486404185, 0.31838730307826246, 0.15220427244402512, 0.09745025356309767, 0.295385846119815, 0.2237562462800089, 0.15424979231081615, 0.47005380594113544, 0.37460458802768404, 0.12014084100253308, 0.3416670053520079, 0.4887238146114349, 0.3112860289570277, 0.2871799625487784, 0.3119259238194252, 0.1690160012755454, 0.31864695040712265, 0.38267856386459453, 0.2625877934650679, 0.34459207410538173, 0.1663540459419941, 0.17833558415839723, 0.10395519112177276, 0.17913612605624496, 0.11141447189963471, 0.1719226963291014, 0.2614751902365031, 0.2483515961244016, 0.16056635648297757, 0.30999962567670236, 0.36018748870077333, 0.44878870003773697, 0.31675437176628907, 0.225143106214022, 0.23216396304828224, 0.3324410266317791, 0.3346985528519958, 0.6575023068909438, 0.7272445243819472, 0.7683030764544645, 0.7043541366842003, 0.6585244922435047, 0.7569681171958977, 0.620801713737113, 0.5387129669119137, 0.6699724190166414, 0.14558754644206606, 0.10884565730874873, 0.09551777808004813, 0.1102682967649613, 0.0920536896353289, 0.10550960794376174, 0.0904354798034912, 0.0926605612496012, 0.09526147755583192, 0.3103205034479415, 0.14713615955361747, 0.23035574042757212, 0.1676641266641189, 0.26611527680457203, 0.2380874032617143, 0.15992399510910615, 0.38894847079600536, 0.18602726251242852, 0.5167195494031405, 0.5086874333089075, 0.48030021733225525, 0.5007042986898737, 0.5215811773845056, 0.5428834713858357, 0.6043412430489762, 0.5293657690672431, 0.520547960071132, 0.40354929049603794, 0.3604988137859425, 0.3796153512834407, 0.2781117637175162, 0.4154279038366644, 0.3755355223931651, 0.4016131881685867, 0.3522928416369797, 0.3946262170553899, 0.18574992309283211, 0.18803987485282803, 0.20142732728299295, 0.20102934084765578, 0.1926138645417006, 0.2017996206274002, 0.18929952135559613, 0.19282429848764093, 0.19445311665362142, 0.2339690939764818, 0.22408801594297723, 0.2003155716327656, 0.18849325890831992, 0.19783785422000277, 0.22409332286116102, 0.4613393893293788, 0.22091614996445819, 0.23609556030130796, 0.7957233564774642, 0.7716827524822001, 0.1960680370781901, 0.7902037803723955, 0.20098980210890416, 0.19144326600724426, 0.7820552557048288, 0.16486348516508698, 0.6785960316348398, 0.7667635115255721, 0.2018462500687822, 0.2101832117174457, 0.16079482201528483, 0.1964985441140047, 0.20435347641559087, 0.20749169072575258, 0.15276391842471693, 0.15015522693461714, 0.22246554853538514, 0.1824646333972627, 0.17651576672669123, 0.18743442159719115, 0.18328724448386846, 0.19414572050348988, 0.18436404712409105, 0.19130367644312074, 0.21647926696288533, 0.08020464177270425, 0.08716937111501977, 0.08261782835198772, 0.07763100049289551, 0.07846508704829758, 0.07835732742844825, 0.07493177699768672, 0.07854367285976638, 0.07584828833347945]}, "mutation_prompt": null}
{"id": "66ff5de8-2dae-4c88-bdd5-0c2ec0b27289", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for greater diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.75  # Refined for better exploration vs exploitation balance\n        self.mutation_factor = 0.8  # Adjusted for improved global search ability\n        self.crossover_rate = 0.9  # Increased for more recombination\n        self.local_search_rate = 0.5  # Further increased to exploit local minima effectively\n        self.adaptive_rate = 0.4  # Modified for better adaptation to current landscape\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.25, 0.6)  # Broadened noise scale for more comprehensive exploration\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Wider range for mutation factor to enhance adaptability\n        self.crossover_rate = np.random.uniform(0.8, 0.95)  # Close monitoring of crossover rates for optimization\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-4 else 0.7  # Updated condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-4 else 0.5  # Adjusted rates for improved learning\n\n    def dynamic_neighborhood_local_search(self, individual, func):\n        neighborhood_size = 3\n        best_candidate = individual\n        best_fitness = func(individual)\n        self.num_evaluations += 1\n        for _ in range(neighborhood_size):\n            candidate = individual + np.random.uniform(-0.1, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_fitness = func(candidate)\n            self.num_evaluations += 1\n            if candidate_fitness < best_fitness:\n                best_fitness = candidate_fitness\n                best_candidate = candidate\n        return best_candidate, best_fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate, local_fitness = self.dynamic_neighborhood_local_search(self.population[i], func)\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Reduced chance for dynamic reduction based on performance\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted population size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Dynamic Neighborhood-based Local Search for Improved Global Optimization.", "configspace": "", "generation": 84, "fitness": 0.29535614470877486, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.20.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.628014392969749, 0.6927761146634019, 0.6569710148179309, 0.6400167446989862, 0.6551225832086551, 0.6606950036088304, 0.6199907450033575, 0.6676369930664101, 0.6665006073221096, 0.42897146493554783, 0.47506327135440973, 0.4421357839674783, 0.3890081026899507, 0.4802418431899388, 0.43892272774254526, 0.4268514999841606, 0.41941416030905654, 0.4386381865578114, 0.1075126520202433, 0.12274283390138385, 0.11587467984503819, 0.10834954557179621, 0.11926180923973095, 0.13297550202334896, 0.10473511052901407, 0.12034418638372868, 0.1242133261606364, 0.10804854684040766, 0.12328355323145457, 0.09555197797671244, 0.10972492617185492, 0.12200931688492733, 0.10273797869752765, 0.10575665513179466, 0.11295024068151893, 0.09984459025503856, 0.8782992328752612, 0.7820006753412261, 0.8631736523323259, 0.8201504737630938, 0.7813704488208546, 0.7870913994324953, 0.7928223342415609, 0.8967431272237998, 0.8426449456492546, 0.3256379232941633, 0.2923870171797799, 0.3275327584160663, 0.3288209695752886, 0.35600627331751666, 0.29868251093646647, 0.30227758931533943, 0.3294116295688292, 0.34232621565655375, 0.5301954657317063, 0.6666988267496781, 0.5337117298285072, 0.630823698400014, 0.6054297412886291, 0.6343889102130318, 0.6142156942378145, 0.6900806621880498, 0.6203530143668625, 0.19752835061648644, 0.16325270933154556, 0.26441749581806484, 0.18963963504088355, 0.16245053954693434, 0.18806641297522997, 0.19733141480906735, 0.24990147258886908, 0.34973817064735246, 0.15353678844690422, 0.1905189803539068, 0.1408103340424679, 0.1455959207841302, 0.13572574942200166, 0.15612679841932164, 0.16921894091242518, 0.1342765662440918, 0.1629025599871704, 0.1344436466462965, 0.09765209559113008, 0.2553907252477746, 0.13006661413668552, 0.2786529195855666, 0.15861066008524904, 0.19548336318317816, 0.2048552589478022, 0.15192019089455933, 0.2900894020067488, 0.38111071846509426, 0.302597820397848, 0.31409953863448103, 0.26110757944442164, 0.3475765972817805, 0.34913898691430334, 0.22001001892071703, 0.42499552443294064, 0.07788980198921969, 0.07024259123032683, 0.07157040650758939, 0.1231256356480741, 0.14072661522342644, 0.12987883534923916, 0.08070283594359295, 0.10718756653190065, 0.07183640832617932, 0.18382098533162938, 0.24442264214915876, 0.18585501258204729, 0.18243933682589486, 0.23523051021716113, 0.21077513116966218, 0.19202479993021437, 0.22078193650089273, 0.21744732251961585, 0.5136995371786028, 0.546285630744427, 0.4989317059570698, 0.5364258708120229, 0.5715033832696497, 0.5385955531923287, 0.514022265870991, 0.5514814795840883, 0.535013705018184, 0.10952399769034271, 0.10062584545045539, 0.11433206611458246, 0.12640525087478616, 0.11749992509113327, 0.1124866705316856, 0.09974345413701435, 0.10530457744644062, 0.10566445210636322, 0.17928962531361226, 0.18561237854042534, 0.14902599774448722, 0.20841749297677903, 0.21996615275130926, 0.20761089217982998, 0.19159531607376068, 0.18244450450165195, 0.16075384542629745, 0.3240788551255429, 0.28185807854572253, 0.29105811220295486, 0.3048710234471751, 0.2887504656006028, 0.2845649784431197, 0.28124302280209934, 0.33042345846812093, 0.31958584094000664, 0.23468757360072612, 0.24231318493384857, 0.24011535435048348, 0.2204432874708926, 0.23103730849357684, 0.21805870225172252, 0.23489432273518351, 0.24304019365452756, 0.21326165923064222, 0.19597031804721288, 0.18438906695730695, 0.20592509293886874, 0.20623106294686644, 0.1779360081655046, 0.20838214622949403, 0.21199428198259285, 0.19905921513884572, 0.16683472277537115, 0.20265093149286717, 0.2143499248491978, 0.20067981784311273, 0.1814946628420817, 0.2252005949110184, 0.23069197123060725, 0.24853152752998642, 0.20159477786210755, 0.17847616185297066, 0.17195679778256212, 0.6137868998452114, 0.17682583288886056, 0.6739996758294686, 0.5499587198102698, 0.49549131078849395, 0.3413476831340767, 0.47296809114044636, 0.5233951695307644, 0.5766073774062057, 0.5989236200786268, 0.23583921134136931, 0.4841223800533583, 0.274029597105795, 0.36534847254559066, 0.3135524737996569, 0.19552063747682502, 0.19821973048328778, 0.16960054086282272, 0.16996556914148464, 0.1910016080811442, 0.17887625712757438, 0.17406490423860888, 0.183407327193306, 0.1980903082097537, 0.17033525304653507, 0.18506699530382476, 0.07848624258544479, 0.07227968317839806, 0.07701207715216585, 0.07379680012770273, 0.07409813526494768, 0.07150318045607951, 0.07235662504191132, 0.06978003795662224, 0.08740828025497871]}, "mutation_prompt": null}
{"id": "1eb44d89-904b-48ff-9c9a-9f2e94668d66", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.9  # Adjusted for improved global search\n        self.mutation_factor = 0.8  # Modified for enhanced adaptability\n        self.crossover_rate = 0.9  # Increased for more thorough recombination\n        self.local_search_rate = 0.5  # Increased for intensified local search\n        self.adaptive_rate = 0.4  # Changed for better parameter tuning\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.4, 0.6)  # Increased noise range for higher diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Extended range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Broadened range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-4 else 0.7  # Adjusted condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-4 else 0.5  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.4:  # Adjusted chance for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Modified reduction factor\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridMemeticDE", "description": "Hybrid Memetic Differential Evolution with Stochastic Parameter Tuning and Adaptive Search Intensification for Enhanced Black Box Optimization.", "configspace": "", "generation": 85, "fitness": 0.397417989318453, "feedback": "The algorithm HybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8520992515305917, 0.8280959328714046, 0.8486085699899861, 0.8469261719085522, 0.8476936215548587, 0.8408397116074159, 0.8494105390080641, 0.8349847864846938, 0.8015058995877877, 0.7682174398696482, 0.7184234270949592, 0.7323386815430163, 0.7294633187724866, 0.7439167685727635, 0.7224639976679113, 0.7573945105231534, 0.7515971036743799, 0.7307288651112365, 0.25515201597564585, 0.23332452963445138, 0.12785872116477492, 0.12294320995354757, 0.3037346640256058, 0.12298564626361108, 0.3877630620768935, 0.15099216062380982, 0.11635372880458139, 0.13218830223545142, 0.12198946566474, 0.12274858700310232, 0.1339563741860076, 0.1602847110270501, 0.17876300780411547, 0.11566664596774245, 0.10502224617663347, 0.14101361158879788, 0.9313019637275697, 0.9569730807825458, 0.9146007388243163, 0.9385073131222339, 0.9030745566539523, 0.9081258772290491, 0.941193569085288, 0.9332501313340503, 0.9285879036395459, 0.5995585708687658, 0.5986569133257796, 0.6312053515504414, 0.6142188160514607, 0.5567069135041594, 0.6234222643408671, 0.6345376317044549, 0.6178658761802021, 0.4904708498486411, 0.8172863735145159, 0.7868096136224321, 0.7301103741145825, 0.8035822711807636, 0.8470818624779839, 0.8249444223800239, 0.8146852894644864, 0.8240961995632274, 0.7894566641505947, 0.2141665504037421, 0.21606397813666478, 0.19282617300980076, 0.14128613635577947, 0.1716680976180689, 0.2033595895768644, 0.22728392752235982, 0.14442242658469373, 0.33164833190659615, 0.15722386849020553, 0.19995579410778108, 0.20856221583894397, 0.1575891306340167, 0.17119889975913516, 0.18715134394803346, 0.1964304188578173, 0.23123496697992496, 0.15382708758240515, 0.30092879376959447, 0.2916875205905589, 0.33044817411965355, 0.4396929714417329, 0.2957448869182966, 0.194019710294433, 0.14205277831387864, 0.32508981519857094, 0.4045638309538536, 0.345529602659024, 0.4977886113839629, 0.39573806173752635, 0.29224567319444583, 0.3325546798698493, 0.41588847140700114, 0.6792123290431323, 0.40387171283743784, 0.20310271804832247, 0.2145473340408326, 0.21782685764425025, 0.05733576597757861, 0.39533428845935537, 0.4389199294353253, 0.13422277467391563, 0.16026852032389727, 0.16105443610649528, 0.14936753784335377, 0.3906454758093202, 0.3691887939097904, 0.4419215491751979, 0.3622974584219081, 0.31167460995768614, 0.3406284767811323, 0.3575173385972198, 0.46612745206489103, 0.375582461249623, 0.6469951826686899, 0.7521639505858638, 0.6110277807228752, 0.6562479850795682, 0.6620314707123038, 0.7683549597545725, 0.7029903608661178, 0.7685250460897739, 0.7209819456688125, 0.09532503771934464, 0.1037696311366908, 0.1053053057106974, 0.09398999420806053, 0.09695986134176149, 0.09913359573747782, 0.10239335211679135, 0.09063815613219117, 0.10767669049256823, 0.19243606144284753, 0.1529682924834782, 0.272611741848676, 0.17226805169070336, 0.30534272113683714, 0.20181528676218363, 0.4829159362527584, 0.25081073898619766, 0.15990825754145066, 0.5590256344379742, 0.48181811924843077, 0.4359133246141532, 0.5258838058736843, 0.45003334392706573, 0.43357823171394416, 0.5253648474413861, 0.5149085940539941, 0.5076746241712597, 0.3963679712697178, 0.3516808307818685, 0.3817243042467735, 0.38202663891581146, 0.392087511241472, 0.336356090180173, 0.42032642833805445, 0.4104677737898681, 0.36803785838089675, 0.201760403471978, 0.18824894225059052, 0.19940691239483332, 0.19245694493307697, 0.19917082962104604, 0.2028591739719242, 0.20037916727685878, 0.18979742436018576, 0.19966777944569913, 0.6078222021871882, 0.3628789424529425, 0.21298078350974825, 0.19630929484162896, 0.21717738908634043, 0.471191876203613, 0.3677058677222117, 0.22481092665122382, 0.2155088267111539, 0.18915209142824785, 0.7763402187016808, 0.19204783923081437, 0.8391898610470852, 0.19528367206149166, 0.8054742133550763, 0.1807041612785626, 0.7025884958579647, 0.17451645925796833, 0.8646734769804648, 0.20431168712003556, 0.7663375789330689, 0.7584274560566128, 0.20159764906813915, 0.7420288799984032, 0.15086138293122708, 0.20721831294290727, 0.1519247527351335, 0.21320814364454033, 0.19771162431941292, 0.1794914468304829, 0.1792065165932467, 0.20910491849873514, 0.20148557584872206, 0.18452284324074042, 0.17917317529286791, 0.17962884708278148, 0.09316727508837319, 0.08953701411806947, 0.07886856206526571, 0.09443410094453497, 0.09315594938609961, 0.07991775174469218, 0.08101593198455792, 0.08652513498962855, 0.08217465816285408]}, "mutation_prompt": null}
{"id": "2921d485-60d7-4072-a3b1-68d368a9c687", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Reduced initial population size for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Tweaked for improved balance\n        self.mutation_factor = 0.75  # Fine-tuned for better adaptability\n        self.crossover_rate = 0.85  # Slightly decreased for more explorative recombination\n        self.local_search_rate = 0.45  # Increased for more frequent local searches\n        self.adaptive_rate = 0.35  # Fine-tuned for effective parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.3, 0.5)  # Further increased noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.7, 0.85)  # Narrowed range for mutation factor\n        self.crossover_rate = np.random.uniform(0.75, 0.95)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.85 if fitness_std < 1e-3 else 0.75  # Updated condition for recalibration\n        self.adaptive_rate = 0.25 if fitness_std < 1e-3 else 0.45  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Adjusted chance for dynamic reduction\n                self.population_size = max(15, int(self.population_size * 0.8))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Local Search and Dynamic Parameter Scaling for Robust Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8792755967863722, 0.8515368651586559, 0.8751069968714505, 0.8822595222319579, 0.8616058975122434, 0.8588042148807906, 0.8761597329376752, 0.8623810601310163, 0.8714733034041583, 0.812069230529512, 0.7677597154168786, 0.7728383211350677, 0.8006040736641751, 0.760362238007217, 0.8058655289078218, 0.7920338977042225, 0.7688052923858748, 0.7973859751379392, 0.4276494244596085, 0.45056244710009385, 0.38359417869063694, 0.4261099480477428, 0.13340956494564815, 0.49776845754380694, 0.14815448216281057, 0.25135056188779714, 0.21508790101564623, 0.16584676092250394, 0.12697706977823164, 0.1239672295709201, 0.1502821795340371, 0.13810745962812432, 0.1505326379166394, 0.1343762586287368, 0.13317202667421535, 0.15186335971269094, 0.9285058505593525, 0.9144601060112616, 0.9198439281936848, 0.9384401096497502, 0.9230381996457189, 0.9284993260752726, 0.9370458068850682, 0.945211542092349, 0.91452219133475, 0.6797585849051434, 0.6202826522955567, 0.6307508944806385, 0.7067563825926967, 0.628386990628634, 0.6381354062297455, 0.6821621435280703, 0.6788523967623801, 0.6970090889489589, 0.8397987865315375, 0.8584884413439495, 0.8338515948414111, 0.8385367702078652, 0.7821008094807528, 0.8320164355756621, 0.8479586480917898, 0.8439682206739382, 0.8593289980847835, 0.2561339093909336, 0.1899143223075841, 0.19502333024703855, 0.1559904807252973, 0.1467582588164038, 0.1800127278159145, 0.2073539778533, 0.1702137237584015, 0.13441935993246368, 0.22324478084828092, 0.12418316182043876, 0.1910177892163697, 0.22512277878163656, 0.13794286648216691, 0.3210949747003249, 0.16876597824055695, 0.2524233864652833, 0.16884892076648395, 0.099114651305099, 0.30050725272233647, 0.21768302340540002, 0.12588252712489234, 0.18303098273728124, 0.06583951412928013, 0.12498138207036313, 0.3307149584110325, 0.5895783663956842, 0.20552845617933735, 0.19078669064996934, 0.1981541087134775, 0.1910860129797316, 0.37012258147755406, 0.4714354313525315, 0.4827173866569322, 0.232498642840118, 0.6755360281190955, 0.06253441284297456, 0.06894865902312453, 0.3068080161232781, 0.08130316812518557, 0.3384718674766777, 0.1877441027447544, 0.2045692306783763, 0.13275554495392716, 0.34318858098184424, 0.2713818875613586, 0.3387243307231099, 0.3525244408102658, 0.5065281897245659, 0.30534769931636485, 0.3331935514639186, 0.3124212998388298, 0.27192179048179366, 0.33267630743128673, 0.6981901075438373, 0.6834374518041544, 0.6588130286707337, 0.7264032653733727, 0.6704058815829743, 0.6528391128353299, 0.5982923694867575, 0.7052124777081344, 0.6914419973114508, 0.11340022295354102, 0.09391645300869256, 0.13408686989868634, 0.12880627682872836, 0.12127374666038937, 0.12914495554610161, 0.10584315838293878, 0.10259016053281034, 0.11740312966562727, 0.20372052253518558, 0.48077767355863354, 0.6834392625559902, 0.2684265068709719, 0.19329822639387162, 0.17449337654249375, 0.17829785996091563, 0.18265231999256415, 0.16764144725290986, 0.5095818244808261, 0.5841857363549723, 0.5132425431841922, 0.5527035846712263, 0.513531809863587, 0.521507642891659, 0.592039400777995, 0.6168352496759345, 0.6091025307556118, 0.34342691419975213, 0.36835963215195744, 0.41138746287399097, 0.37758623968373717, 0.2632167950007872, 0.3840807877706176, 0.4951729070134625, 0.48456726847406906, 0.4817025640925553, 0.2036974824766593, 0.2143053589229318, 0.2156504606951034, 0.204226177471444, 0.17914732959674673, 0.19903251879378525, 0.20329873890051176, 0.1984826849150284, 0.1977955082817746, 0.22756806679884556, 0.2108682648669431, 0.6272135848481242, 0.23414919360512254, 0.22258076990226794, 0.39255303579025014, 0.201562213638397, 0.6682330567019841, 0.22312726337306565, 0.7853229484090365, 0.7450164458561845, 0.727605285385533, 0.8710482778110519, 0.7243707033503438, 0.8355739094747541, 0.20646229976461483, 0.7822815337757, 0.7408233811038738, 0.6228662617621512, 0.20512399217603594, 0.20649521224304868, 0.8262288840658002, 0.2039351605402463, 0.7801848496371281, 0.20987740735210259, 0.8305577742915777, 0.20660789824930748, 0.20222934626555245, 0.1757009227503621, 0.17535100148265215, 0.1757477181014887, 0.21164010993247406, 0.19947416341284585, 0.1943958948442952, 0.18501083851356692, 0.1859118993087111, 0.08346414986668826, 0.07577026534145703, 0.0820776873395982, 0.0813480691748455, 0.08409672160279913, 0.0801626008776597, 0.07574027837669017, 0.09244100070869976, 0.07830555419686303]}, "mutation_prompt": null}
{"id": "ad09c368-04bb-416b-ad76-b955034914ae", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100  # Increased initial population size for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.9  # Increased for higher diversity in the search\n        self.mutation_factor = 0.7  # Fine-tuned for steady exploration\n        self.crossover_rate = 0.7  # Lowered for increased exploration\n        self.local_search_rate = 0.5  # Further increased to intensify local search\n        self.adaptive_rate = 0.5  # Increased for dynamic strategy adjustment\n        self.switch_threshold = 0.3  # New parameter to decide strategy switch\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Modified noise range for better control\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Broader range for mutation factor\n        self.crossover_rate = np.random.uniform(0.6, 0.9)  # Expanded range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-2 else 0.9  # Adjusted condition for diversity factor\n        self.adaptive_rate = 0.4 if fitness_std < 1e-2 else 0.55  # Adjusted parameter based on fitness dynamics\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < self.switch_threshold:  # New condition for dynamic strategy change\n                self.population_size = max(20, int(self.population_size * 0.85))  # Adjusted reduction strategy\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Dynamic Strategy Switch and Enhanced Local Search for Balancing Exploration and Exploitation.", "configspace": "", "generation": 87, "fitness": 0.3011033484594272, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.7086613415744266, 0.7290173384084857, 0.744418844393131, 0.7248981463128086, 0.7196332218975183, 0.7266151308574591, 0.7193239393968952, 0.7335955826610638, 0.7296882942192779, 0.5477813830207238, 0.580895263831875, 0.5508689992065962, 0.5482611042152571, 0.5634356050794995, 0.5578837761731528, 0.5545209581800741, 0.5540945797004696, 0.580654503650673, 0.13166042011000012, 0.10001347580932829, 0.28247377449537947, 0.09854104959203436, 0.18832036711157984, 0.11099018977276431, 0.11967558569567394, 0.10805385933664291, 0.16264096737286549, 0.08813976930295098, 0.10270437631082618, 0.09523277070836389, 0.14293921162906553, 0.11227523527989924, 0.10407316486529528, 0.10437484759037818, 0.11097653954759223, 0.10851091737863261, 0.8742472730690354, 0.928255053896638, 0.825346979732086, 0.9001982939118041, 0.9279281730447704, 0.8738636957865408, 0.8761790660692448, 0.8896372967536604, 0.8360465869553795, 0.39690602944929565, 0.42132054301902566, 0.381598421641154, 0.4230758820262869, 0.36681776862849746, 0.44197658166977083, 0.41233453950689014, 0.3929337100297212, 0.4328829182371713, 0.5463129259996127, 0.5874397598475607, 0.6238072761338174, 0.5235352311099141, 0.5516001124459053, 0.6109122053637308, 0.5606539536883207, 0.5648462908897177, 0.5729995666213464, 0.21359625886811706, 0.1627267053618623, 0.19937120031625732, 0.22416614212961516, 0.16147425032324192, 0.17911724546051355, 0.17397143031630735, 0.19179740126622413, 0.17751268728250813, 0.1617775826539939, 0.15311585668065641, 0.150372052986822, 0.19067344808738973, 0.22468739927494985, 0.21132784743019506, 0.16854923740215877, 0.20799383065871513, 0.24093641870935045, 0.11874894875773045, 0.13330086697673738, 0.11658516467122348, 0.10874895765613346, 0.13554795152711163, 0.11945433574666964, 0.1260304042273741, 0.17575511819834633, 0.1637716249423138, 0.2208107143360859, 0.2519678920760079, 0.2389478184252971, 0.20629280625367596, 0.1942061009312892, 0.2564060489704363, 0.23784537788436655, 0.248555930111934, 0.3090602298345776, 0.015963863024537783, 0.03572540080781128, 0.04573746169514836, 0.03540967794296079, 0.05660947291988794, 0.07887262988654187, 0.06298599764747592, 0.07233813166569802, 0.05260482118747456, 0.13892156732460081, 0.15938886012269937, 0.18934094994464734, 0.20531031115994125, 0.19506938537387375, 0.20880292129134892, 0.16249974760539176, 0.16729640513354993, 0.1651448380771795, 0.5530875110749875, 0.5239354840471278, 0.5589610803049576, 0.5077005528154293, 0.5747268731320327, 0.5395432657664192, 0.5224376033565943, 0.5400856978360402, 0.564654410445762, 0.0900453082316448, 0.08157812781152751, 0.09193791403241336, 0.08620104140993368, 0.07922203607550216, 0.08642181024313267, 0.09558823174412467, 0.08280824227043326, 0.08424815247171169, 0.16528257545149805, 0.1700605828516154, 0.17097858273060718, 0.17466287458396434, 0.19391137760904797, 0.17461412175153368, 0.16292138300499426, 0.17634227356970678, 0.18079881432957023, 0.3187319644507286, 0.31323401202769574, 0.2987166791072744, 0.32487736039466697, 0.3293838919873531, 0.328008873607333, 0.36358195704218266, 0.35455505321226144, 0.33425346765564645, 0.22156573692615555, 0.1987561315407934, 0.24184103266445756, 0.21018583050485107, 0.22650871997198585, 0.22590646938094838, 0.25065501248758504, 0.22063582234174717, 0.2385435293317475, 0.1792380911975464, 0.1976262205771835, 0.20519656455104907, 0.2118560512130998, 0.18038005819977276, 0.18983169912773823, 0.18127151030756639, 0.19370007166807868, 0.18905951579215008, 0.18961744773976108, 0.19163111981279457, 0.18006581922606324, 0.1764476866918041, 0.190244259197062, 0.19224422089312843, 0.18422500236638828, 0.19366425458936476, 0.19596952276955537, 0.18413642398697871, 0.5800773745484449, 0.6259440570858614, 0.5943235036282768, 0.19344144915160177, 0.4652336381427058, 0.4848365567860198, 0.1692848733471084, 0.5467080083735548, 0.5085561910316279, 0.6020151988534885, 0.6322609053898123, 0.19955529518308235, 0.45905123907497514, 0.19313922991125654, 0.18876215231496607, 0.4531070340759171, 0.6013038045847573, 0.1839522112625278, 0.17975375953690564, 0.1810223180656445, 0.17750133168387816, 0.1853540015557431, 0.18982569207195898, 0.17602571770204833, 0.18810703347497537, 0.18527936604486572, 0.06535875558788007, 0.08976884151911857, 0.07110636105116264, 0.06956702797092529, 0.07497242931464332, 0.072820977676061, 0.06961969157024528, 0.07558226475204755, 0.07327556165484894]}, "mutation_prompt": null}
{"id": "71f10c15-0126-437e-9768-38091841d593", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Lowered for improved exploration\n        self.mutation_factor = 0.8  # Tweaked for robustness in adaptation\n        self.crossover_rate = 0.9  # Increased for better recombination\n        self.local_search_rate = 0.4  # Balanced for local search\n        self.adaptive_rate = 0.3  # Adjusted for dynamic parameter updates\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.25, 0.45)  # Adjusted noise range\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.6, 0.9)  # Wider range for mutation factor\n        self.crossover_rate = np.random.uniform(0.8, 0.95)  # Adjusted range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7  # Updated diversity condition\n        self.adaptive_rate = 0.2 if fitness_std < 1e-3 else 0.4  # Adjusted adaptive rate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Fine-tuned chance for reduction\n                self.population_size = max(15, int(self.population_size * 0.75))  # Adjusted population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution utilizing stochastic parameter adaptation and dynamic population management for robust black box optimization.", "configspace": "", "generation": 88, "fitness": 0.38347360176988876, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8969474277946483, 0.8851295361879568, 0.890271128829141, 0.8853133555318939, 0.8864137277115753, 0.8860424680729703, 0.8835137605622656, 0.8969144424984226, 0.8652662169751308, 0.8073326195782543, 0.8083983231403029, 0.8027049778357076, 0.7809633000568506, 0.7740285359562019, 0.8222151719383872, 0.8225817959791681, 0.8205545567560708, 0.7840377719678174, 0.5982521575638453, 0.1476213532713173, 0.4116226075741998, 0.14048438522250184, 0.15367877668751773, 0.17397663973347244, 0.14386652427566582, 0.6114437328015108, 0.16074889432319484, 0.14393331626689176, 0.12657521113133463, 0.12276099957348674, 0.14180001278655907, 0.12508147811877046, 0.16136398148828524, 0.14021622264737943, 0.14888062997752294, 0.13927183041370939, 0.9436876054653707, 0.9235170944852508, 0.9154390868244524, 0.9323309485803765, 0.928681816071282, 0.9090659524432796, 0.9341775339228923, 0.9245778723069238, 0.925383152296457, 0.5685189578511887, 0.595168343605514, 0.3265828783477336, 0.35880631916768935, 0.35677294517328906, 0.44291636890495967, 0.6610645388886225, 0.4553447112142841, 0.4311551063271458, 0.8310282684255749, 0.8482284058880236, 0.37302741594189714, 0.27590816733774093, 0.8793768203275746, 0.21584310180149968, 0.8726780385210162, 0.8717230618077422, 0.23004845724351308, 0.1293518422952208, 0.3171815799929021, 0.16805645012588888, 0.2999548125621828, 0.18362299192330556, 0.26548256500740164, 0.20151377655434288, 0.15698926072055397, 0.15744744660300025, 0.11380161334229666, 0.7580985351720102, 0.1352661294633255, 0.15984752960370785, 0.15923995883151965, 0.1489852752045714, 0.16896281616251196, 0.1782701402587591, 0.2430302513993935, 0.16218843965256668, 0.10934353866132718, 0.1451909117892194, 0.02814652770547399, 0.11711910859195018, 0.12469927443134843, 0.07826640345415925, 0.022454479829837504, 0.09129962653777968, 0.12269840730855608, 0.26621883952080816, 0.25614699675508923, 0.18010566433843667, 0.25514431546788563, 0.22170307891598262, 0.22071541322310972, 0.3949009713043925, 0.15547943719360025, 0.23793237922029575, 0.04920673365856432, 0.1041596422210046, 0.1649945044126785, 0.22006344416687873, 0.07876693134036772, 0.2992901061629545, 0.17389640259290595, 0.2038574132755051, 0.2860007800743798, 0.3486552900771246, 0.24152474319616113, 0.22062851731608302, 0.3245096439960081, 0.3125475554791315, 0.2483272949069727, 0.2946803687269025, 0.2324178723029927, 0.4320803065306098, 0.6218269015114772, 0.8268793355293291, 0.5686557198295725, 0.6150648319455339, 0.6409977557808841, 0.668103585029898, 0.6991072334740398, 0.6980406019846097, 0.17136850653438418, 0.1127486342481081, 0.10946241131956158, 0.1477298492228607, 0.11726288602468726, 0.6817335780077216, 0.10618543286647986, 0.08794065663567596, 0.12331647397922973, 0.33806548082356136, 0.2773470553287962, 0.1920616057971034, 0.20727150990912702, 0.1902189694374541, 0.16925230397696855, 0.2631582385266501, 0.2177150655974357, 0.2598712104021462, 0.6594430435965576, 0.5130595908756741, 0.6116013229756114, 0.541871425374567, 0.6422998815394271, 0.6336196549663031, 0.5437784823510287, 0.7089948000000348, 0.5616589918383452, 0.3609578030479237, 0.38763025770312964, 0.5140532540284576, 0.44532457111130075, 0.3616169654068512, 0.3884321385924566, 0.206108958481665, 0.4967877079966403, 0.5498008859220254, 0.2306341320355083, 0.19170685532271725, 0.18504609775576586, 0.22535162277784726, 0.2093019029889971, 0.20127656274595151, 0.19165069656408518, 0.23241059759158056, 0.20856057570837816, 0.7033565684455197, 0.23827540046737505, 0.684712142635524, 0.22881610427064192, 0.20132683228303017, 0.2380437307075457, 0.6549178251580798, 0.23070854616341063, 0.2147417558069189, 0.16893120907015835, 0.1493613080884968, 0.18358290253414378, 0.8429716184626026, 0.7831968602507258, 0.1930753016131337, 0.8211453626259111, 0.8058331014045567, 0.16901606202468833, 0.38051917696626747, 0.4937852119477034, 0.4633303900651272, 0.8626598097054641, 0.20602465639015588, 0.5227438899082376, 0.5728677865582893, 0.7232240167469566, 0.20744960348407293, 0.18642793490901555, 0.20480464793348951, 0.1803084697732975, 0.17805384554886927, 0.1866959000050501, 0.18933850324209422, 0.18204089569715776, 0.2033294848682874, 0.1825185061341067, 0.09019275360156265, 0.08525968571172182, 0.0815984314171978, 0.08791083780894948, 0.09751849279959057, 0.09159443993409, 0.09101477783736778, 0.07477990898447329, 0.08620349931962124]}, "mutation_prompt": null}
{"id": "5115c9e0-eecd-4d8d-8368-0375cdd1cdaf", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased initial population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted to enhance exploration\n        self.mutation_factor = 0.8  # Modified for improved adaptability\n        self.crossover_rate = 0.9  # Increased for better recombination\n        self.local_search_rate = 0.4  # Adjusted for balanced local search\n        self.adaptive_rate = 0.4  # Refined for dynamic parameter tuning\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.25, 0.6)  # Expanded noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Expanded mutation factor range\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Slightly broadened crossover range\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.7  # Modified recalibration condition\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Adjusted to suit current fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Slightly decreased chance for reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Reduced population size more gradually\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridMemeticDE", "description": "Hybrid Memetic Differential Evolution with Stochastic Local Search Intensification for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 89, "fitness": 0.39742667236319174, "feedback": "The algorithm HybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8188168363712902, 0.8255641437520361, 0.8069874888189471, 0.8234449300599325, 0.8269310263315108, 0.8104118923949152, 0.8136763407981623, 0.8191951812109313, 0.8047178434358507, 0.7036460811486207, 0.7023360732606476, 0.711622446267699, 0.6959780690297576, 0.7202301867221639, 0.6985463660593803, 0.7041934474313912, 0.6883953726870501, 0.7113190652316457, 0.15470980260033518, 0.2023783984607881, 0.27487957695375165, 0.13938393787784475, 0.3391630782187858, 0.43629918478853646, 0.1547434351926562, 0.23377956816892698, 0.20744371091207325, 0.13110659244712697, 0.1314522506609448, 0.11953458124962324, 0.12188562376580425, 0.13538172038480678, 0.11392528419006998, 0.12923116215817898, 0.12018117975826759, 0.26987985886087384, 0.9268612489001639, 0.9116479006168499, 0.9176047805584129, 0.9197148399719999, 0.9048448357510196, 0.942798781733666, 0.920383657510411, 0.916309411915908, 0.9398525360889108, 0.5680909402833465, 0.5797897187859165, 0.519581490085739, 0.5881216713615459, 0.6096849773720621, 0.4976311450525812, 0.5452991852254141, 0.5698219924050381, 0.4433291528530392, 0.781044649697803, 0.8270649695357399, 0.7165184709911137, 0.8021129275376355, 0.7753200275926668, 0.7712453342044767, 0.773049041514903, 0.803474046949077, 0.7761008188136087, 0.14893516308232335, 0.1466744049282772, 0.32134220988938833, 0.15474765819665248, 0.15850117121848106, 0.1552155670987564, 0.36382813946145365, 0.20602113739213823, 0.18581284765164996, 0.19647441609745475, 0.1632051100091092, 0.17804152782133276, 0.19542996851482197, 0.33610892911703005, 0.21281842135815754, 0.19950147830493947, 0.21197657619977062, 0.22826387610938315, 0.12390775001384413, 0.3082233830269945, 0.23580287364506447, 0.43441607795286385, 0.40243593029229796, 0.4086326297510704, 0.46961931812968927, 0.10890553205706344, 0.3182122157035545, 0.5247262143260119, 0.5623512764643975, 0.5501829275591791, 0.4720212245285347, 0.5722795471492066, 0.256384909098229, 0.3887667698589139, 0.5295471433122603, 0.4975746230999888, 0.06641711792209681, 0.11473606151394966, 0.16487984580529524, 0.13943738342280754, 0.1553535629804108, 0.11871248053376637, 0.13035459968145713, 0.1326683697701273, 0.13319148059582053, 0.2089447050187051, 0.3020216692464709, 0.34632290939774335, 0.3762163362020484, 0.38987135682445295, 0.3132493026278139, 0.3956607019968774, 0.33315691078201926, 0.2278102631503942, 0.7311821603678931, 0.712159911981209, 0.6516253340459275, 0.7303166521113564, 0.7146324869839846, 0.661127941472704, 0.7164113761614312, 0.6921385199060659, 0.7054041951370368, 0.0908892949113953, 0.10675249185271496, 0.10182329858776862, 0.09779823150038114, 0.09466904596363657, 0.10602167465903167, 0.1215342030711889, 0.09058256955201727, 0.11771650031895697, 0.18166627123527646, 0.217016569839951, 0.18538379294986673, 0.16107192689123462, 0.16777971797270896, 0.2072144137595544, 0.16029651887196017, 0.27633143636927504, 0.20474225953585035, 0.4840456371789035, 0.5030664862866372, 0.42328555242599064, 0.4711616033054289, 0.421391117452966, 0.4392555367941797, 0.5077505029623586, 0.5231214317035777, 0.5046748814082285, 0.38110188010070245, 0.37146700017849654, 0.3589297517765001, 0.3182731119775606, 0.4086531903252014, 0.3643372732980873, 0.368346337159667, 0.3954258272719886, 0.32897586183518335, 0.2076724035807226, 0.19333903581259293, 0.21901557122331183, 0.19399277120290936, 0.20930125088580775, 0.19505903897250287, 0.19892204230535304, 0.2003442114649644, 0.19850338302207016, 0.5008317331015794, 0.206121826721962, 0.21468905724812426, 0.5489462523267481, 0.20766889357370033, 0.4456206820392007, 0.4930276453562624, 0.5192493139195165, 0.23992137066029817, 0.7796655082551875, 0.20337474764461538, 0.7126324237515143, 0.8185900849962882, 0.21953877589423154, 0.7680773812415731, 0.6394407222768067, 0.7812601490983015, 0.6627031941165888, 0.6695079395662038, 0.734618230817604, 0.6788074892477386, 0.20039462420485732, 0.6767890228583644, 0.20171536856355887, 0.15162659550806368, 0.20751539408290087, 0.20343825246205238, 0.20497561256666963, 0.18672506464697225, 0.1947996129787023, 0.1823080941274643, 0.1755227357223852, 0.18102635160159597, 0.19008191130275598, 0.18731143487099278, 0.18311974644650453, 0.07972398572529016, 0.08177925046508339, 0.07902146890337058, 0.09471464737301882, 0.08680897748417282, 0.07997935738913986, 0.07932005392533026, 0.09069564758339621, 0.08220881301753469]}, "mutation_prompt": null}
{"id": "8cb1ce9f-b463-4ae1-9270-f1816d35901a", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.75  # Adjusted for balance\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.8\n        self.local_search_rate = 0.5  # More frequent local searches\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.6)  # Increased noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Broadened range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 1.0)  # Expanded range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.65 if fitness_std < 1e-3 else 0.85  # Adjusted condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Dynamic reduction chance\n                self.population_size = max(20, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridMemeticDE", "description": "Hybrid Dynamic Parameter Scaling with Enhanced Memetic Strategies for Improved Black Box Optimization.", "configspace": "", "generation": 90, "fitness": 0.4053300193145529, "feedback": "The algorithm HybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8510505495135072, 0.8294498045454177, 0.8462486735518852, 0.8418839632870722, 0.8278667991974269, 0.8325725929257501, 0.8350514351728078, 0.8438030772024783, 0.8437383251175231, 0.7353592194258313, 0.7187124728882421, 0.7137022169170386, 0.7148394545306449, 0.7153092137502628, 0.7199998672946402, 0.7090484164220447, 0.7107824188514729, 0.7219124254082222, 0.19726254087315698, 0.3198094254937207, 0.13562978077545418, 0.09782543380359454, 0.1145131610691491, 0.12125593521332723, 0.1333536090702504, 0.1422710486061466, 0.11781188606419268, 0.11491051662910978, 0.1363966663627647, 0.1083226000922416, 0.12059794972116156, 0.11618983281064954, 0.12937032827839978, 0.13002623858047513, 0.12769340134013707, 0.12616379518700138, 0.9343441799923405, 0.9826339995775888, 0.9159244922449707, 0.9107989228525717, 0.916469464335229, 0.9399354677901266, 0.9385716819250881, 0.9557790947892701, 0.9685945935778328, 0.5208398810430577, 0.5318518123667815, 0.48800456875546594, 0.5381483779530736, 0.49693034630594546, 0.6164112059151381, 0.4829124517840895, 0.5051802879132639, 0.5026388204644452, 0.7696242116052144, 0.7538586075507341, 0.7464973190110051, 0.7885228275635248, 0.7573489067278889, 0.7747273124688999, 0.7944878698099227, 0.8238356055696553, 0.7806806039837371, 0.301451279671221, 0.4954045835923363, 0.3170207196450068, 0.38628111774342133, 0.2524369064107518, 0.12666893895857578, 0.27536578566748304, 0.21901655766301298, 0.5038735322474268, 0.23333417184126937, 0.1511936903824186, 0.5665260750376813, 0.43508394210726675, 0.49907667643852005, 0.34066243685565833, 0.23692999754385324, 0.48527724939916517, 0.390747697727007, 0.4251214988454449, 0.3810087057764233, 0.321265745009358, 0.44264974558117043, 0.43989436365031653, 0.392759283634427, 0.40378346258603337, 0.5082759925582456, 0.3829844432045264, 0.35041027934891034, 0.26789022914503036, 0.2625461440500676, 0.6382331492329731, 0.45604567200664015, 0.5626525532844814, 0.557681691517616, 0.6381705824640417, 0.3724569937461323, 0.22182454479987845, 0.15554613885159674, 0.06090110958988937, 0.23989036416356535, 0.20068034365603493, 0.2696522475032843, 0.15332162263956328, 0.22158008917184902, 0.20761638202038935, 0.31768850967695594, 0.3158522946571064, 0.3354728853306146, 0.32892337799401583, 0.36986527789454926, 0.38492347481120337, 0.3713076523389318, 0.393432870526374, 0.34204910475522643, 0.7642588120085616, 0.7306168018504913, 0.7469598459716307, 0.6329631296416027, 0.5961119194188038, 0.5424033547216482, 0.6867973468590161, 0.7767252428206503, 0.7572193569641433, 0.10289207610165652, 0.09342042893278524, 0.10550936130662703, 0.09859529393105437, 0.10109170550823054, 0.09802505268928341, 0.09098524488913062, 0.10174303861343559, 0.09402437956409726, 0.20939631211290433, 0.17689332337958408, 0.4662536160432883, 0.2168858494161382, 0.34734050403484074, 0.17500591547565147, 0.20312906995572833, 0.2802453486651938, 0.17178910775049516, 0.4934847884409622, 0.4124406844573425, 0.49202016015281835, 0.39329993296199117, 0.37688013283429234, 0.4155520330142979, 0.4514077656620077, 0.5151380254913268, 0.4770947745974575, 0.27117113077105137, 0.3008820720215266, 0.2974939856957467, 0.31595623431532593, 0.3267004737922965, 0.33781019218219976, 0.36912499766537954, 0.39367929675397917, 0.3109743878000474, 0.18504249157852481, 0.21127071538254338, 0.19659655831538325, 0.22376654459832845, 0.199313337863686, 0.18011224164015316, 0.19657700900279362, 0.18300755714463635, 0.19739626617689532, 0.18763278617884782, 0.42700990549200046, 0.3613713119823707, 0.2175490733316675, 0.21513378414517614, 0.19914100818796576, 0.21682265676504697, 0.2669007858052955, 0.17575259594488057, 0.8526142365849071, 0.7032968146701282, 0.1846490538782909, 0.19268327189881584, 0.182732904198337, 0.808974923058041, 0.7068856632134091, 0.1609152466734215, 0.19763646098449594, 0.20794300696613421, 0.764193087534912, 0.7973672659379716, 0.20020305799847882, 0.6970014025215585, 0.7704032332035865, 0.8091249794453175, 0.20717680841055708, 0.8147521085554467, 0.1863285570476383, 0.17643994155226028, 0.18321837078490844, 0.18952565025503376, 0.1837823499821184, 0.19583394757309347, 0.18290716404739382, 0.18688072714318527, 0.1995613780559835, 0.08227744922026237, 0.07447221722379382, 0.07900021534026092, 0.07433722079947924, 0.0686509650119046, 0.09685187685791885, 0.07031101860623545, 0.07771298635008383, 0.07885129878015107]}, "mutation_prompt": null}
{"id": "c9e7fab8-b9b7-43df-92e7-599c9577fabe", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Different diversity factor for exploration\n        self.mutation_factor = 0.8  # Adjusted mutation factor for robustness\n        self.crossover_rate = 0.9  # Increased recombination for better search\n        self.local_search_rate = 0.5  # Modified for frequent local improvements\n        self.adaptive_rate = 0.4  # Adjusted for dynamic parameter tuning\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.6)  # Broadened noise range for improved diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Extended range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.95)  # Modified range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.65  # Adjusted condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Tuned adaptive rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.3:  # Adjusted probability for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Revised reduction strategy\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Enhanced Local Search and Adaptive Population Strategy for Optimal Robustness in Black Box Optimization.", "configspace": "", "generation": 91, "fitness": 0.3899084787576762, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.847020793524053, 0.8453690270475669, 0.839615452491144, 0.8357809514797596, 0.827744651158477, 0.8237127965497103, 0.844330517743856, 0.8377108800604195, 0.8242385001421124, 0.7465356190800998, 0.7209325638925486, 0.730676568145493, 0.7442973973032435, 0.7417823530161541, 0.7205033555156248, 0.7624374864005103, 0.7722241792761111, 0.7194214830319798, 0.30859761399174357, 0.18988584447399226, 0.16270371751520674, 0.14860616318226416, 0.2421597501285233, 0.13723219083268756, 0.1293573034293437, 0.25093104425744694, 0.13964686171861085, 0.13074441877209797, 0.13728166115361873, 0.13812987989055892, 0.24330920680718582, 0.11627736609374895, 0.14040778781071528, 0.12331773245104982, 0.15807199785306913, 0.1529138697405953, 0.9428331371484069, 0.9474397113437597, 0.8979639582495513, 0.9365388572379614, 0.940020980802009, 0.9067850056497516, 0.9380825666952405, 0.9285029045102333, 0.9186832270615575, 0.5736344146285834, 0.5646672612726156, 0.5805327742553128, 0.6018644378163508, 0.593594629074149, 0.5223803857212019, 0.5903824507434096, 0.6326836363147197, 0.5571593103667158, 0.792957654762391, 0.7949511633439996, 0.8011395555620172, 0.8679340247728325, 0.7870330577416017, 0.7781117279453514, 0.789224202559949, 0.8431230461006192, 0.7501408473128631, 0.16816275060514285, 0.17645795916950302, 0.2616128671016852, 0.16040389445690306, 0.16360062995994684, 0.18635587205342885, 0.1597441723086933, 0.16913083275636542, 0.14812536141920807, 0.20607631556908934, 0.168146626803103, 0.1593586403551237, 0.16940601147242995, 0.18649483468443817, 0.5408204456142434, 0.2714265749213194, 0.13552160034923366, 0.22038746521521402, 0.196011574436319, 0.4215333253279546, 0.13270733890995268, 0.09195521490430114, 0.1685494856209192, 0.15683598610616534, 0.26990390668350406, 0.35987769967998706, 0.18171307012016769, 0.1581300663231634, 0.1328744989200692, 0.20036501428285547, 0.1154344791500842, 0.6056378340674888, 0.14640455020137866, 0.5096788157123842, 0.5750378883426233, 0.5478920042153508, 0.18327107700798984, 0.09769720489601219, 0.11520848864781363, 0.17545961599058246, 0.13553656560649363, 0.11790723748832421, 0.0986192570675758, 0.2044624848494051, 0.12151128537460587, 0.3644591062372705, 0.38735919977826505, 0.2736814056044966, 0.3335332501765933, 0.39218212809483255, 0.36774478251592246, 0.30524241923856266, 0.2740314110071188, 0.318380274098781, 0.7174322885380264, 0.7526910266183373, 0.6151040477516193, 0.7262406207682814, 0.7310442387661747, 0.6830892798092048, 0.7137077502255924, 0.7085746662342269, 0.6942111283837943, 0.11025333126667192, 0.10591390092615183, 0.08972235232636627, 0.09528007855572673, 0.08850212644145361, 0.09371556380957058, 0.09667646497766813, 0.10522956580829146, 0.10690501212356596, 0.1976351346374744, 0.17850495904032793, 0.17188640005925282, 0.1789875051596933, 0.1807772228038097, 0.1591893420398297, 0.20221357083375613, 0.17672606570024763, 0.16432160802547202, 0.43313864586305084, 0.46472986816480366, 0.44913468618721275, 0.47684527930292897, 0.45456263810232167, 0.4658986755946428, 0.5187716271733083, 0.49389041568065883, 0.5299912760578267, 0.3627189213239095, 0.4008036401753885, 0.3456727070230864, 0.33506776269985983, 0.3681079430796096, 0.3606643463096373, 0.37927392990790487, 0.41559680243570596, 0.39858904822540886, 0.2203180795222297, 0.18680058369423913, 0.20749357199412466, 0.19417309343005196, 0.19022717836022296, 0.21033567410699505, 0.21832073957137343, 0.20307528581954726, 0.18997071131499366, 0.24037084660882835, 0.19845478122821136, 0.37045544548140674, 0.21919290971804006, 0.2129436922058321, 0.19385203485959834, 0.2212545033492883, 0.29953165188429587, 0.5232966305686387, 0.20083724709916628, 0.1814899975326012, 0.6594835948606647, 0.8149273434197214, 0.7213546253954988, 0.8088793803222789, 0.8186363268790664, 0.6983006178202927, 0.7376184969935649, 0.7368353299375241, 0.20721565458827318, 0.8115892694166948, 0.661225200605055, 0.7601185768191009, 0.19824432862340746, 0.15316213671998558, 0.20520029981860521, 0.717758041834553, 0.20222137746899282, 0.1849183819512642, 0.18760267488066062, 0.17500228579330446, 0.19438963295205147, 0.17972135481259865, 0.18975437480631796, 0.1898017430307828, 0.20004663417420876, 0.07748364541847552, 0.08925422864936483, 0.07526026292533738, 0.08808418403053697, 0.07939548233195926, 0.07419832296402351, 0.07642966264313023, 0.08300868872373812, 0.0823844103046194]}, "mutation_prompt": null}
{"id": "67f05520-6fea-4e6c-b9f0-28bb902d4b1c", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = np.random.uniform(0.6, 0.9)\n        self.mutation_factor = 0.8\n        self.crossover_rate = np.random.uniform(0.8, 0.95)\n        self.local_search_rate = 0.5\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.35, 0.55)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)\n        self.crossover_rate = np.random.uniform(0.7, 0.98)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.7\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.35:\n                self.population_size = max(10, int(self.population_size * 0.85))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedMemeticDE", "description": "Enhanced Memetic Differential Evolution with Adaptive Strategies and Dynamic Population Management for Versatile Black Box Optimization.", "configspace": "", "generation": 92, "fitness": 0.32139655168209963, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8625782824169002, 0.8804016623204519, 0.8608183855230294, 0.886234835922216, 0.8664029251777913, 0.8803991024912161, 0.9068617955592395, 0.878928122187159, 0.8838859326613597, 0.3501388849739612, 0.724895593542374, 0.16574891865503671, 0.06536672783275166, 0.6805291399458049, 0.006952966174223141, 0.8470532285853034, 0.07002534570452446, 0.7982382220857382, 0.1757306253741997, 0.13543570437798058, 0.13143936603462048, 0.18511280753490433, 0.1450873662492015, 0.14588546048155526, 0.6619434613544597, 0.1580202547945999, 0.15986906820807212, 0.14660161519108095, 0.1351598134962152, 0.1621454551230267, 0.14208087874832398, 0.11388013259336371, 0.14267089951666023, 0.11268244027453234, 0.10975490966240309, 0.14749605194646498, 0.9412794144171852, 0.9434616653379033, 0.9607612847119861, 0.9342246741475828, 0.930593317303213, 0.9122435499526923, 0.9434899071957131, 0.9385425621766958, 0.9282856816949707, 0.4170356096036574, 0.3419436480786072, 0.26878758082867005, 0.3324945289207166, 0.2755003554282772, 0.28326691953625216, 0.24865659680395802, 0.6446058320458552, 0.22406679602712398, 0.3858980606345124, 0.3326279658955378, 0.848649213297558, 0.8725459625165107, 0.8582731246255902, 0.8660424330493584, 0.8802765987474749, 0.377302180610812, 0.37999573436504375, 0.14287391932120486, 0.14495571207253766, 0.16275912250313318, 0.17852918872248702, 0.1627981280379971, 0.15433591808956937, 0.1406183983476772, 0.16274693601885992, 0.1651714070250464, 0.13590974401657563, 0.1284240777786153, 0.145771688685711, 0.1791511664463573, 0.19501974619143092, 0.13441596873145933, 0.13982269353864818, 0.19073188023252008, 0.12548055447490059, 0.1391819359097748, 0.09352342500182509, 9.999999999998899e-05, 0.03214929850224746, 0.08057501652430787, 0.14612725407457605, 0.044176484327117405, 0.3080225450092985, 0.044676165238230925, 0.18261465887583006, 0.21231317491826096, 0.21933629773389507, 0.11703750872700291, 0.19495652928866525, 0.1934404902204545, 0.18000403167542078, 0.16194495478300452, 0.15960080119573627, 0.22016537585532703, 0.11830552076088441, 0.1516045333010243, 0.10411140428914956, 0.10295468539763009, 0.09523195401665652, 0.2406640304537463, 0.1660039964782143, 0.15505465541660635, 0.24869034625524933, 0.12538649739718277, 0.1620497418566732, 0.18154939624882294, 0.38037732978990135, 0.2804344785729861, 0.14212327931565383, 0.26345761464989226, 0.203568331142728, 0.5163514079297747, 0.6896682446733007, 0.5353030794985887, 0.5952667506925549, 0.5040575538248018, 0.5584149653633043, 0.5714617782397242, 0.5735018247133673, 0.7290940343962835, 0.11227203519039597, 0.11676029705895197, 0.16012226288421827, 0.11147742019817164, 0.1452860795104074, 0.09831850802464015, 0.1072415995663587, 0.13919637410113195, 0.1242283725474359, 0.24988466160307476, 0.1460486202653135, 0.2608109182971138, 0.2389060667985604, 0.4942140506337329, 0.1690358540522353, 0.26899683530695306, 0.13546520641273962, 0.17528756772124066, 0.48403499788203475, 0.5559902208825409, 0.3569698975557999, 0.5527063346651664, 0.37285779323125334, 0.3407829691843791, 0.2903850688093885, 0.3321280644664013, 0.30098539572844707, 0.23902518632182412, 0.3571049439841234, 0.32229665142664743, 0.34547463658306665, 0.35254907982078765, 0.2711070373192339, 0.23185295990225419, 0.29875122707475876, 0.22485009865577044, 0.22198210477308788, 0.24137742910769533, 0.19027380088818058, 0.21310796467126636, 0.21328982383382922, 0.2045290289472268, 0.1955601375863546, 0.2016195935097359, 0.20355668784181924, 0.21304936001763686, 0.20464290163379795, 0.2250289542787135, 0.23371473670313603, 0.7318808891687411, 0.22246879253589136, 0.3790321825665973, 0.207490507814731, 0.21405081821911276, 0.1953624965149866, 0.1853845748267241, 0.825160257750174, 0.19450973275217875, 0.18562017046655221, 0.798076340806513, 0.1675628267820577, 0.18570933403489143, 0.19909868931379793, 0.7988340320406413, 0.7394048998757414, 0.7123037500816911, 0.6565768593675978, 0.20259992461361997, 0.34858401103119685, 0.20983989658614033, 0.22238387217092792, 0.2042680637277775, 0.1844701493298141, 0.1919483960986399, 0.19552895102549128, 0.22542001989252392, 0.20224167189881792, 0.18226640925683235, 0.1871333636166833, 0.18684723402819392, 0.18589475743595962, 0.0861001764512046, 0.07221635573990226, 0.0984775914225332, 0.08670958595062583, 0.0835837977357834, 0.07853610397364186, 0.08028297144213847, 0.07421520633802448, 0.0769844677447904]}, "mutation_prompt": null}
{"id": "a8bd239f-2c55-4fc4-8f0c-d0e3b1f085b7", "solution": "import numpy as np\n\nclass HybridAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.8  # Factor controlling diversity\n        self.mutation_factor = np.random.uniform(0.6, 0.9)  # Mutation factor with broader range\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # Variable crossover rate\n        self.local_search_rate = 0.35  # Probability of local search\n        self.adaptive_rate = 0.35  # Adaptive parameter adjustment rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Adjusted noise scale for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        fitness_std = np.std(self.fitness)\n        self.mutation_factor = np.random.uniform(0.65, 0.8) if fitness_std > 1e-3 else np.random.uniform(0.7, 0.85)\n        self.crossover_rate = np.random.uniform(0.8, 0.95) if fitness_std > 1e-3 else np.random.uniform(0.75, 0.9)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.4:  # Probability of reducing population size\n                self.population_size = max(20, int(self.population_size * 0.85))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridAdaptiveMemeticDE", "description": "Hybrid Adaptive Memetic Differential Evolution with Dynamic Diversity Promotion and Self-Adjusting Population Size for Enhanced Black Box Optimization.", "configspace": "", "generation": 93, "fitness": 0.3965642792574127, "feedback": "The algorithm HybridAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8652686771587512, 0.8589388918123396, 0.8572118032153409, 0.8624881217839391, 0.8758495191315379, 0.8661819885080877, 0.8695239903021502, 0.877738198932232, 0.8648652965744186, 0.7859634366829068, 0.6941910636137371, 0.7863783087452876, 0.7833231854681976, 0.7670688887433371, 0.7830501893595098, 0.7758758924145178, 0.7790475899648791, 0.7515463975791634, 0.15754448164524437, 0.13698002280183919, 0.16668454209541705, 0.16288659439566, 0.23297253372626636, 0.14683995247468518, 0.37188197602593287, 0.363127655047101, 0.1441475567724375, 0.21511903889817452, 0.14733648991787773, 0.12596589062895092, 0.12959842450248493, 0.11469242213570019, 0.1185207006439104, 0.13445410753052234, 0.12584530913623293, 0.12787890736883323, 0.909457402996311, 0.9368715225038431, 0.9127602417005385, 0.9136472015521632, 0.9178002949193904, 0.9250828593130958, 0.933313299450508, 0.9462573232072703, 0.9342986050841002, 0.6395795712630603, 0.28442582438482855, 0.6649390066473043, 0.5310583837148497, 0.6767431284731509, 0.6948814029838546, 0.5745154561016206, 0.6946440412351167, 0.4833295077430647, 0.822204204297599, 0.8595446399330603, 0.8777387787275999, 0.8488444415116739, 0.8393354801002832, 0.852583472983458, 0.8294395873228968, 0.34251174948777685, 0.8783535130430464, 0.17158514112043943, 0.16449546714069985, 0.2795697747153221, 0.3104790096935285, 0.24497568718033336, 0.21175446345666338, 0.3303234434505272, 0.1803492147852801, 0.1625823182292514, 0.13710609758122771, 0.14562476196316387, 0.21063304293890983, 0.21747771241487712, 0.1699513608945361, 0.519155148048515, 0.15603562601805676, 0.1676446281382309, 0.16602174359834332, 0.3758447453617091, 0.37592347825552297, 0.010515756743420979, 0.5952952028205578, 0.11303741505010945, 0.5895211043194586, 0.2451954877600485, 0.15827702421711198, 0.1160121583685797, 0.3359100272961989, 0.22692077865943128, 0.2069612655970865, 0.15794187830004935, 0.24834994982403025, 0.5042011030165131, 0.6711490382933305, 0.29589003002426917, 0.4465092140399638, 0.05709554706068298, 0.09268106240429896, 0.16031382227940483, 0.2615007024781646, 0.3337796000246661, 0.18715820199032784, 0.1274938853360622, 0.17091552770237228, 0.15158185848774952, 0.4612421211879213, 0.3452212576121435, 0.25511956700421523, 0.37126024011098147, 0.39094562381041564, 0.3929677279812066, 0.41530997896538613, 0.41137178516897577, 0.36841031146031067, 0.7444817811409086, 0.7610572470326833, 0.8245821272095859, 0.8021206142460557, 0.6006547689069792, 0.7720123562978676, 0.7687069555436419, 0.745860132909671, 0.6920167225036158, 0.10614563998606719, 0.11645511286865362, 0.11160806103548548, 0.12903395407412177, 0.10776369085345994, 0.10666625372514915, 0.1021900182951544, 0.10703706686126446, 0.11907815050110171, 0.18518240892500504, 0.2478231335956853, 0.15415169665422745, 0.2161732895894144, 0.3675117855172867, 0.19037779872606253, 0.19368197346012506, 0.40576831799232094, 0.159725270215192, 0.5142446989645076, 0.4885353260491667, 0.5122241400601055, 0.5531677354202279, 0.47986226864723736, 0.47298051028319166, 0.5720949304001086, 0.585955524638922, 0.5846265582156478, 0.3986118024653982, 0.30722068816410775, 0.39824492569773307, 0.43390688897206586, 0.41970179262885055, 0.38574052921822555, 0.4308274639159043, 0.450483280489293, 0.42090885965859126, 0.20742062168831765, 0.2011278581097341, 0.18192444258747553, 0.2114831715313914, 0.22640173575401812, 0.2012218586375112, 0.19508996822366953, 0.18461889287140543, 0.19513966984893272, 0.19176323009670182, 0.6506106123189282, 0.532189995672447, 0.38253002380462187, 0.20384541530293132, 0.4946562360622736, 0.22699687088741216, 0.20674980629443818, 0.22799998574625346, 0.20561505587540474, 0.17933005515485378, 0.18227697836349133, 0.832448480324735, 0.19563699279893954, 0.8689932866643335, 0.7991506686007274, 0.1837787813177043, 0.1706911053405683, 0.8068805265624236, 0.20530488095455157, 0.20591278710697147, 0.6382387443511731, 0.16445883774024928, 0.744961945262856, 0.20632154837686745, 0.16227859252782195, 0.2068891331723115, 0.1824998950735922, 0.18524011373133686, 0.18258598560170913, 0.19800906654394457, 0.20224167189881792, 0.17073865008272482, 0.18361802143917072, 0.17774570320668226, 0.1809364927489513, 0.07985688473111863, 0.08074628303954501, 0.08960874427182586, 0.0848152589542136, 0.0819479350952268, 0.0827671280678609, 0.08367321351521428, 0.0816946503465128, 0.0762774659625316]}, "mutation_prompt": null}
{"id": "89cbf8b1-805a-4d82-92f3-98895c1a73bd", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted for better exploration\n        self.mutation_factor = 0.8  # Increased for improved mutation effect\n        self.crossover_rate = 0.9  # Increased for enhanced crossover exploitation\n        self.local_search_rate = 0.35  # Decreased to focus more on overall search\n        self.adaptive_rate = 0.4  # Adjusted for adaptive tuning\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.25, 0.45)  # Slightly narrower noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.75, 0.9)  # More focused mutation factor range\n        self.crossover_rate = np.random.uniform(0.8, 1.0)  # Higher range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7  # Modified condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.4  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Adjusted chance for dynamic reduction\n                self.population_size = max(15, int(self.population_size * 0.75))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Exploration and Constrained Local Search for Efficient Black Box Optimization.", "configspace": "", "generation": 94, "fitness": 0.4091370539668486, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8775553953115214, 0.8786438403419005, 0.8778793814576553, 0.8855332984481662, 0.8948427304128972, 0.898263886809674, 0.8944620155807058, 0.891014659955655, 0.8874088736602762, 0.8017616623660923, 0.8023256590329273, 0.8228299682785031, 0.8185986224200117, 0.7070596524809426, 0.7938300829086864, 0.8038189887043101, 0.7944804358886582, 0.7906310321205672, 0.154018730790058, 0.13330713416103668, 0.1304356265480504, 0.5712012722677691, 0.16494506462076775, 0.6344350967098403, 0.11137562128527478, 0.6524264909208195, 0.18588017283107938, 0.1473880260818876, 0.11792471362696744, 0.15499809915798068, 0.15126635021200796, 0.14622749626535259, 0.11439580991655662, 0.1474539330026391, 0.14279827567592351, 0.16367418933514377, 0.9440923295135891, 0.9137538140348637, 0.9444641218940598, 0.9379678504514299, 0.9236495099164292, 0.9459429181683222, 0.9232389938600954, 0.9310348435892541, 0.9562050357750304, 0.7526257359034053, 0.6254351196690794, 0.695802157280955, 0.6791624288952496, 0.5053891826131068, 0.7242900282666889, 0.33528995350224255, 0.6402363119839487, 0.7165489420039879, 0.3800559383104778, 0.8817307741046949, 0.8652932737203363, 0.8759474406356063, 0.8691240405754774, 0.3713391387617957, 0.8952252130799263, 0.2824077048067385, 0.8693602497171982, 0.1361159963314894, 0.17305460541523532, 0.18002203817514328, 0.1762895901935876, 0.13037754899367537, 0.6783863849523664, 0.2470027373799819, 0.7756616086073185, 0.28128386451078524, 0.2622903303607561, 0.12078248090642862, 0.11968335782067663, 0.22043532546068145, 0.16544264925976948, 0.17693072981591196, 0.19834122532364928, 0.1534672013481675, 0.16679674326586902, 0.12713415086890834, 0.14668500766878367, 0.19159321325922452, 0.418901487610985, 0.1047827733852329, 0.06601430464456826, 0.014927850828954092, 0.0870505214353432, 0.03591825643576285, 0.49000746425291364, 0.37259192316195255, 0.19277315977716936, 0.2914053624116354, 0.2577737625438682, 0.08918658074273866, 0.2691605438178105, 0.23307744530239694, 0.20734185982919173, 0.25038437617769416, 0.19165477271154185, 0.11178372930613001, 0.19114804589733347, 0.11601176283870485, 0.1992741126544647, 0.14036347883072342, 0.11056719417839445, 0.10921130730225759, 0.36411415616728415, 0.32574967173864944, 0.39912126341153553, 0.4698441016247207, 0.4687055789101343, 0.436960174848957, 0.2936921512205086, 0.16254443452857303, 0.36735388262689117, 0.7144875618983991, 0.8294334717953813, 0.676309846945033, 0.6510535305117535, 0.6166802517077313, 0.8011557330557875, 0.845182680762427, 0.6301452961357592, 0.6797687783037576, 0.14980221056465248, 0.13907883583324931, 0.09477126626944188, 0.13050580050397365, 0.09517243207706683, 0.17798323941716576, 0.11562183306917939, 0.10490406697245758, 0.16754161101621134, 0.423580536143807, 0.38695123166755685, 0.23929379604256806, 0.23526001320485956, 0.2661657233486521, 0.21320223871875355, 0.26349441815110597, 0.20826858497564948, 0.3392255440317318, 0.6184680744624556, 0.407718054637103, 0.5820635259410268, 0.4969213126526787, 0.5751808617183245, 0.35484910014507054, 0.6533307375017018, 0.6772305562992729, 0.3697657424420576, 0.4292405681737327, 0.4028771538259459, 0.4635379300571498, 0.495156840106296, 0.3260876995023836, 0.5113547500242841, 0.3441764892846969, 0.3916731038724359, 0.5562831847887045, 0.2160083640674234, 0.19055356448636862, 0.1878937255640445, 0.19854050818126745, 0.2109404009580197, 0.1975003180978856, 0.21858973222402833, 0.19499189260919036, 0.19016491640665623, 0.22567438172597487, 0.6298819599245622, 0.21725698469477994, 0.22977778842676866, 0.2259125645732446, 0.6034960371535585, 0.24193753063369416, 0.5431137132035877, 0.21981243543238183, 0.8744271465071669, 0.8749427939453414, 0.19481127317744584, 0.8473782603867575, 0.18331110731389566, 0.8856999634775818, 0.7189683953891772, 0.7976445882547882, 0.17561263206894395, 0.8875492032723552, 0.20907163125365857, 0.8637579109413274, 0.7679268147759669, 0.20667331184542792, 0.16426816236240083, 0.15332650388616298, 0.20562856549819786, 0.8605196749514966, 0.19292621801163, 0.18898638499024956, 0.20806255686973252, 0.18727135274955264, 0.18933640160609833, 0.2005275308396709, 0.18946715268903336, 0.189420410447542, 0.18076473599026288, 0.0892570487181027, 0.08154375217844867, 0.08204416303768014, 0.08504324484458703, 0.08861190841362843, 0.10998779278322346, 0.08310023537648048, 0.08351769186931757, 0.081334477497357]}, "mutation_prompt": null}
{"id": "919c721e-72a7-4ab8-acdb-a3be1ffe1ad2", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Adjusted population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.9  # Enhanced diversity for broader search\n        self.mutation_factor = 0.8  # Adjusted for improved exploration\n        self.crossover_rate = 0.8  # Fine-tuned for more balanced recombination\n        self.local_search_rate = 0.5  # Increased for more frequent local optimizations\n        self.adaptive_rate = 0.4  # Balanced rate for parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.25, 0.55)  # Extended noise range for enhanced diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Broadened range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.7  # Updated condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.25:  # Adjusted chance for dynamic reduction\n                self.population_size = max(10, int(self.population_size * 0.85))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Dynamic Population and Parameter Tuning for Enhanced Diversity and Convergence in Black Box Optimization.", "configspace": "", "generation": 95, "fitness": 0.36411908384712377, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8976874501909617, 0.8586688637486113, 0.9246789152492212, 0.8815225236393206, 0.8759073255316373, 0.920755981183105, 0.8913167444669479, 0.8944184354490043, 0.9257071197801765, 0.28178701725177835, 0.8203444929702223, 0.18082521560293285, 0.7815430554792118, 0.2579044960173582, 0.8745706317269332, 0.8018125979200328, 0.13674740786692585, 0.06888684467566086, 0.16765061585597563, 0.16584997908756927, 0.17846736063384683, 0.16617481404514034, 0.15936016306556267, 0.1648294356115121, 0.17334694365001846, 0.1516970218417788, 0.2393555342505832, 0.1412379813121164, 0.13667641833324307, 0.15389399866773623, 0.3470137456178084, 0.13689418585690094, 0.13652662380037672, 0.13222469206912302, 0.16385043059141813, 0.5449380408981546, 0.9575124494853888, 0.9459545976799318, 0.957032068127871, 0.9680053376594591, 0.9540065991396459, 0.9435089616574667, 0.9423819983222611, 0.9326818220983573, 0.966616182059161, 0.6033915874943463, 0.7814278324103391, 0.7920127829559542, 0.3054634723769195, 0.43644059922256095, 0.7262214895957095, 0.30825138647299277, 0.4349630440026895, 0.3005686141760483, 0.3792259647121744, 0.3789910115963899, 0.9246268955276165, 0.8471720313295235, 0.8892085436441458, 0.35381396664100573, 0.38011745059164537, 0.8140302207404019, 0.852617635657687, 0.18738679480782006, 0.1405949310254715, 0.1662428869705771, 0.14780486421773276, 0.15932784423625457, 0.23395805044421036, 0.17352359460957212, 0.25152151961396463, 0.1691611794600678, 0.16672648270974766, 0.20709760133063548, 0.17389647514880158, 0.12718496622683284, 0.14180616123257062, 0.18964838254947736, 0.20529243311279666, 0.1652749593697168, 0.20800345227401762, 0.08383433354898806, 9.999999999998899e-05, 0.017252850927204078, 0.0655465875865826, 9.999999999998899e-05, 0.06032411725495146, 0.06545165540076014, 0.18851652042374212, 0.014217188514826007, 0.24021097631180743, 0.1816375055099323, 0.15255755375855784, 0.17340679512140944, 0.12198049667365707, 0.1208558049133055, 0.18676472017258416, 0.3205590708106343, 0.16662729270317855, 0.09598429445862144, 0.12526161505102607, 0.10449355634316815, 0.08132972843922093, 0.2353664360760792, 0.14685852160593982, 0.15607390029849866, 0.22476949651806977, 0.15163775030213544, 0.3107791786712103, 0.16212960978225188, 0.20243543562071642, 0.33492858589669516, 0.21407937430888602, 0.308465077077553, 0.13286752781712696, 0.16912360857031394, 0.13939390465485846, 0.602936879855593, 0.5753669561401676, 0.6278325825981661, 0.631468069219047, 0.6342555169865365, 0.7255803186951122, 0.6891590084520347, 0.5863278116773072, 0.6409398150940746, 0.1050454358503512, 0.11748009363640899, 0.12746479322035886, 0.16149143876798389, 0.1147732938357825, 0.1539316276481466, 0.10342776923939423, 0.13932914811478148, 0.14834899672394586, 0.21508833977964747, 0.21583217062903637, 0.19826285204882843, 0.18968756554064847, 0.18926733976308974, 0.17030569697370224, 0.3275049830705885, 0.2924850094819673, 0.23533066696665594, 0.5979805095621173, 0.3917409353643512, 0.32865415296011313, 0.6417635778506077, 0.3820821262234253, 0.6295120597309003, 0.5272137130727754, 0.658566323648968, 0.5916577968452877, 0.21743893524966096, 0.39318589338221377, 0.3475386671309464, 0.2991220988495329, 0.3416435153668794, 0.30618995105546987, 0.33046421695577455, 0.36088436323952366, 0.5154666278386439, 0.22639748394452952, 0.21463281209367424, 0.19395128856911936, 0.18923847810541128, 0.2053014078462907, 0.21152326249541187, 0.213800384649234, 0.18998467878558145, 0.2177411431126386, 0.6052074403457436, 0.24167109838879153, 0.22139110133241957, 0.5386898925381592, 0.2273129727541785, 0.2541845814937518, 0.21562116265309628, 0.576155552877748, 0.804149909242584, 0.18469186779675606, 0.8691709264663185, 0.9223000551998646, 0.8740780250873805, 0.7465984959393808, 0.18473589622456033, 0.7887364679689726, 0.20443375499066796, 0.1774687501830593, 0.8562436311748001, 0.20755075536318668, 0.8974231233539639, 0.8222179106012695, 0.16449295817642196, 0.7629747505634971, 0.21008230293503827, 0.7079505089730982, 0.7601188963265776, 0.20166709811908612, 0.20163143057238708, 0.17289481210269264, 0.19723975086752565, 0.18208212696950654, 0.19827012794311327, 0.18396881966307876, 0.19668224610960838, 0.18672838610529308, 0.08421486134177303, 0.08034390640119726, 0.08174858256065287, 0.09803941053281051, 0.085854657058139, 0.08218543933135403, 0.08492019794245986, 0.09042004350415955, 0.09088554118280623]}, "mutation_prompt": null}
{"id": "cb4a913a-cf62-47d2-a6b4-1b457cfa68d7", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.9  # Enhanced for broader search space coverage\n        self.mutation_factor = 0.8   # Adjusted for improved convergence\n        self.crossover_rate = 0.8    # Modified for optimal recombination\n        self.local_search_rate = 0.5  # Increased to capitalize on promising regions\n        self.adaptive_rate = 0.4     # Fine-tuned for effective parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Adjusted noise range for diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Expanded range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.9)   # Broadened range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.8  # New condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Revised rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.4:  # Adjusted chance for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Further reduced population size\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedMemeticDE", "description": "Enhanced Memetic Differential Evolution with Stochastic Local Search and Adaptive Strategy Tuning for Broad-Spectrum Optimization.", "configspace": "", "generation": 96, "fitness": 0.3768151863741774, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8161099644217732, 0.8187161079925371, 0.7980887836739343, 0.8276024866237438, 0.8387277995348209, 0.8198051784711125, 0.8306687262469646, 0.8256129541098376, 0.7950737113703075, 0.7210320793480305, 0.7056098966377455, 0.6865725490279077, 0.7109720364388702, 0.7150517633172883, 0.6833045003298603, 0.6952804113548164, 0.6919040997429711, 0.6718884633488553, 0.12203794979461613, 0.1970046794232343, 0.20358240149339213, 0.26288566119710144, 0.1337274470345413, 0.1156363242996078, 0.12125405605448247, 0.11057338420751583, 0.1422697918569471, 0.15121085366823372, 0.13316490392756408, 0.11810380264381382, 0.14349241203762741, 0.1127109045858189, 0.13037750638588153, 0.1361983466206832, 0.1141874983098281, 0.10071948883830995, 0.9347423118147883, 0.9826394513836776, 0.9009915901963629, 0.921875999273209, 0.9430523861765373, 0.9131915628014532, 0.9422969266314128, 0.9684168758851596, 0.9225153922855416, 0.6140154557248922, 0.5417867837098, 0.5317542019704976, 0.5821342341443484, 0.49254851999407756, 0.5470153970650591, 0.5482100570088386, 0.4980701157703419, 0.5804017408038915, 0.7768809368470645, 0.6584219132018383, 0.7794687235190829, 0.7961934980511375, 0.7997166787878267, 0.7638730671698077, 0.7202302226693504, 0.7284200635388083, 0.7290223696963416, 0.20126063076870782, 0.18473939623871183, 0.28261208687825745, 0.22616516896485372, 0.26053807620760827, 0.23410460538517452, 0.17327817580433913, 0.18220327628185695, 0.19984439255106523, 0.3982173105884703, 0.33310416693292877, 0.42539864027701124, 0.3243487075755842, 0.21953015874755843, 0.1867473126714827, 0.1982243164180778, 0.27207588912843117, 0.17537788334133653, 0.2358993042007298, 0.3235885750525954, 0.30789839358938487, 0.14428746849192753, 0.2852084294383439, 0.23855795935625623, 0.379162691410039, 0.32807732654631705, 0.18065918690726557, 0.3712023212560359, 0.4551761962792209, 0.31111740611183036, 0.3912580355429126, 0.3328291349491367, 0.4402193223987676, 0.49043494048321745, 0.5263102783331958, 0.3925358703399433, 0.1497512943597078, 0.09621844937842183, 0.19072098117810254, 0.15156162256479289, 0.12596597938496756, 0.19590911291230761, 0.12514349750980924, 0.1378987666880741, 0.11103004230210956, 0.2794495834455515, 0.2876284104546548, 0.3038491165914292, 0.3067317019698753, 0.32745768905008454, 0.28374218625342473, 0.3074942497334072, 0.26445728049016737, 0.2817396973192312, 0.6921654276269912, 0.6773666179014047, 0.6711258095084853, 0.7191977096969053, 0.6259372167876465, 0.6831009481239663, 0.6943806138800951, 0.6575892966022429, 0.6602676870494282, 0.11596496546578583, 0.10422616050985667, 0.1121952606979052, 0.11678067768056166, 0.09540794928945073, 0.1073266035749173, 0.09480764288530208, 0.10387510182719795, 0.09881183753105083, 0.17616961147826438, 0.4404650171854462, 0.19920552782203205, 0.1845935424113888, 0.23452409745896696, 0.15939528648815648, 0.2120834437000192, 0.17821191061262454, 0.1625933245488249, 0.4414715456694487, 0.36447634407211704, 0.4297600483201718, 0.41161508060161645, 0.3822732941459681, 0.37628606810548004, 0.47608469907629314, 0.4482151698986677, 0.45806885955322674, 0.2961180616070965, 0.29131357752045683, 0.2769262998492179, 0.35335472716825855, 0.2704969987640323, 0.292142877430678, 0.31994870638026673, 0.34743390356462767, 0.3049814555270113, 0.18708000071394848, 0.19474648543453765, 0.19515458955681675, 0.19438478456512875, 0.20441871222965535, 0.2068034131905705, 0.19010644988088377, 0.19143666120953773, 0.19273658424036744, 0.1888552729226981, 0.2118755351162055, 0.43780799956141847, 0.21712410358876955, 0.19229403347999474, 0.21105278319091003, 0.2279333131709288, 0.2432579798991863, 0.20830655253563424, 0.7071891455161786, 0.6928713023333977, 0.7362741695855929, 0.8375976173368593, 0.19576098533154784, 0.6670606138937001, 0.16254919517839794, 0.1821723342446614, 0.7392966047286974, 0.7740923142024309, 0.2029304647645792, 0.7166320224009062, 0.20196419756747008, 0.7131064263723097, 0.5827190895992831, 0.20653412258835446, 0.20659582574684632, 0.2015495748896986, 0.18608458917971527, 0.17976023622337034, 0.19040686984681843, 0.17724203421961648, 0.21304244947867834, 0.19441635623418996, 0.17387212597842394, 0.1939924475782544, 0.18520940265813357, 0.0717458627073031, 0.07825829623660152, 0.07046463425126881, 0.08037005049223012, 0.07352089954278396, 0.08067725442326079, 0.0862620519807924, 0.0759850528631183, 0.08177327903367204]}, "mutation_prompt": null}
{"id": "505549b8-3ad9-474c-a56a-eb82954fbac6", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.local_search_rate = 0.5\n        self.adaptive_rate = 0.4\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.4:\n                self.population_size = max(20, int(self.population_size * 0.85))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "ImprovedAdaptiveMemeticDE", "description": "Improved Adaptive Memetic Differential Evolution using Stochastic Iterative Learning for Enhanced Global and Local Search.", "configspace": "", "generation": 97, "fitness": 0.4111782874838355, "feedback": "The algorithm ImprovedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8678337901961299, 0.8417096088808428, 0.8530657675414838, 0.8537250388134567, 0.8605711841893957, 0.8454487045256915, 0.8632348033035655, 0.8503652949230337, 0.8385418339164542, 0.7606502431599205, 0.7134068409961751, 0.7741317190221135, 0.7632350009150018, 0.7308492163989444, 0.7280069967177065, 0.7778378956541154, 0.7621117190307483, 0.7769992994814312, 0.390606314305905, 0.12043748621314376, 0.1249976735999675, 0.14322588115747636, 0.23758070927253483, 0.14914464146590511, 0.449233624907604, 0.23891334837678646, 0.12096866917932525, 0.11167989705280867, 0.11437825548615166, 0.10132971647124522, 0.12904801573839664, 0.14898001025930585, 0.13492913712737664, 0.12092714283266193, 0.13094970464567723, 0.1295727918116345, 0.9236088791698527, 0.9320166544436921, 0.917432346059872, 0.9474904891613558, 0.9321940914635226, 0.9181670881530607, 0.9310120800671658, 0.9396097088753501, 0.9206504959070845, 0.6442332695277325, 0.6259909093270771, 0.6491376767939425, 0.6037051821617292, 0.5746562860859484, 0.6362354598015101, 0.6421457644908009, 0.6442286117792304, 0.5383578991525213, 0.8677816023570517, 0.8188803722005338, 0.37030176382991065, 0.8475324445368598, 0.8528622027688115, 0.8636739963811868, 0.8137572618704312, 0.8409470870366856, 0.8205431678100426, 0.16211689074136226, 0.1360592177536446, 0.1653216371243338, 0.15317934011241063, 0.22481959392752182, 0.28091713553006425, 0.3884228248536087, 0.18497562829162106, 0.16400329967186045, 0.14069674293613366, 0.12364154661148896, 0.6266623663911077, 0.18665257440253236, 0.1798831877541084, 0.2126483323336027, 0.18135601287433123, 0.17402429206308423, 0.16748664201616248, 0.19208985976476667, 0.1764774342893881, 0.1164236592101886, 0.5991583207964487, 0.5831967086696279, 0.5201909606409639, 0.1611969167743419, 0.5708666570724759, 0.4033062369162196, 0.38647244177607076, 0.23902736131823565, 0.5035493863934704, 0.6563502782251547, 0.24514404596366202, 0.33353113252074995, 0.7291818781492585, 0.6730532549732009, 0.39701878884588027, 0.1424084737191681, 0.21264440560489117, 0.150594572211875, 0.14533403085072283, 0.16217253132541298, 0.4736804324612309, 0.23027896355555544, 0.11946742327599535, 0.17014219048428836, 0.33232467304004676, 0.27637165955394716, 0.5004280373521637, 0.3643808357911278, 0.37539096693228813, 0.34105660743456323, 0.22130072789856148, 0.3432597421142344, 0.29021272205030735, 0.7979858985215035, 0.7629632376831836, 0.598175443387125, 0.7940775250860468, 0.7389272999845964, 0.79610993812291, 0.782800080020767, 0.6752015602529065, 0.7924905261971467, 0.13584515653956186, 0.08896736099875813, 0.13671041514046045, 0.12101605147981076, 0.1096149190691953, 0.12351706753201319, 0.1328511073465637, 0.11309833924092505, 0.10001077441189554, 0.20604595774568923, 0.2352423936012379, 0.23784386220254006, 0.16718101116932538, 0.3231806411702932, 0.15755147060648267, 0.27215873499981336, 0.1958503476039527, 0.23042688438237324, 0.533456556878094, 0.3886310586239825, 0.5179627188357077, 0.5222143786615148, 0.508839051458368, 0.532904256355178, 0.4783080093895379, 0.527413170934478, 0.5263186456835613, 0.4066779708337971, 0.39874183689088594, 0.4222396687380038, 0.35553875405640234, 0.35410535208279625, 0.44388603559993967, 0.48863411848360805, 0.43849998368917664, 0.43721370949240124, 0.210669207272965, 0.18952343257025972, 0.194292112746269, 0.21011621300988448, 0.2098051209147619, 0.20971732485950767, 0.20460371485499407, 0.22651954347405412, 0.22340841100156528, 0.2017800968062501, 0.22475255411647954, 0.589251714736163, 0.193638699691017, 0.4416215319629442, 0.20180675477888843, 0.1983415077757894, 0.18485898543528123, 0.25449777093619885, 0.8730613488108339, 0.7870409940777559, 0.16568178198987338, 0.8573065847096556, 0.1935435891583155, 0.8298587303488639, 0.739437536782628, 0.17192351718416343, 0.845126176162869, 0.7993708668360995, 0.20679745155810447, 0.8319980118825755, 0.20454604759865458, 0.19700295064437323, 0.7810165937995319, 0.20869106258862113, 0.20514855553800515, 0.20636072697808328, 0.1866981171222324, 0.18243592245810036, 0.18487273920375225, 0.2053075710814546, 0.18680844719943257, 0.1836740774510912, 0.18388592273419846, 0.195284439231991, 0.18677731621297577, 0.08880806535024477, 0.08330803707632206, 0.08213620428522861, 0.10298557978832501, 0.08297438469508689, 0.08058535428385438, 0.08545013252834233, 0.08630477954259963, 0.07933414935789873]}, "mutation_prompt": null}
{"id": "3350ee51-7dd4-4fb3-9613-8f146613aee0", "solution": "import numpy as np\n\nclass EnhancedCooperativeMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Slightly increased for enhanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.7  # Adjusted for better exploration-exploitation balance\n        self.mutation_factor = 0.8  # Increased to broaden search\n        self.crossover_rate = 0.8  # Decreased for more diversified solutions\n        self.local_search_rate = 0.5  # Slightly increased for thorough local optimization\n        self.adaptive_rate = 0.4  # Adjusted for dynamic parameter adaptation\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Adjusted for refined diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.65, 0.9)  # Broadened range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.9 if fitness_std < 1e-3 else 0.65  # Updated condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.35:  # Adjusted chance for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Modified population size reduction\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedCooperativeMemeticDE", "description": "Enhanced Cooperative Memetic Differential Evolution with Intelligent Diversity Management and Adaptive Parameter Evolution for Improved Black Box Optimization.", "configspace": "", "generation": 98, "fitness": 0.3810468971376153, "feedback": "The algorithm EnhancedCooperativeMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8438522616225566, 0.8440857389980784, 0.8133287951536281, 0.8294501562559263, 0.8383349404481452, 0.8302370311369508, 0.8478313574973944, 0.8488905732924579, 0.8182593186908491, 0.7428993854312229, 0.727185232473253, 0.7220971976106265, 0.7487006969846854, 0.7371525413930902, 0.7369351589819302, 0.7637652873918299, 0.7096613006639068, 0.7186764594571435, 0.14960895421893017, 0.13499199709791831, 0.21502572007507748, 0.2444643479158085, 0.16414335229298171, 0.2601796567383873, 0.25439628221867283, 0.21288409225379934, 0.44311114045331057, 0.1440911039751117, 0.29824174381460733, 0.14435456378446776, 0.1517693784939882, 0.14334267510898568, 0.2363325770166168, 0.14350945470712284, 0.2931875197931767, 0.13084647399579086, 0.9344963545532756, 0.935484912119265, 0.9145452311862112, 0.9170137781965262, 0.9529317930685679, 0.9101844839409334, 0.9434511455082404, 0.9550922816924505, 0.8966237013419598, 0.6462736350983636, 0.6142534053184796, 0.5758684849917867, 0.6033525840294889, 0.5734749541483901, 0.633181486911035, 0.6395893598761808, 0.5966948829217418, 0.5352749165081243, 0.8066295122260774, 0.7322906821215854, 0.7949444317328476, 0.8488376966438479, 0.8089563842931203, 0.7853897663552365, 0.7871888229539509, 0.3748615648431224, 0.7663793173668818, 0.19413651601703663, 0.16131075523005545, 0.21753437708986845, 0.12395007351289167, 0.4729662886225846, 0.1494094391299735, 0.19578386448211038, 0.17853270402735855, 0.1464107558514266, 0.19496844293907, 0.1236594551070277, 0.16812974922784596, 0.1426932828384342, 0.1363154961018559, 0.3286886255663759, 0.16119024127465165, 0.16669385366902734, 0.1587427641351684, 0.10062610089590163, 0.19634591453237693, 0.13748491626867687, 0.07188137277840012, 0.3938968205730684, 0.23849441831789164, 0.1744541600780667, 0.43862365310801055, 0.14064503615411628, 0.1886579827193574, 0.2776295541376913, 0.20110018309373456, 0.07944474013480884, 0.14241494168131963, 0.1513916194435011, 0.4777765143266499, 0.3235029747134782, 0.5013183965930113, 0.05937870208567897, 0.09786372192156445, 0.09153502906262367, 0.10478733802353857, 0.2054254398361688, 0.19217236515791025, 0.17553874183319607, 0.24434138335130906, 0.17989039347777125, 0.2795366102646918, 0.2743348161854712, 0.3078710315227221, 0.3943126261427987, 0.35543533480820644, 0.32263850106751957, 0.35616659659353167, 0.25348354070820334, 0.2817273598460681, 0.7439357233304971, 0.671231981977123, 0.6849273078958984, 0.7688500322083248, 0.7008051251007371, 0.6620869126917772, 0.7060766208963405, 0.6751579445842517, 0.6721900808823826, 0.09928766306525194, 0.10384349797909287, 0.10219951250901449, 0.11084877956275485, 0.12184238195518715, 0.1147042154119916, 0.11630070271314707, 0.11265527689910104, 0.1127395000570467, 0.1801319059253187, 0.24661450192576906, 0.1906059190995445, 0.17872590906423125, 0.17523063056309496, 0.17366520682075992, 0.1861297495562214, 0.18690661786916973, 0.1755705598056737, 0.4606103126690301, 0.4500495887001916, 0.4643553226342154, 0.46233512214847095, 0.4321405243603623, 0.4545751925687418, 0.47693521822759644, 0.45859040281758334, 0.49160643422286476, 0.33375530203493997, 0.2952623101727859, 0.3250591193890121, 0.3663330703699149, 0.31395740481255463, 0.32476245021221894, 0.40018921515273087, 0.410782276876273, 0.3870603545486194, 0.19600484235801763, 0.18360672929076605, 0.18374978183981283, 0.20838886278230273, 0.19968818224016938, 0.20202955250688515, 0.20316595925595593, 0.19102422780367256, 0.19096224759981062, 0.22906466866687902, 0.4418224140386412, 0.5987458748668375, 0.3409260247570809, 0.32921545890190107, 0.5089189242468322, 0.21305956513739743, 0.48180604368344715, 0.2031903319480305, 0.708022252063246, 0.7181577189464643, 0.7281836350612447, 0.1921831670912204, 0.1949880078007301, 0.808075741428832, 0.7615937415734618, 0.16238161229096382, 0.718159710166111, 0.16709206895226691, 0.20430768102315655, 0.657815067412403, 0.20624543802576212, 0.7434577436389598, 0.6784216506442989, 0.20490514817595884, 0.20819225945662045, 0.20462039873354043, 0.1879965731488119, 0.19022979705235288, 0.1886716911524089, 0.18997372058161732, 0.18779723589390285, 0.17544849083754377, 0.17712757609367114, 0.19665216554499332, 0.1978794854207756, 0.0792969290950668, 0.08819886728244586, 0.0852540182420578, 0.08553047981381023, 0.09100799272701465, 0.07877674365867549, 0.08385781094054123, 0.08775238682310971, 0.07854564709069745]}, "mutation_prompt": null}
{"id": "d63f9371-ec44-4ea5-a571-0035c8e0c8ff", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60  # Increased initial population size for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.num_evaluations = 0\n        self.diversity_factor = 0.75  # Adjusted for enhanced diversity control\n        self.mutation_factor = 0.80  # Tuning for robustness in solution space exploration\n        self.crossover_rate = 0.80  # Adjusted for effective recombination\n        self.local_search_rate = 0.5  # Increased for more frequent local optimizations\n        self.adaptive_rate = 0.4  # Fine-tuned for dynamic parameter adjustment\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.num_evaluations += 1\n\n    def select_parents_random(self):\n        return np.random.choice(self.population_size, 3, replace=False)\n\n    def crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.crossover_rate\n        return np.where(mask, mutant, target)\n\n    def mutation_de(self, rand1, rand2, rand3):\n        mutant_vector = rand1 + self.diversity_factor * self.mutation_factor * (rand2 - rand3)\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def self_induced_diversity(self, individual):\n        noise_scale = np.random.uniform(0.2, 0.4)  # Adjusted noise range for structured diversity\n        noise = np.random.normal(0, noise_scale, self.dim)\n        return np.clip(individual + noise, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.mutation_factor = np.random.uniform(0.75, 0.9)  # Adjusted range for mutation factor\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # Adjusted range for crossover rate\n        fitness_std = np.std(self.fitness)\n        self.diversity_factor = 0.8 if fitness_std < 1e-3 else 0.7  # Updated condition for recalibration\n        self.adaptive_rate = 0.3 if fitness_std < 1e-3 else 0.5  # Adjusted rates based on fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.num_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                idxs = self.select_parents_random()\n                rand1, rand2, rand3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = self.mutation_de(rand1, rand2, rand3)\n                offspring = self.crossover(self.population[i], mutant)\n                offspring_fitness = func(offspring)\n                self.num_evaluations += 1\n                if offspring_fitness < self.fitness[i]:\n                    self.population[i] = offspring\n                    self.fitness[i] = offspring_fitness\n                if np.random.rand() < self.local_search_rate:\n                    local_candidate = self.self_induced_diversity(self.population[i])\n                    local_fitness = func(local_candidate)\n                    self.num_evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_candidate\n                        self.fitness[i] = local_fitness\n            self.adapt_parameters()\n            if np.random.rand() < 0.4:  # Adjusted chance for dynamic reduction\n                self.population_size = max(20, int(self.population_size * 0.85))  # Slightly increased reduction rate\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n    def __call__(self, func):\n        self.optimize(func)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedMemeticDE", "description": "Enhanced Memetic Differential Evolution with Adaptive Local Search and Diversity Control for Improved Black Box Optimization Efficiency.", "configspace": "", "generation": 99, "fitness": 0.3919340193017986, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "c9e36459-4093-4018-9d55-20ae6ae83699", "metadata": {"aucs": [0.8554003057557306, 0.8263088880771325, 0.808067720047899, 0.8343344515601496, 0.8485132767935009, 0.8195891692338164, 0.8347695695305395, 0.8378238649620837, 0.8067557765446538, 0.7548934511092079, 0.7302807494658848, 0.7044608505638708, 0.7470892804952842, 0.7269675398025834, 0.7263242954691671, 0.7477892409547475, 0.7244961699026553, 0.7233413949462841, 0.33746237889122055, 0.22020181597624444, 0.1437052783366164, 0.14159208046534455, 0.2863489272019992, 0.1865281368023517, 0.32361710614217154, 0.15506305841885437, 0.17098376596633658, 0.14696621596001713, 0.11956172250757591, 0.1426878178174844, 0.11551536474473456, 0.1269850361814593, 0.13223001398619594, 0.13451676524084155, 0.242835256296846, 0.1026987911072661, 0.9280417387077401, 0.9678283453315172, 0.9262115289684419, 0.9208117004467621, 0.9529738072292027, 0.9472962166914988, 0.9499815441721348, 0.9444888566737271, 0.9069893417632281, 0.5950049323981972, 0.5804452356747853, 0.5418294876991765, 0.6023386249024063, 0.5926044960599255, 0.5818052872556609, 0.6075815995995428, 0.5493482257398741, 0.5480732821062142, 0.8189082201440627, 0.7650754021725085, 0.7403463755985109, 0.8418372358327055, 0.7933187982406548, 0.7695320256802312, 0.7779145466908933, 0.8099233449197256, 0.7199093738739424, 0.3183392922531698, 0.26139974212262507, 0.17945536536128015, 0.12513747524437568, 0.19102228069804006, 0.20853289432483657, 0.17143702933185945, 0.22147323153515308, 0.23516756771359248, 0.26835394520027556, 0.15001342047006383, 0.25833705844498134, 0.19380934809644945, 0.2545826706631672, 0.15148709295346485, 0.46465542378304137, 0.26456547866432956, 0.18043681977495885, 0.3735105176768513, 0.32900941338693757, 0.2855434675451952, 0.3776021396876922, 0.2774347861345192, 0.15786084305008063, 0.320160222236643, 0.3485325999940524, 0.18881771135355285, 0.5115062389584422, 0.22158685191180771, 0.4071335681580779, 0.38282538690191303, 0.22104760242756627, 0.3136534827305433, 0.5334508747417089, 0.2342577537085475, 0.4844424468724091, 0.19721604083424038, 0.17682427101795328, 0.1876130402366184, 0.15125848168425293, 0.1643265972329112, 0.14234310207924172, 0.1950670678622508, 0.1681915382973177, 0.1389331593758647, 0.22335168499596347, 0.3145373189885523, 0.2834050202552386, 0.3258182074308622, 0.3441863048695244, 0.3281210451244405, 0.31445615472427213, 0.2839136244549927, 0.313916403766749, 0.6291183168235528, 0.6898111086662495, 0.7156162845386124, 0.6657509864276452, 0.6316748607889675, 0.7050969888777878, 0.690418831932073, 0.6887702093830339, 0.6493347206537372, 0.10495599723022986, 0.09430256241260959, 0.10294308359685533, 0.10348026370807129, 0.10850903147780044, 0.09341188605546735, 0.11675376657991743, 0.09663426212312132, 0.10329694836474101, 0.19141831574360735, 0.18109868396431072, 0.16945392943334137, 0.22467157292861384, 0.20236018985739213, 0.2576112272403268, 0.24771045293757554, 0.19717291680717863, 0.170710665942016, 0.4112075550133292, 0.4197525573167681, 0.3661252552593415, 0.4280053465895769, 0.3889346036284007, 0.4765979064107453, 0.5383491244200647, 0.48084663134707695, 0.46125726852179016, 0.3560800708512065, 0.3244195857637493, 0.33327975612635463, 0.32175644573057294, 0.29061501848430893, 0.3133085891945744, 0.3298144675178415, 0.30442590999128183, 0.3229623989897036, 0.20379184179100096, 0.19565825833362027, 0.21221358168062243, 0.18648304772114233, 0.1840176708520722, 0.20510438804637077, 0.22706965930395695, 0.1855493325848896, 0.18043839560715658, 0.2533395472714992, 0.18660477270675724, 0.19900104436472432, 0.19388091892063553, 0.32046379434235706, 0.18979628591925668, 0.5286246540737112, 0.20570026400461416, 0.21790800429539992, 0.16886417239743134, 0.19943219144200308, 0.7463391513771487, 0.20726870804822506, 0.7746017042255466, 0.7414736799997266, 0.7997941806804376, 0.18272341254411129, 0.7255272305913869, 0.7304621052346336, 0.7659067960794154, 0.7457169056772772, 0.19878773749232737, 0.736523461979869, 0.7088605680578874, 0.754104870159864, 0.7505927189501261, 0.20204905049801491, 0.19112602997301675, 0.19328850405669873, 0.1815256888957315, 0.20412944709287717, 0.1812483540405574, 0.18177876460367526, 0.182620283956473, 0.18749281814368912, 0.19041313567222018, 0.08050341740556888, 0.08066046078676115, 0.09127485977536054, 0.07990325803098985, 0.09062970955673466, 0.08531121151315146, 0.08835700234538546, 0.07763990175287272, 0.08815844950453156]}, "mutation_prompt": null}
