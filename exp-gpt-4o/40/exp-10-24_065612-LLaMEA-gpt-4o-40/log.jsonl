{"id": "a96eadae-1777-41a1-99ea-e8522d35604b", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Population size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population)\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation strategies to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.19055013100200777, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.14.", "error": "", "parent_id": null, "metadata": {"aucs": [0.31607665583176625, 0.6634048080626709, 0.46874766087640596, 0.2786476087364892, 0.6426157313192189, 0.6545620758888319, 0.6638517639326693, 0.5938689974338638, 0.3379843809542894, 0.019902159576088874, 0.11300730492616384, 9.999999999998899e-05, 0.34255052076893044, 0.09995807297951653, 0.33051644325951546, 0.3139409640334413, 0.16309449485498184, 0.010554841303044848, 0.12848248079317204, 0.1150669997018613, 0.16183972431583593, 0.12706356693572873, 0.1561301209076864, 0.12886270454697146, 0.1309864811566942, 0.14951390870649228, 0.13895569640008887, 0.1188391074949624, 0.11826156978696367, 0.13011227565147654, 0.13049767169302373, 0.10933320226265608, 0.11378055069203852, 0.1326836890292763, 0.10340336195668165, 0.0638298161263594, 0.5643420754215944, 0.12301392237286801, 0.1474587873892198, 0.6608722717241278, 0.10118659058015678, 0.7305240573299949, 0.11897232571778227, 0.14130220468544774, 0.7106210481403645, 0.08447203634180678, 0.1455714435563692, 0.08319201780660956, 0.05756599963314124, 0.058773906462671444, 0.05897602941375246, 0.12647289431362407, 0.08671867875803507, 0.20179312907917846, 0.2328626668008661, 0.2878025085754663, 0.220998719168227, 0.2641531033193858, 0.20438475937820977, 0.19017885031013515, 0.1612894134613292, 0.1627122167966225, 0.5960165818884346, 0.14984905577254282, 0.13055179219943325, 0.15130728203749189, 0.18846454074231478, 0.23511212000855353, 0.1158213394497627, 0.2366611681454761, 0.1861174350333924, 0.19654158497715313, 0.19446769662410757, 0.15799972169015186, 0.09961933151626112, 0.07564981957401617, 0.12584578174068506, 0.15992278494297718, 0.12693114983526865, 0.11678005887156195, 0.11862672611766989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06312979168060595, 0.048770800604539866, 0.03949316340149289, 0.01004717721590076, 0.09825829492481586, 0.0063907046786758626, 0.15527509535844652, 0.05410303850775322, 0.09408396623721327, 0.0603478694297408, 0.026849215976188834, 0.15187413655865112, 0.07302373612935553, 0.1655520510266073, 0.09803747536198693, 0.05796536641408656, 0.053624498163526324, 9.999999999998899e-05, 0.055435272849168715, 0.08621239933075864, 0.04946564584413404, 0.01065732978177003, 0.03448406279594329, 0.0430772876747596, 0.12900202280156814, 0.06684295682856356, 0.20490964843129078, 0.12441411950000547, 0.004236889628701612, 0.18212292925909446, 0.10143638141810729, 0.14435781658994096, 0.08868831814383715, 0.3650498019470456, 0.24841825653508576, 0.3094909279729001, 0.3631704268096796, 0.41930220634695414, 0.3682234527729682, 0.517827975991956, 0.3693148431957408, 0.4515870997609206, 0.1274728194740815, 0.130953930760499, 0.08716072564299315, 0.08880503823728081, 0.09067829650867665, 0.10141183565258871, 0.09957346927621824, 0.08637544510048079, 0.11357681541694109, 0.2535408420238404, 0.15087181912720493, 0.15983237744468293, 0.16476258090763185, 0.1640607347782892, 0.14480023399730912, 0.23128064101832624, 0.1492880494868687, 0.13380019614387073, 0.29129354654975226, 0.32321544563489, 0.3474007755608456, 0.20826061806703766, 0.332087826457225, 0.3575168043356183, 0.20195633391691703, 0.35281960992485295, 0.2583279045278418, 0.23084834891337713, 0.19942715607899775, 0.22947096200805395, 0.17569315588834722, 0.2019088955378998, 0.2717596196710692, 0.20931696659168098, 0.21772870282912626, 0.26218549201552666, 0.20395694592884617, 0.18729999140378972, 0.1669261133120412, 0.19191816743962586, 0.2323414901452775, 0.19693565817526604, 0.1974119640118812, 0.18331394580234384, 0.23746419183388356, 0.1940901701034652, 0.19801274888843468, 0.210400795082351, 0.19276671631603537, 0.1977983027996849, 0.2124942860987573, 0.2085993165018054, 0.211148789769792, 0.1967512490476181, 0.17429280365830346, 0.1811261692312376, 0.17601373149009292, 0.1691755614503263, 0.19438715955854213, 0.1733163001203033, 0.424187746661977, 0.16841129549313205, 0.5328106063656677, 0.3079745822973158, 0.1911711611454624, 0.3557227649633802, 0.20223711307033576, 0.286162886853627, 0.12494916004989576, 0.36043999633558543, 0.15189479052662824, 0.3407271150370802, 0.18012579697294406, 0.16943532642428194, 0.18746153250299813, 0.1716621026174775, 0.18167603682197164, 0.18348250848182568, 0.17463176917156453, 0.20554904188058798, 0.17586791594866769, 0.0866051790186122, 0.08766113444910695, 0.0774541232233491, 0.07969033369234602, 0.07845729161815251, 0.06488368960509683, 0.06840825859461419, 0.07799266330069532, 0.06920829515216975]}, "mutation_prompt": null}
{"id": "676025a3-c851-4ccc-8996-d58d7c37b629", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Population size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population)\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation strategies to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a96eadae-1777-41a1-99ea-e8522d35604b", "metadata": {"aucs": [0.31607665583176625, 0.6634048080626709, 0.46874766087640596, 0.2786476087364892, 0.6426157313192189, 0.6545620758888319, 0.6638517639326693, 0.5938689974338638, 0.3379843809542894, 0.019902159576088874, 0.11300730492616384, 9.999999999998899e-05, 0.34255052076893044, 0.09995807297951653, 0.33051644325951546, 0.3139409640334413, 0.16309449485498184, 0.010554841303044848, 0.12848248079317204, 0.1150669997018613, 0.16183972431583593, 0.12706356693572873, 0.1561301209076864, 0.12886270454697146, 0.1309864811566942, 0.14951390870649228, 0.13895569640008887, 0.1188391074949624, 0.11826156978696367, 0.13011227565147654, 0.13049767169302373, 0.10933320226265608, 0.11378055069203852, 0.1326836890292763, 0.10340336195668165, 0.0638298161263594, 0.5643420754215944, 0.12301392237286801, 0.1474587873892198, 0.6608722717241278, 0.10118659058015678, 0.7305240573299949, 0.11897232571778227, 0.14130220468544774, 0.7106210481403645, 0.08447203634180678, 0.1455714435563692, 0.08319201780660956, 0.05756599963314124, 0.058773906462671444, 0.05897602941375246, 0.12647289431362407, 0.08671867875803507, 0.20179312907917846, 0.2328626668008661, 0.2878025085754663, 0.220998719168227, 0.2641531033193858, 0.20438475937820977, 0.19017885031013515, 0.1612894134613292, 0.1627122167966225, 0.5960165818884346, 0.14984905577254282, 0.13055179219943325, 0.15130728203749189, 0.18846454074231478, 0.23511212000855353, 0.1158213394497627, 0.2366611681454761, 0.1861174350333924, 0.19654158497715313, 0.19446769662410757, 0.15799972169015186, 0.09961933151626112, 0.07564981957401617, 0.12584578174068506, 0.15992278494297718, 0.12693114983526865, 0.11678005887156195, 0.11862672611766989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06312979168060595, 0.048770800604539866, 0.03949316340149289, 0.01004717721590076, 0.09825829492481586, 0.0063907046786758626, 0.15527509535844652, 0.05410303850775322, 0.09408396623721327, 0.0603478694297408, 0.026849215976188834, 0.15187413655865112, 0.07302373612935553, 0.1655520510266073, 0.09803747536198693, 0.05796536641408656, 0.053624498163526324, 9.999999999998899e-05, 0.055435272849168715, 0.08621239933075864, 0.04946564584413404, 0.01065732978177003, 0.03448406279594329, 0.0430772876747596, 0.12900202280156814, 0.06684295682856356, 0.20490964843129078, 0.12441411950000547, 0.004236889628701612, 0.18212292925909446, 0.10143638141810729, 0.14435781658994096, 0.08868831814383715, 0.3650498019470456, 0.24841825653508576, 0.3094909279729001, 0.3631704268096796, 0.41930220634695414, 0.3682234527729682, 0.517827975991956, 0.3693148431957408, 0.4515870997609206, 0.1274728194740815, 0.130953930760499, 0.08716072564299315, 0.08880503823728081, 0.09067829650867665, 0.10141183565258871, 0.09957346927621824, 0.08637544510048079, 0.11357681541694109, 0.2535408420238404, 0.15087181912720493, 0.15983237744468293, 0.16476258090763185, 0.1640607347782892, 0.14480023399730912, 0.23128064101832624, 0.1492880494868687, 0.13380019614387073, 0.29129354654975226, 0.32321544563489, 0.3474007755608456, 0.20826061806703766, 0.332087826457225, 0.3575168043356183, 0.20195633391691703, 0.35281960992485295, 0.2583279045278418, 0.23084834891337713, 0.19942715607899775, 0.22947096200805395, 0.17569315588834722, 0.2019088955378998, 0.2717596196710692, 0.20931696659168098, 0.21772870282912626, 0.26218549201552666, 0.20395694592884617, 0.18729999140378972, 0.1669261133120412, 0.19191816743962586, 0.2323414901452775, 0.19693565817526604, 0.1974119640118812, 0.18331394580234384, 0.23746419183388356, 0.1940901701034652, 0.19801274888843468, 0.210400795082351, 0.19276671631603537, 0.1977983027996849, 0.2124942860987573, 0.2085993165018054, 0.211148789769792, 0.1967512490476181, 0.17429280365830346, 0.1811261692312376, 0.17601373149009292, 0.1691755614503263, 0.19438715955854213, 0.1733163001203033, 0.424187746661977, 0.16841129549313205, 0.5328106063656677, 0.3079745822973158, 0.1911711611454624, 0.3557227649633802, 0.20223711307033576, 0.286162886853627, 0.12494916004989576, 0.36043999633558543, 0.15189479052662824, 0.3407271150370802, 0.18012579697294406, 0.16943532642428194, 0.18746153250299813, 0.1716621026174775, 0.18167603682197164, 0.18348250848182568, 0.17463176917156453, 0.20554904188058798, 0.17586791594866769, 0.0866051790186122, 0.08766113444910695, 0.0774541232233491, 0.07969033369234602, 0.07845729161815251, 0.06488368960509683, 0.06840825859461419, 0.07799266330069532, 0.06920829515216975]}, "mutation_prompt": null}
{"id": "ec9da54c-c7fe-43f4-bb35-e77e4222f712", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Population size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population)\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation strategies to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a96eadae-1777-41a1-99ea-e8522d35604b", "metadata": {"aucs": [0.31607665583176625, 0.6634048080626709, 0.46874766087640596, 0.2786476087364892, 0.6426157313192189, 0.6545620758888319, 0.6638517639326693, 0.5938689974338638, 0.3379843809542894, 0.019902159576088874, 0.11300730492616384, 9.999999999998899e-05, 0.34255052076893044, 0.09995807297951653, 0.33051644325951546, 0.3139409640334413, 0.16309449485498184, 0.010554841303044848, 0.12848248079317204, 0.1150669997018613, 0.16183972431583593, 0.12706356693572873, 0.1561301209076864, 0.12886270454697146, 0.1309864811566942, 0.14951390870649228, 0.13895569640008887, 0.1188391074949624, 0.11826156978696367, 0.13011227565147654, 0.13049767169302373, 0.10933320226265608, 0.11378055069203852, 0.1326836890292763, 0.10340336195668165, 0.0638298161263594, 0.5643420754215944, 0.12301392237286801, 0.1474587873892198, 0.6608722717241278, 0.10118659058015678, 0.7305240573299949, 0.11897232571778227, 0.14130220468544774, 0.7106210481403645, 0.08447203634180678, 0.1455714435563692, 0.08319201780660956, 0.05756599963314124, 0.058773906462671444, 0.05897602941375246, 0.12647289431362407, 0.08671867875803507, 0.20179312907917846, 0.2328626668008661, 0.2878025085754663, 0.220998719168227, 0.2641531033193858, 0.20438475937820977, 0.19017885031013515, 0.1612894134613292, 0.1627122167966225, 0.5960165818884346, 0.14984905577254282, 0.13055179219943325, 0.15130728203749189, 0.18846454074231478, 0.23511212000855353, 0.1158213394497627, 0.2366611681454761, 0.1861174350333924, 0.19654158497715313, 0.19446769662410757, 0.15799972169015186, 0.09961933151626112, 0.07564981957401617, 0.12584578174068506, 0.15992278494297718, 0.12693114983526865, 0.11678005887156195, 0.11862672611766989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06312979168060595, 0.048770800604539866, 0.03949316340149289, 0.01004717721590076, 0.09825829492481586, 0.0063907046786758626, 0.15527509535844652, 0.05410303850775322, 0.09408396623721327, 0.0603478694297408, 0.026849215976188834, 0.15187413655865112, 0.07302373612935553, 0.1655520510266073, 0.09803747536198693, 0.05796536641408656, 0.053624498163526324, 9.999999999998899e-05, 0.055435272849168715, 0.08621239933075864, 0.04946564584413404, 0.01065732978177003, 0.03448406279594329, 0.0430772876747596, 0.12900202280156814, 0.06684295682856356, 0.20490964843129078, 0.12441411950000547, 0.004236889628701612, 0.18212292925909446, 0.10143638141810729, 0.14435781658994096, 0.08868831814383715, 0.3650498019470456, 0.24841825653508576, 0.3094909279729001, 0.3631704268096796, 0.41930220634695414, 0.3682234527729682, 0.517827975991956, 0.3693148431957408, 0.4515870997609206, 0.1274728194740815, 0.130953930760499, 0.08716072564299315, 0.08880503823728081, 0.09067829650867665, 0.10141183565258871, 0.09957346927621824, 0.08637544510048079, 0.11357681541694109, 0.2535408420238404, 0.15087181912720493, 0.15983237744468293, 0.16476258090763185, 0.1640607347782892, 0.14480023399730912, 0.23128064101832624, 0.1492880494868687, 0.13380019614387073, 0.29129354654975226, 0.32321544563489, 0.3474007755608456, 0.20826061806703766, 0.332087826457225, 0.3575168043356183, 0.20195633391691703, 0.35281960992485295, 0.2583279045278418, 0.23084834891337713, 0.19942715607899775, 0.22947096200805395, 0.17569315588834722, 0.2019088955378998, 0.2717596196710692, 0.20931696659168098, 0.21772870282912626, 0.26218549201552666, 0.20395694592884617, 0.18729999140378972, 0.1669261133120412, 0.19191816743962586, 0.2323414901452775, 0.19693565817526604, 0.1974119640118812, 0.18331394580234384, 0.23746419183388356, 0.1940901701034652, 0.19801274888843468, 0.210400795082351, 0.19276671631603537, 0.1977983027996849, 0.2124942860987573, 0.2085993165018054, 0.211148789769792, 0.1967512490476181, 0.17429280365830346, 0.1811261692312376, 0.17601373149009292, 0.1691755614503263, 0.19438715955854213, 0.1733163001203033, 0.424187746661977, 0.16841129549313205, 0.5328106063656677, 0.3079745822973158, 0.1911711611454624, 0.3557227649633802, 0.20223711307033576, 0.286162886853627, 0.12494916004989576, 0.36043999633558543, 0.15189479052662824, 0.3407271150370802, 0.18012579697294406, 0.16943532642428194, 0.18746153250299813, 0.1716621026174775, 0.18167603682197164, 0.18348250848182568, 0.17463176917156453, 0.20554904188058798, 0.17586791594866769, 0.0866051790186122, 0.08766113444910695, 0.0774541232233491, 0.07969033369234602, 0.07845729161815251, 0.06488368960509683, 0.06840825859461419, 0.07799266330069532, 0.06920829515216975]}, "mutation_prompt": null}
{"id": "e89f2e7a-c994-4563-9925-be195b13578c", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Population size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population)\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation strategies to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a96eadae-1777-41a1-99ea-e8522d35604b", "metadata": {"aucs": [0.31607665583176625, 0.6634048080626709, 0.46874766087640596, 0.2786476087364892, 0.6426157313192189, 0.6545620758888319, 0.6638517639326693, 0.5938689974338638, 0.3379843809542894, 0.019902159576088874, 0.11300730492616384, 9.999999999998899e-05, 0.34255052076893044, 0.09995807297951653, 0.33051644325951546, 0.3139409640334413, 0.16309449485498184, 0.010554841303044848, 0.12848248079317204, 0.1150669997018613, 0.16183972431583593, 0.12706356693572873, 0.1561301209076864, 0.12886270454697146, 0.1309864811566942, 0.14951390870649228, 0.13895569640008887, 0.1188391074949624, 0.11826156978696367, 0.13011227565147654, 0.13049767169302373, 0.10933320226265608, 0.11378055069203852, 0.1326836890292763, 0.10340336195668165, 0.0638298161263594, 0.5643420754215944, 0.12301392237286801, 0.1474587873892198, 0.6608722717241278, 0.10118659058015678, 0.7305240573299949, 0.11897232571778227, 0.14130220468544774, 0.7106210481403645, 0.08447203634180678, 0.1455714435563692, 0.08319201780660956, 0.05756599963314124, 0.058773906462671444, 0.05897602941375246, 0.12647289431362407, 0.08671867875803507, 0.20179312907917846, 0.2328626668008661, 0.2878025085754663, 0.220998719168227, 0.2641531033193858, 0.20438475937820977, 0.19017885031013515, 0.1612894134613292, 0.1627122167966225, 0.5960165818884346, 0.14984905577254282, 0.13055179219943325, 0.15130728203749189, 0.18846454074231478, 0.23511212000855353, 0.1158213394497627, 0.2366611681454761, 0.1861174350333924, 0.19654158497715313, 0.19446769662410757, 0.15799972169015186, 0.09961933151626112, 0.07564981957401617, 0.12584578174068506, 0.15992278494297718, 0.12693114983526865, 0.11678005887156195, 0.11862672611766989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06312979168060595, 0.048770800604539866, 0.03949316340149289, 0.01004717721590076, 0.09825829492481586, 0.0063907046786758626, 0.15527509535844652, 0.05410303850775322, 0.09408396623721327, 0.0603478694297408, 0.026849215976188834, 0.15187413655865112, 0.07302373612935553, 0.1655520510266073, 0.09803747536198693, 0.05796536641408656, 0.053624498163526324, 9.999999999998899e-05, 0.055435272849168715, 0.08621239933075864, 0.04946564584413404, 0.01065732978177003, 0.03448406279594329, 0.0430772876747596, 0.12900202280156814, 0.06684295682856356, 0.20490964843129078, 0.12441411950000547, 0.004236889628701612, 0.18212292925909446, 0.10143638141810729, 0.14435781658994096, 0.08868831814383715, 0.3650498019470456, 0.24841825653508576, 0.3094909279729001, 0.3631704268096796, 0.41930220634695414, 0.3682234527729682, 0.517827975991956, 0.3693148431957408, 0.4515870997609206, 0.1274728194740815, 0.130953930760499, 0.08716072564299315, 0.08880503823728081, 0.09067829650867665, 0.10141183565258871, 0.09957346927621824, 0.08637544510048079, 0.11357681541694109, 0.2535408420238404, 0.15087181912720493, 0.15983237744468293, 0.16476258090763185, 0.1640607347782892, 0.14480023399730912, 0.23128064101832624, 0.1492880494868687, 0.13380019614387073, 0.29129354654975226, 0.32321544563489, 0.3474007755608456, 0.20826061806703766, 0.332087826457225, 0.3575168043356183, 0.20195633391691703, 0.35281960992485295, 0.2583279045278418, 0.23084834891337713, 0.19942715607899775, 0.22947096200805395, 0.17569315588834722, 0.2019088955378998, 0.2717596196710692, 0.20931696659168098, 0.21772870282912626, 0.26218549201552666, 0.20395694592884617, 0.18729999140378972, 0.1669261133120412, 0.19191816743962586, 0.2323414901452775, 0.19693565817526604, 0.1974119640118812, 0.18331394580234384, 0.23746419183388356, 0.1940901701034652, 0.19801274888843468, 0.210400795082351, 0.19276671631603537, 0.1977983027996849, 0.2124942860987573, 0.2085993165018054, 0.211148789769792, 0.1967512490476181, 0.17429280365830346, 0.1811261692312376, 0.17601373149009292, 0.1691755614503263, 0.19438715955854213, 0.1733163001203033, 0.424187746661977, 0.16841129549313205, 0.5328106063656677, 0.3079745822973158, 0.1911711611454624, 0.3557227649633802, 0.20223711307033576, 0.286162886853627, 0.12494916004989576, 0.36043999633558543, 0.15189479052662824, 0.3407271150370802, 0.18012579697294406, 0.16943532642428194, 0.18746153250299813, 0.1716621026174775, 0.18167603682197164, 0.18348250848182568, 0.17463176917156453, 0.20554904188058798, 0.17586791594866769, 0.0866051790186122, 0.08766113444910695, 0.0774541232233491, 0.07969033369234602, 0.07845729161815251, 0.06488368960509683, 0.06840825859461419, 0.07799266330069532, 0.06920829515216975]}, "mutation_prompt": null}
{"id": "2cdfc63b-c016-4c77-a795-011c150387f5", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Population size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population)\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridDE", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation strategies to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a96eadae-1777-41a1-99ea-e8522d35604b", "metadata": {"aucs": [0.31607665583176625, 0.6634048080626709, 0.46874766087640596, 0.2786476087364892, 0.6426157313192189, 0.6545620758888319, 0.6638517639326693, 0.5938689974338638, 0.3379843809542894, 0.019902159576088874, 0.11300730492616384, 9.999999999998899e-05, 0.34255052076893044, 0.09995807297951653, 0.33051644325951546, 0.3139409640334413, 0.16309449485498184, 0.010554841303044848, 0.12848248079317204, 0.1150669997018613, 0.16183972431583593, 0.12706356693572873, 0.1561301209076864, 0.12886270454697146, 0.1309864811566942, 0.14951390870649228, 0.13895569640008887, 0.1188391074949624, 0.11826156978696367, 0.13011227565147654, 0.13049767169302373, 0.10933320226265608, 0.11378055069203852, 0.1326836890292763, 0.10340336195668165, 0.0638298161263594, 0.5643420754215944, 0.12301392237286801, 0.1474587873892198, 0.6608722717241278, 0.10118659058015678, 0.7305240573299949, 0.11897232571778227, 0.14130220468544774, 0.7106210481403645, 0.08447203634180678, 0.1455714435563692, 0.08319201780660956, 0.05756599963314124, 0.058773906462671444, 0.05897602941375246, 0.12647289431362407, 0.08671867875803507, 0.20179312907917846, 0.2328626668008661, 0.2878025085754663, 0.220998719168227, 0.2641531033193858, 0.20438475937820977, 0.19017885031013515, 0.1612894134613292, 0.1627122167966225, 0.5960165818884346, 0.14984905577254282, 0.13055179219943325, 0.15130728203749189, 0.18846454074231478, 0.23511212000855353, 0.1158213394497627, 0.2366611681454761, 0.1861174350333924, 0.19654158497715313, 0.19446769662410757, 0.15799972169015186, 0.09961933151626112, 0.07564981957401617, 0.12584578174068506, 0.15992278494297718, 0.12693114983526865, 0.11678005887156195, 0.11862672611766989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06312979168060595, 0.048770800604539866, 0.03949316340149289, 0.01004717721590076, 0.09825829492481586, 0.0063907046786758626, 0.15527509535844652, 0.05410303850775322, 0.09408396623721327, 0.0603478694297408, 0.026849215976188834, 0.15187413655865112, 0.07302373612935553, 0.1655520510266073, 0.09803747536198693, 0.05796536641408656, 0.053624498163526324, 9.999999999998899e-05, 0.055435272849168715, 0.08621239933075864, 0.04946564584413404, 0.01065732978177003, 0.03448406279594329, 0.0430772876747596, 0.12900202280156814, 0.06684295682856356, 0.20490964843129078, 0.12441411950000547, 0.004236889628701612, 0.18212292925909446, 0.10143638141810729, 0.14435781658994096, 0.08868831814383715, 0.3650498019470456, 0.24841825653508576, 0.3094909279729001, 0.3631704268096796, 0.41930220634695414, 0.3682234527729682, 0.517827975991956, 0.3693148431957408, 0.4515870997609206, 0.1274728194740815, 0.130953930760499, 0.08716072564299315, 0.08880503823728081, 0.09067829650867665, 0.10141183565258871, 0.09957346927621824, 0.08637544510048079, 0.11357681541694109, 0.2535408420238404, 0.15087181912720493, 0.15983237744468293, 0.16476258090763185, 0.1640607347782892, 0.14480023399730912, 0.23128064101832624, 0.1492880494868687, 0.13380019614387073, 0.29129354654975226, 0.32321544563489, 0.3474007755608456, 0.20826061806703766, 0.332087826457225, 0.3575168043356183, 0.20195633391691703, 0.35281960992485295, 0.2583279045278418, 0.23084834891337713, 0.19942715607899775, 0.22947096200805395, 0.17569315588834722, 0.2019088955378998, 0.2717596196710692, 0.20931696659168098, 0.21772870282912626, 0.26218549201552666, 0.20395694592884617, 0.18729999140378972, 0.1669261133120412, 0.19191816743962586, 0.2323414901452775, 0.19693565817526604, 0.1974119640118812, 0.18331394580234384, 0.23746419183388356, 0.1940901701034652, 0.19801274888843468, 0.210400795082351, 0.19276671631603537, 0.1977983027996849, 0.2124942860987573, 0.2085993165018054, 0.211148789769792, 0.1967512490476181, 0.17429280365830346, 0.1811261692312376, 0.17601373149009292, 0.1691755614503263, 0.19438715955854213, 0.1733163001203033, 0.424187746661977, 0.16841129549313205, 0.5328106063656677, 0.3079745822973158, 0.1911711611454624, 0.3557227649633802, 0.20223711307033576, 0.286162886853627, 0.12494916004989576, 0.36043999633558543, 0.15189479052662824, 0.3407271150370802, 0.18012579697294406, 0.16943532642428194, 0.18746153250299813, 0.1716621026174775, 0.18167603682197164, 0.18348250848182568, 0.17463176917156453, 0.20554904188058798, 0.17586791594866769, 0.0866051790186122, 0.08766113444910695, 0.0774541232233491, 0.07969033369234602, 0.07845729161815251, 0.06488368960509683, 0.06840825859461419, 0.07799266330069532, 0.06920829515216975]}, "mutation_prompt": null}
{"id": "1cbe7175-ed48-4fb0-9e8f-90e7ba9c8dc3", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n    \n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n    \n    def _adaptive_F(self, generation_count):\n        return 0.1 + 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n    \n    def _adjust_population_size(self, generation_count):\n        # Reduce the population size as generations progress to focus on exploitation\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n            \n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Dynamic Population Size Adjustment for Efficient Exploration and Exploitation.", "configspace": "", "generation": 5, "fitness": 0.1949245039754707, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.14.", "error": "", "parent_id": "a96eadae-1777-41a1-99ea-e8522d35604b", "metadata": {"aucs": [0.22971221862676738, 0.3604656829138707, 0.6713710928212824, 0.3394266332050667, 0.7026120750520384, 0.7256194821319304, 0.5132355186564186, 0.40995815262638646, 0.37139766541038266, 0.4649742315273443, 9.999999999998899e-05, 0.25874814930835965, 0.4101190904509471, 0.5288883542895839, 9.999999999998899e-05, 0.0973097434770207, 0.454498214130274, 0.4873482772105274, 0.13658396946009543, 0.13949513608705744, 0.22192448808658538, 0.14223216840732078, 0.15780725752014202, 0.15391105923456416, 0.17652461426362298, 0.29987585702516184, 0.14875033558787132, 0.13980205930088063, 0.08539531025368852, 0.09924987677100794, 0.10958010293315079, 0.10105470112694837, 0.10779412493383278, 0.08024937075406036, 0.10966994786060946, 0.08402059565965814, 0.14869876809800664, 0.14221690405369702, 0.13295616102921926, 0.6729406941832659, 0.11398557736281223, 0.1992375772525341, 0.6967692054639534, 0.12605945382418482, 0.1450978378770591, 0.11612743016910665, 0.13356871861316577, 0.05248900622526942, 0.029467671844918053, 0.04890596484198795, 0.08317111480521722, 0.14242844684199296, 0.07809992155965628, 0.145460973623169, 0.20115853402987005, 0.22011689149111713, 0.16850417537785722, 0.25380543277767986, 0.34651712343521857, 0.19789650330151787, 0.1386483306564591, 0.15241549402884624, 0.24374041117213363, 0.11174756191837809, 0.13083120640816726, 0.21639568116046037, 0.1609991554252903, 0.12418431224986437, 0.13756646969825448, 0.26610448092364436, 0.1904271728715914, 0.12722174235854067, 0.16863562928305031, 0.2865993768207943, 0.246735182635767, 0.05918622183547029, 0.12733249376481348, 0.12336882560547624, 0.09230177066682332, 0.12275980444207313, 0.12194596876900798, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0845183385742232, 9.999999999998899e-05, 0.05426935506909358, 0.011329897939700406, 9.999999999998899e-05, 9.999999999998899e-05, 0.11838879712854378, 0.22646452437623865, 0.10353082622578202, 0.0983979962930207, 0.10963195758483435, 0.12543750570535628, 0.4619544268086815, 0.07830218881479034, 0.2030594158913106, 0.06888868774412982, 0.0853861154625074, 0.1734491983284986, 0.07929359613253817, 9.999999999998899e-05, 0.0509800641880469, 0.0561346486970149, 0.08425662828595537, 0.13673096877661062, 0.12845324706780337, 0.05957372801679195, 0.08021489271702809, 0.045863758661747855, 0.05050212400181031, 0.1148401844765653, 0.09109334923244328, 0.161700448329135, 0.06607435982293697, 0.39130357889723355, 0.2774315643311728, 0.454027965689885, 0.446951932191053, 0.4820310996516226, 0.42552272061380825, 0.44989945121012975, 0.45468508998051627, 0.40513773396732755, 0.10003231638002874, 0.13306157029645127, 0.1037558536950226, 0.11854173220296726, 0.0857428904204729, 0.1410605906756024, 0.1184236129992734, 0.11993695806933369, 0.08114387305205784, 0.15782712179486302, 0.13160939502930413, 0.13917857679910905, 0.22342756555590915, 0.15652191469974897, 0.13674617697894043, 0.3183878733479403, 0.20510974682918626, 0.20917127473657116, 0.2655033858811554, 0.2794047502800099, 0.29173364140194635, 0.3351204907470011, 0.23112308495650458, 0.37497191911687655, 0.25119569430885036, 0.3474795623205722, 0.23669008001550007, 0.2639046545754349, 0.2152013653209538, 0.2328258795974062, 0.2002728333869721, 0.22383643757433558, 0.2708445026745854, 0.21532829934501685, 0.21401749290185645, 0.19311164462350738, 0.19199156843045362, 0.19994570635017705, 0.1919133320212294, 0.20019358960151679, 0.18598556653284193, 0.19774195641377135, 0.20300081386682267, 0.217198449715708, 0.18074216720376424, 0.18795120093154982, 0.1978494680151096, 0.20408613100338457, 0.2227296194382935, 0.18925541661268053, 0.20151815982451082, 0.2293370512469235, 0.2906766061282615, 0.21363350535913694, 0.1808395634734471, 0.1757405052247515, 0.18526041587986142, 0.17543592720988943, 0.1954300256468684, 0.1894395497535345, 0.14654371068025196, 0.16700910168587035, 0.6512319031435292, 0.5249578650739928, 0.1960485562195241, 0.3297237466444558, 0.20281985079461273, 0.3061599074592166, 0.15797143706267436, 0.15884718981687784, 0.13070306829708644, 0.19425249857306193, 0.1942101631141293, 0.17325975415622974, 0.20276174521496992, 0.1759460113425021, 0.1924751007673715, 0.17376293504063356, 0.17030528435538128, 0.1914947785918144, 0.16927159767543343, 0.07540227916787079, 0.0661945530372604, 0.07714530624906912, 0.0778898704031028, 0.07199419281404895, 0.08299836386083903, 0.08679080228781078, 0.08056491280953726, 0.08377000911902521]}, "mutation_prompt": null}
{"id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.1  # Probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Self-Adaptive Strategies for Improved Convergence and Robustness.", "configspace": "", "generation": 6, "fitness": 0.21855067502286138, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "1cbe7175-ed48-4fb0-9e8f-90e7ba9c8dc3", "metadata": {"aucs": [0.6057224324175117, 0.6277440377061738, 0.617031998181418, 0.62761107582564, 0.6240933397307433, 0.6339046683476914, 0.6542366967413056, 0.6290159462977754, 0.6290333771832636, 0.32768781845219186, 0.36117573523959834, 0.34657464658046777, 0.35586748288444037, 0.32790155914823393, 0.3449113624055854, 0.35271638491106583, 0.3504681409694195, 0.3905735005838309, 0.12045549803619038, 0.130875010983733, 0.15336756895388048, 0.13782428167973926, 0.14633971939453494, 0.12925334735484917, 0.14554516767731251, 0.13891887732128527, 0.1371041099710406, 0.08945350119097695, 0.10702143580130574, 0.10574640489507525, 0.11778589621879765, 0.11151128009739841, 0.12824470930436216, 0.11218732926233954, 0.11136978464821701, 0.11500410002914796, 0.8205509916656182, 0.8569783285536867, 0.9250073089846316, 0.9025278267100053, 0.8459232853782691, 0.8500423811278625, 0.8197628482109404, 0.7787636600981256, 0.7837009939407162, 0.24539244339826194, 0.21885260534832118, 0.2340024658274804, 0.21180552474697611, 0.259212087967869, 0.24780800219340415, 0.2431889650848943, 0.24295882493335053, 0.2503887807503272, 0.244360511700077, 0.2589800787146438, 0.27389392308971106, 0.2628587075641985, 0.39012839202730387, 0.2592481489973275, 0.2742977460529745, 0.26184284846444805, 0.2604630645431174, 0.1368724378231364, 0.13683741319645215, 0.13446531133701012, 0.12077418896060976, 0.13462724531325543, 0.13311679406526633, 0.135675866193526, 0.14586272651403598, 0.1538982106408031, 0.13600081128183394, 0.10635542616548121, 0.1452972094317816, 0.13934367920147472, 0.16438811588384883, 0.13215253299151342, 0.14393414380138003, 0.13886476324729502, 0.1309057665358896, 9.999999999998899e-05, 9.999999999998899e-05, 0.005176288341731783, 9.999999999998899e-05, 9.999999999998899e-05, 0.03209501834599249, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10419967491324056, 0.09949834742103358, 0.11019252028183768, 0.07292816106922329, 0.08940868709461358, 0.09754135356997118, 0.10061853862912429, 0.1269460474972136, 0.11914245344105479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010320729515038485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033033129661896865, 0.0783498223709117, 0.06955654883440499, 0.09643419021108135, 0.08758414699397399, 0.09624287285245225, 0.0924327442508538, 0.09239010198998399, 0.10090122416327763, 0.09811317642108097, 0.42766230313364983, 0.4213219748442216, 0.43091355555930155, 0.41513195885077625, 0.41958122640097795, 0.40139639131541116, 0.41872042677976473, 0.40272163598602184, 0.4294285354759082, 0.10474951232125673, 0.08704500480006883, 0.07806111742423605, 0.07158058465476735, 0.07923631568797063, 0.09463187354879632, 0.08724398843654113, 0.08753902978120254, 0.08030394273423458, 0.1313775703787582, 0.13240319354178487, 0.1447791470702774, 0.12207971536958795, 0.13057655715984784, 0.12461678125523012, 0.12079896612168395, 0.1273496203891078, 0.1370162514249441, 0.27367464423009213, 0.2659338169680112, 0.27863943720773054, 0.2758282732028745, 0.2549872776181765, 0.2807650991730536, 0.30360176623513724, 0.30712246704010127, 0.30440214930570675, 0.19392080140932244, 0.2113600274958478, 0.1765088818866325, 0.20403781507248708, 0.17947546765487155, 0.1943077849960606, 0.20568062806498455, 0.21033426777657316, 0.21854845008215795, 0.20119597666410527, 0.19507386368327395, 0.17597333176594931, 0.1791782753265463, 0.17654804162048243, 0.18387529291940696, 0.17812782072851274, 0.18629119127882687, 0.18125430768028739, 0.17778959133092942, 0.19047219746870947, 0.1906646283360205, 0.18584526589726624, 0.18248718256533603, 0.21044128309671384, 0.18465359581030838, 0.18533566745142194, 0.18828320499516626, 0.19315818566645526, 0.21451209992071885, 0.15757448815400954, 0.48402191582914467, 0.23613174118859837, 0.2234922540640708, 0.20606786672609045, 0.21145726597459535, 0.22960159648651568, 0.1707567806544683, 0.19974551805876706, 0.2244879586859374, 0.1959448991224534, 0.20399990652433975, 0.17889900153278082, 0.18843045534968994, 0.19662274970692484, 0.20223302014673306, 0.17902948047817047, 0.21950066345061192, 0.17936596804971783, 0.18896194635852648, 0.17374541534474086, 0.17347624875542988, 0.21285596943989815, 0.1784625565096265, 0.1803126314166491, 0.08299618777760098, 0.06614766695586882, 0.07818398556620121, 0.08090676212309522, 0.08406027919637094, 0.07164210828992978, 0.07532786308236716, 0.06864211625626049, 0.07393572134932169]}, "mutation_prompt": null}
{"id": "35cae01d-1037-4871-9669-a7e402befcb1", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.1  # Probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Self-Adaptive Strategies for Improved Convergence and Robustness.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {"aucs": [0.6057224324175117, 0.6277440377061738, 0.617031998181418, 0.62761107582564, 0.6240933397307433, 0.6339046683476914, 0.6542366967413056, 0.6290159462977754, 0.6290333771832636, 0.32768781845219186, 0.36117573523959834, 0.34657464658046777, 0.35586748288444037, 0.32790155914823393, 0.3449113624055854, 0.35271638491106583, 0.3504681409694195, 0.3905735005838309, 0.12045549803619038, 0.130875010983733, 0.15336756895388048, 0.13782428167973926, 0.14633971939453494, 0.12925334735484917, 0.14554516767731251, 0.13891887732128527, 0.1371041099710406, 0.08945350119097695, 0.10702143580130574, 0.10574640489507525, 0.11778589621879765, 0.11151128009739841, 0.12824470930436216, 0.11218732926233954, 0.11136978464821701, 0.11500410002914796, 0.8205509916656182, 0.8569783285536867, 0.9250073089846316, 0.9025278267100053, 0.8459232853782691, 0.8500423811278625, 0.8197628482109404, 0.7787636600981256, 0.7837009939407162, 0.24539244339826194, 0.21885260534832118, 0.2340024658274804, 0.21180552474697611, 0.259212087967869, 0.24780800219340415, 0.2431889650848943, 0.24295882493335053, 0.2503887807503272, 0.244360511700077, 0.2589800787146438, 0.27389392308971106, 0.2628587075641985, 0.39012839202730387, 0.2592481489973275, 0.2742977460529745, 0.26184284846444805, 0.2604630645431174, 0.1368724378231364, 0.13683741319645215, 0.13446531133701012, 0.12077418896060976, 0.13462724531325543, 0.13311679406526633, 0.135675866193526, 0.14586272651403598, 0.1538982106408031, 0.13600081128183394, 0.10635542616548121, 0.1452972094317816, 0.13934367920147472, 0.16438811588384883, 0.13215253299151342, 0.14393414380138003, 0.13886476324729502, 0.1309057665358896, 9.999999999998899e-05, 9.999999999998899e-05, 0.005176288341731783, 9.999999999998899e-05, 9.999999999998899e-05, 0.03209501834599249, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10419967491324056, 0.09949834742103358, 0.11019252028183768, 0.07292816106922329, 0.08940868709461358, 0.09754135356997118, 0.10061853862912429, 0.1269460474972136, 0.11914245344105479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010320729515038485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033033129661896865, 0.0783498223709117, 0.06955654883440499, 0.09643419021108135, 0.08758414699397399, 0.09624287285245225, 0.0924327442508538, 0.09239010198998399, 0.10090122416327763, 0.09811317642108097, 0.42766230313364983, 0.4213219748442216, 0.43091355555930155, 0.41513195885077625, 0.41958122640097795, 0.40139639131541116, 0.41872042677976473, 0.40272163598602184, 0.4294285354759082, 0.10474951232125673, 0.08704500480006883, 0.07806111742423605, 0.07158058465476735, 0.07923631568797063, 0.09463187354879632, 0.08724398843654113, 0.08753902978120254, 0.08030394273423458, 0.1313775703787582, 0.13240319354178487, 0.1447791470702774, 0.12207971536958795, 0.13057655715984784, 0.12461678125523012, 0.12079896612168395, 0.1273496203891078, 0.1370162514249441, 0.27367464423009213, 0.2659338169680112, 0.27863943720773054, 0.2758282732028745, 0.2549872776181765, 0.2807650991730536, 0.30360176623513724, 0.30712246704010127, 0.30440214930570675, 0.19392080140932244, 0.2113600274958478, 0.1765088818866325, 0.20403781507248708, 0.17947546765487155, 0.1943077849960606, 0.20568062806498455, 0.21033426777657316, 0.21854845008215795, 0.20119597666410527, 0.19507386368327395, 0.17597333176594931, 0.1791782753265463, 0.17654804162048243, 0.18387529291940696, 0.17812782072851274, 0.18629119127882687, 0.18125430768028739, 0.17778959133092942, 0.19047219746870947, 0.1906646283360205, 0.18584526589726624, 0.18248718256533603, 0.21044128309671384, 0.18465359581030838, 0.18533566745142194, 0.18828320499516626, 0.19315818566645526, 0.21451209992071885, 0.15757448815400954, 0.48402191582914467, 0.23613174118859837, 0.2234922540640708, 0.20606786672609045, 0.21145726597459535, 0.22960159648651568, 0.1707567806544683, 0.19974551805876706, 0.2244879586859374, 0.1959448991224534, 0.20399990652433975, 0.17889900153278082, 0.18843045534968994, 0.19662274970692484, 0.20223302014673306, 0.17902948047817047, 0.21950066345061192, 0.17936596804971783, 0.18896194635852648, 0.17374541534474086, 0.17347624875542988, 0.21285596943989815, 0.1784625565096265, 0.1803126314166491, 0.08299618777760098, 0.06614766695586882, 0.07818398556620121, 0.08090676212309522, 0.08406027919637094, 0.07164210828992978, 0.07532786308236716, 0.06864211625626049, 0.07393572134932169]}, "mutation_prompt": null}
{"id": "f04b7500-4b13-4d4b-9fa9-0658729ff8b0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9\n        self.CR = 0.8\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.15  # Increased probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(6, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.standard_cauchy(self.dim) * 0.1\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Dynamic Local Search and Cauchy Distribution for Robust Exploration.", "configspace": "", "generation": 8, "fitness": 0.19647817878118767, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {"aucs": [0.5160119367376178, 0.5162832610627659, 0.4955711878679735, 0.48865367818174466, 0.4881655854888901, 0.47621103609899595, 0.5300638172800678, 0.5006295863661607, 0.47397777199290514, 0.2007739468962405, 0.21763971183395114, 0.24518775840380935, 0.21722171749126307, 0.19298071368483438, 0.2119681801308042, 0.21383420793825003, 0.23647428598921072, 0.21743745128020897, 0.09471056302490011, 0.09741979186000316, 0.094821355693395, 0.11366627441447197, 0.09332663814794018, 0.09191003138904652, 0.09330525825041336, 0.0978196774549791, 0.10657730799056209, 0.08869615684832222, 0.09829316881235972, 0.09010176269759396, 0.08179710023942066, 0.09656635395608282, 0.08235401020124222, 0.08212393221370762, 0.09997501777036466, 0.08008093296392271, 0.8427987555369599, 0.7837755177944945, 0.8123703565869305, 0.7463866898686307, 0.8278645492089103, 0.6879612646979683, 0.8809220731333736, 0.7532965809837762, 0.8710706712392685, 0.20977883936274289, 0.19136583950054897, 0.190681856525998, 0.2156585477094728, 0.20956472465494158, 0.20865667944045185, 0.20287169479120826, 0.2101711369328797, 0.1824432445220796, 0.23672536662849974, 0.23840594185740127, 0.24208054324295858, 0.25578115849284144, 0.5063811100883504, 0.3797557025544879, 0.2798015868568323, 0.2639997294842108, 0.2703725028223194, 0.12575484435192463, 0.11784389449993338, 0.13201484185643808, 0.10818555615789316, 0.11722439580015709, 0.1348894228797488, 0.1320559655079151, 0.11922752084540056, 0.13387645778753376, 0.12735311754981982, 0.09458040786612965, 0.10894076695565913, 0.12340407215740379, 0.12273892854482016, 0.12917562629412427, 0.11778469969073158, 0.10660117523833246, 0.13032043479110866, 0.020020113026550823, 0.004603698682896007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013981856512019886, 0.0012887958317884252, 9.999999999998899e-05, 0.0991641714167445, 0.12776453160199364, 0.13404880783265893, 0.09045473449142283, 0.09797452015626895, 0.12552456081186114, 0.1516500735177022, 0.12358661285428274, 0.1516912422874206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08146330458288953, 0.0762080625600896, 0.07490222051593742, 0.09620074616859442, 0.09123467492654946, 0.09780364189866009, 0.0851679181771633, 0.07091990927050573, 0.09818974416024007, 0.3726183356703131, 0.38555189807626267, 0.38719258890017505, 0.3884947960449956, 0.38978532615198824, 0.3822881222482434, 0.4059955112932372, 0.36911577455882627, 0.3858586531985173, 0.073107680797033, 0.0850636361558289, 0.0966072143749428, 0.07758998719208554, 0.06939328493308417, 0.07364025816100583, 0.07500629525250846, 0.0752203909214415, 0.08082546891879339, 0.12606838334199277, 0.12491457125474248, 0.12241754415646777, 0.13747085082454646, 0.15352351801093933, 0.14275348069354243, 0.11605839878074475, 0.1193762932142699, 0.1419179011106657, 0.25637752905873035, 0.24307285362402364, 0.24321561956830895, 0.22104810216080784, 0.22419131921002522, 0.21773371634293082, 0.25436891988466404, 0.26521517314502585, 0.26583023966415675, 0.16802621118238004, 0.15915769437872773, 0.19970125406671457, 0.1657929974675868, 0.16324497523143167, 0.15826886238725268, 0.16575735740614805, 0.197002153679114, 0.19643218713077282, 0.16995222862054926, 0.17881702440019565, 0.1898568132373455, 0.18667701304095385, 0.1814450680713845, 0.18737544333863676, 0.18763899942794038, 0.1856405018020859, 0.18405078027437527, 0.170855471970203, 0.17733510815086806, 0.18937261370679015, 0.16867424721608126, 0.1812768678487756, 0.1768888647285266, 0.16612197413534902, 0.17146524685673048, 0.16485499711196028, 0.15513357021331542, 0.39906056695498293, 0.3282504278821611, 0.15925909044176512, 0.20723735172298985, 0.2511172384762431, 0.15447648699523675, 0.1517536248462038, 0.19341135486786065, 0.23977390251747055, 0.18993249351395303, 0.29043951693063663, 0.21812506508015628, 0.18691932635056485, 0.21957774980663325, 0.19661154856133767, 0.22591543044500795, 0.1615640803824674, 0.171397892877877, 0.18677000347168393, 0.16745666389531966, 0.16742695675453811, 0.17402067979965852, 0.16278037201850404, 0.20192055843315782, 0.18121545693382124, 0.17646398574248756, 0.06718359663681117, 0.06442958129683773, 0.06179102214319354, 0.09863162491744148, 0.0824140406784003, 0.06791570608010555, 0.08296205318127436, 0.066151130334834, 0.06841396855457993]}, "mutation_prompt": null}
{"id": "4e129388-2f8d-4e5b-924a-c145f734203f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9\n        self.CR = 0.85\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.15\n    \n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return self.CR - 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return self.F - 0.3 * np.sin(np.pi * generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.05 + 0.05 * np.random.rand(), self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Dynamic Scaling and Adaptive Local Search for Robust Optimization.", "configspace": "", "generation": 9, "fitness": 0.11492209960798329, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.18.", "error": "", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {"aucs": [0.1327712079592902, 0.14041345863954013, 0.15393290409230198, 0.20288318146382311, 0.17166944075386914, 0.17093536993156488, 0.15707649152124892, 0.18451325768602433, 0.1691958005268258, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04326162278695034, 0.0444919178180786, 0.05092832034836625, 0.04702563156710893, 0.06976406820624836, 0.0640955493679054, 0.05083400414334771, 0.04909369499441818, 0.0719920182627386, 0.033480434108543844, 0.03610851556069539, 0.04201586305136484, 0.04181849834199114, 0.030077089324815787, 0.033560621111004774, 0.03427567014236976, 0.020935472881973838, 0.03627205595463234, 0.9041830891004895, 0.8778033114188939, 0.8985242977838093, 0.9459701734243814, 0.9249864477210922, 0.9285108230743508, 0.9481489677055895, 0.8790089763425787, 0.8838261832471248, 0.06250897388688514, 0.0831421254924486, 0.05488638820085179, 0.12213633680321978, 0.020980237541303404, 0.05614752191368266, 0.08028216904900876, 0.04932487882807868, 0.051263751174964844, 0.12136092726252135, 0.1359870746209697, 0.05970571375811884, 0.10489449825727148, 0.14475184485417336, 0.10991877204037959, 0.09627844995786039, 0.1437430332863633, 0.135604589353445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0072137843168677, 0.010027291765382196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006812411105349914, 0.010548839971755264, 0.05015716861691111, 0.05359456604400381, 0.013803758006522782, 0.014696707955221933, 0.06893939652276126, 0.043329773912182956, 0.05109201829970189, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008307652374822672, 9.999999999998899e-05, 9.999999999998899e-05, 0.14473113244113045, 0.16376204910655412, 0.15945095783854613, 0.1862829340185338, 0.18537107250519247, 0.21197195381518985, 0.1713393685341743, 0.13618252099902817, 0.1639703012989594, 0.05240631927222583, 0.05046289329639442, 0.04650425722766072, 0.036340314065812174, 0.03795317329810588, 0.043374046112392484, 0.05000989664299338, 0.038398945552611585, 0.041302413984859565, 0.1258299936907038, 0.1423153832255757, 0.13615810831094077, 0.15556354161900088, 0.14867258135646155, 0.1256537202583946, 0.13315583084394966, 0.13261724059562807, 0.14663569753106387, 0.15546948488031354, 0.15484518584529505, 0.16123183192790724, 0.15279340768965344, 0.16501821467021105, 0.14683894997815639, 0.18999664918032588, 0.18057218894401028, 0.17167663564338254, 0.10228831044709408, 0.07954839290324855, 0.12807707255267653, 0.08114550635386664, 0.10086852258724033, 0.1074280983579512, 0.12654721510115363, 0.09966340279293051, 0.10406076704666012, 0.14502620856688886, 0.14396944586683025, 0.13716789422277376, 0.1467439770565354, 0.13169294939049325, 0.16266477030614712, 0.1339214366537168, 0.14654043110398784, 0.15934228932350214, 9.999999999998899e-05, 0.07373341029491876, 0.13035093324458702, 0.14979653247192015, 0.15590035859226392, 0.13260285583869302, 0.15227159708302584, 0.1272511578034653, 0.17478693832182912, 0.1155812829280558, 0.1943807759957492, 0.1625785961056081, 0.10683415031776133, 0.15171118707571973, 0.22870676736503093, 0.1124661223494644, 0.11025357715520245, 0.11189362654926005, 0.11019446477463368, 0.1545268679690207, 0.12287423619316706, 0.11646898756187751, 0.13475720500396204, 0.12422917407058065, 0.14778365872108112, 0.13880703432939445, 0.14212055377922295, 0.17258159510145799, 0.1719042312777701, 0.17143144994734227, 0.19109757874902367, 0.171474440013357, 0.16462362144895704, 0.1624358448724641, 0.16992556782604884, 0.17067850714488086, 0.046863411066748295, 0.04138642851627883, 0.04618899370532492, 0.03683876523752583, 0.04511635671828007, 0.04385703483442738, 0.036738336307292174, 0.03916846703075205, 0.03289674839488821]}, "mutation_prompt": null}
{"id": "01a23345-8508-4ef5-9d65-b06ea9c735c0", "solution": "import numpy as np\n\nclass HybridAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.2  # Adjusted probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual, func):\n        gradient = np.random.uniform(-0.1, 0.1, self.dim)  # Simulated gradient\n        return np.clip(individual - gradient, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial, func)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridAdaptiveMemeticDE", "description": "Hybrid Adaptive Memetic DE with Dynamic Population Control and Gradient-based Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 10, "fitness": 0.20951688866967227, "feedback": "The algorithm HybridAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {"aucs": [0.5940088149011554, 0.5640455315849456, 0.5914553611668678, 0.5762712936391559, 0.5733986966039584, 0.580874551738379, 0.5459134125183283, 0.5491430351898435, 0.5683683296064748, 0.2567619248708035, 0.27004986359991534, 0.2619586514108201, 0.2748909821728832, 0.29128219562607305, 0.27094069443486335, 0.3001665898110776, 0.27683875126443014, 0.25379792998632233, 0.11650415107949152, 0.1007642844268879, 0.10697184378385027, 0.11538604168562339, 0.11342801950935177, 0.09404253169106835, 0.11571056696551063, 0.11693601625620664, 0.12475616814847179, 0.09219293845735121, 0.0958075976707583, 0.0911562527155324, 0.1048478007910717, 0.0961663528776393, 0.0854250803809975, 0.09329646939728786, 0.09614708836258523, 0.09389133168234343, 0.7907852009778654, 0.7444702261063135, 0.8132020003545954, 0.8021041721437482, 0.8329683499443927, 0.8177445456686323, 0.8987131038426208, 0.7687200523677882, 0.7888330801079934, 0.2370619726348565, 0.2558789009484873, 0.2347405370675255, 0.23034815609406356, 0.23157477155376216, 0.23470834785102856, 0.24629785950935257, 0.20713763480428404, 0.20270458222045795, 0.2560923277576782, 0.24340592951044016, 0.3494227359758024, 0.2906603269534458, 0.29541827004197785, 0.306027107475931, 0.2976773716375517, 0.280470014477768, 0.3294334360557716, 0.1416377069663427, 0.11227410025304618, 0.1463475434913204, 0.12989997021164978, 0.12194428950201652, 0.13113732512270182, 0.140797771268107, 0.1213070238381424, 0.14253200047739378, 0.12954714950667878, 0.11411768195921468, 0.1304127380973361, 0.14995914713430625, 0.15656724901073027, 0.14171487516744907, 0.14498404685111987, 0.11898336288007971, 0.12964415449385558, 0.0026336021878722304, 0.01644233607366974, 0.0016946935444038802, 0.022034824423988186, 9.999999999998899e-05, 9.999999999998899e-05, 0.011183842631463992, 0.002320840230828791, 9.999999999998899e-05, 0.11801587079700426, 0.12184622137142742, 0.0957980504051178, 0.11794515072569833, 0.10912255804232462, 0.07305643873184142, 0.10748245910972687, 0.18914633577930728, 0.14680764910125887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09538392573208787, 0.07748606758340737, 0.09391073804599093, 0.105883448481365, 0.08338486117230115, 0.1015369912353854, 0.09162824312424, 0.10218416629696203, 0.08628189318045354, 0.40653305311507393, 0.4209385621500592, 0.397203329217761, 0.40119272988796106, 0.41905967902607677, 0.38662496414506053, 0.41329806157925, 0.4063196735743354, 0.40147478565285666, 0.075434266130461, 0.08611143212803474, 0.08979020480004507, 0.08231824539903898, 0.07930413259365032, 0.07531200664534221, 0.08800851560504541, 0.07668640241997104, 0.09105032533545288, 0.11936530211282315, 0.12482901161281335, 0.14597064058078846, 0.1503465311050508, 0.13389052074729713, 0.14148821498899578, 0.1298524443970116, 0.14295561602650886, 0.153671166257756, 0.26188419080682146, 0.24235617963174405, 0.2654436765758612, 0.2692995272430355, 0.244138752664243, 0.2627898713000889, 0.2858573324711775, 0.28656153594341727, 0.2880704323526109, 0.19108197405790273, 0.18586792169483135, 0.17569054006746132, 0.18345815382835695, 0.1702601093197651, 0.1980732300103203, 0.22588225733275935, 0.1923931281471245, 0.20254221522705362, 0.19650680515081165, 0.17712044139841088, 0.17298939368773225, 0.18112018090810234, 0.18289108754985595, 0.19521749472709404, 0.18696092377079432, 0.1831094729890872, 0.1885499931016168, 0.18107933282763777, 0.17891748300589772, 0.17921130298411403, 0.17298928659407375, 0.17349168528944192, 0.17634225857077213, 0.17582825910831323, 0.1806314584604004, 0.18335883486950633, 0.1525249912813662, 0.3251782160568192, 0.16857981318704063, 0.2550576807639542, 0.2537853557783788, 0.1734968011194966, 0.3764666644376973, 0.16950446166614797, 0.18134417027472338, 0.23205759444719942, 0.19113669175485803, 0.2503725944265337, 0.17701967401211094, 0.20104453790854504, 0.18294673189585353, 0.2884346383827857, 0.3832775785776985, 0.19040505058779678, 0.17975897412455943, 0.17875176681689664, 0.17889729645994445, 0.1814030693071702, 0.18126361194948526, 0.17353440138911613, 0.18051698398084604, 0.17868785145654187, 0.18476753087408682, 0.07975585227140347, 0.06939849005285526, 0.06316753300629463, 0.07040520577565823, 0.0750705720128153, 0.06191493518546609, 0.06921339446348174, 0.06958947325704756, 0.07150371847170278]}, "mutation_prompt": null}
{"id": "f3707ac4-2798-4f5c-a984-652088cb5795", "solution": "import numpy as np\n\nclass HybridSelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.75\n        self.CR = 0.85\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_probs = [0.1, 0.05]  # Probabilities for different local searches\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c, d = np.random.choice(indices, 4, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]) + 0.5 * (self.population[d] - self.population[idx]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.75 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual, method):\n        if method == 0:\n            perturbation = np.random.normal(0, 0.1, self.dim)\n        else:\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < np.max(self.local_search_probs):\n                    method = np.random.choice([0, 1], p=self.local_search_probs)\n                    trial = self._local_search(trial, method)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridSelfAdaptiveDE", "description": "Hybrid Self-Adaptive Differential Evolution with Multi-Perturbation Local Search for Enhanced Global and Local Exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {}, "mutation_prompt": null}
{"id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.15  # Increased probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for enhanced exploration\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Dynamic Scaling and Improved Local Search for Better Exploration-Exploitation Balance.", "configspace": "", "generation": 12, "fitness": 0.2441649815064807, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "8f077d46-2c05-4105-80cd-0fe1711829c5", "metadata": {"aucs": [0.6522974809068652, 0.6150518504472182, 0.654597523762015, 0.6477022678831728, 0.6446786745641158, 0.6615750621980537, 0.6498277506760797, 0.6387629723905695, 0.6322112758873191, 0.39359392739387256, 0.33629235415470726, 0.3040791024298909, 0.3643966052850476, 0.3846700153653786, 0.38190638784897124, 0.3695312094158356, 0.3647197049887011, 0.3965070012734613, 0.11104039577302227, 0.11542534178637454, 0.11340859554419913, 0.13911416116339348, 0.13692645298485495, 0.11657868471393917, 0.105961552758564, 0.1029691855814896, 0.1128973765566581, 0.11132366612789701, 0.09121033920491883, 0.10859832997040975, 0.1053771312615358, 0.10684591856490644, 0.10209320641116959, 0.11359655800549628, 0.0964902161642005, 0.11577874875257421, 0.7484610098945417, 0.8069586501221491, 0.7354952465428839, 0.7164991001481167, 0.80732771215402, 0.7854407722864037, 0.7576871369549351, 0.7647126406132977, 0.7844651430883407, 0.2696649549998248, 0.2485531641811386, 0.26930703797081945, 0.2325933667947655, 0.27380016382466055, 0.27444629841271184, 0.2522685015917764, 0.19390308530541223, 0.2600630304025654, 0.315035371293665, 0.6191755993645811, 0.5842317470896572, 0.505363947279927, 0.3113253919536989, 0.5268262210232766, 0.46516337930171936, 0.4867154626025961, 0.29731606278923295, 0.17260309805276242, 0.128207966897249, 0.1521930014761097, 0.1465331571166747, 0.12905785078379872, 0.1540763168005127, 0.15151480809760032, 0.1412755557772032, 0.14668184255619077, 0.139793812317899, 0.14076865618845602, 0.1274110482863211, 0.1270816597815143, 0.15338334668827247, 0.14450417510204971, 0.15437402909268916, 0.13915978062410395, 0.12808197622782302, 0.03602123304940574, 0.04482742492713898, 0.01457491954670731, 0.0716059766064594, 0.07703090013450697, 0.0366258523517321, 0.04705092165404856, 0.04778203518454738, 0.05082611766949796, 0.2281995156620401, 0.10666127893000776, 0.1547366378937589, 0.1584651633933024, 0.18258822316789103, 0.16333902333370842, 0.21620305807154205, 0.198786201758005, 0.18600314018541952, 9.999999999998899e-05, 0.017588974004673408, 0.007121175630522836, 9.999999999998899e-05, 0.0023093398352180827, 0.025572465301456626, 9.999999999998899e-05, 0.007569788055168281, 0.0002108575369728083, 0.11111640121051736, 0.10074322157486748, 0.12261203829853862, 0.10861464098893137, 0.13932593707601626, 0.14088951888402135, 0.12835511600933402, 0.13582803882000483, 0.10452920591584114, 0.4428603833316511, 0.48293225254576355, 0.4427902348588668, 0.4314275539943203, 0.4511834507650371, 0.4231203027279479, 0.4658965175954135, 0.46151496240236933, 0.4348078160939105, 0.08269668628515825, 0.08823246483392866, 0.08291124974176256, 0.0865309792051463, 0.08756096679837899, 0.09514685288139046, 0.09560464795532642, 0.08427751400972261, 0.08707662914887371, 0.12818362173409859, 0.15440577334706618, 0.1686664765353294, 0.12448660159790037, 0.1573541570119441, 0.14791856235217038, 0.14070905340945938, 0.12068124246188472, 0.13399038295747978, 0.3053408532027212, 0.2981710627344766, 0.3023181865381651, 0.30118891595539277, 0.28209596793653935, 0.31399866426196055, 0.30798062483391875, 0.3273947769220724, 0.30447779358438, 0.21234704680604455, 0.23097681129068037, 0.23061430792273152, 0.21231484515088273, 0.1990348844544454, 0.2191331960272277, 0.22710661657530096, 0.24267262775903453, 0.220669563681549, 0.18268394748344896, 0.17992738493648341, 0.1791626924653088, 0.19277612617721973, 0.20255411106575927, 0.18423109409115446, 0.1962823949244633, 0.19281896576575186, 0.19082530512163143, 0.19397041200611442, 0.19323339906337955, 0.19019695041804685, 0.20143234135922972, 0.17941250561778777, 0.19473414652988763, 0.20125417123351208, 0.2272470804465001, 0.18338290423972003, 0.442547816206196, 0.1792736377716455, 0.3626624710035127, 0.6526710822354513, 0.547233477923952, 0.6368773929819354, 0.16845284576164832, 0.20680524392934163, 0.23480604310200304, 0.40783439217592754, 0.20058718443988277, 0.2958276977073996, 0.21331132650300466, 0.24714165547105327, 0.1824903471828183, 0.14652115989639714, 0.4368133633091804, 0.38545623230713577, 0.17972217599440243, 0.1718315157575706, 0.17691204266345562, 0.17310735693954393, 0.1912901308545394, 0.1734396654949233, 0.20643448448772728, 0.1963764629441972, 0.17681012488300274, 0.06981497856533336, 0.08883876493722787, 0.07786546382024839, 0.08208327453078801, 0.07235366851398872, 0.07323385848848285, 0.07285231216629584, 0.08763101636765513, 0.07324167220410926]}, "mutation_prompt": null}
{"id": "c4e068bb-99ee-4b00-b3f0-b04bb7625a29", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.2  # Adjusted probability for local search\n        self.tunneling_prob = 0.05  # Probability for quantum tunneling\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.15, self.dim)  # Reduced perturbation for refined search\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _quantum_tunnel(self, solution):\n        offset = np.random.uniform(-0.5, 0.5, self.dim)\n        return np.clip(solution + offset, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n\n                if np.random.rand() < self.tunneling_prob:\n                    trial = self._quantum_tunnel(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredDE", "description": "Quantum-inspired Differential Evolution with Quantum Tunneling and Enhanced Local Search for Superior Global Optimization.", "configspace": "", "generation": 13, "fitness": 0.22744235430668538, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.6143314895443344, 0.5597956991142121, 0.5789947967947029, 0.6313202863553111, 0.5738517356824555, 0.6137624999341722, 0.6080707136379535, 0.5895157153522113, 0.6070898283098858, 0.25107219837326544, 0.3104950430385647, 0.2935014359866607, 0.26533674377068417, 0.2995987817189639, 0.33481551612369687, 0.2657671991461079, 0.30031913277063427, 0.30741910372834247, 0.09648392355308333, 0.13727514507602645, 0.10923113650286054, 0.100979709832405, 0.10492612803590784, 0.09636640256068385, 0.09984805506753947, 0.11197588744764198, 0.10678389112368258, 0.09142232910829984, 0.09355222388573037, 0.09135709088430954, 0.09385388474415102, 0.09267985490250374, 0.10055077574930293, 0.09546229710747123, 0.09942729654857063, 0.09879284074340289, 0.8229460868956661, 0.7604845269441404, 0.7460623530869717, 0.8168789638286995, 0.7810318629278444, 0.7900081356722412, 0.7854857741455943, 0.8276723727565465, 0.8039887429086576, 0.2454077815330845, 0.2381496214618034, 0.23969478058779126, 0.24651623860863037, 0.21731585336494919, 0.2626437576384444, 0.24958992132130653, 0.2283397806877081, 0.21667006409353384, 0.3344773633684063, 0.39078585692848256, 0.2950464603589812, 0.29078936471436423, 0.4329361143284406, 0.5765657920075912, 0.3348929757387733, 0.40858777182139683, 0.4152463922300924, 0.14049606239272672, 0.17093104024141526, 0.13254764717283685, 0.14289562400002886, 0.15098271949771047, 0.13496252708299905, 0.14609315839666337, 0.12886075587541124, 0.1363755701736018, 0.1246467414817265, 0.11754188673667065, 0.14097427592962086, 0.15570074131795608, 0.1399391505646026, 0.13778490735612503, 0.1355570755895027, 0.1530815918463292, 0.13505151037115104, 0.038824829644169445, 0.042474829059629515, 0.014967259004966427, 0.03651966009219376, 0.041926792191470996, 0.06720235351938697, 0.021791459653140555, 0.020454712330862268, 0.0439932140241035, 0.17266140327702673, 0.14141526584415476, 0.1522455729358868, 0.08555989446038581, 0.11071851543797784, 0.15325746030725163, 0.17295722397577906, 0.18224354579183877, 0.14623028573178476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00034779997988643174, 0.008545922917285509, 9.999999999998899e-05, 0.004653384960965901, 9.999999999998899e-05, 0.0016033259939904898, 0.1045108933503539, 0.12222672978184068, 0.0932991976084615, 0.09653031663115341, 0.11103796462210425, 0.11489055705369577, 0.11042161711684417, 0.08633775406500444, 0.0908228630824015, 0.4113973571672097, 0.41519904223821746, 0.4379492110978346, 0.45961669780320247, 0.4224407670232374, 0.4327699214665365, 0.437356659277237, 0.4185405764336303, 0.4137076604808323, 0.10849884309866353, 0.0849227858639322, 0.10335753546232807, 0.0837690332001082, 0.08790806889896574, 0.0944209158183067, 0.10286994724234699, 0.07899299524769687, 0.09790056743589703, 0.13408210883741922, 0.14227246358345924, 0.13426090282964798, 0.162884606482824, 0.13176279615219444, 0.13130724851270137, 0.1171541630488846, 0.1508577928644279, 0.13153377003250388, 0.2691127963036636, 0.2744167168617986, 0.27245509967770354, 0.28044029883172605, 0.2785448149708808, 0.27907962302214095, 0.3056677256526875, 0.2875542959704176, 0.27738475536005713, 0.1882205402773136, 0.2152119563718764, 0.21473813564207545, 0.18878595427583944, 0.17787152173898702, 0.20226744059257284, 0.21240526657420744, 0.2320197049916597, 0.208187210086057, 0.18422353311216344, 0.18168546328117918, 0.1825429321080163, 0.17944566346831559, 0.17809714072501392, 0.17822026428026294, 0.18406847271584958, 0.16887887647137978, 0.18567796741455733, 0.19890386017688266, 0.1744181314966723, 0.1825851466823547, 0.1763160371231095, 0.17099659784544763, 0.17813363796169046, 0.19079233221924286, 0.17781992475727826, 0.1813648058297267, 0.5012041581026889, 0.17318223860743875, 0.6458699895392844, 0.4818769839129513, 0.3159626870616581, 0.4720474317627138, 0.4012254270642962, 0.42901917451658533, 0.22182119602770067, 0.268726536109803, 0.1787177261084244, 0.28028574425606767, 0.16546627398146885, 0.19237883056403504, 0.17747890254784215, 0.21894044903692989, 0.1973065398983309, 0.23075493866403562, 0.218882187515145, 0.1956478910329006, 0.18081355527169163, 0.1742223594568444, 0.17623627186263835, 0.18163992878787916, 0.17639369625356016, 0.1819897023417194, 0.17480619566823385, 0.07938691558269018, 0.06604200632029711, 0.07316967397682528, 0.07199537225221031, 0.07755809197659058, 0.06994638927042396, 0.07489649569475665, 0.07577985640825446, 0.07977053764911801]}, "mutation_prompt": null}
{"id": "02f0fc21-7ac8-4a2e-acf4-0cfeebb5bbff", "solution": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.QF = 0.9  # Quantum scale factor\n        self.CR = 0.8  # Lower crossover rate for stability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.20  # Adjusted probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.QF * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _quantum_walk(self, individual):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Quantum step size\n        return np.clip(individual + step_size, self.lower_bound, self.upper_bound)\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_QF(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        if np.random.rand() < 0.5:  # Randomly choose between local search or quantum walk\n            perturbation = np.random.normal(0, 0.3, self.dim)  # Enhanced perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        else:\n            return self._quantum_walk(individual)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.QF = self._adaptive_QF(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredADE", "description": "Quantum-inspired Adaptive Differential Evolution with Dynamic Quantum Walks for Enhanced Global Search and Local Refinement.", "configspace": "", "generation": 14, "fitness": 0.21219840905469411, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.5851153025139972, 0.6073626310612286, 0.6161580887625644, 0.598849148328507, 0.5841847557688722, 0.6078168192159511, 0.5609023955541018, 0.5805456344361679, 0.628372503786577, 0.3176068387083848, 0.27300381471697344, 0.3203645647419585, 0.3107845798566681, 0.2853833101000347, 0.3264754152020799, 0.3150393563697389, 0.30916027722118167, 0.31805328946726596, 0.10114556025188681, 0.12879974783130033, 0.1207625555013343, 0.12106746114852263, 0.12374889651506926, 0.1394993763248229, 0.13023781507269072, 0.10881005689920475, 0.1264837338862579, 0.10606007358153713, 0.12576097732574687, 0.10849549050941332, 0.10820596380906555, 0.10981601293991827, 0.10256564640736743, 0.10970717444331035, 0.10032923655817938, 0.12132435209577197, 0.8870996911411266, 0.8156216945936798, 0.8012139147578724, 0.787144569830298, 0.8252373490168702, 0.8315912416485645, 0.8689223748387014, 0.7882371019426923, 0.7778452190480605, 0.22167192513430978, 0.20478540908883858, 0.21565207778184337, 0.22613465725263127, 0.23407698886215156, 0.24348187252653164, 0.23079401560038837, 0.2428971868023676, 0.22264185714821272, 0.2609137744314969, 0.25212683441587846, 0.24364165227798262, 0.27822688934053663, 0.3080760383845973, 0.2685113484233278, 0.36595601355942786, 0.2733253624754848, 0.3293419269675967, 0.12680848122194444, 0.12447023722896411, 0.12634634258822042, 0.12711877605857058, 0.15893850020264966, 0.13533108396118698, 0.12030297537131462, 0.14967238306019803, 0.13592695379908615, 0.13078731512703257, 0.13256053346429852, 0.13175909752164117, 0.15924542921376228, 0.12236733103475783, 0.13198187686575824, 0.12547994767975046, 0.15638091483986427, 0.12557684872591812, 0.018749666849356084, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014510931852951381, 9.999999999998899e-05, 9.999999999998899e-05, 0.11377079592767803, 0.11074803047595883, 0.09399774177037745, 0.08256104663331443, 0.1198921571353585, 0.10052031551607565, 0.12076100745046803, 0.10873719925754688, 0.10240948268273808, 9.999999999998899e-05, 9.999999999998899e-05, 0.010424174063322966, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08889659635342317, 0.0764530066284107, 0.08560644705553389, 0.07153758355699225, 0.08802022185276615, 0.08956901745061752, 0.08010699396553245, 0.08776043335504002, 0.09259553320924352, 0.4055194833085306, 0.42350183869224634, 0.427478516162209, 0.42751743211008486, 0.4201168743245114, 0.42740110020567124, 0.4218161515584308, 0.40079636747331515, 0.43373692170804257, 0.09447073015144325, 0.09169577845576204, 0.0933344521067474, 0.10594386260890154, 0.09242809427271714, 0.07812323870000559, 0.08626350079887257, 0.08987609758524995, 0.07808731783189338, 0.12461564924182111, 0.1320217074917508, 0.12179375526203984, 0.12336053069280117, 0.1444293687421696, 0.11962129081515138, 0.1411556635122675, 0.11553385262405846, 0.14323753273534423, 0.2765927419323563, 0.2807892337170719, 0.29169266720754017, 0.27803951500881874, 0.2671613684549119, 0.2782620856548389, 0.2875539713238374, 0.28140416149382985, 0.304577191615533, 0.2000980068938244, 0.1881069774165417, 0.17541806951314098, 0.18865149229554556, 0.17013730161169638, 0.17492489066201866, 0.1994294453974681, 0.19825024474754827, 0.21092074893392976, 0.1917471536467077, 0.19813084195305963, 0.18596659227240164, 0.18963372301103132, 0.19809402831716583, 0.1727104487794926, 0.20014330398007052, 0.18228343920099088, 0.1782736323948373, 0.16668590072156564, 0.19246761063247875, 0.17937360013561432, 0.1931880813661746, 0.1791297452049344, 0.1861026803707393, 0.17791378338436403, 0.19366536923674582, 0.19239887182835647, 0.14625203604462023, 0.1743620597751102, 0.18847471931102688, 0.49380551977868536, 0.18500370855476866, 0.18732047014413533, 0.263078122529242, 0.1604825638250157, 0.3169033726409418, 0.19930540067835334, 0.19404546668649514, 0.18096751852371562, 0.15913225606875148, 0.1745531665809622, 0.1769984983226952, 0.22431610617451359, 0.18875718556582366, 0.19172854666522932, 0.16163770319685677, 0.18038633940999738, 0.17771309756557296, 0.16568022376775604, 0.17774486173821424, 0.18876342645005817, 0.18746278659780302, 0.16654177719949692, 0.18122581002258287, 0.08124852089454693, 0.07122180532638489, 0.06735728636662497, 0.07605152742662236, 0.07720918811849209, 0.06535545717854874, 0.07172058770161716, 0.07223449353020206, 0.06266746075049201]}, "mutation_prompt": null}
{"id": "58e9bccd-14e5-452d-bd63-368b3a68ec71", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.2  # Increased probability of enhanced local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.15, self.dim)  # Modified perturbation for enhanced search\n        quantum_gate = np.exp(1j * np.pi * perturbation)  # Simulated quantum gate effect\n        return np.clip(individual + perturbation.real, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredDE", "description": "Quantum-inspired Differential Evolution with Adaptive Quantum Gates and Enhanced Local Search for Robust Global Optimization.", "configspace": "", "generation": 15, "fitness": 0.20344971820561866, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.5320081203393467, 0.5401969799887347, 0.5167514815292826, 0.552917875965784, 0.5404959960819349, 0.5579965315430369, 0.5556845751252535, 0.5377915451125319, 0.563538481354603, 0.20443839227988037, 0.24436021990006285, 0.22741835639796304, 0.24704988645254333, 0.2200955133699941, 0.21602076801260606, 0.22812268092591492, 0.25974081419062267, 0.22250923171205927, 0.10702503961924581, 0.11205717256086467, 0.10142706196943274, 0.09820509337156003, 0.11466111740969243, 0.12979911757252116, 0.1160498155542955, 0.09639997834619751, 0.11685266276973894, 0.08784177370984303, 0.09178545547128392, 0.08635771925051616, 0.0949939027114649, 0.08962269259080369, 0.08668970340153193, 0.09443892647403662, 0.08908510101178713, 0.0930816469233916, 0.7204820605746585, 0.7550363202772225, 0.7951751087041504, 0.7557877220811445, 0.8936739120767494, 0.8240575227039548, 0.7766807100914797, 0.7676129375626605, 0.6844610498254605, 0.23888523753509383, 0.1960894123271557, 0.2176845116933439, 0.20923267640981025, 0.21817682061814558, 0.2183170376109973, 0.21903692840800015, 0.17928130419175414, 0.21112691686070262, 0.2647025317173327, 0.2861404446440179, 0.2800661916629459, 0.2852730023073269, 0.27717517034343, 0.2956228667493016, 0.35137630087633565, 0.2609719925380424, 0.2509827427721645, 0.13946520694460285, 0.1404635244321264, 0.130523239606971, 0.11624939106101961, 0.13320827485943032, 0.12578976847180456, 0.13190858669646155, 0.13608066884938674, 0.12168264435902398, 0.1021811069914973, 0.1408372836111781, 0.1342089589026194, 0.14262169884885556, 0.13932945136113106, 0.1253245159108588, 0.13489828082884325, 0.13102960042681533, 0.145038653417493, 0.0011227013096724026, 0.023862234738287746, 0.01447726102126412, 0.008827036872769534, 9.999999999998899e-05, 0.014080093877471889, 0.00030514967397321513, 0.02629897627401856, 9.999999999998899e-05, 0.12831801251149932, 0.17010395450659455, 0.10555837645382093, 0.14989346936798664, 0.10656434499278933, 0.10439105491870504, 0.09603978976260819, 0.14694411246915384, 0.15943156936837732, 0.005629435984714326, 9.999999999998899e-05, 9.999999999998899e-05, 0.00208081561026352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014487726438217052, 0.07792336131228461, 0.08255377889152948, 0.07445009342531972, 0.1027079417354918, 0.09594316584941698, 0.10336148726632544, 0.09893427043868852, 0.08308258234289845, 0.08948893337098418, 0.38921273179125304, 0.3898324894895474, 0.4034443077670856, 0.3807649264845513, 0.40240168004874644, 0.37730447360283226, 0.397363522311892, 0.40255264678305025, 0.3946033102808887, 0.07461664856074313, 0.08614239778971367, 0.08668726386168457, 0.0965832523714697, 0.07711623336744144, 0.08625915791803018, 0.08966721970070068, 0.0859079363664711, 0.09067828418871615, 0.11559891068401451, 0.13777747667224516, 0.14656120651262883, 0.16587825543354806, 0.13719451176428576, 0.11545078808489073, 0.12180764353729501, 0.15240016874224094, 0.13041528380529366, 0.2581153843345497, 0.2631893217850939, 0.2545988896678032, 0.256494967440306, 0.2617748783030356, 0.2571241111687881, 0.2670844784029395, 0.2820675247141673, 0.2739974509570515, 0.1886967872732005, 0.2052157049818819, 0.18945005012805993, 0.18154716970341, 0.2050710347275434, 0.1976732557290547, 0.19243639301862991, 0.20230760899874656, 0.2078000659082555, 0.17839976517785194, 0.17732705164905727, 0.18561932639187473, 0.17129335888546515, 0.19087162353113185, 0.18638663171444403, 0.19035783635971204, 0.21747760865125687, 0.17730712533018833, 0.17673416740691028, 0.1776248444524876, 0.17654698632011934, 0.1825459108892893, 0.1748985240893941, 0.1784876137156154, 0.1800064587523288, 0.1781365461694261, 0.17295911755008697, 0.15722279305526188, 0.17620702013939338, 0.16146437163058203, 0.4808775193160759, 0.33094115473013175, 0.2737865919519068, 0.2572365179849976, 0.2588343131820091, 0.17064908158664915, 0.1611720644823994, 0.18217207018142967, 0.20967307052229656, 0.1888696781068746, 0.15255474913224665, 0.15839826513269128, 0.23093417642899883, 0.29055833768852357, 0.1928934166932218, 0.18313421787421869, 0.16675767183214596, 0.1774289264297193, 0.18864360293572335, 0.1734346711101421, 0.18051156673579316, 0.16452050675885743, 0.1869763942914071, 0.18087615147230685, 0.08343510555350508, 0.07993897092933289, 0.07405936569378535, 0.08035879847335692, 0.07139055414936701, 0.07172341445556252, 0.08865849910664925, 0.0794298600188591, 0.07678675909163135]}, "mutation_prompt": null}
{"id": "2460d7eb-c87e-4b75-9745-84b63fe5a999", "solution": "import numpy as np\n\nclass SelfAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim  # Slightly larger initial population\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.local_search_prob = 0.2  # Increased probability for local search\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR_F(self, generation_count):\n        self.CR = 0.9 - 0.5 * np.sin(np.pi * generation_count / (self.budget / self.pop_size_initial))\n        self.F = 0.5 + 0.5 * np.cos(np.pi * generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(6, self.pop_size_initial * factor))  # Ensure minimum size of 6\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)  # Reduced perturbation for focused search\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self._adaptive_CR_F(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "SelfAdaptiveMemeticDE", "description": "Self-Adaptive Memetic Differential Evolution with Dynamic Population and Enhanced Local Search for Efficient Exploration and Exploitation.", "configspace": "", "generation": 16, "fitness": 0.1645857724960909, "feedback": "The algorithm SelfAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.39570691822406545, 0.40235446241524786, 0.4108976153440721, 0.43638163617453274, 0.42989319002213755, 0.41987963297837283, 0.43680507410983005, 0.40851111526709183, 0.39305685475999985, 0.15952317866819665, 0.13872559422429054, 0.14686503356741398, 0.15081808810399377, 0.151947688254069, 0.12565031755800626, 0.13726697670892185, 0.16897405452001624, 0.155760621066087, 0.10026405994824039, 0.10195491829833991, 0.09575484735586126, 0.10676464957088172, 0.10964915538106379, 0.09725037660630309, 0.10748018802029224, 0.10131635902029668, 0.08773885656365565, 0.10273343504580645, 0.07918013660671863, 0.08487698322284232, 0.08633129311410048, 0.08253296851280922, 0.09709859694860357, 0.08238145953792031, 0.0785467275467101, 0.08134173944659673, 0.8394149653171397, 0.863828191539876, 0.9223609338148634, 0.8806170559477009, 0.8935891316955117, 0.971403209968908, 0.8706108873743182, 0.9400168453821326, 0.8998319277742842, 0.13713331248925698, 0.13368881196522675, 0.11597241235399236, 0.1377110071065929, 0.11667391586300868, 0.15946601768716318, 0.13719996154740022, 0.1422785463150873, 0.13355695490043584, 0.18927427446749034, 0.16720693598276826, 0.15721993400226109, 0.17413037010549415, 0.17959929719206758, 0.18060830591392296, 0.19150886679917944, 0.19247725162832352, 0.15991118427881224, 0.10083243082267712, 0.069192063540358, 0.05786189099953265, 0.08088768174239325, 0.06132548655763581, 0.056203069124176164, 0.07480365739746975, 0.06666403454115644, 0.07413157044419372, 0.05689052082386792, 0.08564096258737719, 0.040109637990304536, 0.08846512905431592, 0.08267370333581481, 0.06985503028993423, 0.07687844058561699, 0.049858727226965716, 0.06676296291920902, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02018148832662825, 0.039703943542242826, 0.017783067510931838, 0.020105650696897848, 0.023237313222268297, 0.015402424479356025, 0.04665952212043889, 0.08561684532983638, 0.025581810719214948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018687861046182697, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04411895132068788, 0.033591411711410335, 0.025117833215893337, 0.0443496338537559, 0.03892070037839934, 0.04740803583532982, 0.03266669199549288, 0.0370444909157126, 0.036135235511199015, 0.3086077966587686, 0.33105923530153236, 0.30107698919758996, 0.32052475422939153, 0.33761582231505294, 0.3174303274966219, 0.3185480318851579, 0.3120721436099164, 0.3159667394331105, 0.06730977631958268, 0.07869312273351403, 0.0722832148996102, 0.07542588251203108, 0.06309247202914559, 0.0644239228004404, 0.06870653535217874, 0.060887453668099445, 0.06422974201121556, 0.13830825857372986, 0.1279463801100359, 0.13198179477138672, 0.13833795114718395, 0.1328687886363008, 0.13942707287817335, 0.13010345635278087, 0.14451224628046422, 0.1267820491014814, 0.19319113734646187, 0.20695069544215972, 0.20342701386994044, 0.17663849663338316, 0.19130459318122972, 0.19633181895969243, 0.2100472716882874, 0.23978113701562564, 0.2195934788685162, 0.12661993872713118, 0.1367574478299226, 0.13518634755368752, 0.12971795202119973, 0.12300494098867043, 0.12488498075031707, 0.15067449069108263, 0.1455731558668344, 0.14006034593331018, 0.1531223113416592, 0.14351331268966439, 0.1767556349371463, 0.1667967097093186, 0.15269053340283623, 0.16027688322211942, 0.1980821929796872, 0.19242591417060428, 0.17373100700381128, 0.17281603929887568, 0.16622195203120937, 0.17338659754184826, 0.17062631451175403, 0.17469097902049957, 0.15548012935109767, 0.1650413647558393, 0.17051612212532108, 0.17210956393276244, 0.14823466129084195, 0.1523516568228802, 0.1762553102813632, 0.13781228774917686, 0.15249602800637552, 0.13834978277815502, 0.139955924109057, 0.20664352920706064, 0.13921397946451997, 0.1403448738147417, 0.17692631598931507, 0.15727928153828563, 0.12767800405003416, 0.12509723126518524, 0.15326000158883657, 0.2911693451306403, 0.23177654694889893, 0.2541565596989074, 0.18465072928067705, 0.18401530773781982, 0.19299008584653266, 0.17479232621557073, 0.18975885102881107, 0.18151902022834243, 0.16777210529285458, 0.17430406932384845, 0.1793408503581404, 0.06208092177849589, 0.06232143517110511, 0.061595848336573944, 0.06090891178466151, 0.0615656199144623, 0.06604285998209436, 0.05435929439543674, 0.05556947101591991, 0.07595091713209401]}, "mutation_prompt": null}
{"id": "a05d0694-03ad-4c51-bf82-80bdc9b5df15", "solution": "import numpy as np\n\nclass StochasticAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim  # Adjusted population size for quicker convergence\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly reduced differential weight for stability\n        self.CR = 0.85  # Adjusted crossover rate for balance\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.25  # Increased probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # More aggressive size reduction\n        self.pop_size = int(max(5, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.15, self.dim)  # Fine-tuned perturbation strength\n        if np.random.rand() < 0.5:  # Hybrid local search with random exploration\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "StochasticAdaptiveMemeticDE", "description": "Stochastic Adaptive Memetic Differential Evolution with Dynamic Scaling and Hybrid Local Search for Enhanced Convergence.", "configspace": "", "generation": 17, "fitness": 0.22409044740306935, "feedback": "The algorithm StochasticAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.6054669987162135, 0.6316128282176399, 0.6226493244858629, 0.6118173351890512, 0.629539234271473, 0.6400734347755048, 0.640555075246431, 0.5914405052483978, 0.6076720591682636, 0.2855108971763223, 0.3012787911119782, 0.32286138118080887, 0.3088493149873267, 0.3298218147715045, 0.31605421403920886, 0.33340951623669124, 0.3420912598265219, 0.3116887964310784, 0.10187631480691328, 0.10871575048314697, 0.11474237303699741, 0.10527834328782115, 0.10659249722362307, 0.11937843756736743, 0.11959064239951334, 0.11021397085242368, 0.10814337239677985, 0.09576751472952616, 0.09987924983694008, 0.10527089518775634, 0.1133589329233653, 0.09986423205464745, 0.10089093289890005, 0.093705911853736, 0.096076339356298, 0.10532412784987133, 0.8281082171136016, 0.8207760745882299, 0.8480036831587388, 0.7234220110870775, 0.8217922640133877, 0.7887983243173564, 0.7792886893787776, 0.8504780545446546, 0.7925386890693606, 0.2589107853412884, 0.23746673836397147, 0.22472347306756568, 0.2308009086836772, 0.21134417448964526, 0.24040861393791446, 0.26500058503060964, 0.256778441472862, 0.2476400194354389, 0.2517918555308458, 0.28616990159584743, 0.30709105839088013, 0.32476308554403455, 0.3879292376639558, 0.27041591309239543, 0.2772857161656068, 0.3980245961626021, 0.2580310945479035, 0.15280581150401218, 0.13031931722271128, 0.14311946548052945, 0.1336276371581182, 0.13825064846626078, 0.1260004778681756, 0.15433034968738268, 0.133640054903577, 0.1579145331505244, 0.1394989719605395, 0.13590371114553168, 0.13733930339570322, 0.13138269031010297, 0.13865226224073068, 0.141048638515337, 0.13514385390569528, 0.11627052418411554, 0.1346800798055694, 0.018593854193177828, 0.05076536838661727, 0.012872917232179537, 0.003752166500541887, 0.017450531383921386, 0.008270434854705688, 0.013304734511392802, 0.008344756850548363, 0.011371450322365306, 0.12467511016030441, 0.16320556139074216, 0.13559560105340385, 0.1466898329527827, 0.12268098541386696, 0.10981389488308446, 0.13263931750074465, 0.14249262724837153, 0.14295152659487853, 9.999999999998899e-05, 0.0006615943723256024, 9.999999999998899e-05, 9.999999999998899e-05, 0.000672204516885877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0059385330507507605, 0.10774473892711245, 0.1153959993391267, 0.10992084748453201, 0.11946450835766231, 0.10063063133735217, 0.11291814956990742, 0.0920999831074576, 0.11441116499675519, 0.09528052080277771, 0.41826901366281366, 0.44899572958057077, 0.44925189423157286, 0.4508906063265662, 0.44420577464263966, 0.4445522315943162, 0.42167456188429464, 0.4325796902526112, 0.4655428431956591, 0.09748613090512914, 0.07699292358266885, 0.08609296615964379, 0.09532843813625091, 0.08746543127314599, 0.0763310410697331, 0.11939947479504232, 0.0852634086295686, 0.09572851696718554, 0.12156202703369212, 0.1282098439502779, 0.1300935061147962, 0.12249348822539285, 0.12058558955469267, 0.14900619178914243, 0.12120270914849984, 0.15131547982500437, 0.1475309417328612, 0.2769141848447353, 0.2973956825716926, 0.2942840902941841, 0.3001381136025013, 0.27713509826044724, 0.2627663291260155, 0.2719060585288371, 0.3037542607911021, 0.278628940595094, 0.17363003123818488, 0.24578470663225738, 0.22483701120608535, 0.19652747304809604, 0.1991378205072606, 0.20463875168132306, 0.22281450043273332, 0.21047034413685306, 0.20285752633172793, 0.18792945481555823, 0.19306224492305757, 0.1933217678262712, 0.1811020266664113, 0.17461592725759167, 0.1842422932873845, 0.1938359476488134, 0.16534088877775466, 0.18738274812872024, 0.19556244157664382, 0.19266739316802706, 0.20297799541405093, 0.18542901968527625, 0.2378252776581321, 0.18446869971032454, 0.18346204223161533, 0.17944848198526964, 0.19947660446265747, 0.4662055562909936, 0.2738732910057291, 0.2415834206674825, 0.4943522334082783, 0.4356750968049047, 0.21463600288632823, 0.2929305202891517, 0.21116777058912994, 0.2250859775713533, 0.17521664854965946, 0.20835970098890255, 0.15986831694043635, 0.17853302816128047, 0.19459499977610217, 0.347347005047384, 0.19508708904284844, 0.3698068274292413, 0.20126355320126, 0.18983391669155258, 0.18813273602276925, 0.16949796667586803, 0.19370313171000075, 0.1865882243751117, 0.17713713375219964, 0.16847812986071042, 0.17087902377706576, 0.19942333882831642, 0.07017945431273998, 0.072241264547096, 0.0702297784229513, 0.06872237914026014, 0.07644234917322645, 0.07856759994873519, 0.08783951673542068, 0.07113697324865498, 0.07911134605834014]}, "mutation_prompt": null}
{"id": "7667d8e9-29bf-4c2f-b2bf-6786637eb1aa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.15  # Increased probability of applying local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor))\n\n    def _local_search(self, individual):\n        perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for enhanced exploration\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Dynamic Scaling and Improved Local Search for Better Exploration-Exploitation Balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.6522974809068652, 0.6150518504472182, 0.654597523762015, 0.6477022678831728, 0.6446786745641158, 0.6615750621980537, 0.6498277506760797, 0.6387629723905695, 0.6322112758873191, 0.39359392739387256, 0.33629235415470726, 0.3040791024298909, 0.3643966052850476, 0.3846700153653786, 0.38190638784897124, 0.3695312094158356, 0.3647197049887011, 0.3965070012734613, 0.11104039577302227, 0.11542534178637454, 0.11340859554419913, 0.13911416116339348, 0.13692645298485495, 0.11657868471393917, 0.105961552758564, 0.1029691855814896, 0.1128973765566581, 0.11132366612789701, 0.09121033920491883, 0.10859832997040975, 0.1053771312615358, 0.10684591856490644, 0.10209320641116959, 0.11359655800549628, 0.0964902161642005, 0.11577874875257421, 0.7484610098945417, 0.8069586501221491, 0.7354952465428839, 0.7164991001481167, 0.80732771215402, 0.7854407722864037, 0.7576871369549351, 0.7647126406132977, 0.7844651430883407, 0.2696649549998248, 0.2485531641811386, 0.26930703797081945, 0.2325933667947655, 0.27380016382466055, 0.27444629841271184, 0.2522685015917764, 0.19390308530541223, 0.2600630304025654, 0.315035371293665, 0.6191755993645811, 0.5842317470896572, 0.505363947279927, 0.3113253919536989, 0.5268262210232766, 0.46516337930171936, 0.4867154626025961, 0.29731606278923295, 0.17260309805276242, 0.128207966897249, 0.1521930014761097, 0.1465331571166747, 0.12905785078379872, 0.1540763168005127, 0.15151480809760032, 0.1412755557772032, 0.14668184255619077, 0.139793812317899, 0.14076865618845602, 0.1274110482863211, 0.1270816597815143, 0.15338334668827247, 0.14450417510204971, 0.15437402909268916, 0.13915978062410395, 0.12808197622782302, 0.03602123304940574, 0.04482742492713898, 0.01457491954670731, 0.0716059766064594, 0.07703090013450697, 0.0366258523517321, 0.04705092165404856, 0.04778203518454738, 0.05082611766949796, 0.2281995156620401, 0.10666127893000776, 0.1547366378937589, 0.1584651633933024, 0.18258822316789103, 0.16333902333370842, 0.21620305807154205, 0.198786201758005, 0.18600314018541952, 9.999999999998899e-05, 0.017588974004673408, 0.007121175630522836, 9.999999999998899e-05, 0.0023093398352180827, 0.025572465301456626, 9.999999999998899e-05, 0.007569788055168281, 0.0002108575369728083, 0.11111640121051736, 0.10074322157486748, 0.12261203829853862, 0.10861464098893137, 0.13932593707601626, 0.14088951888402135, 0.12835511600933402, 0.13582803882000483, 0.10452920591584114, 0.4428603833316511, 0.48293225254576355, 0.4427902348588668, 0.4314275539943203, 0.4511834507650371, 0.4231203027279479, 0.4658965175954135, 0.46151496240236933, 0.4348078160939105, 0.08269668628515825, 0.08823246483392866, 0.08291124974176256, 0.0865309792051463, 0.08756096679837899, 0.09514685288139046, 0.09560464795532642, 0.08427751400972261, 0.08707662914887371, 0.12818362173409859, 0.15440577334706618, 0.1686664765353294, 0.12448660159790037, 0.1573541570119441, 0.14791856235217038, 0.14070905340945938, 0.12068124246188472, 0.13399038295747978, 0.3053408532027212, 0.2981710627344766, 0.3023181865381651, 0.30118891595539277, 0.28209596793653935, 0.31399866426196055, 0.30798062483391875, 0.3273947769220724, 0.30447779358438, 0.21234704680604455, 0.23097681129068037, 0.23061430792273152, 0.21231484515088273, 0.1990348844544454, 0.2191331960272277, 0.22710661657530096, 0.24267262775903453, 0.220669563681549, 0.18268394748344896, 0.17992738493648341, 0.1791626924653088, 0.19277612617721973, 0.20255411106575927, 0.18423109409115446, 0.1962823949244633, 0.19281896576575186, 0.19082530512163143, 0.19397041200611442, 0.19323339906337955, 0.19019695041804685, 0.20143234135922972, 0.17941250561778777, 0.19473414652988763, 0.20125417123351208, 0.2272470804465001, 0.18338290423972003, 0.442547816206196, 0.1792736377716455, 0.3626624710035127, 0.6526710822354513, 0.547233477923952, 0.6368773929819354, 0.16845284576164832, 0.20680524392934163, 0.23480604310200304, 0.40783439217592754, 0.20058718443988277, 0.2958276977073996, 0.21331132650300466, 0.24714165547105327, 0.1824903471828183, 0.14652115989639714, 0.4368133633091804, 0.38545623230713577, 0.17972217599440243, 0.1718315157575706, 0.17691204266345562, 0.17310735693954393, 0.1912901308545394, 0.1734396654949233, 0.20643448448772728, 0.1963764629441972, 0.17681012488300274, 0.06981497856533336, 0.08883876493722787, 0.07786546382024839, 0.08208327453078801, 0.07235366851398872, 0.07323385848848285, 0.07285231216629584, 0.08763101636765513, 0.07324167220410926]}, "mutation_prompt": null}
{"id": "e95cea6c-d773-4205-acc3-440ba34fa9a9", "solution": "import numpy as np\n\nclass QuantumInspiredMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.15\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.65 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.35 + 0.55 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor * 0.9))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredMemeticDE", "description": "Quantum-Inspired Adaptive Memetic Differential Evolution with Enhanced Quantum Perturbation for Improved Exploration.", "configspace": "", "generation": 19, "fitness": 0.2446298861970119, "feedback": "The algorithm QuantumInspiredMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "a242895c-cc82-407d-94d0-69beb9b6c10b", "metadata": {"aucs": [0.6779782701614743, 0.6764735373027575, 0.6907554666646079, 0.7033852129683947, 0.6682054474586079, 0.6645725288638493, 0.699143332438573, 0.6788266524006346, 0.6596731965035543, 0.4335197693578635, 0.44537494213172635, 0.42781627464416594, 0.4366006517757802, 0.4479752560673119, 0.40417917544898874, 0.415073246960981, 0.43022456715236024, 0.4427882679501337, 0.18431198759903378, 0.18063579509297156, 0.14708163209452818, 0.18333012891180656, 0.236556079850616, 0.1256830190686551, 0.19651027592394898, 0.17758018924592556, 0.1750053696583671, 0.09874935744016511, 0.1827305028847418, 0.1236543969560493, 0.11306672161028708, 0.11711012892095896, 0.12353528767197008, 0.10965906823757554, 0.11351206737808883, 0.10426569761419247, 0.8171031011553805, 0.793346852689016, 0.7660838709449977, 0.9003503815617637, 0.7582580696586483, 0.8184136946622069, 0.8620614246551067, 0.8710601140401513, 0.7839263428348113, 0.2516570401016718, 0.261502591362915, 0.30092296969035326, 0.28788707927380564, 0.26625509624747257, 0.3033631834233743, 0.2751671971264239, 0.23404765001280103, 0.29314386164045536, 0.29131258221539436, 0.5519296337974737, 0.2859975472568409, 0.5033723720401937, 0.5063456966013993, 0.42615742898803854, 0.21764731968860374, 0.5857660679235077, 0.31385031234439986, 0.10766247787530758, 0.16872478818669734, 0.14311095920623707, 0.14438516895494125, 0.12223397130475844, 0.1384103264553056, 0.15195068516298904, 0.14929594382605704, 0.14926036673153797, 0.14775677766595796, 0.14857316130514808, 0.12958279182003407, 0.11629859253980979, 0.13380810871094817, 0.1248959633756247, 0.15251517553786254, 0.173700108450914, 0.14416129576584158, 0.012205392641334023, 0.008035545289125534, 0.00564766828480856, 0.00028444977165476004, 0.008111704271925424, 0.001987799588067718, 0.005892519780357763, 0.021134249137650163, 0.04993974310837235, 0.1052368340200528, 0.12287659658099126, 0.10145026428968229, 0.12950848675967663, 0.07073521364114255, 0.07845737585968471, 0.16351098165568767, 0.12442259149230217, 0.1438644687811491, 9.999999999998899e-05, 0.00014891896443802732, 0.006670249561989139, 9.999999999998899e-05, 0.002526832294041159, 9.999999999998899e-05, 0.009947747780994387, 0.00012529030978369882, 9.999999999998899e-05, 0.12230595527575294, 0.12540292179273116, 0.10379408620936759, 0.10907940836715702, 0.1330796083547955, 0.12392251557026335, 0.10498168488157755, 0.11150104684069229, 0.09692495795950273, 0.43467436692065275, 0.4955920942764067, 0.4493670904226629, 0.42797661958335464, 0.4539257776642833, 0.4573906761222367, 0.4460890174182619, 0.43537507418893406, 0.4716551466100447, 0.11752117062653922, 0.08458339696680672, 0.09119611509726111, 0.10346754410756931, 0.09802038909286181, 0.09917658545616814, 0.08015357680617685, 0.08478809775396057, 0.08897294198513539, 0.11887394789106331, 0.14809000455040333, 0.14476287292325374, 0.14327573824173923, 0.12915176423314556, 0.13847382669305353, 0.13550825567838276, 0.14508634604092108, 0.14066083650369, 0.2824195295214311, 0.27110967276440434, 0.28887655252946, 0.3005295884778896, 0.2983339716094865, 0.2842503709175407, 0.3277400547808452, 0.30194178479275213, 0.3183256658433544, 0.1883479695782605, 0.2152014101156412, 0.22479098847998324, 0.21617005536413403, 0.20288434627047403, 0.1898774179287358, 0.19860268747497023, 0.23967591098175878, 0.20546355545417438, 0.20243290334441522, 0.1656685194790436, 0.20285790925952818, 0.1879883360623914, 0.20204444661290877, 0.1957302499592365, 0.2005925357528232, 0.19985261922849262, 0.1952535858572889, 0.21237051658650075, 0.1867871645983542, 0.17967087031150908, 0.1834705778008392, 0.20696464139235315, 0.19606335678666942, 0.22389416372986326, 0.18360892020348307, 0.21030994022588634, 0.19888804973364926, 0.49265717232847706, 0.1666783637755831, 0.6180234588220535, 0.3289500341502152, 0.41221733734267796, 0.2739380984762467, 0.1449024701077649, 0.5394778843977535, 0.31884578643316086, 0.20479042208035747, 0.20269216869926843, 0.20120558704332647, 0.1545891075484347, 0.1845111780225298, 0.16856204265656127, 0.3203821712685644, 0.3702075109237799, 0.1858792528972113, 0.18108832707284872, 0.17875020944890008, 0.1916267786712309, 0.183907562812465, 0.1689895021792196, 0.18531728861444863, 0.17155758858494086, 0.17893909474737102, 0.08194322711188429, 0.0736497548019257, 0.08200084391843143, 0.07533698858378235, 0.07712903303846741, 0.08363201127654829, 0.06983702982878914, 0.06992395079018698, 0.07220331009208258]}, "mutation_prompt": null}
{"id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.2\n        self.global_perturbation_prob = 0.1\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor * 0.8))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "Quantum-Inspired Coevolutionary Memetic Differential Evolution with Adaptively Blended Quantum Perturbation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 20, "fitness": 0.2549674015744619, "feedback": "The algorithm QuantumInspiredCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "e95cea6c-d773-4205-acc3-440ba34fa9a9", "metadata": {"aucs": [0.7094393508854364, 0.7042553524832175, 0.7239544145230532, 0.714062787076261, 0.6828893884304326, 0.7155973908517592, 0.6856853297261708, 0.6992893028524776, 0.6851785545926402, 0.4523988767482179, 0.44762845902506465, 0.4416992723683615, 0.4368734340990248, 0.1767160618446949, 0.4908808174235101, 0.45185174953441465, 0.49478757987189426, 0.47794267836748416, 0.23379505994560978, 0.24312943461878256, 0.1348577005524627, 0.17518384828833022, 0.1295789464082756, 0.17955564235452626, 0.2055046407661535, 0.23312496443208996, 0.22992385212434008, 0.1822317240026594, 0.1175154744448722, 0.11548093549754379, 0.12140002505656211, 0.10095195262898338, 0.20068513421246736, 0.11755066212577403, 0.1225751176340587, 0.11065650230410051, 0.9058309512586868, 0.8207974578789422, 0.8419623759603192, 0.9093540870590817, 0.8381325358649818, 0.8372429179640062, 0.8239104044060741, 0.813422400149917, 0.8577105754618212, 0.3127675924393033, 0.30027411443986096, 0.23522534039354615, 0.3297070147730585, 0.3149562069602698, 0.20192332819434156, 0.2999439381207101, 0.19147025157204445, 0.2704472011636594, 0.6713900319952303, 0.5658156989066185, 0.18417209263299328, 0.32479246052286936, 0.5051799394675347, 0.6210386737391074, 0.4419592398765355, 0.22268015703752342, 0.3000439798818918, 0.16125879083891415, 0.16104442250780904, 0.17162036663063063, 0.12485475993661022, 0.13594704366185328, 0.12569995206621298, 0.16631199076329617, 0.14747796282614323, 0.18969245152332592, 0.15712769450046782, 0.14279707820104925, 0.1609021462199537, 0.15572927503402556, 0.1584025777802166, 0.15501785524475364, 0.1758831116430507, 0.1792769238974683, 0.17406316932754584, 0.08100909981525162, 0.10195714739862449, 0.05032886813170245, 9.999999999998899e-05, 0.033057490861402083, 0.01947577249858934, 0.0065373678457711915, 0.059954698847528576, 0.055830284638841876, 0.14809946093512594, 0.1877592568285178, 0.14933802374748917, 0.07981431977446718, 0.10024250621627939, 0.1496497708899981, 0.20870965311260292, 0.18323497062750793, 0.12654440672526712, 0.015245732463074146, 0.00010652755259943358, 9.999999999998899e-05, 0.05368534673515846, 9.999999999998899e-05, 0.019574516493775285, 9.999999999998899e-05, 9.999999999998899e-05, 0.018983007166635035, 0.12695883915863582, 0.10909894835970335, 0.14792662982026772, 0.1354137475837861, 0.1324192497437474, 0.10293730952508173, 0.1178456524131467, 0.09562359531403597, 0.12934917655573008, 0.4350891305418746, 0.44903436409878605, 0.471988768249614, 0.4921053554485838, 0.4560938056141083, 0.4812423768254124, 0.4822310517756556, 0.4631359103979106, 0.47549081348948896, 0.11118246295155965, 0.10267306000840404, 0.09932581027877274, 0.10540872366970855, 0.08973154428312535, 0.09509712896534661, 0.07937756300913279, 0.09054992323969946, 0.09802117027941437, 0.1562583202272082, 0.11744520725205143, 0.13699751409804706, 0.12423587939221903, 0.14488027891102995, 0.23941501324349634, 0.1608014172919251, 0.14998203241055996, 0.11971121139891583, 0.23625291745521326, 0.32807093699782797, 0.3092406091317177, 0.30902459446297237, 0.3039146111503701, 0.31018985133838584, 0.32717421700830496, 0.3181147421167674, 0.3047090908451906, 0.19300373960552764, 0.21879891475946056, 0.23349412869845776, 0.24935357495431532, 0.22924534495646132, 0.2489874441655332, 0.2247981674055083, 0.23148293645137197, 0.2317697189521678, 0.2004396252082813, 0.19144530128662995, 0.19010817474581587, 0.2113381195940478, 0.19672859692416678, 0.1810694887256451, 0.19474198276802868, 0.17399621068949223, 0.19228371245783293, 0.18864710493834913, 0.20987385486965038, 0.19712872543965076, 0.1864857185326989, 0.1925571892349187, 0.2102964381531609, 0.23921868068247587, 0.20336421645666403, 0.21465018550683912, 0.15112581855350404, 0.3603121470335827, 0.15400973662303818, 0.6744319584846639, 0.21403799851783478, 0.7317066552008367, 0.1801230864457286, 0.1689832492515756, 0.6560847553428644, 0.22420892123519887, 0.2075455347809393, 0.19935221676842096, 0.184718957309279, 0.1888768385692301, 0.16521007668507137, 0.19880766082361234, 0.20494750839924158, 0.2006508860642613, 0.16921562070531038, 0.19665956075592705, 0.18234478758172834, 0.1864713305049801, 0.18223890100395068, 0.19289638586376923, 0.17730557968054128, 0.1669459463975017, 0.18784401329264, 0.08123471785452496, 0.08114175019062442, 0.06819981788832141, 0.08153146451152848, 0.07156405156803847, 0.06719511928296762, 0.07222740400889838, 0.07795726414824455, 0.07804397812713137]}, "mutation_prompt": null}
{"id": "5ad8cb45-4c73-4ab1-b03c-83a6a6ee492a", "solution": "import numpy as np\n\nclass QuantumInspiredHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.25\n        self.global_perturbation_prob = 0.15\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor * 0.75))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredHybridDE", "description": "Quantum-Inspired Hybrid Differential Evolution with Adaptive Population Strategies and Dynamic Perturbations for Enhanced Search Capability.", "configspace": "", "generation": 21, "fitness": 0.22025422399714797, "feedback": "The algorithm QuantumInspiredHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.617739339970411, 0.6033328049582515, 0.6092824106828345, 0.6223862253443271, 0.5973434800888973, 0.6190705133317878, 0.6345284917619807, 0.6210624161852116, 0.617928694956508, 0.37222417779157935, 0.38054745925686784, 0.32196115681456705, 0.3666445891247049, 0.3409954688813239, 0.3601171522323866, 0.35058616478530924, 0.3719486660154705, 0.3516838376028327, 0.1688325217525335, 0.11224917818510094, 0.18272892065143065, 0.22098187173702522, 0.22093824216507973, 0.1288940911009926, 0.16791836762701318, 0.11475800159692484, 0.21241091334067008, 0.11567027095594618, 0.11391443512182653, 0.11882992724843044, 0.11914315001323617, 0.18419412941291646, 0.11560134735997185, 0.12386318707433508, 0.10271531672642653, 0.10221477251187339, 0.8921605279149348, 0.8324980337030398, 0.910100781380232, 0.8609720448416465, 0.8178961179368971, 0.9436470674764931, 0.8556559590652776, 0.9297627326116147, 0.8263086102905912, 0.24667162765881234, 0.2637823577175955, 0.255916722982919, 0.23515211860926777, 0.24555573727008195, 0.23718807401672515, 0.2442363731660263, 0.2560764169427492, 0.2242951427735801, 0.25646571938942275, 0.19582751914381247, 0.26413025617942354, 0.2980033293609199, 0.25379644199506457, 0.25499615551860466, 0.26700003268304096, 0.3016780273065709, 0.2950547028110019, 0.12726479589428386, 0.12400988195452445, 0.13206082257785545, 0.1282581759171002, 0.1248355228875796, 0.09254890355309275, 0.13644951759556556, 0.13899481766983213, 0.15563694844699527, 0.11739605165386091, 0.1342378086137127, 0.12680085821395437, 0.13476620261283712, 0.11470075637372279, 0.12777821186916694, 0.1235150082140859, 0.1245934890455288, 0.12775622726636515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007411327913401378, 0.09813410915779719, 0.0925563867331255, 0.10609806784927, 0.061677771299267214, 0.021819857229892103, 0.13789434406989642, 0.08522346039317164, 0.1838128556529457, 0.09857166354812996, 0.00030798311847846094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008799248487078914, 0.0032532405096767913, 0.005698304331011261, 0.08690333407338602, 0.10575213556453, 0.07122972509755199, 0.08856145033790941, 0.08646207170208542, 0.09602037597214452, 0.10176193249594712, 0.07046131711447001, 0.09773958991355103, 0.3944849949756859, 0.4114360034397908, 0.41614840162999467, 0.4043140535859645, 0.40128071884869376, 0.4242985870988357, 0.42732193402142626, 0.4133796901629663, 0.39937466768527574, 0.08067881864274318, 0.08385147209303034, 0.07635424632710586, 0.08496700269482971, 0.09798067306615177, 0.08648100714081486, 0.08724818736990747, 0.08841056648272227, 0.09552664240814779, 0.12261086687673306, 0.14204955067790093, 0.15287518436108405, 0.13849760048051363, 0.2177017050421055, 0.142215475969368, 0.13698743684141723, 0.1441518676841157, 0.12368157645956912, 0.26295148800695056, 0.2724219868974975, 0.2643287141043146, 0.2842343109395765, 0.2694070255547021, 0.27579577686643686, 0.2810455032153897, 0.32465447622094257, 0.29163370945619316, 0.19819745534463662, 0.203912831253795, 0.18010211259145048, 0.17706508197938509, 0.18979395087045303, 0.16625462853691875, 0.2082993101916062, 0.20879552092055553, 0.18541815845651233, 0.18911870090986438, 0.17762643868093164, 0.177365123968256, 0.20676866910388747, 0.17648229993068543, 0.17761859615171216, 0.20127946261302854, 0.1868254162076135, 0.1923329749770456, 0.18311286542359217, 0.1929881410854849, 0.17818324402962749, 0.1735579935793543, 0.20054616371528156, 0.17663634267086403, 0.2137755730797395, 0.19448620265484529, 0.19909431702701275, 0.1993231800813383, 0.22470592080718865, 0.15655146320424485, 0.3768498409508503, 0.1575265161231444, 0.5975606951409955, 0.18367742141467824, 0.25229766025622724, 0.18632265053285169, 0.1824255983230778, 0.17558475993676637, 0.18725344362600704, 0.1826170193958505, 0.20333455910970377, 0.16140462296195313, 0.17946035753651213, 0.1938094877592973, 0.20145863623096016, 0.18460349180829205, 0.17618542292382555, 0.16922844801408832, 0.18823120322717746, 0.17885417330834752, 0.17185568131815687, 0.18043448505882576, 0.16924009478218904, 0.19714695575172836, 0.0729123109883063, 0.0687912796418223, 0.07333732249779479, 0.08052210221340883, 0.07051457844575071, 0.06270019522489512, 0.07840360643466515, 0.07298134657796451, 0.08126147445392284]}, "mutation_prompt": null}
{"id": "3d7dbb3b-faff-4d4e-b208-f0cf0914dd15", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.2\n        self.global_perturbation_prob = 0.1\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(4, self.pop_size_initial * factor * 0.8))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "Quantum-Inspired Coevolutionary Memetic Differential Evolution with Adaptively Blended Quantum Perturbation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.7094393508854364, 0.7042553524832175, 0.7239544145230532, 0.714062787076261, 0.6828893884304326, 0.7155973908517592, 0.6856853297261708, 0.6992893028524776, 0.6851785545926402, 0.4523988767482179, 0.44762845902506465, 0.4416992723683615, 0.4368734340990248, 0.1767160618446949, 0.4908808174235101, 0.45185174953441465, 0.49478757987189426, 0.47794267836748416, 0.23379505994560978, 0.24312943461878256, 0.1348577005524627, 0.17518384828833022, 0.1295789464082756, 0.17955564235452626, 0.2055046407661535, 0.23312496443208996, 0.22992385212434008, 0.1822317240026594, 0.1175154744448722, 0.11548093549754379, 0.12140002505656211, 0.10095195262898338, 0.20068513421246736, 0.11755066212577403, 0.1225751176340587, 0.11065650230410051, 0.9058309512586868, 0.8207974578789422, 0.8419623759603192, 0.9093540870590817, 0.8381325358649818, 0.8372429179640062, 0.8239104044060741, 0.813422400149917, 0.8577105754618212, 0.3127675924393033, 0.30027411443986096, 0.23522534039354615, 0.3297070147730585, 0.3149562069602698, 0.20192332819434156, 0.2999439381207101, 0.19147025157204445, 0.2704472011636594, 0.6713900319952303, 0.5658156989066185, 0.18417209263299328, 0.32479246052286936, 0.5051799394675347, 0.6210386737391074, 0.4419592398765355, 0.22268015703752342, 0.3000439798818918, 0.16125879083891415, 0.16104442250780904, 0.17162036663063063, 0.12485475993661022, 0.13594704366185328, 0.12569995206621298, 0.16631199076329617, 0.14747796282614323, 0.18969245152332592, 0.15712769450046782, 0.14279707820104925, 0.1609021462199537, 0.15572927503402556, 0.1584025777802166, 0.15501785524475364, 0.1758831116430507, 0.1792769238974683, 0.17406316932754584, 0.08100909981525162, 0.10195714739862449, 0.05032886813170245, 9.999999999998899e-05, 0.033057490861402083, 0.01947577249858934, 0.0065373678457711915, 0.059954698847528576, 0.055830284638841876, 0.14809946093512594, 0.1877592568285178, 0.14933802374748917, 0.07981431977446718, 0.10024250621627939, 0.1496497708899981, 0.20870965311260292, 0.18323497062750793, 0.12654440672526712, 0.015245732463074146, 0.00010652755259943358, 9.999999999998899e-05, 0.05368534673515846, 9.999999999998899e-05, 0.019574516493775285, 9.999999999998899e-05, 9.999999999998899e-05, 0.018983007166635035, 0.12695883915863582, 0.10909894835970335, 0.14792662982026772, 0.1354137475837861, 0.1324192497437474, 0.10293730952508173, 0.1178456524131467, 0.09562359531403597, 0.12934917655573008, 0.4350891305418746, 0.44903436409878605, 0.471988768249614, 0.4921053554485838, 0.4560938056141083, 0.4812423768254124, 0.4822310517756556, 0.4631359103979106, 0.47549081348948896, 0.11118246295155965, 0.10267306000840404, 0.09932581027877274, 0.10540872366970855, 0.08973154428312535, 0.09509712896534661, 0.07937756300913279, 0.09054992323969946, 0.09802117027941437, 0.1562583202272082, 0.11744520725205143, 0.13699751409804706, 0.12423587939221903, 0.14488027891102995, 0.23941501324349634, 0.1608014172919251, 0.14998203241055996, 0.11971121139891583, 0.23625291745521326, 0.32807093699782797, 0.3092406091317177, 0.30902459446297237, 0.3039146111503701, 0.31018985133838584, 0.32717421700830496, 0.3181147421167674, 0.3047090908451906, 0.19300373960552764, 0.21879891475946056, 0.23349412869845776, 0.24935357495431532, 0.22924534495646132, 0.2489874441655332, 0.2247981674055083, 0.23148293645137197, 0.2317697189521678, 0.2004396252082813, 0.19144530128662995, 0.19010817474581587, 0.2113381195940478, 0.19672859692416678, 0.1810694887256451, 0.19474198276802868, 0.17399621068949223, 0.19228371245783293, 0.18864710493834913, 0.20987385486965038, 0.19712872543965076, 0.1864857185326989, 0.1925571892349187, 0.2102964381531609, 0.23921868068247587, 0.20336421645666403, 0.21465018550683912, 0.15112581855350404, 0.3603121470335827, 0.15400973662303818, 0.6744319584846639, 0.21403799851783478, 0.7317066552008367, 0.1801230864457286, 0.1689832492515756, 0.6560847553428644, 0.22420892123519887, 0.2075455347809393, 0.19935221676842096, 0.184718957309279, 0.1888768385692301, 0.16521007668507137, 0.19880766082361234, 0.20494750839924158, 0.2006508860642613, 0.16921562070531038, 0.19665956075592705, 0.18234478758172834, 0.1864713305049801, 0.18223890100395068, 0.19289638586376923, 0.17730557968054128, 0.1669459463975017, 0.18784401329264, 0.08123471785452496, 0.08114175019062442, 0.06819981788832141, 0.08153146451152848, 0.07156405156803847, 0.06719511928296762, 0.07222740400889838, 0.07795726414824455, 0.07804397812713137]}, "mutation_prompt": null}
{"id": "a56a6037-30d8-4c3b-9a6a-b3d6f969a2c5", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3\n        self.global_perturbation_prob = 0.1\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(6, self.pop_size_initial * factor * 0.7))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.normal(0, 0.05, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim) * 0.1\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Population and Adaptive Strategies for Improved Exploitation and Exploration.", "configspace": "", "generation": 23, "fitness": 0.2279727903968601, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.6927032387611545, 0.6577122421598096, 0.6357058958170354, 0.6459432812079582, 0.6499037088225313, 0.658969082908687, 0.6717198186166776, 0.6448504920324545, 0.6525852434726906, 0.32323965130288423, 0.30773547173178295, 0.3296491816556103, 0.30903124200357945, 0.31025806433171754, 0.3316332845757143, 0.3393053330843966, 0.32285550567890064, 0.33624326725159326, 0.13226055565855277, 0.1715051344491496, 0.12207840776681278, 0.13701203814619423, 0.13339928408567614, 0.1749745291921483, 0.15287995679360178, 0.14975695900510455, 0.15799657742489215, 0.13507994750065844, 0.11489599126791439, 0.11353455250977418, 0.11592940031059129, 0.10655747225782253, 0.15130670226767218, 0.12987573783242656, 0.11264390575098737, 0.12784103897827115, 0.852746620271631, 0.9071005493715538, 0.8758286805730825, 0.8069855071054293, 0.8830568565366386, 0.8787690705795648, 0.8469666139402316, 0.8697797189716082, 0.887537396735257, 0.3108172931694596, 0.2801629108882431, 0.2651789501995433, 0.22740172225189692, 0.20464736733679412, 0.2787598877002293, 0.2670399789723852, 0.2885048684101794, 0.25851950315323613, 0.3198483018984911, 0.27094012847708926, 0.29034098887658133, 0.25626396585659394, 0.2729128445395993, 0.3256413368109101, 0.26287560234445084, 0.42363595063527193, 0.26729482722056164, 0.15262593821102022, 0.15421596060285758, 0.15948780572647592, 0.13824675653183038, 0.14181839517804695, 0.13656136156231846, 0.14792748602600236, 0.1505836687357519, 0.1512540441914476, 0.1448189574366714, 0.12912035335032324, 0.15042504554113056, 0.13975036042439493, 0.13711877202529887, 0.14186693548854457, 0.1573237859737504, 0.12775851501930324, 0.14718205558375008, 0.007450282426764709, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00224205274818412, 9.999999999998899e-05, 9.999999999998899e-05, 0.0716716352238711, 0.09230759190389803, 0.10558932132145893, 0.11379323443932265, 0.08545214661504053, 0.06101345736164754, 0.11726680506639264, 0.09892420157976611, 0.09750761561378807, 0.011660169935924891, 9.999999999998899e-05, 9.999999999998899e-05, 0.011402601257107348, 9.999999999998899e-05, 0.0016077845824876702, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10516677181920553, 0.11301245403365101, 0.09270870328321201, 0.1253134433490133, 0.1235908069956484, 0.13091343779083087, 0.09083050607603127, 0.10667224686182164, 0.09969530645149194, 0.43880575424831625, 0.44483764471571463, 0.43584455414290846, 0.4399827993461809, 0.4343073003247344, 0.4333706294719406, 0.4627939725708414, 0.44163569159298954, 0.4410240953382698, 0.09363877104391849, 0.09236746337600066, 0.08658681543985747, 0.10962505562459623, 0.0768550605932683, 0.09486821941375911, 0.08745876484631321, 0.08836964845223849, 0.10206630106326686, 0.11350997635227433, 0.13706922990866788, 0.1511330535462999, 0.13039953227644563, 0.13259670120378864, 0.12427824136197918, 0.13580245808561997, 0.14070931725376012, 0.13614568305778152, 0.2706044096523792, 0.2881114343715875, 0.29455644478466403, 0.25888779528677186, 0.2933444620925104, 0.292575766833598, 0.2871060957201954, 0.3097927651595124, 0.2896467361318178, 0.1885253535398228, 0.2185005989520632, 0.22025897192877286, 0.18378054327885918, 0.1896162144116481, 0.22461003033636306, 0.23106919075949706, 0.21225266491558148, 0.19486582941623876, 0.17996978318167622, 0.19053505842471619, 0.17864267533090683, 0.20896819267888, 0.20179356364852497, 0.18236304207694698, 0.1847739086184922, 0.2104741129695361, 0.21128947407115173, 0.1884487092998528, 0.20379263507488388, 0.19915507696196866, 0.210773512146042, 0.1818406078314615, 0.18787909781123824, 0.18711868611814153, 0.20891654586333364, 0.1930402825213886, 0.3329398519180239, 0.1773213799420782, 0.18103841574115676, 0.6087089290167724, 0.17018976060174595, 0.18383598467703677, 0.2222491691700501, 0.2532584692074369, 0.23502114252558437, 0.2975268996750253, 0.1986394140571509, 0.28194302139826954, 0.3288736536485757, 0.15774976217740222, 0.19156423043756876, 0.2014304955329842, 0.15100080928856208, 0.20280502491746155, 0.1751654097789579, 0.1714003757641709, 0.18168542045173852, 0.18574258501958973, 0.1727760598463175, 0.174669194346029, 0.194930602263379, 0.16978853537815575, 0.1921075642330018, 0.07323912952988432, 0.07219622555128002, 0.065720576435642, 0.07734617058475701, 0.0755321072708095, 0.06756039669085512, 0.08428118602990908, 0.0734400569497966, 0.08017329502644588]}, "mutation_prompt": null}
{"id": "f1ffc06d-cc88-448c-ae04-f6023ca52052", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim  # Adjusted initial population size for more diverse sampling\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly reduced mutation factor\n        self.CR = 0.85  # Slightly reduced crossover rate for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Increased probability to enhance local searching\n        self.global_perturbation_prob = 0.15  # Increased probability for global exploration\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted to maintain diversity longer\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted for smoother convergence\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor * 0.75))  # Adjusted for more gradual reduction\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.05)  # Reduced perturbation scale\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim) * 0.5  # Half-scale global perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Stochastic Quantum Local Search and Dynamic Population Resizing for Improved Convergence.", "configspace": "", "generation": 24, "fitness": 0.22159897499723005, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.5963170247233415, 0.6293132296989551, 0.629148020212006, 0.6281072736522284, 0.616709280739839, 0.6258369447924802, 0.6225513084018649, 0.6178033011341293, 0.6276800384952229, 0.3217565381620272, 0.31225079301377046, 0.28287140325030347, 0.3544197537640543, 0.35074044044698927, 0.2737886067052414, 0.3478437200447254, 0.34968583530355923, 0.36700783249023883, 0.2322530501951623, 0.12006695925850797, 0.22186778748336133, 0.13451310421003104, 0.25457111527114173, 0.22122874181502095, 0.22662512943958035, 0.23306473108915304, 0.21276045132254207, 0.20052999728818854, 0.19305220261792233, 0.1903279082562067, 0.16030340659271403, 0.105644301440603, 0.1977862561188759, 0.10454020902724626, 0.11028838320584711, 0.11826800420651795, 0.8305472113818794, 0.882522408546761, 0.8264627453732234, 0.8519659302920497, 0.8173467131305815, 0.864724545023331, 0.9495394320007389, 0.8973287588269229, 0.8621021128401379, 0.21970880429958084, 0.2128961961487189, 0.2581444920022926, 0.26012529966095044, 0.2441760429536146, 0.2244724697307432, 0.2250916817138866, 0.21476826290255435, 0.2351626567044337, 0.22677359290302634, 0.22344120397380174, 0.2823412462170285, 0.26198496731216303, 0.30409120158176506, 0.26101795987423904, 0.25460080509600835, 0.2521240030119465, 0.2645756610315759, 0.14601105353336585, 0.13077740979878982, 0.16497015210344057, 0.12879956475014043, 0.13019552968906356, 0.13906754113216102, 0.14527940392339533, 0.1494615066523851, 0.14273520640017445, 0.13130996747377632, 0.11245155124920969, 0.11205242133089233, 0.169064905819173, 0.11463720057130045, 0.13141822855138074, 0.12937160622055766, 0.11726441182038339, 0.14155091936278918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0894061068551728, 0.0921107931203825, 0.06364514713800529, 0.1447378280240188, 0.05260790891028133, 0.09662681657458017, 0.10940498672753107, 0.1112139825108045, 0.07237221508861935, 9.999999999998899e-05, 9.999999999998899e-05, 0.013035716937687347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011838871005798168, 9.999999999998899e-05, 0.09990856754844102, 0.08179688048621647, 0.07690275000668367, 0.10122201223673744, 0.09021091710146012, 0.09919967071584901, 0.09519248218753018, 0.08777838586163544, 0.09531572409586075, 0.41905537415651073, 0.39325115079451056, 0.41052603795196274, 0.4180426344053775, 0.44158845580341544, 0.4212361915921873, 0.411487574992923, 0.43181711689301217, 0.41561774242643545, 0.08367574671388844, 0.0912979123337756, 0.08840506887889876, 0.09035935757003821, 0.09067380099539701, 0.08887186223544341, 0.09186056591284963, 0.08682260101524097, 0.08791042252825787, 0.1478620119430658, 0.12684666662113708, 0.14493769121436073, 0.13172645194311317, 0.15507500020474874, 0.1266645738715777, 0.1368847253413613, 0.12213050836508321, 0.1323155247327923, 0.2688014632787493, 0.2574653757137536, 0.2730449173496722, 0.26224085573807976, 0.27283070722469527, 0.2886880639615803, 0.30107279007422805, 0.30951054142125844, 0.28793557065042974, 0.18553091382425468, 0.1702477255933691, 0.2004204687688963, 0.17298849035814434, 0.19674518234936722, 0.19254359182323433, 0.22252775846952422, 0.20255196301156264, 0.20379482850107855, 0.1919953299131284, 0.19244377833211312, 0.17368906120730976, 0.19171339705576362, 0.18779847792724047, 0.1843898441713594, 0.18381679599599643, 0.17694788672186446, 0.1918985154446161, 0.17937653808991816, 0.1881700552583817, 0.1850615190549354, 0.2950004696233247, 0.18591898316542899, 0.18012306943929557, 0.18725992603219077, 0.1803591586869392, 0.23478570552708566, 0.172068999388856, 0.19091296280033343, 0.33954956764242905, 0.20187420873169648, 0.1731481654039695, 0.42964154455436643, 0.1645618289256996, 0.21003085010076306, 0.2369011711362956, 0.27113976426544695, 0.19455169576949716, 0.2625948525951456, 0.18433728774315528, 0.18734459225380884, 0.16886793413284884, 0.20312140404872647, 0.14039710675989658, 0.20428578312224677, 0.1855066677905779, 0.19661473047315836, 0.17409630833675183, 0.18540834163853082, 0.18287326749263655, 0.1970186824542267, 0.1709269468701512, 0.16989246840604633, 0.1660177415876778, 0.07964257060655944, 0.05878980768293729, 0.07563781466373098, 0.062713545243125, 0.07563719121017998, 0.07179842107424628, 0.06648908622862038, 0.07033368433525211, 0.07191328081674453]}, "mutation_prompt": null}
{"id": "e7c047b8-86e5-45cc-9249-60bebc3eafda", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Slightly increased global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget / self.pop_size_initial))  # Modified CR adaptation\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget / self.pop_size_initial))  # Modified F adaptation\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget / self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor * 0.85))  # Adjusted population size reduction\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.2)  # Changed range and std dev\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(-2.5, 2.5, self.dim)  # Broadened perturbation range\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-Inspired Differential Evolution with Improved Perturbation Mechanics for Dynamic Population Management and Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 25, "fitness": 0.21609001199418043, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.6193968810873971, 0.5995973095878365, 0.5697775470082125, 0.5650952479145168, 0.5855594388756987, 0.5915791767884673, 0.606702844530772, 0.585992982477859, 0.6036449670049701, 0.24897527841654965, 0.2669028981725232, 0.20855733809566712, 0.24946089535985327, 0.2853905059251809, 0.2318759867018101, 0.2538005488219526, 0.2421743497705976, 0.26777470046687446, 0.133937987598863, 0.1560525318388467, 0.14122889683568662, 0.13662480391070786, 0.11262940206335148, 0.1476654199911318, 0.16348964553151146, 0.11591970860208844, 0.11003115707794209, 0.12590388004400743, 0.14216893545218212, 0.13468604268400508, 0.1332002455986696, 0.11801501377751933, 0.11663365185585084, 0.11138964755898817, 0.1104634325503091, 0.1056375787801015, 0.8321997719372098, 0.8593268269264016, 0.8384824708734921, 0.8710971613350545, 0.8701523057627597, 0.8769821008177058, 0.8854470875309269, 0.9035404943291503, 0.8599006881424232, 0.25129616484708683, 0.25092764571210413, 0.24542364745476475, 0.2360551883193538, 0.2266623775204386, 0.24778687908888608, 0.23300007274353607, 0.23271622824267257, 0.28540915157682434, 0.28138888850525356, 0.21363524266971023, 0.27644426241274855, 0.2814566185155086, 0.2971944176575455, 0.3056679019378533, 0.2939747115320013, 0.2576075834808573, 0.2745934336345215, 0.13589416970159252, 0.13620945023586517, 0.11950774056999691, 0.14035046266314533, 0.13549626027163963, 0.12409948840918894, 0.13144605177539237, 0.14485760902932487, 0.1415575433257139, 0.13259432176777752, 0.11801382496820989, 0.1274683547470732, 0.1350189586718047, 0.12698711900216963, 0.13952640663791915, 0.13882782308754393, 0.13694329608764366, 0.1259884476683112, 9.999999999998899e-05, 9.999999999998899e-05, 0.005811225140195164, 0.009305560944241509, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005822518926834608, 9.999999999998899e-05, 0.08267817656304921, 0.09488462205468662, 0.08310664688678904, 0.06717297202797567, 0.054056311394919065, 0.07410934021010529, 0.11564011997662604, 0.08331570429520996, 0.07597285163171841, 9.999999999998899e-05, 0.009112650478613205, 9.999999999998899e-05, 0.005876823571417611, 0.00046196105664364495, 0.008969514599294959, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001001536422522431, 0.08170349875943461, 0.07673653822196991, 0.09241122780403044, 0.10454979648187968, 0.11708067539000477, 0.08905849370837127, 0.09013712032490184, 0.07948579300574732, 0.07841863606516186, 0.403348214344047, 0.413814645936355, 0.41750685502301244, 0.4161702493431064, 0.4021874828201507, 0.39727521758338147, 0.4284648835572381, 0.40258466012176775, 0.42325327025693105, 0.09583481529901905, 0.08434354670806388, 0.07545803838048526, 0.08887809469802, 0.09446472882286583, 0.08320447558892252, 0.07981970319729914, 0.0926272818857522, 0.08668893815431333, 0.13903867110779644, 0.12817382939244615, 0.12338883085145957, 0.1375171273618394, 0.13234812671170493, 0.14193710295859696, 0.12345441011694636, 0.12193607282158059, 0.13919341866628943, 0.27822720494832753, 0.29618208296589943, 0.27455263561154897, 0.24372077279350268, 0.2799686212459557, 0.2776452056072991, 0.2921281934341847, 0.28702524602383106, 0.27791117990291514, 0.19032969254949783, 0.1829946375142144, 0.18113193630980928, 0.18315690214058256, 0.17432948777937052, 0.17173882448767397, 0.21513242401361365, 0.20866139986065635, 0.18083415149213455, 0.17941345982722245, 0.18181059392932453, 0.20331733804908758, 0.18418260579367685, 0.18598964619320724, 0.18515772249435436, 0.1756961589068622, 0.1779342476878013, 0.2097879432176235, 0.175410622983718, 0.19656702249458824, 0.18739947464814777, 0.1816720824052751, 0.19344849558345945, 0.18444904877898816, 0.19569350150485, 0.2005603061890342, 0.1779646610133423, 0.27960227409247596, 0.5692128425301162, 0.30397692907609986, 0.35876392236449506, 0.2021995076477282, 0.49344551666265835, 0.3509947586811669, 0.18522263553934537, 0.21604312670279102, 0.212266165699171, 0.19126258476110847, 0.2810674723961939, 0.22536751310595604, 0.19493787610976487, 0.15631869929061704, 0.20060972958005685, 0.20768268097747355, 0.20674310849239907, 0.16957284971290132, 0.19276669242083877, 0.17412030184033778, 0.18544602901486051, 0.18022068946322556, 0.17266575357002278, 0.17679267448034697, 0.18524312317164704, 0.17093314025649908, 0.07164648553463593, 0.07354488026025596, 0.062201136757167874, 0.0655391006439362, 0.07151245767644798, 0.06469570159597993, 0.07739975883914196, 0.07029407506217611, 0.07125997762842906]}, "mutation_prompt": null}
{"id": "4ab35e37-a529-47b5-ac8c-73c87a576e4f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Slightly increased\n        self.global_perturbation_prob = 0.15  # Slightly increased\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * np.sin(2 * np.pi * generation_count / (self.budget/self.pop_size_initial))  # Introduced sinusoidal adaptation\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = max(4, int(self.pop_size_initial * factor * 0.85))  # Slightly adjusted\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-1, 1, self.dim) * np.random.normal(0, 0.05)  # Reduced perturbation amplitude\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + perturbation / 2, self.lower_bound, self.upper_bound)  # Reduced impact\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-Inspired Differential Evolution with Dynamic Adaptive Parameters and Multi-Strategy Exploration for Superior Global Optimization.", "configspace": "", "generation": 26, "fitness": 0.20964288383970436, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.5434994253372064, 0.5140975835533973, 0.5450213740582682, 0.5603554226955887, 0.5284753450287053, 0.5285880006446662, 0.5389633790753706, 0.5700292126035917, 0.5362406032210816, 0.25526923511579624, 0.20214968986853055, 0.2497934635351612, 0.2149502684490271, 0.21447290870574665, 0.22081901244186808, 0.2667541040008826, 0.2142788844647071, 0.2519830439437305, 0.18007356323542467, 0.16901637149610393, 0.17036435097622127, 0.1732028125565328, 0.11755646005514753, 0.11959509180110595, 0.17226404691356179, 0.17618919615792916, 0.18230016518848735, 0.16908577393777702, 0.13088307851647263, 0.1370096539561586, 0.1027667424354346, 0.10323080950361696, 0.09995255080655019, 0.16973378506241954, 0.08782641784906686, 0.10361744646418825, 0.8803296916954587, 0.847489932301471, 0.9525244901246573, 0.8726047681540264, 0.9077762132689349, 0.916347809230472, 0.9073844976445691, 0.8611274608405519, 0.8309931466040517, 0.22061157967838896, 0.22101608022947083, 0.22322669605838263, 0.1917874502872221, 0.2302412237450021, 0.22575188461129614, 0.21065242409978813, 0.21293239325141788, 0.22288320071862777, 0.3395223292097058, 0.39758880177319034, 0.2567867351794262, 0.2645808105021843, 0.2900070706142228, 0.2366114760689878, 0.24819690335089328, 0.2638659763532727, 0.2873292381521598, 0.10485505889648883, 0.13105953508127255, 0.1313871858745579, 0.09782443399267826, 0.12553618250684373, 0.13432633798318183, 0.10691226876173765, 0.12632373561449217, 0.16644207467830396, 0.13592324498299402, 0.07664700176785155, 0.10129157353888862, 0.11470678703453485, 0.1114226540001908, 0.15165528048266497, 0.09346559461374049, 0.12165074239032181, 0.12946764063834604, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028391758638425246, 0.016126542435172864, 0.0025141604677372253, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00046594723164239404, 0.12506835630858548, 0.11794062940297412, 0.08551311080689761, 0.04870613641726518, 0.07949330979903912, 0.09097763084423582, 0.1364745732719943, 0.10332358800107178, 0.12657570790563244, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000956622747634861, 9.999999999998899e-05, 0.009340442504998103, 9.999999999998899e-05, 0.003417053075015608, 0.06096704382570839, 0.0894619230180781, 0.08949252367291771, 0.08286794669608755, 0.09436099885691507, 0.09720689824306594, 0.08372645863882278, 0.08438095343236329, 0.08399963208123462, 0.38481209003168015, 0.4152926779853917, 0.39748638855238716, 0.389617011309205, 0.3724561116744347, 0.378132387567921, 0.4024090192081088, 0.39000488362848906, 0.3811383451731968, 0.08300959133745889, 0.08480736947831069, 0.08944291258506842, 0.08429726065612797, 0.08741687374681317, 0.09003922311410983, 0.07865344758209158, 0.10024689789683594, 0.0985638075796087, 0.1382479580604944, 0.14574882639565623, 0.13674683962945833, 0.12910611347194767, 0.15188228988802477, 0.16288399084203742, 0.13695078481183864, 0.1562945574443374, 0.1527480036372788, 0.2628154559971465, 0.26853881724136686, 0.272863518670704, 0.2402626349429594, 0.25035850587634845, 0.2510918621793231, 0.2767647603735327, 0.2962601890322437, 0.27395413296036464, 0.1840135367360478, 0.1659313899291206, 0.16239925127903299, 0.1907284557750899, 0.15929290914133631, 0.17478963358803956, 0.18461143370793298, 0.193547879158961, 0.17945148764247765, 0.1909426027699619, 0.16735516456575839, 0.1772014303609809, 0.18330305455213025, 0.1633038638691845, 0.17533138398743797, 0.19041484051992197, 0.18527074207583094, 0.16862156172733356, 0.2527801389835873, 0.19299382593699643, 0.18891081825944267, 0.24175009749313026, 0.19142259260082395, 0.18772194581177826, 0.2109794969196721, 0.25897546444765207, 0.19473461477070686, 0.3871122876287716, 0.252426036096716, 0.1633994887524396, 0.16424382448612307, 0.1626935645897083, 0.3394613603102421, 0.20364248699743304, 0.17929932854531072, 0.18784438019489813, 0.19623962709107168, 0.21723242948365207, 0.22610252955047971, 0.19661240381391087, 0.1774995929525054, 0.18605301444334166, 0.1873860660770782, 0.3573126146647846, 0.1950639977447397, 0.19747214174836725, 0.17973257323656722, 0.18256265667024185, 0.18555612630789164, 0.17805544456861422, 0.18812342008264582, 0.17733617731640405, 0.17667857765636708, 0.1748869397942301, 0.0663154246227492, 0.06487148561904144, 0.06541915545523591, 0.07162506863961249, 0.0679183723705199, 0.06732199303276121, 0.06604611291344431, 0.07560204577352103, 0.07081474718066749]}, "mutation_prompt": null}
{"id": "8e317d6e-608b-4150-b8f7-e357fd8507a8", "solution": "import numpy as np\n\nclass HybridCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 12 * dim  # Adjusted initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9  # Adjusted mutation factor\n        self.CR = 0.8  # Adjusted crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Increased local search probability\n        self.global_perturbation_prob = 0.15  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted adaptive crossover rate\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted adaptive F\n\n    def _adjust_population_size(self, generation_count):\n        factor = 1 - (generation_count / (self.budget/self.pop_size_initial))\n        self.pop_size = int(max(5, self.pop_size_initial * factor * 0.75))  # Adjusted population size factor\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.1)  # Adjusted perturbation range\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return np.clip(individual + perturbation * 0.1, self.lower_bound, self.upper_bound)  # Scaled perturbation\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridCoevolutionaryDE", "description": "Hybrid Coevolutionary DE with Adaptive Quantum-Inspired Perturbation and Dynamic Population Strategy for Enhanced Convergence.", "configspace": "", "generation": 27, "fitness": 0.22613888648425706, "feedback": "The algorithm HybridCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.6363721258144931, 0.6422149901780252, 0.6610445109903927, 0.6483283638826305, 0.6182633402353952, 0.6349102006629532, 0.6499735692582063, 0.6391168032218553, 0.6144205070906186, 0.35453680320189995, 0.35456450146297436, 0.3434573754591961, 0.36059844431351395, 0.39340464380602636, 0.33370159453509074, 0.37310275956840344, 0.3453508050540476, 0.3649151789475449, 0.2691221557424893, 0.2051746677690255, 0.23640193361783401, 0.11679543265483494, 0.2052662016403497, 0.11946296646534993, 0.21555861758351325, 0.12072844429243013, 0.2305688283214229, 0.18998295334279192, 0.11043459040642212, 0.11552542733322557, 0.1181821002122242, 0.16355790017045202, 0.1813603466350996, 0.17605510367991795, 0.185441095788219, 0.11845009759453973, 0.8353215077732231, 0.8143851650907915, 0.7922390520350182, 0.8591590913158644, 0.7894546550635297, 0.8278104141213242, 0.844728702475762, 0.8012785964337618, 0.8254402117338538, 0.2723795769657118, 0.2927616413416526, 0.2734508987845725, 0.24626760525752278, 0.24713575106760122, 0.2531624646552375, 0.2752848518510699, 0.26490406502270125, 0.2399017492993466, 0.3267960623684363, 0.2812303660450204, 0.29841746867032015, 0.2992177813940169, 0.37125853507037854, 0.2765341531115121, 0.29143000971088606, 0.28497905873686225, 0.2766088081177456, 0.14627032203678558, 0.13757384231653358, 0.14114568142121464, 0.14203551454510055, 0.14917758540158155, 0.12718669641899993, 0.14835425937005786, 0.14972411953182796, 0.15174552791626883, 0.1601875627201238, 0.1322329985330991, 0.12376296904208905, 0.1516207369886251, 0.12990603339929097, 0.17048882776838437, 0.16581006477407678, 0.10817485252144254, 0.1266083255694177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0155247838214988, 9.999999999998899e-05, 0.001971213937287386, 9.999999999998899e-05, 9.999999999998899e-05, 0.09474837154520499, 0.08641236879254355, 0.09835669550653836, 0.08523102421464479, 0.07156573765203778, 0.08889975854949406, 0.11249626068472007, 0.09794501205161832, 0.12363602874976476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038353693655599486, 9.999999999998899e-05, 0.0003801346689691343, 9.999999999998899e-05, 0.07962935511719349, 0.11291180263377176, 0.11890040869185181, 0.08525887213791061, 0.10507399176905474, 0.12320530461320778, 0.10094543194025607, 0.08938017871465198, 0.10582997734825894, 0.43691495284785276, 0.40345105112005886, 0.4368867755683322, 0.44105410385292854, 0.39981771836265256, 0.4212264025842887, 0.42732280311265625, 0.41069665950562917, 0.4310335026116535, 0.1082355553157468, 0.0938484949564008, 0.08738862825190719, 0.08853696361989893, 0.09316479395419397, 0.10082296286932468, 0.08944724269199178, 0.10027825165516657, 0.085175360448151, 0.13145366823167404, 0.138880519924096, 0.14611619151687427, 0.1270163899688712, 0.13078819192457902, 0.14015646413456595, 0.14604569592537264, 0.14399979829684273, 0.12472418268338292, 0.2699363554454378, 0.2356583211028439, 0.2858681977412024, 0.26876909003712146, 0.2861732216916184, 0.2718356962003169, 0.3127370776592595, 0.3048688434114244, 0.2864469992651949, 0.20342154760387954, 0.19551211336933816, 0.211922222784505, 0.1811150919046074, 0.1961223472271536, 0.19408602597345348, 0.22270861195176916, 0.20795400848046575, 0.21659440590250723, 0.17100603993449026, 0.18084072215642388, 0.19293783029912426, 0.17374343301903195, 0.18542636880977337, 0.18470956713469144, 0.18141435804300854, 0.18531189064936393, 0.184834347167529, 0.21990314437353842, 0.18619910999956213, 0.18420357145377986, 0.19387509515071877, 0.19580993911273503, 0.17935124412198333, 0.1904534720447325, 0.1871692021432647, 0.17826592164301713, 0.2216338868236145, 0.22753848511641683, 0.29888352569030563, 0.20741409246538722, 0.38561214731594573, 0.360394102178041, 0.15329644843545176, 0.21066968494213156, 0.17628465184011854, 0.3422282985839634, 0.16580298023753604, 0.16175536592854256, 0.1913439242638687, 0.1917632931126645, 0.1780899112910751, 0.28894336275122656, 0.1489673415319539, 0.13933088515397885, 0.18597249061698795, 0.19642219981976683, 0.18782150296033073, 0.1686467844790046, 0.1814343123488208, 0.17223182771925638, 0.19461176389655743, 0.19459253787285502, 0.17843090883768487, 0.0807008911355449, 0.06579227150256406, 0.0759293566982222, 0.0708249743728927, 0.07360560249430437, 0.06996755356299234, 0.08688275667129242, 0.07336254056157943, 0.07372042921459265]}, "mutation_prompt": null}
{"id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 28, "fitness": 0.2557920780950308, "feedback": "The algorithm QuantumInspiredCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "97b4841e-bc08-466d-a7c3-af9054358bdb", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "fcfa3e49-47f2-4c06-9bfd-41c854a91e81", "solution": "import numpy as np\n\nclass QuantumEnhancedCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim  # Adjusted population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9  # Adjusted scaling factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n\n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n\n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumEnhancedCoevolutionaryDE", "description": "An enhanced Coevolutionary Differential Evolution algorithm using adaptive quantum-inspired perturbation strategies and dynamic exploration-exploitation balancing across diverse optimization landscapes.", "configspace": "", "generation": 29, "fitness": 0.25050193793547054, "feedback": "The algorithm QuantumEnhancedCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.7949733350893076, 0.8570946295866495, 0.8064010356932654, 0.8689211761855985, 0.8671860369392137, 0.8357290337781466, 0.9016010149468418, 0.8741481731015327, 0.8653135281251654, 0.3551084703050361, 0.29071788309712543, 0.07580410752295208, 0.3478459860415146, 0.31001222483505386, 0.3103906488031317, 0.3181114538619523, 0.2674766816550599, 0.20127539085415558, 0.14356915462397624, 0.13903567374990722, 0.13611491741492387, 0.11994007306871224, 0.11755366081858576, 0.09245541962834958, 0.1475304629313825, 0.09350457063252793, 0.13065243831247697, 0.13206249043500684, 0.10894239831955399, 0.07927132320338592, 0.09747672341188296, 0.16336757256985368, 0.13705988405470215, 0.13704264335271832, 0.12971247551480314, 0.10321625419127267, 0.9390893785969958, 0.9044498269401374, 0.9026806971878446, 0.8335218103426606, 0.9188383072259398, 0.9065385893354427, 0.9215665959500582, 0.9322752857079815, 0.9355930113168921, 0.32711284781093064, 0.41186758825604475, 0.4015799230787709, 0.22267150639626565, 0.338407632531217, 0.30577909861349006, 0.36721271822027046, 0.2492708695858613, 0.38889535353355154, 0.16363048295461813, 0.20763588061152327, 0.14186097728683655, 0.18331784473291945, 0.2717156126007342, 0.9100340403041939, 0.3343918593792037, 0.3120224048212138, 0.22805949533758685, 0.12517622492030256, 0.15681933070058307, 0.14572380182480082, 0.1519804203353038, 0.134662107362454, 0.12818730407219103, 0.14109923579510664, 0.16663076501784924, 0.24942004842618481, 0.12498960423596095, 0.11487127735050962, 0.1373444340066482, 0.12234991145251684, 0.11957203978251296, 0.15089198266692294, 0.16886753283613087, 0.1234585533379664, 0.1236604940622612, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051428335890897015, 9.999999999998899e-05, 0.0012066172934214192, 0.00010130618968795524, 9.999999999998899e-05, 0.12421294309996433, 0.049744164250747014, 0.09452087498647599, 0.05528364021296006, 0.06298748743768978, 0.0313581817627786, 0.07663159121588214, 0.07249312227426885, 0.0902694615937284, 0.04121206647862585, 0.11847791520706397, 0.1083975081370796, 0.1337006603541877, 0.11951100739556808, 0.16592200286262615, 0.13887180907136187, 0.09764394762736262, 0.18719341251794763, 0.18625722806886902, 0.07099734363120336, 0.1464812326559819, 0.03641107085677764, 0.20871004335726506, 0.11185976943481235, 0.19633313951071807, 0.15169452528462102, 0.09058355024737663, 0.4690667248945073, 0.5377315862550707, 0.4915231263694, 0.46972750826311815, 0.46158073954877277, 0.46574778803011363, 0.45479402272696134, 0.4710878878094831, 0.46868356466356265, 0.10517626150107495, 0.08849351786743975, 0.12534532769174767, 0.13314409196852317, 0.10450630847727438, 0.09077166771857359, 0.08141241402370836, 0.12634034577823428, 0.08811820983517626, 0.16669105672765183, 0.18542020365475642, 0.25185125062690483, 0.15892296115982174, 0.15447743055890428, 0.18218590928780765, 0.1383256361176204, 0.19477587718136058, 0.17581859481448392, 0.24313487582923377, 0.27827442941751945, 0.22008151124873188, 0.39028598131696535, 0.23976077531477136, 0.36587020124111236, 0.3023057911097362, 0.31005793196206344, 0.297371787224615, 0.20298386986384864, 0.27899159007207586, 0.24202122017023697, 0.1618381072020455, 0.16798901844859304, 0.1681982047880871, 0.18440272414214742, 0.23795130289368394, 0.2255036563933982, 0.19699676231398644, 0.2068818097871673, 0.19067185184092472, 0.17888088363065713, 0.18964588040668873, 0.19185099786821347, 0.19850415383884223, 0.20819128771682593, 0.18854724861190075, 0.18874111520325687, 0.19337901979395677, 0.31114999937293153, 0.1931758286148334, 0.19174046711224324, 0.18829183407765238, 0.18058498362663644, 0.19585825888663733, 0.1661819065403639, 0.1833008156314514, 0.18712671890722044, 0.14986241973406267, 0.8676051465102871, 0.1968927278875311, 0.19506830160955335, 0.18338661229250652, 0.14675645832480044, 0.30735902429638384, 0.2657030814333643, 0.16674642803819895, 0.25360342105242606, 0.20983930548864105, 0.1640587760362303, 0.60910944160373, 0.1654405197813127, 0.20405154659849256, 0.38542702817721297, 0.17794769603561056, 0.20010332719846113, 0.1843288936878167, 0.19743923012210884, 0.18307596227993628, 0.1755285683783011, 0.18570507188938368, 0.18061115100597258, 0.19113651283027133, 0.08915082356809745, 0.08071032151560797, 0.08320734586681044, 0.0913090258599838, 0.0703884147876217, 0.07504325867146422, 0.09023778462475762, 0.09086821858158456, 0.07883231991074169]}, "mutation_prompt": null}
{"id": "9e1ca1a0-d921-4337-ae64-028c1b41530d", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "98194a5f-deb2-403b-aaa5-51218e4d5086", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.75 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.6, 0.6, self.dim) * np.random.normal(0, 0.06)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.2, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumInspiredDE", "description": "An enhanced Quantum-Inspired Coevolutionary DE algorithm that leverages dynamic scaling and selective local search to optimize black-box functions more effectively.", "configspace": "", "generation": 31, "fitness": 0.2428543005562466, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8751067939964701, 0.8499623825948286, 0.8709511503434699, 0.8345517925308291, 0.8488516605655154, 0.817263452729796, 0.8854878293826276, 0.86498690590339, 0.841821511966273, 0.35065585777357167, 0.3828580137019081, 0.4223042681237651, 0.26359013144924215, 0.5626087796607637, 0.32704352020519656, 0.23703047073942463, 0.348017084964128, 0.4135093799695152, 0.12182635697446398, 0.14727469160571893, 0.10521337109870943, 0.14541411931853576, 0.15060134449820484, 0.1665298070389647, 0.10945130808246906, 0.15031421120122068, 0.17113536740543445, 0.07536666065904352, 0.15290182776999972, 0.11588993169918138, 0.14585132365013176, 0.0939424396033266, 0.10778345304996406, 0.11300797363365978, 0.16387806626846813, 0.14824878464896063, 0.9086568156917862, 0.9214520163123467, 0.9186756297124574, 0.9281359559018828, 0.8940067395079557, 0.9297647075036587, 0.9207183748877682, 0.919351676074529, 0.9182977575306287, 0.23564840282723176, 0.3071627280804502, 0.28259938516510685, 0.2204809903750976, 0.3178567694334683, 0.3128977335554731, 0.2820538604736237, 0.30741246607726036, 0.34514683380854205, 0.20954301284049015, 0.25611480980624735, 0.23651966555241788, 0.20610609932682977, 0.2013278883903764, 0.26661787853950947, 0.28300492470893823, 0.33798103347695796, 0.22599441210570914, 0.12199288685302179, 0.12359576030724051, 0.12417112129180718, 0.14951131018623187, 0.4555499290969932, 0.16819568759122705, 0.18888536746304496, 0.13555148278778384, 0.13764857857139978, 0.11760104745444566, 0.14683223884835406, 0.10835073462759426, 0.11900018468470985, 0.16747312394760427, 0.14258073987713338, 0.12223484353130676, 0.1191237674067317, 0.20914701823756054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07926476628013768, 0.04842761795749717, 0.03417614570824057, 0.07477269399987241, 0.04401139155951239, 0.03507902627909576, 0.05060501762836378, 0.057286834190304003, 0.07056882794583197, 0.06786046643406263, 0.22433506010666393, 0.04864176799652309, 0.2109429527774067, 0.08042276035682316, 0.0811581608588604, 0.09087900065564558, 0.14022636679844547, 0.13758910703818183, 0.06325362767366982, 0.09728910027384496, 0.06996491199577193, 0.1868533062093024, 0.19043232236089602, 0.14817908060739282, 0.113538046594023, 0.0814264009954131, 0.16684230431693525, 0.4735402846722221, 0.44862068688503387, 0.43415205712733185, 0.44981337323799775, 0.49385989776911154, 0.4479961180625581, 0.4685857077005603, 0.4601476660587126, 0.43859321016474073, 0.12165338576961171, 0.11872409331971956, 0.08476201530680205, 0.06888388566297887, 0.07650733141904142, 0.099325141052091, 0.1257879719194932, 0.11979831214051151, 0.18137972607323605, 0.1494072008244477, 0.15428727896669858, 0.20063057085094438, 0.14384377727901554, 0.1712001324147988, 0.1479727968311445, 0.15954911609582378, 0.13484703165519873, 0.14883396117516368, 0.22106478990444933, 0.3137836474700204, 0.323081632007984, 0.21662762699836025, 0.33916544776854884, 0.32773134690693617, 0.23588615311577588, 0.2887334055519758, 0.24705808035288734, 0.23114025456361043, 0.1877157277202829, 0.17221345567535795, 0.2637728993896997, 0.14443458451345814, 0.21893630020272503, 0.19778157313634315, 0.20590712754275642, 0.2605838906792496, 0.20278170921204197, 0.1594273032545067, 0.1782441055062156, 0.19479216333063876, 0.1805694621493703, 0.17388947785234576, 0.2602508926299171, 0.17080893007434206, 0.20178895086239168, 0.18124016247504593, 0.1739441397534629, 0.1906614429960023, 0.20153075735974513, 0.18824878226067931, 0.20604878064576726, 0.2350688688423188, 0.17264023484960833, 0.17286429985750162, 0.17070630900946804, 0.4651655055659155, 0.1897161095978448, 0.19215799693667046, 0.14916055429357222, 0.2506092101135191, 0.14212604640721183, 0.15505055330051343, 0.15996023649301583, 0.16307225210145648, 0.1652392338469454, 0.2966767128949951, 0.18572556805008966, 0.15704599953472043, 0.21054444934413796, 0.20198785425382437, 0.2614035156448248, 0.20505585644834634, 0.1824022135010438, 0.17485032775385134, 0.17854068090639552, 0.17862610296168857, 0.20184346638877215, 0.1803669093025957, 0.1811880561647674, 0.18270260829142504, 0.17892052935397718, 0.08984303101520486, 0.09613464712219466, 0.06984004162099389, 0.08074061181468528, 0.06903750681153198, 0.07141871746311168, 0.07577526512949084, 0.06569551149887576, 0.08694411052745676]}, "mutation_prompt": null}
{"id": "c2209de3-cd6e-441f-a721-f48eb439c93c", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "d534b031-6687-400a-b5db-14a0dfe6cbcd", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "c3ed2175-98b4-479a-a849-da134f64cf0b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredCoDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 15 * dim  # Increased initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim) * np.random.normal(0, 0.1)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Changed to different normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumInspiredCoDE", "description": "Enhanced QuantumInspiredCoDE using dynamic parameters and stochastic exploration-exploitation adjustment for improved convergence on diverse functions.", "configspace": "", "generation": 34, "fitness": 0.24195652637309292, "feedback": "The algorithm EnhancedQuantumInspiredCoDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8187033909737426, 0.8262541801697172, 0.779693651824219, 0.8211158740369794, 0.8215196288799449, 0.7931944983342123, 0.8080470058831548, 0.8047573347405125, 0.7619968116034905, 0.477323436486756, 0.5377288411990444, 0.5633019610589102, 0.45925296339366006, 0.4826799351267893, 0.47387078680693673, 0.35404198345705473, 0.370542357268574, 0.41430524744191366, 0.13845916494868182, 0.16495866781351032, 0.14264621834909064, 0.1605889163330264, 0.2773159737135157, 0.16575048723017805, 0.15875690204569515, 0.12224493182617624, 0.1484863862910334, 0.08727140106065634, 0.10297441818932418, 0.13998157387306087, 0.0916711913753383, 0.09078071574777569, 0.0878981940349397, 0.11171635720449158, 0.09203101725021334, 0.1232259283356465, 0.8673539405650675, 0.8830828807746782, 0.8924882393647774, 0.8643717703511824, 0.9273095228001333, 0.8723101910566166, 0.9202661076777034, 0.8788139339391979, 0.9279522855906734, 0.3189321658148552, 0.3038619902305426, 0.37560979607654776, 0.311434251241245, 0.2397403997977341, 0.2298811103720534, 0.255391398906443, 0.25532656341614957, 0.14978620679058352, 0.3150182005622806, 0.21261091965875756, 0.19336882113827825, 0.30655898238841894, 0.34491895714349263, 0.2469963635240502, 0.6476639637237878, 0.22734658180497547, 0.2065848053757693, 0.13388442247052734, 0.12046865906884885, 0.1354726998757082, 0.14541055853964213, 0.10778151180466089, 0.11288376931020572, 0.15552137396344823, 0.13667371354031144, 0.13822156358498983, 0.14196881038154952, 0.10865993369951699, 0.12358021516058093, 0.15376277733248267, 0.14998368353071057, 0.12301176519940016, 0.12269110434745578, 0.15892050016270443, 0.10301679844392497, 0.054174898721366826, 0.025234192990196025, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00027902541502100586, 9.999999999998899e-05, 9.999999999998899e-05, 0.08428184215201795, 0.06506511759187683, 0.07177163239559792, 0.10723963678939996, 0.01788911723704456, 0.05032326600571779, 0.04690810420427516, 0.08404068537045473, 0.07437941282706872, 0.017037156669682862, 0.048129196379959605, 0.10355771831822369, 0.19921036279083926, 0.06806228612047394, 9.999999999998899e-05, 0.13646976398560473, 0.15556695287054312, 0.1283765896270208, 0.12773764706528423, 0.10506954867643181, 0.11163656552429113, 0.1248450753256275, 0.1903776620278349, 0.12313735728585817, 0.10045780659534831, 0.18813580610312197, 0.10090694705848857, 0.4736337478091627, 0.4091256271089596, 0.43107833821385844, 0.45184809595846864, 0.4556317520493516, 0.43264901763514374, 0.49252638434314444, 0.4431069593838377, 0.4394995558408272, 0.08912545229304525, 0.07948838495980504, 0.13402489023413022, 0.09137557497069648, 0.10380366449410283, 0.07704407755711584, 0.08818988155893803, 0.10311197788646964, 0.09464549550745482, 0.1734890801523783, 0.13802323764400748, 0.13761654372803256, 0.14414537563601248, 0.13813190421819932, 0.14204554078562504, 0.15458732524270402, 0.13327039981758548, 0.1474837255276803, 0.2675427146007071, 0.23543938152505905, 0.26468715779228624, 0.22813726167109805, 0.24291157687416953, 0.20717943159462815, 0.269874035544458, 0.29394634167630473, 0.2529036045864641, 0.20066209039449456, 0.21008606756797488, 0.25722493275932345, 0.18743231836233432, 0.17544512199526996, 0.18224654405708096, 0.23351436948968274, 0.21349854500908882, 0.24594705720480958, 0.22008263273994533, 0.17151218454337935, 0.18267955396135382, 0.20505273350305597, 0.19053460559806368, 0.17015437451607973, 0.18967454432773656, 0.21002401148637206, 0.17356323197041312, 0.2066042153551353, 0.17788567195436533, 0.1990423436487223, 0.18621071664427802, 0.187216103245176, 0.17936112455943498, 0.20542530951171867, 0.18178362059993247, 0.17274198541993524, 0.18387141459656586, 0.17984383112356395, 0.19874121068719564, 0.18585627866522747, 0.17626498284274406, 0.16256726242851727, 0.31454647910561695, 0.15709544781248608, 0.16528788486524282, 0.4863902817255168, 0.19938121109004825, 0.24196539276245954, 0.4409947043689013, 0.196502719117026, 0.19194484363920616, 0.19894168123322808, 0.16776937379033974, 0.2022197144657042, 0.19829243460748414, 0.1979823798872261, 0.1810918501243095, 0.18680252737980085, 0.18853003310028782, 0.16955939498492767, 0.19036870106837456, 0.1883037883025267, 0.18930439251294306, 0.07644289058375031, 0.0728632682876863, 0.07658678986489198, 0.07301716276354331, 0.07489337061821244, 0.08692534082714953, 0.0759158149879764, 0.09112669139856511, 0.08450470518645448]}, "mutation_prompt": null}
{"id": "eb971bab-b747-4ef2-9c32-8ac8795852c9", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3\n        self.global_perturbation_prob = 0.2\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _stochastic_gradient_local_search(self, individual, func):\n        gradient = np.random.normal(0, 0.05, self.dim)\n        improved = individual - gradient * (func(individual + gradient) - func(individual)) / np.linalg.norm(gradient)\n        return np.clip(improved, self.lower_bound, self.upper_bound)\n\n    def _adjust_population_size(self, generation_count):\n        diversity_control = 0.98  # Modified control factor\n        self.pop_size = int(max(4, self.pop_size_initial * diversity_control ** generation_count))\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._stochastic_gradient_local_search(trial, func)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "RefinedQuantumInspiredCoevolutionaryDE", "description": "A refined Coevolutionary Differential Evolution algorithm introducing stochastic gradient-based local improvement and adaptive population diversity control for enhanced exploration-exploitation across diverse optimization landscapes.", "configspace": "", "generation": 35, "fitness": 0.21282941551949353, "feedback": "The algorithm RefinedQuantumInspiredCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.6470719347584624, 0.6387060090057868, 0.6501826943387373, 0.6293285585908535, 0.6615544799989344, 0.635718804919056, 0.6446579719718095, 0.644833940636054, 0.6625060925846623, 0.29793082618941336, 0.3361214611276604, 0.285601557535184, 0.3179947785388738, 0.36715957667767174, 0.2640152475619417, 0.22323231882454364, 0.379484018155248, 0.3725487787649868, 0.11988878218557963, 0.1424602142121274, 0.10756316319272241, 0.12153897734315433, 0.1271989470459075, 0.12249654996551596, 0.12354094521826742, 0.11618143902976608, 0.11929683685145998, 0.09645472038789826, 0.1009782784718436, 0.1014966546924283, 0.1005344654524628, 0.11006069681900643, 0.10356832852570841, 0.12045264318198556, 0.0984497234406756, 0.10185953617375565, 0.7797303452927311, 0.8190683233167416, 0.8118346833135195, 0.7966177102519977, 0.854891031486106, 0.8962570111398201, 0.8620164611159654, 0.8402891991644466, 0.9015771766463059, 0.2339945312097318, 0.2534928773927493, 0.260502730189187, 0.22471729558743314, 0.2369142788485018, 0.24413678720479282, 0.22663688762491618, 0.24858587875202742, 0.24840522909481233, 0.20107215900953423, 0.3391778671366571, 0.19745373326559656, 0.2583706923273147, 0.2699074616782109, 0.25093724696884334, 0.22487304065846336, 0.26079554127824234, 0.3066483602509965, 0.11219769996634654, 0.10424289955086385, 0.11014174667243637, 0.13178986259050451, 0.11292690651455561, 0.10127541595832701, 0.10624266118369019, 0.13197927526255337, 0.11799905449141357, 0.1150550295592957, 0.07470287473075987, 0.0995157759222659, 0.11255735407671474, 0.1304963566262306, 0.12836399859148462, 0.10593712448301718, 0.11488023629743216, 0.1177710914230673, 9.999999999998899e-05, 0.0220819119637905, 9.999999999998899e-05, 9.999999999998899e-05, 0.0063077006662956014, 0.002617123811571087, 9.999999999998899e-05, 9.999999999998899e-05, 0.015278111474614553, 0.04086107759667523, 0.051432902566234784, 0.06464111596925182, 0.0645182271549869, 0.06515034212038917, 0.054916911039802785, 0.11996616473535904, 0.07572760249817079, 0.04563369744139434, 9.999999999998899e-05, 0.00033324697631742506, 0.04706166894887942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025349752710397633, 0.07643394448357343, 0.07713969480670424, 0.0672717222066278, 0.06087980281611671, 0.08429691689289653, 0.09011061742938131, 0.057587867986026, 0.0718001720612157, 0.04447266834077068, 0.4226232361918456, 0.4138179202263873, 0.41563797605745645, 0.4291656085914778, 0.407416637716178, 0.40648004876973876, 0.4399133938217805, 0.41158173435148204, 0.41263154724821394, 0.09215092542181469, 0.10148302225320693, 0.09557236934170998, 0.10552660137595704, 0.08470696484382934, 0.08198738283828422, 0.08588861760983457, 0.07761800692391296, 0.08244263471747693, 0.13851799937069553, 0.1351999849523723, 0.13313404858138822, 0.1589267946624281, 0.14044541907734642, 0.15119141128967473, 0.15630338013594647, 0.12353690322994748, 0.1269370953922062, 0.27707670100445536, 0.2795862952617405, 0.2807238267861851, 0.2853153426490176, 0.2541422814249542, 0.28377687203649826, 0.29462187978166443, 0.31903258305859317, 0.2825389807165596, 0.19133365198877306, 0.1837342173641885, 0.168969378852306, 0.12877600012261625, 0.17183251308147263, 0.14987263465432354, 0.187742488015343, 0.20848591177849485, 0.1732227758260464, 0.18582381393849723, 0.1796962360308355, 0.26424657338741897, 0.18456159210834555, 0.16805194751013097, 0.16246199234575887, 0.1852664190862544, 0.16984108551983734, 0.19014334844981096, 0.174265602771295, 0.20050889116565918, 0.17792996694941243, 0.16703381564215836, 0.1808099005018836, 0.1743529142949919, 0.17181919630796927, 0.18263527737462537, 0.17849635880626125, 0.43125387861613695, 0.5528684419810062, 0.16153544998064573, 0.4788922577972824, 0.17321072457695885, 0.21189322215265505, 0.3547401572366846, 0.15547641399372314, 0.1952201479505884, 0.2211513352005472, 0.21267103814878263, 0.18613930227165676, 0.16673542215957315, 0.14687154629287302, 0.16759601192319262, 0.1471187351449864, 0.1454635070892042, 0.1939963419157168, 0.1886453022777571, 0.18839417855880847, 0.19383043745409267, 0.19919410392033288, 0.1770927106505067, 0.175046913573213, 0.19660819779298666, 0.17244568047705433, 0.17037928691184112, 0.07098985843721983, 0.0717443300522358, 0.06356488039537567, 0.07758554413924534, 0.06913202971054722, 0.08358067037718209, 0.07925618988127936, 0.06509498745315889, 0.07354676295438545]}, "mutation_prompt": null}
{"id": "27385c72-1cef-43b3-bb25-632c43cef2f9", "solution": "import numpy as np\n\nclass RefinedQuantumCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "RefinedQuantumCoevolutionaryDE", "description": "A refined Quantum-Inspired Coevolutionary Differential Evolution algorithm with probabilistic selection mechanisms and finer-tuned adaptive parameters for enhanced convergence in diverse optimization landscapes.", "configspace": "", "generation": 36, "fitness": 0.2532963655933665, "feedback": "The algorithm RefinedQuantumCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8735444568041648, 0.8225608561636719, 0.8732145864870221, 0.8801909635166778, 0.8297646933790113, 0.8097650252524904, 0.8576724439571315, 0.8309135864355524, 0.8340381685518465, 0.37611278593465913, 0.4701338018901887, 0.3115563379524581, 0.5689098760354109, 0.4064923695707693, 0.5477165373449965, 0.43937083522871223, 0.3146952179146737, 0.3621133243453586, 0.1684122190787133, 0.13704019251652755, 0.1652430729341413, 0.121777175421942, 0.17738254230897088, 0.07742560794890652, 0.22560482578328234, 0.1436366778924405, 0.1652746481444819, 0.13930335065454458, 0.14947460686157588, 0.13984137311598133, 0.16425651006402842, 0.11492728937320462, 0.09164407278101627, 0.17020459632578733, 0.14581492079331715, 0.0864389230101057, 0.9055238371329853, 0.8665791845546154, 0.9049219863043818, 0.8884826467574007, 0.8917838416204403, 0.9160180223815554, 0.917876929141016, 0.9022656266374225, 0.8983223844978733, 0.34622874735582343, 0.31281421275411425, 0.39784049834201074, 0.3957266811703154, 0.40317657670476026, 0.34247657329491044, 0.3802490870115237, 0.28021974552346063, 0.3023238413574296, 0.3389108912940889, 0.22162831097603264, 0.16278267716042683, 0.27305227487367867, 0.35623088112533374, 0.33925739237336594, 0.32176021455645165, 0.2274014712690784, 0.22880014785092118, 0.1325079659776247, 0.12746152000703548, 0.15540156903548485, 0.14496831103430963, 0.1277630872380363, 0.19249213867914128, 0.1298290619095862, 0.14233106665205375, 0.171825448641012, 0.12586533254203536, 0.11329906098802534, 0.1220340382471411, 0.1854099958391282, 0.21769595101053496, 0.1210743030560596, 0.20720237153008925, 0.13485918310588385, 0.1311712640428112, 0.02620063581639409, 0.13573787255096215, 9.999999999998899e-05, 0.05148774903483189, 9.999999999998899e-05, 9.999999999998899e-05, 0.02136642317302284, 0.09639747342393024, 9.999999999998899e-05, 0.11279453144131657, 0.08782621189017858, 0.10343098004711482, 0.040467681158195434, 0.05007081916829936, 0.035010478213861274, 0.10195123940108608, 0.08679662388159981, 0.09089371809288915, 0.1500145651195529, 0.09115785193894443, 0.03829644494853024, 0.1160412031837359, 0.08668822505090679, 0.20618256921953393, 0.14674355185845056, 0.28604830971827144, 0.10945649532414392, 0.30180067404551614, 0.13826604342386895, 0.14842732985305374, 0.044309181981901036, 0.07461442578079513, 0.1234258914463029, 0.17485435014211292, 0.15327475774750787, 0.07677406895402439, 0.48318556320625017, 0.4772003020661285, 0.49903835826694676, 0.48097800675734104, 0.5067779832417457, 0.43520223526290824, 0.45559985077626397, 0.45656317228563326, 0.47625922012594324, 0.11825104373485851, 0.13818094156038097, 0.11994964943867636, 0.14375447955534892, 0.08975452274188356, 0.08151932962877839, 0.11586059857326492, 0.10299063604898506, 0.12331655154733401, 0.1712522335110911, 0.1398768739234314, 0.1589245134148758, 0.14612052998144864, 0.1521947358080421, 0.17160318159843868, 0.15643985436046803, 0.23351111009596315, 0.1270888162898407, 0.2472793368155174, 0.2442995161497985, 0.2740755700836208, 0.24646867885279022, 0.2877957186029855, 0.24748044699968408, 0.24666623017989464, 0.27459222960670626, 0.2024241591917294, 0.27261612983557126, 0.2654230075884071, 0.1980093768982487, 0.21621019380334172, 0.2767141093684109, 0.20481404147729032, 0.21648336795622003, 0.21251765386883914, 0.1676920228457015, 0.20895021888333742, 0.17364861359968708, 0.25933201070782963, 0.1820347893423636, 0.1751803101429077, 0.21305833362597026, 0.19768467350514052, 0.17493063527727004, 0.2169403137965763, 0.19801869974145048, 0.1886368913098896, 0.18737373321004802, 0.2032661961990001, 0.213074459050838, 0.21119355617515545, 0.19911375512267104, 0.21987919602826833, 0.23364083238241407, 0.18188950951162108, 0.1652636730953273, 0.1524035179738532, 0.39745851261769494, 0.19369884552613492, 0.1592101203101005, 0.20827074111949428, 0.3863980170825466, 0.16039884875924038, 0.3063670295948334, 0.20536726837788222, 0.16870346832584326, 0.19822451596098167, 0.20081521780621892, 0.15165142784417107, 0.11114704102279116, 0.20041491837673608, 0.17047865947149243, 0.17489789594419258, 0.20907197774334862, 0.19207137017794074, 0.17507284427590908, 0.17486780488048714, 0.1840914675092592, 0.1805267111797355, 0.17810071558348206, 0.1690240505478099, 0.09499490517476639, 0.07384187572990009, 0.08759372503999929, 0.0719799827629658, 0.08603203132860093, 0.0762989601424715, 0.08442541528213865, 0.0692734952165569, 0.08725190248078163]}, "mutation_prompt": null}
{"id": "39e80a32-70b2-4f69-b5cd-5f7991a529d7", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "5feec859-d2b5-4f21-ba77-8d6fc251dd63", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "bb1a2603-6603-4e59-bbb5-eb94127dcb9f", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "79a575dd-4077-4956-8fba-f0ad6d941bb3", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "dc543da5-dd04-412e-be5b-1dcd3275174e", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Adjusted probability\n        self.global_perturbation_prob = 0.2  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Introduced decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.05)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)  # Changed to normal distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "A novel Coevolutionary Differential Evolution algorithm incorporating adaptive perturbation strategies and dynamic control of exploration-exploitation balance, designed to optimize performance across diverse black-box functions.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8393401582675513, 0.8295981689838927, 0.8312211231211046, 0.793128381060076, 0.8384941698703393, 0.8028483991727128, 0.8362808878000058, 0.8322394175082497, 0.8251360373704179, 0.3314181242291784, 0.5064850936308537, 0.5466098383631584, 0.43773285279114993, 0.7121270980862571, 0.31068015600891896, 0.5653003503046048, 0.35972733817256664, 0.4543874753556809, 0.13250238872196018, 0.1072690076636924, 0.14458072157674828, 0.16642438761944034, 0.16182370444651428, 0.14584790074506004, 0.16134864326332155, 0.14495092385086394, 0.14491486969823564, 0.10129502173715077, 0.14435471568398095, 0.19962827389485926, 0.1484858602634367, 0.13529911416673945, 0.1282136824349167, 0.2196390182370075, 0.15861191420217668, 0.15118828516801863, 0.9176204485236517, 0.8749044900798659, 0.8892074449501081, 0.8688639204997018, 0.8899503865094175, 0.872499092935588, 0.9101382472213196, 0.9142330675604363, 0.9376412508739485, 0.3613169649688073, 0.4299992555685951, 0.31629768619137266, 0.23253693226640826, 0.3921557374460346, 0.3391321109370561, 0.4087321625027325, 0.2477342920832073, 0.3081902857413945, 0.21332697810133494, 0.22152348415597145, 0.139650903436636, 0.2707821444316363, 0.3452850148524599, 0.18299925463635724, 0.23198956344078103, 0.22171211815117364, 0.22889101644902698, 0.12582478620442905, 0.11340124328677326, 0.11565478876610613, 0.13822250062605568, 0.15675479455376895, 0.12137140637605914, 0.1443169218678011, 0.12757905225082722, 0.13051525541486242, 0.13085064387320833, 0.15603570457820892, 0.14975840688814823, 0.14251187928109177, 0.14008650291427271, 0.16004750962110725, 0.18306989237640325, 0.11492282995853453, 0.1506299952518304, 0.045787799962945575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038702442047797714, 9.999999999998899e-05, 9.999999999998899e-05, 0.02239596656263798, 0.05883263241216208, 0.08602771650378449, 0.06823123635335104, 0.09722631024206307, 0.03304163055475384, 0.17929438689895905, 0.1374343115946205, 0.07620379818531742, 0.2113520491009293, 0.08051235300419102, 0.03641303875207236, 0.09273256735168944, 0.2266241238356771, 0.007326026448023382, 0.27624241221875934, 0.10530734246178286, 0.22929404670736442, 0.36679950292483376, 0.16957483302385556, 0.12583614323584147, 0.11274548496684833, 0.1493857461974858, 0.12028106040531661, 0.14051868569199688, 0.1789406519028105, 0.13612767907263512, 0.4300186546235073, 0.4982169929687249, 0.46257931062620583, 0.4419140159501652, 0.42425301467675003, 0.46076880533069986, 0.4638904629300463, 0.43636112845312813, 0.4680891228074763, 0.11762979960229969, 0.12051924908722944, 0.10955167317643955, 0.12622929922929793, 0.12341428046191938, 0.09677096367728988, 0.091971698821386, 0.0793238357680357, 0.1032197080232683, 0.1330733466095675, 0.14672947652709156, 0.1543509441439732, 0.15025352792409918, 0.12480945534026255, 0.16254967198079762, 0.2000247819160652, 0.12193000694079059, 0.18745193053113274, 0.243011454953448, 0.2475998027981683, 0.25267374355690797, 0.33043130510155205, 0.27959445697463936, 0.28445199357698214, 0.3247045579393114, 0.3306865012246094, 0.2553050465813439, 0.21838738285193082, 0.22681613526968236, 0.17996285422701497, 0.18214993731403706, 0.22478399449220432, 0.23643372571978316, 0.21978349030766453, 0.2924906393268618, 0.22814126272383706, 0.2116769574976607, 0.17903956999401904, 0.19950589723172174, 0.19540024519749266, 0.1769095030744553, 0.19731137915315133, 0.22130028351319053, 0.18388573038952205, 0.19566415069047927, 0.20855437125223109, 0.19929102182465053, 0.2106902314610255, 0.18941580945094194, 0.1968236111236562, 0.1765416189753698, 0.1848671032893584, 0.20324092955349493, 0.2019136628552708, 0.18087934377264203, 0.7903394357405257, 0.18214719249950095, 0.3861646120807254, 0.7270234492719267, 0.18939155566775434, 0.14526214276693028, 0.1622400747971653, 0.18218665053365857, 0.44837019451734683, 0.1628077476190749, 0.13638665954061469, 0.16031734546100618, 0.1951468103121593, 0.19736022607954784, 0.19697412445628693, 0.1509892285241312, 0.15025661943899982, 0.17510570482933885, 0.20240548745246956, 0.1864690967997189, 0.203637548961751, 0.1985785407703946, 0.18022875769825808, 0.18278843471744088, 0.18278422025435437, 0.16850673331682864, 0.0812008316054067, 0.07606041945063369, 0.09619679656253832, 0.07398600512752251, 0.0679150445761677, 0.08375104889685658, 0.06955942928105774, 0.08434463528034797, 0.0749295474174031]}, "mutation_prompt": null}
{"id": "f8ba5a64-f6d4-4c4d-8c93-549855c67cef", "solution": "import numpy as np\n\nclass EnhancedCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9  # Modified scaling factor\n        self.CR = 0.8  # Modified crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n        self.stagnation_threshold = 5  # New parameter to monitor stagnation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.3 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Updated decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.08)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Adjusted distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        generation_count = 0\n        stagnation_counter = 0  # Counter to track stagnation\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n                        stagnation_counter = 0  # Reset stagnation counter\n                    else:\n                        stagnation_counter += 1\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n            if stagnation_counter >= self.stagnation_threshold:\n                self.F = 0.6  # Adaptive strategy to escape stagnation\n                stagnation_counter = 0\n\n        return best_sol", "name": "EnhancedCoevolutionaryDE", "description": "An Enhanced Coevolutionary Differential Evolution using variable mutation strategies and adaptive population behavior to maintain a balance between exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.24894978230350465, "feedback": "The algorithm EnhancedCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8440896994235983, 0.8270053306934763, 0.8588172475655393, 0.8310036354652668, 0.86098365104484, 0.8652183935011322, 0.8739886523038183, 0.8655950448768905, 0.8657017211210251, 0.32648373332812985, 0.25314192097785404, 0.25202740955334624, 0.36351756400190083, 0.30892925815861116, 0.23636874107876993, 0.2674015809740107, 0.2588776827700372, 0.1499685911246581, 0.1701495451678351, 0.1109708668400603, 0.1644039598952739, 0.13457985831988895, 0.21389252069935805, 0.14590081733663662, 0.11826811629164091, 0.1627313111495725, 0.1385957492435751, 0.1631587874008783, 0.2500796966213622, 0.08811697114113926, 0.13602547796701947, 0.09569774462815361, 0.0961268419718806, 0.16271015333075134, 0.10811974879956054, 0.10978996013516662, 0.9045214046250626, 0.8616308586358923, 0.9036753588106478, 0.8695645333570571, 0.8869678673450473, 0.9160745765152526, 0.918760722620054, 0.8766699509544646, 0.9074610085954884, 0.4508461077612709, 0.2947980867197383, 0.3193809349749277, 0.40532621172560634, 0.43603850688362267, 0.2858835818561485, 0.3056846568916186, 0.34950473453228126, 0.388270156433669, 0.3489498139083804, 0.21779113168418396, 0.24019487017742946, 0.26101119321912225, 0.33556805199222983, 0.18625282411003674, 0.29813634028360503, 0.3738716893576748, 0.36216955999968414, 0.12380265993039175, 0.15278753821700908, 0.1304803915627334, 0.16005596648973575, 0.15712965226310238, 0.1979700607376197, 0.21729526240213004, 0.1453015036179267, 0.1363367770299032, 0.12335126326931645, 0.1747814870785276, 0.17939752185463387, 0.13774802481389414, 0.131265014588678, 0.14216691552103533, 0.1867578745027656, 0.18707483087998034, 0.168039924438808, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05538864656869136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04862385831238647, 0.07650717710369304, 0.08754410752665809, 0.14933210479806036, 0.10380630838534599, 0.04922421724341619, 0.011287721032616549, 0.1969774466639117, 0.1369218959617018, 0.17256764086909915, 0.306723339989849, 0.2624552764500171, 0.0632954124110322, 0.3797686582085956, 0.11423492420560433, 0.14365751977908714, 0.15387411742691948, 0.17139031709465236, 0.14909928315320753, 0.11108578290018212, 0.17729438791646812, 0.042785349724752675, 0.06317051437993837, 0.09404419977039014, 0.18798995803814278, 0.12739762031383028, 0.32716040454265205, 0.09125014225247763, 0.4498870532045196, 0.540369860563674, 0.44177969688936136, 0.45373797992039333, 0.4954204221313381, 0.47420124484330495, 0.4330814924220252, 0.4810213876111594, 0.45821374205668486, 0.09916072233890405, 0.11241475999411721, 0.11797458904704239, 0.11812081969192656, 0.08229492567593844, 0.10606543631297116, 0.09952073232052261, 0.11120853641952766, 0.12348128653818147, 0.14217786845124503, 0.1750092994838044, 0.15188881337973448, 0.17394414093085364, 0.1744938815849879, 0.17411667918237395, 0.17787054490075516, 0.12115757241643843, 0.1609576810805614, 0.31082184264297075, 0.29106205084675074, 0.2375298316110489, 0.2870740468746691, 0.22383493534208387, 0.3408396413808463, 0.2814032208071815, 0.28158336924686855, 0.3046456178383047, 0.24022724794123107, 0.2355229534279888, 0.2940157977065011, 0.17570255144593083, 0.22162628628616343, 0.22560363125976357, 0.23794499585236695, 0.23913503141060122, 0.2067203614100761, 0.18922457812182825, 0.1897607053127568, 0.19839474207240204, 0.20512049839675195, 0.1921360896703671, 0.18623207034559852, 0.1870456639225938, 0.18916459725327195, 0.18030937487776388, 0.17955870372912142, 0.16389028118375248, 0.18401084952652458, 0.1805847227902857, 0.17571863091952344, 0.1979610944800826, 0.1878522443493682, 0.18845398835880633, 0.19441317008017145, 0.15834690988306432, 0.16196782526390374, 0.1712555712338708, 0.1663849765092984, 0.19662810737149483, 0.13023377601246844, 0.20922120656623033, 0.13532160446634567, 0.16354668089632485, 0.15429060249325233, 0.20575834242799784, 0.26013060773384, 0.16607590324382004, 0.19718827374611425, 0.15027945210690685, 0.20264901531204582, 0.20687005902904232, 0.2056622975933715, 0.17349380839669726, 0.18419000265484886, 0.21407987827984476, 0.1947702794522157, 0.1779501945517128, 0.18351562764586438, 0.17555697766926937, 0.17653024053344202, 0.17560463783263747, 0.06885319031312154, 0.08987815283217149, 0.0957384801692962, 0.06777258744352799, 0.07294089055718556, 0.08993597627912331, 0.08755939497290544, 0.07857187164694501, 0.07895926522771368]}, "mutation_prompt": null}
{"id": "649c2d4f-0fe6-4479-bd02-cfe1dd2116eb", "solution": "import numpy as np\n\nclass EnhancedCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability\n        self.global_perturbation_prob = 0.25  # Adjusted probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.7 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))  # Adjusted range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93  # Adjusted decay factor\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.6, 0.6, self.dim) * np.random.normal(0, 0.07)  # Adjusted perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.laplace(0, 0.5, self.dim)  # Changed to Laplace distribution\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedCoevolutionaryDE", "description": "An enhanced Coevolutionary Differential Evolution algorithm with improved mutation strategies and dynamic adaptation for better convergence across diverse optimization landscapes.", "configspace": "", "generation": 43, "fitness": 0.2519990339520724, "feedback": "The algorithm EnhancedCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8339441246909812, 0.8404368522132413, 0.8325384284411914, 0.8313753095527723, 0.8523514602052893, 0.8456832762342311, 0.8358756937951525, 0.8478149710622009, 0.8314591694936696, 0.48298144056778713, 0.4582902860814895, 0.4100171102025816, 0.23272885380497443, 0.3585707591455154, 0.5375674630601821, 0.543719299075209, 0.2527325925112719, 0.17905265745727994, 0.1463068788211156, 0.29576830804383636, 0.14785398897825175, 0.17576202228221105, 0.2878577428786836, 0.1569027903966539, 0.10808716004688745, 0.16988341605594015, 0.15724303306915477, 0.11069993587273619, 0.08809878484251954, 0.14306691180789843, 0.1531670501268202, 0.12911513371237593, 0.15622462767829692, 0.09602291009775632, 0.14067978139210047, 0.16367788836654185, 0.8838686916740564, 0.8797429146351783, 0.8862904533687379, 0.9019685685330647, 0.8981429661524397, 0.9315381073365306, 0.9228666562332835, 0.9031555768116424, 0.8706583193668432, 0.34650325158040207, 0.3450241838190835, 0.4371328238530501, 0.3888665245268459, 0.3411053249934759, 0.36493905855805875, 0.27685469841411203, 0.29053726482348485, 0.29876031293789096, 0.29833153638478593, 0.347459276828299, 0.21656500297610548, 0.4478604589041002, 0.20750431951520953, 0.3181482211204346, 0.2812418851749324, 0.29481955067827526, 0.22729678248131946, 0.15421509077602036, 0.2520275563403359, 0.18402896652313216, 0.15234790435010037, 0.1173167345244609, 0.1204721711286546, 0.1561370993549075, 0.14292293991077654, 0.14250027261242593, 0.11678668902399736, 0.10688739015068294, 0.14138965378778523, 0.1683750378225628, 0.11936167166292999, 0.12577432705349423, 0.1255688416473486, 0.1652801332333087, 0.12830720989244804, 9.999999999998899e-05, 0.010225881604623455, 0.006014329056671319, 0.025782056735690784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04065803503475496, 0.06698856440110867, 0.052031755778830124, 0.1824030038534985, 0.028387434770660525, 0.03661282408610955, 0.021634734019863378, 0.044855633905118375, 0.08367101972369895, 0.07212880089710594, 0.06186280659636645, 0.09221027206850596, 0.04224915771035176, 0.13398790461749088, 0.019055429239769217, 0.17658834969750492, 0.10422460746696394, 0.12938425457829839, 0.22825307889333823, 0.11899640468774308, 0.06647607411913015, 0.1425635376956108, 0.20138077536524768, 0.13566239790775958, 0.05661405635707428, 0.17632541875233487, 0.1510541384942149, 0.08367608169174767, 0.4426743336149568, 0.4891640631386436, 0.4395358966323072, 0.4665483382134987, 0.44514036351720365, 0.462719839703313, 0.48148770748594527, 0.4861767310666558, 0.5306502429871662, 0.08976341164349111, 0.1330612246544104, 0.1262675091885629, 0.12219574315693338, 0.11598912474467993, 0.14729552418627723, 0.10771657838817028, 0.11523450266315338, 0.09432784115355186, 0.19505215321841218, 0.15480373533593061, 0.21740893134041017, 0.13738949996694683, 0.17835542069617605, 0.18086136305847422, 0.13165090344682706, 0.13746103930459197, 0.13348746769082243, 0.3455858510669918, 0.25281223385743545, 0.2894888458733865, 0.3092525730053055, 0.2445012266096681, 0.2880998392791241, 0.29445067163002037, 0.38885581556118354, 0.3425135332880881, 0.25321976207653096, 0.2148050942771974, 0.2490473997960495, 0.2171667164907214, 0.21829617382575084, 0.19777572691646528, 0.24447527565689864, 0.19635105098575856, 0.20204501741324166, 0.22096650894411896, 0.19318378547767345, 0.1744270871431619, 0.20464660551221414, 0.17124247380864177, 0.204929380394403, 0.19900145236384803, 0.19278498618287887, 0.161984884185287, 0.2050318679678097, 0.18756237353001914, 0.18961364927694047, 0.19223027526211045, 0.20307728447038076, 0.19721559093983876, 0.19152871837545138, 0.1928235221108615, 0.19315193651967277, 0.18879762385559584, 0.14628361266731804, 0.19853911525404566, 0.43363860891684336, 0.7090688179352775, 0.15910055401426748, 0.1588445142636873, 0.15293152706536273, 0.16455677651420209, 0.16265490831188312, 0.162644922471751, 0.26591537977370094, 0.19955366754556358, 0.313661607385344, 0.20110319630382556, 0.15791114104137427, 0.1363952973754926, 0.14156209386637797, 0.17393597972055652, 0.18057951512988024, 0.18168712686359856, 0.18114341261412648, 0.17503231142252829, 0.19763142572101655, 0.1774729074039395, 0.19510753951512982, 0.17109798693807865, 0.07982497391152354, 0.0805131156871225, 0.07986920163384525, 0.07364586959356967, 0.08633178671864483, 0.07318606146213191, 0.08120897810944006, 0.07464905345723494, 0.07624668956170977]}, "mutation_prompt": null}
{"id": "56a92c7c-5e29-41b3-84b1-8fc5896064d0", "solution": "import numpy as np\n\nclass QuantumInspiredCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.5  # Modified to enhance exploration\n        self.CR = 0.7  # Modified to enhance diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Adjusted probability for more frequent local search\n        self.global_perturbation_prob = 0.25  # Adjusted probability for stronger global perturbations\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))  # Revised adaptation range\n\n    def _adaptive_F(self, generation_count):\n        return 0.3 + 0.6 * (generation_count / (self.budget/self.pop_size_initial))  # Revised adaptation range\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Modified for a more gradual decay\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.03)  # Fine-tuned perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.5, self.dim)  # Enhanced to cover larger space\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredCoevolutionaryDE", "description": "An improved Quantum Inspired Coevolutionary DE algorithm with enhanced adaptive strategies and a focus on maintaining diversity for robust optimization across diverse black-box functions.", "configspace": "", "generation": 44, "fitness": 0.23228435210647153, "feedback": "The algorithm QuantumInspiredCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8149477717380574, 0.7938735618455152, 0.8427749228328153, 0.7969315858450781, 0.7272254203088269, 0.8296352181829106, 0.8336406404811579, 0.779896023340211, 0.7439205373658206, 0.4200181883448818, 0.3686861762568424, 0.4146523183637567, 0.3453755204758935, 0.31453894416471895, 0.40718718383020647, 0.23807109209903643, 0.33293506307392295, 0.34342993236336783, 0.32578864728405055, 0.1410662064710434, 0.163938350681625, 0.2616445864229757, 0.09243208563882777, 0.11306240994713312, 0.13642043785563052, 0.11869465901986098, 0.1513648525031307, 0.10959482516028651, 0.09061356436008794, 0.12645212750055235, 0.11408354151134226, 0.11219345753157017, 0.10282068255509091, 0.10298473066448899, 0.050576168446539116, 0.061122474281567474, 0.9190087202512538, 0.8808752345961501, 0.864888295710537, 0.9310448679162543, 0.8908336979542046, 0.9115479072935221, 0.8893678408928585, 0.8967855090771966, 0.8542630633841171, 0.20188912020117367, 0.19321018600680262, 0.19068506923131567, 0.21339758220174054, 0.24404261449625286, 0.18281949432538602, 0.14860719573167858, 0.21413428591923134, 0.19027252512239068, 0.20846465325964003, 0.3145771456775429, 0.16686380671743828, 0.17371663634383516, 0.26769038324747485, 0.19108853471932563, 0.21032845749127438, 0.2035680441065948, 0.18334435508372804, 0.19666522487517113, 0.1933010141539031, 0.26205933257709557, 0.1572632248267981, 0.11868148035441606, 0.1384109047959271, 0.13780753937709, 0.13709880203715197, 0.14592915852580968, 0.16180428009509173, 0.13924170612362885, 0.12154987298503239, 0.15781219008328684, 0.14823184724072835, 0.12093062362398654, 0.11992088336487627, 0.14302521421067993, 0.14783179680762804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0777697475339979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08360770241156512, 0.06718649172912283, 0.06629752015358226, 0.031573950019522234, 0.02910673828048982, 0.026504126140897144, 0.1563620881807023, 0.0906352553591101, 0.13366744217927184, 0.09782980050087986, 0.22674657970813128, 0.148650751624945, 0.32762495991537255, 0.2190418786642545, 0.11116415010497716, 0.11659655178899853, 0.12099123173427484, 0.0761892615594455, 0.2298887373847438, 0.20445277591168365, 0.19860842661473366, 0.03412616113451061, 0.08641325089097951, 0.14185629908223696, 0.13296289736635003, 0.11085704553177111, 0.2409408534965064, 0.4577950314415481, 0.4403677364731029, 0.4997707524991949, 0.41827200276736753, 0.4007869269971094, 0.45440972114298084, 0.42115565048359016, 0.4025737135272792, 0.4408772292785612, 0.12464676346117975, 0.08247049927377648, 0.07962671565832169, 0.14241302547751733, 0.08027087149031087, 0.0766767076935968, 0.1223708740270949, 0.09476286799982159, 0.11469882514766983, 0.14097948226650692, 0.15933038010313738, 0.14369604050651685, 0.1385763411108053, 0.17123916465050426, 0.14718741050455464, 0.15598877486425977, 0.1674189965463374, 0.21040584637098103, 0.20424693889056078, 0.2142861087861263, 0.21840159247403423, 0.26117792313498556, 0.27257628059557004, 0.20613620793766563, 0.21715963368614621, 0.29884925087891945, 0.18635299023742924, 0.16051678954409687, 0.14067622909444888, 0.20948013763229822, 0.16845145192362287, 0.14835216469803636, 0.16798657303717224, 0.20293652213562652, 0.20673234891056969, 0.2077324174408326, 0.22552362458767572, 0.19630749695478023, 0.23898427931502164, 0.19626876426568818, 0.17290023151957068, 0.19243314621570606, 0.2165510681110816, 0.1994296192613252, 0.2170805201794871, 0.17584104875009465, 0.18928765574390705, 0.19094418618156583, 0.18883420962841535, 0.17988635626616978, 0.18954049205640588, 0.20134065391481404, 0.19060582237341528, 0.23808466636118153, 0.17905703153697794, 0.18378252224989555, 0.15044398645357238, 0.36431356472794085, 0.17384204106563172, 0.1961550549465776, 0.1831795504276259, 0.14618269074650647, 0.15699443812732006, 0.15276287279570622, 0.17905519749076393, 0.30256886811731565, 0.1546527647684216, 0.20002885413914095, 0.19520597617418411, 0.1293129951332277, 0.1266928833539065, 0.2005041467963734, 0.1824074583136599, 0.18217337563483427, 0.18709751145778797, 0.17407864108401339, 0.18229681402883557, 0.19589259658976388, 0.1933189414467824, 0.186478609920539, 0.19499652829443104, 0.0810841164314059, 0.08114426587376511, 0.08209072648796478, 0.07241826700432341, 0.07638128203167194, 0.0861066885717442, 0.08437589831716263, 0.09811692713446951, 0.08163530606642944]}, "mutation_prompt": null}
{"id": "c43cad5e-06a6-4230-b13d-a845c86ee4e4", "solution": "import numpy as np\n\nclass MultiStrategyDynamicPopulationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35\n        self.global_perturbation_prob = 0.25\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.5 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget/self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.06)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "MultiStrategyDynamicPopulationDE", "description": "Multi-Strategy Dynamic Population DE, a hybrid differential evolution algorithm with dynamic population control and adaptive parameters to effectively balance exploration and exploitation across diverse optimization landscapes.", "configspace": "", "generation": 45, "fitness": 0.27816953325490135, "feedback": "The algorithm MultiStrategyDynamicPopulationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "f9e51b6b-8b81-42b9-9b97-1795ab39b228", "metadata": {"aucs": [0.8751570061965577, 0.836788261701475, 0.8490062509015651, 0.8670487894343194, 0.8621987254999349, 0.850735682262722, 0.8166867833206943, 0.8259334984643587, 0.8496933037384534, 0.0951976712123409, 0.6949973599512204, 0.3982286472230495, 0.297159362391881, 0.7239355897680315, 0.48086129239704367, 0.2925380055638155, 0.5926028638166743, 0.2651650606958801, 0.15098144303262873, 0.10615176658291436, 0.11527831330317784, 0.11182385690559071, 0.151028638402798, 0.12819314073255572, 0.11285745292889893, 0.13456014573084996, 0.6853303395026134, 0.10512287823081656, 0.13429558200683478, 0.09592249119082064, 0.10409500559442109, 0.13276146874998618, 0.08410421581282823, 0.125360494773619, 0.1712036604708459, 0.10916604923836803, 0.9164426965645703, 0.912086117223359, 0.9238476089310176, 0.9482220083998995, 0.9124634551458619, 0.9132931754088377, 0.9159702176505775, 0.922320216784549, 0.900700359680645, 0.2695450226525028, 0.25103559275090337, 0.3997737316247715, 0.3580014858448386, 0.3820227040515849, 0.3914798496732079, 0.3732647634364116, 0.3037761478117027, 0.2922362938936637, 0.3642298548385664, 0.29489711138611385, 0.36121103192270443, 0.8123777978115089, 0.20422047091161055, 0.8572462438957629, 0.25351939530545764, 0.211339256564947, 0.3179842310206339, 0.1930059097767879, 0.20775707360203954, 0.22004488621315277, 0.21569620596051764, 0.1465318513751961, 0.120309840892873, 0.14262638856607646, 0.12316442032501307, 0.12542812807316073, 0.21889388840134416, 0.10638883370551844, 0.14777507932939404, 0.20778924882339433, 0.10986522758911765, 0.16431911611269479, 0.15725162014083272, 0.12036607949973244, 0.178321618967342, 9.999999999998899e-05, 0.011020153633583663, 0.0334836643208839, 0.047473630469347716, 0.053575860099610906, 9.999999999998899e-05, 0.03498152798896681, 9.999999999998899e-05, 0.012554809525364363, 0.07481181129636627, 0.06790128195285794, 0.09447569787656995, 0.07326621366280728, 0.05528129093225964, 0.03015598376628459, 0.09037405999816239, 0.12806678852038222, 0.0681459032574252, 0.19870786957208375, 0.13024790427100275, 0.049539707416712764, 0.20106855424206826, 0.08231686889253798, 0.24736713535933774, 0.15095441852528635, 0.1476803175388568, 0.18619649659024629, 0.14557597010009138, 0.13208522029336767, 0.06394579310022164, 0.15723840871262873, 0.06780873422321021, 0.0518461066256477, 0.11304717494987804, 0.12083825775184143, 0.09925547341307772, 0.49315790619523525, 0.5291795215618911, 0.4685244009192454, 0.513973338787992, 0.4708349380255168, 0.55056561521837, 0.49744059816033215, 0.43402339593841577, 0.5445462617588149, 0.1387510899058092, 0.09167687069755726, 0.11684908141531014, 0.11944966318477013, 0.09776387034800227, 0.12339385905100497, 0.12175461069614679, 0.17283395053392192, 0.0890595487474839, 0.14994583346286983, 0.23184638539408586, 0.17149502684148155, 0.19403431647851654, 0.2179181215996825, 0.13995416907607083, 0.16581690556597872, 0.19330555640557068, 0.1551140279664872, 0.2461518018364307, 0.35388998673695926, 0.24852271906133705, 0.305898765809693, 0.3854938439123623, 0.29519924278965104, 0.3331440323315036, 0.3005930062833785, 0.3025944693893796, 0.18570845086498933, 0.275970597997246, 0.2091618251700842, 0.23642343105809105, 0.18064200822923593, 0.2717731985567008, 0.3001074689029264, 0.2295095978646824, 0.22586038165367994, 0.19098066411920844, 0.1710646066583007, 0.19928406952049127, 0.1875616339962527, 0.19264083323150827, 0.17678228310009814, 0.18150630635904097, 0.1938551683423957, 0.20635076800264784, 0.17576298814818836, 0.2081105477360825, 0.19020439756379093, 0.19265786032177878, 0.183757335334629, 0.18174755757351235, 0.22005162190143812, 0.18212805246205577, 0.18007590401965934, 0.7677225788313469, 0.19735279699580965, 0.6271463290317935, 0.22464346621796583, 0.8441275866747063, 0.19684680546205213, 0.7748577687975619, 0.16711110414984032, 0.8250797146257153, 0.3651186853987004, 0.20598594203217757, 0.1233062424419451, 0.37501069932600783, 0.204655884004181, 0.44096982774090443, 0.22286204470695703, 0.15019804992145036, 0.14773720844786398, 0.19355373515025653, 0.18762299920040026, 0.18358667990988575, 0.17883480037528277, 0.17857887535215633, 0.17846395172501184, 0.18713377730393743, 0.18959968068138744, 0.2186653090800712, 0.06990721591417293, 0.08103622819700718, 0.07346311713597553, 0.08839384888285584, 0.0907619583844469, 0.07418874181926316, 0.08431349613319816, 0.07620768702376879, 0.07239561005670114]}, "mutation_prompt": null}
{"id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Adjusted F for better exploration\n        self.CR = 0.9  # Adjusted CR for greater diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4  # Increased probability for local search\n        self.global_perturbation_prob = 0.2  # Slightly decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Slight adjustment for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted Differential Evolution, integrating adaptive learning rates with quantum-inspired local search to enhance convergence speed and precision.", "configspace": "", "generation": 46, "fitness": 0.29263639444249967, "feedback": "The algorithm AdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "c43cad5e-06a6-4230-b13d-a845c86ee4e4", "metadata": {"aucs": [0.8401834431641492, 0.8346590961296124, 0.8355072186109646, 0.8376689416710098, 0.8120798120413495, 0.8448928378631488, 0.8405261495406384, 0.8345936276818441, 0.8350593403376865, 0.5360770807734994, 0.6850294957626553, 0.7470652326119098, 0.6622131747774875, 0.2371286309602545, 0.43788833167174934, 0.3740902924075855, 0.7140024175058718, 0.37908246139802115, 0.14139908127792844, 0.11444058400102386, 0.1444672816910012, 0.14715134142219122, 0.14434792837663812, 0.13813380677891596, 0.10910956861822174, 0.1487413030030077, 0.1429430178262412, 0.10655684737894955, 0.10514638232136386, 0.14499556682546155, 0.12402013447603655, 0.14382190042092857, 0.09134967501182267, 0.11246612260796773, 0.10978886789591213, 0.10495196611871838, 0.911738813438452, 0.9017660765748203, 0.9061682525173397, 0.9214549823700747, 0.8964254178902765, 0.8840885216674402, 0.9027108664334987, 0.9336971974782017, 0.8840073033893617, 0.43604410431425655, 0.42623124037432036, 0.39183098915623704, 0.45628797127505727, 0.48434194901133587, 0.3222982975823897, 0.3909128871747335, 0.3894650679260969, 0.45036934434689013, 0.3630250868955701, 0.5340804025791996, 0.8434601369669954, 0.26450760335398205, 0.18566992951526007, 0.2100341028397693, 0.21808631714358717, 0.37287246446774924, 0.7894760701984543, 0.31385596086619294, 0.19210150339434717, 0.15326757052076168, 0.1689841804116573, 0.1504410711872115, 0.18372979655688193, 0.16352724035564659, 0.23658894161486055, 0.15078619626690293, 0.1810200607850081, 0.1993621681545601, 0.1900518699797964, 0.1266347097228514, 0.2271156900413921, 0.16649050908406593, 0.20043470020986764, 0.17341826039850783, 0.22434328068485765, 9.999999999998899e-05, 0.0053312953860726875, 0.008646795455644729, 0.03990893745669377, 0.13101889116533771, 0.06521658647344541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09882850609415039, 0.07058018037916447, 0.06376549943252396, 0.08370541554926691, 0.04061375678448109, 0.05471382573211814, 0.18613944593872933, 0.10343641917492064, 0.16999775276658924, 0.06434988909352579, 0.05311073063261951, 0.11635406505745671, 0.1621851318810109, 0.11065236922109267, 0.14992548378846426, 0.10960961999478114, 0.12609701456435485, 0.15298639130192115, 0.15004334138325826, 0.138392295344955, 0.1370213686259525, 0.08930493829231767, 0.15292897808447903, 0.19616610129199386, 0.10029073277254774, 0.14702902061357326, 0.14874878869556474, 0.5150217698929365, 0.48959965919462334, 0.5562321516788449, 0.4686593405368691, 0.4715921196779165, 0.46688102598017345, 0.5078920047272408, 0.49323287774921487, 0.5006529966451121, 0.1495315886666263, 0.08147480835880472, 0.12847309032051457, 0.09925740972970742, 0.11144077579918243, 0.12804137608587007, 0.08791877990029862, 0.08066472749533327, 0.10374047846571066, 0.27585750206714754, 0.17079806182964696, 0.18884814865623034, 0.21580145120568472, 0.13649003078198219, 0.14433180825255276, 0.24849775102407745, 0.17040934369066585, 0.17798873662556292, 0.26890461033931246, 0.2680393488128766, 0.3443633461995136, 0.35227085919969836, 0.3944802646802399, 0.3353832153719213, 0.3966851660159755, 0.28207888549864824, 0.3840214984583592, 0.1947976156394562, 0.28295763616514935, 0.2046253175096262, 0.18702707356269344, 0.2035405803677185, 0.19353370345084586, 0.22191873307822563, 0.2472703280667431, 0.22672561524028656, 0.17621332275590262, 0.20436235196596708, 0.19342706896853756, 0.1862793797815402, 0.1754830840774957, 0.20133212386075205, 0.17912756386867645, 0.1832884620588775, 0.18907558858771023, 0.17085343767215722, 0.18901262555428622, 0.2205012813553825, 0.6041400291209742, 0.21725997855195778, 0.6165851682688048, 0.1954536871306919, 0.21047690409763598, 0.19095292722561308, 0.16818453809578715, 0.736213640155504, 0.8285559116642037, 0.17308680905594742, 0.19113482826387573, 0.15969203592130632, 0.8357312312008385, 0.8308681246417945, 0.804817880541514, 0.4306640319186459, 0.46695371350691306, 0.1987015488540299, 0.48671760941185216, 0.15996254599769233, 0.12404254893197009, 0.1257642636960571, 0.3897521393812392, 0.2056603417237618, 0.18369351633887987, 0.17187384184531607, 0.1780602611016462, 0.18727106735047316, 0.19982851777788324, 0.18523637539176918, 0.18005831626418878, 0.1846641686838678, 0.18974436282206197, 0.08390679816211377, 0.07912359203230557, 0.07006584520149595, 0.07381932229987032, 0.08511693742808124, 0.07762404518202237, 0.08235472393872756, 0.07218078451965271, 0.08427274617036984]}, "mutation_prompt": null}
{"id": "10be4a06-30e5-42d8-8ea4-6741199104a1", "solution": "import numpy as np\n\nclass EnhancedQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for more controlled mutation\n        self.CR = 0.85  # Adjusted CR for balanced diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.65 + 0.25 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted for slightly faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumAssistedDE", "description": "Enhanced Quantum Assisted Differential Evolution integrates adaptive crossover and mutation strategies with quantum-inspired local search and greedy selection for optimized convergence.", "configspace": "", "generation": 47, "fitness": 0.28634511711579425, "feedback": "The algorithm EnhancedQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8676820141221215, 0.8501412386348076, 0.8705785762732017, 0.8809472829421625, 0.8563931963961992, 0.8558899602316342, 0.8914346284750886, 0.8764033453812528, 0.8794602271132747, 0.42945990032966275, 0.5295848202995271, 0.5145665326661676, 0.6596428156215669, 0.4508948073926937, 0.4899209144467769, 0.5081033521491181, 0.4375681601109418, 0.5597719862354522, 0.12077326723889914, 0.11941420889777088, 0.17172343383413868, 0.0943610660471158, 0.1499691428811316, 0.16142304158706033, 0.17112005146033493, 0.17591416160511053, 0.17306490973048527, 0.12601664224035503, 0.13060119179425123, 0.0773493279546883, 0.12367593022543788, 0.12622741124707304, 0.09546386277484376, 0.08994254444339744, 0.1256111022401889, 0.16771193335409862, 0.9232052262915571, 0.9073260850294471, 0.9437492606887681, 0.8987750632895616, 0.9329544419009861, 0.9370541690987626, 0.9423274761242015, 0.934520133553451, 0.8900822013157588, 0.4017024025302739, 0.47951421022671525, 0.44079743401164717, 0.46631553087978606, 0.4870092988527477, 0.4432215435598158, 0.4058238437666498, 0.43069538473680624, 0.39133929547251844, 0.8332658428279267, 0.3656894067789467, 0.21942783886522488, 0.2714127168334294, 0.321330319684052, 0.8188695693870821, 0.8588304164292675, 0.35827580224984057, 0.2362183145510348, 0.20463539211860848, 0.12364827003078349, 0.16396399459428557, 0.14894845156920777, 0.19622888721916554, 0.1898212971817641, 0.1876072689596272, 0.12520513350553297, 0.12781379402981652, 0.186980356170939, 0.20379753729011618, 0.12507191148644525, 0.1267918055680386, 0.1284178163464179, 0.16347221084017127, 0.21315336510128668, 0.17600673829238944, 0.1770102925473952, 9.999999999998899e-05, 0.04812662767828224, 9.999999999998899e-05, 9.999999999998899e-05, 0.004403103639306738, 9.999999999998899e-05, 0.028295392095537997, 9.999999999998899e-05, 9.999999999998899e-05, 0.06420929809242648, 0.035412921746146075, 0.058827101916573366, 0.10692718191580475, 0.08327719715660475, 0.022979479809864145, 0.11733838150473896, 0.1851899765898828, 0.09493399186538864, 0.042879061806726404, 0.06267116977030707, 0.04493467783798821, 0.14505385634295254, 0.12473745315244211, 0.13484608931223574, 0.18631253378850055, 0.13543815444956164, 0.12051984867889809, 0.1564945639637002, 0.20861721313501946, 0.19481390429961498, 0.15196436755796783, 0.1727571924853295, 0.10493342187704324, 0.12542623891013027, 0.1383423526869012, 0.23970330551360797, 0.48588091372801623, 0.47059603904673664, 0.518399749843439, 0.5487407711745769, 0.5269916484633596, 0.46201814874439007, 0.48767897656183234, 0.5650901902894889, 0.5202338556050516, 0.1226051248589336, 0.0986429028975001, 0.12568044614169194, 0.1747157194854253, 0.1636416834067932, 0.10588670363531949, 0.13154214681816634, 0.10367358963071127, 0.08758581129574927, 0.16046437689214632, 0.19048877487571403, 0.14825995652786828, 0.15725851612399433, 0.16192675846693982, 0.12792289888686537, 0.16906288657870805, 0.21021843097247073, 0.1667503672037901, 0.30222784124935975, 0.3601664551176553, 0.35286739658845745, 0.40409270373300965, 0.3511208827281803, 0.3127034781262378, 0.44081870082707286, 0.34144307062660995, 0.24213794063255112, 0.15957489724381635, 0.17585543848231588, 0.24311415743271303, 0.168864008203499, 0.2559975897893364, 0.24547772781165245, 0.28700777481211537, 0.29931782491315706, 0.2140982145545619, 0.20144283895515747, 0.23644519747037807, 0.19111397140248187, 0.2128257454532393, 0.1859226596991137, 0.18025618890961237, 0.2315562733734824, 0.18600008005191127, 0.19602197085132778, 0.17930293504464812, 0.2426769425741928, 0.16944859993723638, 0.19587942228698274, 0.20767548362994626, 0.18733203309171154, 0.21044300883552847, 0.22011010062478098, 0.21195618445518072, 0.1837364826647121, 0.15460131996679938, 0.8062802948385943, 0.8965339848638247, 0.19350716535468304, 0.17442836554706043, 0.637711665588616, 0.12825493748256722, 0.13132833664694643, 0.2064384370345822, 0.19986069708276388, 0.16532419796822506, 0.8692932298508974, 0.16305516588192892, 0.1251309855560705, 0.20537767343565638, 0.34582900854466825, 0.208846137025266, 0.18757888502518283, 0.1714193994289417, 0.19099163182111156, 0.19201705201582286, 0.19139731993365905, 0.17835500193467035, 0.18032587032149672, 0.203977173033155, 0.18266042077066225, 0.07305398719648981, 0.08062345336723842, 0.0833720405370123, 0.08784059329138039, 0.0870611733822787, 0.07539755016089733, 0.07420876754286998, 0.07948820125177358, 0.08190476324240004]}, "mutation_prompt": null}
{"id": "b41ba108-7bfb-430f-b5b0-663d4d03ebec", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration-exploitation\n        self.CR = 0.8  # Adjusted CR for improved convergence\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # More aggressive decay for population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.2)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Lower variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n\n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n\n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n                elif np.random.rand() < 0.2:  # Fitness-based selection probability\n                    new_population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum Inspired Adaptive Differential Evolution with Quantum Tunneling and Fitness-based Selection for enhanced convergence and exploration.", "configspace": "", "generation": 48, "fitness": 0.1824301068313829, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.37635014278983747, 0.40348533034924905, 0.4509378031180634, 0.43104787019278623, 0.45795535133026977, 0.4309987874618677, 0.4014740452436335, 0.47818888357778466, 0.4196035784368083, 0.01418500998164296, 0.057965832937346584, 0.02396239731510308, 0.010313334366301219, 0.01411211866887463, 0.014060148238053238, 0.029639983745075593, 0.1030621271903377, 0.10490583359825434, 0.09840088266389524, 0.09272190929634694, 0.11496917665307715, 0.09969970768311887, 0.1230947369428872, 0.09831957123889457, 0.10581149910949839, 0.09777970189128227, 0.09357909642616213, 0.09272579731573716, 0.10162424589676744, 0.10573446209771342, 0.10282694297498307, 0.09295836358961573, 0.09346778032108383, 0.07038270215846021, 0.0841372782982922, 0.08227144149291721, 0.8953923045517744, 0.9127049832111949, 0.8996036488210701, 0.8786148122598652, 0.8867371031347413, 0.8846959476159467, 0.9039189972389763, 0.8910837866218007, 0.8996832218712333, 0.1699827820830444, 0.20470033498081286, 0.18818335081190152, 0.18118163209279592, 0.17759446006353918, 0.19149474630711305, 0.1631543069454836, 0.15225386843151267, 0.15928873248529563, 0.20789613522783335, 0.10788586019922441, 0.20789476999409595, 0.21491022774130086, 0.22030666396987197, 0.33587154323479695, 0.17179531764396938, 0.19858625450475575, 0.24131553755581914, 0.13264366355460155, 0.1450227773372602, 0.120629214612195, 0.13266158777485149, 0.12168969085890025, 0.12988521588635327, 0.12659359749995513, 0.13869604323789486, 0.1419337014290002, 0.07378109354583284, 0.12385704316105461, 0.06870972524394969, 0.126973027803997, 0.12490430029020227, 0.12226595125853423, 0.1357513651623916, 0.12682234476443321, 0.12220988454400716, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0791771651267138, 0.041506079965172415, 0.05299274727888392, 0.03003943549688426, 0.02155058264067633, 0.06443461762573499, 0.04512331812097636, 0.042278264341590543, 0.11108381178160709, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0516189623744755, 0.07471602839881974, 0.09062418130505012, 0.07952127742034076, 0.08406548467328179, 0.06809666819233229, 0.07133643355769803, 0.08544294588428314, 0.0914535158897215, 0.39230648337727203, 0.34398677289328283, 0.3939618707477025, 0.39407225262475, 0.42909437666021977, 0.41175109122997355, 0.375987284931092, 0.34820824930663197, 0.3462215009163261, 0.08725950734317978, 0.07332908659712789, 0.0783828318167834, 0.07189615960673768, 0.09099836052408627, 0.08243810974364418, 0.07938622189005895, 0.09136391540602695, 0.08696533351784097, 0.14667314689056898, 0.12854762491795624, 0.3111903633762575, 0.1332854369602774, 0.15265495373578974, 0.15764745731059315, 0.19439410496024667, 0.14329647445749272, 0.15055024519217108, 0.23081617815235067, 0.2526909024500853, 0.24083921611304937, 0.2651458951806134, 0.2164481675361517, 0.3098114483195472, 0.21496789212817635, 0.26899927638740195, 0.21173122021386215, 0.17654665491732757, 0.15523805707958704, 0.20892448348924553, 0.17508771687112712, 0.2035101684353634, 0.2041387403327689, 0.1784280032997787, 0.18218054761734848, 0.15403759520903737, 0.1970802262008775, 0.19675727758060857, 0.18607183894281987, 0.1786644852705298, 0.19596889857932098, 0.1985083914022996, 0.1820330339865689, 0.1989713412731744, 0.16310308996016754, 0.1698107863122179, 0.17936269906565538, 0.17140372007106908, 0.17344146148061923, 0.1867957541066224, 0.1794826245599468, 0.21129795749103764, 0.17389910261890895, 0.16860639743499595, 0.16643920575382887, 0.17256210346304413, 0.1691959300879522, 0.1557310110322342, 0.16265558425569449, 0.16072869115706379, 0.19524825672183643, 0.14916076850692317, 0.1670805467260943, 0.2606851873316197, 0.16564158382883432, 0.45372666909286685, 0.19814755273941165, 0.13489338082653135, 0.2036759185389344, 0.11952147121479173, 0.10291285906610081, 0.20392599783799625, 0.1762880926021848, 0.1761916533438822, 0.1713508548286894, 0.17940456788114056, 0.17309545394778125, 0.178187100041156, 0.19366269588881146, 0.18976217576960486, 0.2062916299925579, 0.07954770658573906, 0.07755084566019199, 0.07211445625833035, 0.07271896244251619, 0.0660663812182738, 0.0581008062680487, 0.06940474656579987, 0.0737182425291043, 0.0714865663373293]}, "mutation_prompt": null}
{"id": "a69e722c-ecdd-4df8-bf4f-dd237746cad4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Base scaling factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4\n        self.global_perturbation_prob = 0.2\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        rand_factor = np.random.uniform(0.5, 1.0)\n        mutant = np.clip(self.population[a] + self.F * rand_factor * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * np.exp(-generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * np.sin(np.pi * generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Increased population reduction rate\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.9, self.dim)  # Enhanced variance for diversification\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveQuantumDE", "description": "Enhanced Adaptive Quantum-Assisted Differential Evolution with Dynamic Scaling Factor and Adaptive Population Reduction for Improved Flexibility and Convergence.", "configspace": "", "generation": 49, "fitness": 0.2409931965643265, "feedback": "The algorithm EnhancedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8877080948934105, 0.8841733761312893, 0.8107516320428754, 0.8532514207486881, 0.8464972462709258, 0.855337935508756, 0.8269580337228924, 0.849012185686165, 0.8845968437897065, 0.06098724857840243, 0.10482888316366679, 0.15956734734774158, 0.1197933867633959, 0.07246255195806084, 0.18094482154905778, 9.999999999998899e-05, 0.10693704055110265, 0.03807485224441409, 0.1321559144139366, 0.14168025279807206, 0.15310997500590295, 0.16805861652507315, 0.13743298607381915, 0.12680965796676968, 0.104868439344036, 0.14338837710245356, 0.12853566723594156, 0.11644187428372677, 0.10581656160112962, 0.11075099617103368, 0.1120976330661222, 0.1520406353518129, 0.15408391363536356, 0.09242428321372376, 0.11656290637104116, 0.10879907824315194, 0.9316553307716077, 0.9213803024874812, 0.9141462607535255, 0.9393742315237718, 0.9326515102702595, 0.9129619624226315, 0.9399274806349006, 0.9553264060722825, 0.9534694285344588, 0.2590786326905973, 0.24136227380334196, 0.2591024965638782, 0.4743386165546596, 0.36071599818466515, 0.2976201942986534, 0.22510366718320762, 0.35645023556577626, 0.40108460077657315, 0.22430983568650464, 0.15697673211423957, 0.1629795759197341, 0.20985183836715438, 0.2716339742256265, 0.21086675172842073, 0.17380194862532894, 0.38771357904143344, 0.22761650210405238, 0.15247906322324523, 0.17620286276406094, 0.11933431693638996, 0.12594148360122803, 0.12861338422916357, 0.21929780143514443, 0.29045668328549024, 0.18603252081089539, 0.16514391848113774, 0.13257970099079808, 0.1312407720232781, 0.15044478066252398, 0.20887781356404167, 0.13829741045855048, 0.2385086361733998, 0.13660161861083198, 0.10220018008216014, 0.15229838261724638, 9.999999999998899e-05, 0.018940074225075487, 9.999999999998899e-05, 0.0033584901152293734, 0.001259772943870252, 0.04504508197569845, 0.012717979720392791, 9.999999999998899e-05, 0.03516312418367906, 0.08292238218118964, 0.10562997582889677, 0.09523018834651098, 0.08198888167640417, 0.06440414684032125, 0.03573502095866965, 0.06284149706390907, 0.039445126900301664, 0.06543886482535566, 0.22805109834389992, 0.05068270364110561, 0.0992642346561956, 0.17612701807083664, 0.15020065037991603, 0.1250555589048492, 0.10404421913721762, 0.1027149393673884, 0.2000637286012349, 0.06385118445500904, 0.17630198558198518, 0.1498991931828908, 0.0590270719917928, 0.13811507879778928, 0.17581932653875754, 0.30130205021201883, 0.08609743038668982, 0.20768402613690828, 0.5248125650527896, 0.46486682718676, 0.48812071008828306, 0.5222323757441905, 0.4880265325987093, 0.4456431077831974, 0.5290597247476159, 0.4976617550342204, 0.45554426636015366, 0.11119079101875318, 0.09971440004309351, 0.1402412648436986, 0.10357772520205, 0.08162902476402345, 0.11940459512535873, 0.08313474301216606, 0.09670017911143225, 0.09834612308073098, 0.1357037754735977, 0.1612532734809422, 0.14817283194049846, 0.1263660921257881, 0.1614006106808552, 0.12815462668156674, 0.1611900507242643, 0.1253802195032716, 0.17460597595550753, 0.21439122341943218, 0.2448473551991468, 0.20434404224748537, 0.31684016216941147, 0.30153298712116816, 0.246717675949082, 0.19157137026662896, 0.4026704303999732, 0.38267387639993444, 0.23346940232154068, 0.24297970268515778, 0.2855350694198504, 0.250641336136434, 0.1992726536010333, 0.21297307291284195, 0.35891024311197994, 0.19485106447985423, 0.354865394494816, 0.20244734734997805, 0.20085835066109325, 0.20458473187966497, 0.2220261801744432, 0.20346445482761766, 0.18539360678429317, 0.184457681293832, 0.1987001113852116, 0.22073554104088255, 0.18271977344221646, 0.18956602879828066, 0.2344179807103295, 0.19246726512355383, 0.19362769769146382, 0.1683254600783597, 0.1930731566655891, 0.213298530299043, 0.19357378135539616, 0.1613600937789903, 0.16180787701348076, 0.5182622717388783, 0.2654300786848346, 0.14287028822014813, 0.740160164831891, 0.16860774472477658, 0.1636625571217104, 0.16303840105751843, 0.23858354676275573, 0.2560667940737946, 0.15170230422840392, 0.16665635957741975, 0.2255275816073843, 0.17456817937735725, 0.11027281887317075, 0.1502259471627727, 0.2044559858621281, 0.1778221221812133, 0.19601175252049474, 0.185765200816559, 0.1724470293532031, 0.18552598675765408, 0.18347304293405997, 0.17764689051779536, 0.17429338448839193, 0.1849465991986654, 0.08567180886999959, 0.07756148388276618, 0.07745840276908256, 0.0887837343370822, 0.06668286918860267, 0.06800627656738256, 0.08634667495045234, 0.07971016529924768, 0.0803446569239128]}, "mutation_prompt": null}
{"id": "d17ffba6-08a9-4e58-a72e-8f2e41053b2b", "solution": "import numpy as np\n\nclass QuantumCatExplorationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration\n        self.CR = 0.85  # Adjusted CR for enhanced recombination\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Reduced probability for local search\n        self.schrodinger_prob = 0.6  # Increased probability for Schrodinger exploration\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Faster decay for population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _schrodinger_exploration(self, individual):\n        if np.random.rand() < self.schrodinger_prob:\n            duality = np.random.choice([-1, 1], self.dim)\n            perturbation = np.random.uniform(-0.2, 0.2, self.dim) * duality\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def _global_perturbation(self, individual):\n        perturbation = np.random.normal(0, 0.6, self.dim)  # Adjusted variance for global perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._schrodinger_exploration(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumCatExplorationDE", "description": "Quantum-Cat Exploration DE, enhancing global search with Schrdinger-inspired exploration techniques for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 50, "fitness": 0.17014808046701754, "feedback": "The algorithm QuantumCatExplorationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.33565186618333986, 0.28943955944660493, 0.2959442561751081, 0.309554829395394, 0.304435595223032, 0.30647227644046116, 0.34162814077002945, 0.2921292879727252, 0.2948043260545564, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003810753942330436, 9.999999999998899e-05, 0.0020994923500921026, 0.07513176141845179, 0.08061516854304429, 0.081518113571032, 0.09000643440897294, 0.09094776499631207, 0.07797382085681348, 0.08805658133212257, 0.09293150301369602, 0.07927147936023338, 0.08320067436275436, 0.09410811546234854, 0.06974458832091257, 0.07037377310508397, 0.07284983239858811, 0.06742152311003846, 0.06746688756638541, 0.06871967460486417, 0.08712046925477157, 0.9257189020587411, 0.8658707737881163, 0.9126329256036305, 0.9062217490843093, 0.9237045409702952, 0.9166233069025216, 0.9309567063051507, 0.9003593647140051, 0.9188779783562473, 0.18228607780994133, 0.16025289683491684, 0.17473479651712898, 0.1689687599138484, 0.1880825699652544, 0.1727224775241113, 0.165591891303691, 0.17920886088979915, 0.175456266377929, 0.20560203329920745, 0.23553912915403674, 0.20672526840562555, 0.24388968802175848, 0.23714379093352767, 0.22431986349007638, 0.21046751092875893, 0.2296749122747549, 0.2511221723086283, 0.0942914866990241, 0.10956232494642393, 0.12015037067840384, 0.12449752254662994, 0.10092489555772322, 0.09741323844137784, 0.11678184982350703, 0.15499341442619807, 0.1060046295461301, 0.09529120160181714, 0.09468776432933779, 0.11471468340969737, 0.11721658102705823, 0.11421711145741664, 0.08944957819337329, 0.10034494925155946, 0.08403489667857045, 0.0978509306647738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08897631974375453, 0.06459786452393679, 0.07256948517395756, 0.017566025233193838, 0.01985109941905483, 0.032986601473633304, 0.05090410480427998, 0.03840451794770616, 0.0511673526582852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030818648005706883, 0.053166525219522365, 0.03209211447187721, 0.04361064229527978, 0.033192713921872175, 0.0428574999784076, 0.0675654011697081, 0.04456649049156458, 0.039976627274854626, 0.30788392877391, 0.30964114533545417, 0.306226228498263, 0.29431094380571443, 0.29862145467978685, 0.29500206431844667, 0.300467991209419, 0.3112175678463389, 0.3282436936891482, 0.08117741349447027, 0.08344018109796203, 0.06743278520352469, 0.08698061972448778, 0.09237927850524708, 0.08269352122967777, 0.08315550466739696, 0.07693633321266002, 0.0780329997376632, 0.12984386895526345, 0.13091945753560308, 0.1449348825226784, 0.2272389051946394, 0.12425887349639197, 0.1521118767373899, 0.13473441996422186, 0.11736897578202021, 0.13567353555399897, 0.2304752535163095, 0.22554434006832513, 0.23285747375124033, 0.22549157921406748, 0.22886311765245326, 0.24628010583123683, 0.2241996194610315, 0.22516387646375646, 0.2318325176887409, 0.16582543655708903, 0.16656204775345773, 0.1746159440082483, 0.1664509445017862, 0.1469096145544979, 0.15805285499748167, 0.17815591515290818, 0.18400017701214477, 0.14752663524864207, 0.19707952535393403, 0.19090424809092643, 0.1938156510150989, 0.17420742395258026, 0.18975504447610603, 0.19870613237509827, 0.18615379891315265, 0.1842896914237615, 0.19500524653538265, 0.16163782812545158, 0.17214918441297655, 0.1654033604893964, 0.1736195698078733, 0.1745946717697041, 0.17005915316351072, 0.17797405774413988, 0.16947083057188006, 0.16684584766883892, 0.3884478527104409, 0.38103618169852127, 0.1494153315978345, 0.4296899777988409, 0.18803406645111098, 0.16859058252433368, 0.16342726158586052, 0.42637872609869387, 0.14880505581620673, 0.1504253691878834, 0.19079853027916183, 0.1821844987464758, 0.2166124745070982, 0.26812340896137676, 0.22122994284240738, 0.19836238015665164, 0.09018081692502089, 0.14691122891111952, 0.17533844723475212, 0.17129143634430566, 0.18940198031370215, 0.17511924842086268, 0.17970152246889415, 0.20102802810414333, 0.1660746527499517, 0.18045447791916303, 0.19112956441051854, 0.06525222697826505, 0.0688140997060509, 0.07376742264898817, 0.08722354352612804, 0.07482507439545227, 0.06538670942148839, 0.07218406629688612, 0.067802699422986, 0.07457777570557322]}, "mutation_prompt": null}
{"id": "23e120d2-8f95-4430-ad5c-f90cce99a3a3", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for better exploration\n        self.CR = 0.85  # Adjusted CR for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay of population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategy and Perturbation for Enhanced Global Exploration.", "configspace": "", "generation": 51, "fitness": 0.2680720932810011, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8489498620119263, 0.8167143936197963, 0.8004578557593652, 0.8282327237829571, 0.8435362389050799, 0.8428052229465557, 0.7689062923019808, 0.8470118686448185, 0.8265932231073219, 0.3254302939986261, 0.6848315247411467, 0.3791488236505939, 0.5577647474262977, 0.5146360648102011, 0.5163832854509993, 0.3651669722461095, 0.28886421432398424, 0.3406082538420383, 0.1245767909509683, 0.14690321287960828, 0.11231480360792234, 0.09513670411396846, 0.1368100509382455, 0.16732996539285128, 0.14338559575771137, 0.6440804271631155, 0.17500059305865967, 0.10573379814162853, 0.09204720449071102, 0.12557085287329084, 0.07463509948592184, 0.09014364747881287, 0.06544210646308113, 0.12350034377865649, 0.10130698042661246, 0.10922585607408564, 0.9130588327799305, 0.8972748596211221, 0.902073607413733, 0.9077354742749691, 0.8950237660041658, 0.9179284970062946, 0.9124839200491747, 0.9114206822049631, 0.8881868039218715, 0.4355205446145466, 0.42044366319082604, 0.417879547451784, 0.3981154626736254, 0.46550248872537403, 0.3985304493418891, 0.21773846596730773, 0.35212544686632474, 0.33021651603347235, 0.2234305286104742, 0.36245689199440956, 0.22542734607888293, 0.21037495567673148, 0.2653272934391564, 0.8839032951131907, 0.3645438743249234, 0.36574041144864977, 0.2217277731966354, 0.12208653196886377, 0.16347259535078051, 0.14973521014631497, 0.22315882102136297, 0.2679276559832695, 0.15563582208275417, 0.15211391185967316, 0.17502096886073737, 0.24524069626924516, 0.12288118633635481, 0.1687570353993535, 0.2717755664239805, 0.2028702523781909, 0.14018702566655306, 0.1178954810071784, 0.17947448077638362, 0.16478665830405048, 0.17959324864635928, 9.999999999998899e-05, 0.06867389928617429, 0.05748711243467863, 9.999999999998899e-05, 9.999999999998899e-05, 0.007305724178749418, 0.0621916779974474, 9.999999999998899e-05, 9.999999999998899e-05, 0.055775451378738405, 0.08863076578603746, 0.025460158864978766, 0.08055118184991894, 0.056612894091768284, 0.07325631864168813, 0.10400511674517643, 0.06816356657648326, 0.04973782637928925, 0.06719453069095072, 0.1250931847884995, 0.0995834470485224, 0.15184342701125464, 0.12553254866974006, 0.08578130681999496, 0.16401970983395042, 0.1594565465445147, 0.212723540680961, 0.234461354658832, 0.04212942019595489, 0.12180177225605515, 0.2613313372095708, 0.1313302160783345, 0.16999215416290137, 0.1966436370633432, 0.12424869412149142, 0.23182943226402997, 0.4972853738305817, 0.5067298550120605, 0.46812664102517054, 0.503534888783813, 0.492418382943264, 0.45709241541027923, 0.5177679935227495, 0.5224299330957602, 0.5121358526155384, 0.09435235015043364, 0.134179938724175, 0.11181322024404294, 0.11858556793640818, 0.11521694548217387, 0.12937911617975373, 0.10521944875761113, 0.09856482364440766, 0.07976516105415321, 0.12986747648604724, 0.17495025126019303, 0.2068687615135285, 0.15407774727722368, 0.14531303975888787, 0.1583455181819805, 0.23732492187084253, 0.22892318925367827, 0.164485721915973, 0.30682738911086227, 0.36920205803127903, 0.26654550816009615, 0.1921544888411052, 0.2839228887597198, 0.3813737249108271, 0.28919215780361784, 0.3553774989498728, 0.345221184355355, 0.24320981871424607, 0.2510891788541776, 0.18137042952364157, 0.16909469932212084, 0.2244644008083796, 0.16976290789885662, 0.2568866338284883, 0.25713738094972216, 0.2562696270955356, 0.17754647080462926, 0.19547343244288917, 0.2018842068105997, 0.18183399693897562, 0.19307185060950116, 0.17303702305635382, 0.17294571928945168, 0.17098114994983227, 0.21567642172383217, 0.21544202275537083, 0.2869868371000368, 0.17833712570512994, 0.18881725616402623, 0.20510789198787371, 0.195759118649926, 0.17258716687296305, 0.18336562367307352, 0.1925691230404244, 0.16066539680731406, 0.2789409456118458, 0.8595638459840542, 0.18034607296452632, 0.19361820839243937, 0.16504891314584857, 0.18295577180850475, 0.1502325840802825, 0.15602481634838095, 0.15269339586920794, 0.30595794038147117, 0.16076984782266468, 0.30643973371899325, 0.16996850636474337, 0.2000501446703351, 0.1605395797788457, 0.6549591703730906, 0.20290872152310246, 0.17785218756688193, 0.17738924392389566, 0.19661767446530853, 0.19878984786200726, 0.20674854368112427, 0.18666682742574503, 0.19387713197679446, 0.220506242250603, 0.19397144529939192, 0.0773815364220547, 0.07042494249775921, 0.07735298919836608, 0.088824826806702, 0.08953149040842112, 0.0738669620747543, 0.08173322605363753, 0.06494395944636744, 0.08079213080574077]}, "mutation_prompt": null}
{"id": "84c70c80-1a88-45dc-9f90-e3cbe4ba2c3b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.6  # Modified F for balanced exploration\n        self.CR = 0.95  # Adjusted CR for enhanced diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.25  # Adjusted global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.95 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Non-linear decay for more dynamic adaptation\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** (generation_count / 2)))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for subtle perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveQuantumAssistedDE", "description": "Enhanced Adaptive Quantum Assisted Differential Evolution incorporating non-linear population scaling and dynamic quantum search variation for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.2678209251198887, "feedback": "The algorithm EnhancedAdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7941296346551596, 0.834107503967668, 0.8467435367309323, 0.7997749977894236, 0.8378634964390118, 0.8455340734283434, 0.8311614036941978, 0.8564626245106552, 0.8204396545654387, 0.22498920508247477, 0.3133092816224399, 0.4581926638629169, 0.3284498272552361, 0.3926652645636248, 0.25173735287917376, 0.5534298416386163, 0.28699017938217475, 0.5115120237766029, 0.10744886083990257, 0.1086536147088134, 0.13807330666301443, 0.12333666204543847, 0.13707011044070927, 0.11755149248046781, 0.1363428264006349, 0.1360828744245084, 0.17085626257089048, 0.13142742433079224, 0.09939627315293198, 0.08506406582335835, 0.14661920543101314, 0.08550949934231666, 0.12411839931120194, 0.07002091685006595, 0.09362454861374059, 0.10198244900826847, 0.860724048332, 0.8586225009133865, 0.8777502640725979, 0.8928513142338789, 0.883792992344586, 0.8987581646222732, 0.8889756375813248, 0.8593486252553023, 0.8771389267224159, 0.4506094269651879, 0.5179956105334639, 0.40359674284474745, 0.44709606735242713, 0.35018454364677365, 0.4110233359621267, 0.40539246497497505, 0.3598303589277767, 0.4074769414913769, 0.3462357814627236, 0.3265458686318723, 0.322972576211776, 0.24026622501449668, 0.25863086826958237, 0.3354423915120367, 0.23882597268943428, 0.32803832302782854, 0.22284155482927126, 0.2160662588195148, 0.18290684968772197, 0.1619744458873008, 0.15460301555336187, 0.1427380792926306, 0.2556934006290287, 0.18650186865837703, 0.3125433834162088, 0.14475245598176456, 0.1415179622450794, 0.1954275297754572, 0.1792803836304745, 0.12054730391035662, 0.12184739431815617, 0.17784905857162336, 0.12464762160558673, 0.12219984216988522, 0.16519025437245238, 9.999999999998899e-05, 9.999999999998899e-05, 0.0676322538809827, 9.999999999998899e-05, 0.04660298411542285, 0.11215086479695802, 0.046088914758145805, 0.1260743349789626, 0.0396904514772245, 0.12351427445843388, 0.06264120266457163, 0.138649890158269, 0.19287660609691148, 0.10799089147353769, 0.07966727738400115, 0.1330294596475915, 0.10940862372235316, 0.16646553467495628, 0.14627663101850596, 0.09408051418557462, 0.11300178227960056, 0.08147554123232892, 0.10127457239308602, 0.12145501287203897, 0.14181610008823553, 0.10208103981918304, 0.18471459278128455, 0.09572921759485087, 0.13965319686051114, 0.1681208372923655, 0.3116218511786809, 0.21921619608754683, 0.3023457384932765, 0.14885120239590066, 0.07717085905831922, 0.18329176347730536, 0.47864799842849903, 0.4807491230868387, 0.5315057114639641, 0.5818749328153687, 0.53670184263346, 0.4513078012014041, 0.4676365441252065, 0.4857352941016939, 0.47622289122152706, 0.1115158025933286, 0.10100978603405908, 0.11197562904143266, 0.1040268014128577, 0.17421338882641468, 0.11139554256225459, 0.13042562668684277, 0.10716636983669792, 0.11753483590300007, 0.16665415403249606, 0.14056533233026347, 0.14570964592598756, 0.19368986022948387, 0.13810652830157977, 0.15388189159264654, 0.12547877028807541, 0.14347475222756223, 0.1423115824781196, 0.3130064536944709, 0.36483232663035137, 0.27749652436590355, 0.3164356579770903, 0.2757244336862361, 0.3064695287207202, 0.2738134969437287, 0.3219300348948011, 0.393134078132217, 0.18962832284698872, 0.2090705129846947, 0.25346213414202845, 0.19808647373583577, 0.20151040776810747, 0.27852480732460094, 0.18498925629462482, 0.24005348415500039, 0.23800155084258257, 0.16976110139073375, 0.21508963986738638, 0.1962025836049588, 0.2134335420978305, 0.17320759310887623, 0.20403208163927422, 0.19790969345734666, 0.20552574007841629, 0.21540384368898946, 0.1795795414447301, 0.20775230748141926, 0.17936666678455715, 0.17310427380512228, 0.19315867916164764, 0.18435941234002695, 0.1982869693694561, 0.7017234856836096, 0.17478421231951924, 0.15833747650184227, 0.16832041053562719, 0.8008132321983696, 0.1678398612807559, 0.16534220184296555, 0.19227192531963855, 0.16459868892929574, 0.14823357384572244, 0.2070203314454181, 0.30563656003174045, 0.20557473719802555, 0.5129671441824315, 0.5163926857955918, 0.42144097349835985, 0.16116455961053922, 0.5259177759889142, 0.2034089302255484, 0.15003791102653086, 0.19486204104423255, 0.186472033808593, 0.18447472847156754, 0.1865820201769106, 0.1766976284174867, 0.18776540074698211, 0.18850122800858526, 0.1688119808010966, 0.1779509213171696, 0.10769656550350915, 0.07336827538571089, 0.09540684827648038, 0.07799656425506729, 0.07342161960583748, 0.08527116503674281, 0.07434346946517179, 0.07724905006754057, 0.06587380557531419]}, "mutation_prompt": null}
{"id": "e994dfc9-25cd-4117-b735-01ba5b3e3639", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Adjusted F for better exploration\n        self.CR = 0.9  # Adjusted CR for greater diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4  # Increased probability for local search\n        self.global_perturbation_prob = 0.2  # Slightly decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Slight adjustment for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted Differential Evolution, integrating adaptive learning rates with quantum-inspired local search to enhance convergence speed and precision.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8401834431641492, 0.8346590961296124, 0.8355072186109646, 0.8376689416710098, 0.8120798120413495, 0.8448928378631488, 0.8405261495406384, 0.8345936276818441, 0.8350593403376865, 0.5360770807734994, 0.6850294957626553, 0.7470652326119098, 0.6622131747774875, 0.2371286309602545, 0.43788833167174934, 0.3740902924075855, 0.7140024175058718, 0.37908246139802115, 0.14139908127792844, 0.11444058400102386, 0.1444672816910012, 0.14715134142219122, 0.14434792837663812, 0.13813380677891596, 0.10910956861822174, 0.1487413030030077, 0.1429430178262412, 0.10655684737894955, 0.10514638232136386, 0.14499556682546155, 0.12402013447603655, 0.14382190042092857, 0.09134967501182267, 0.11246612260796773, 0.10978886789591213, 0.10495196611871838, 0.911738813438452, 0.9017660765748203, 0.9061682525173397, 0.9214549823700747, 0.8964254178902765, 0.8840885216674402, 0.9027108664334987, 0.9336971974782017, 0.8840073033893617, 0.43604410431425655, 0.42623124037432036, 0.39183098915623704, 0.45628797127505727, 0.48434194901133587, 0.3222982975823897, 0.3909128871747335, 0.3894650679260969, 0.45036934434689013, 0.3630250868955701, 0.5340804025791996, 0.8434601369669954, 0.26450760335398205, 0.18566992951526007, 0.2100341028397693, 0.21808631714358717, 0.37287246446774924, 0.7894760701984543, 0.31385596086619294, 0.19210150339434717, 0.15326757052076168, 0.1689841804116573, 0.1504410711872115, 0.18372979655688193, 0.16352724035564659, 0.23658894161486055, 0.15078619626690293, 0.1810200607850081, 0.1993621681545601, 0.1900518699797964, 0.1266347097228514, 0.2271156900413921, 0.16649050908406593, 0.20043470020986764, 0.17341826039850783, 0.22434328068485765, 9.999999999998899e-05, 0.0053312953860726875, 0.008646795455644729, 0.03990893745669377, 0.13101889116533771, 0.06521658647344541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09882850609415039, 0.07058018037916447, 0.06376549943252396, 0.08370541554926691, 0.04061375678448109, 0.05471382573211814, 0.18613944593872933, 0.10343641917492064, 0.16999775276658924, 0.06434988909352579, 0.05311073063261951, 0.11635406505745671, 0.1621851318810109, 0.11065236922109267, 0.14992548378846426, 0.10960961999478114, 0.12609701456435485, 0.15298639130192115, 0.15004334138325826, 0.138392295344955, 0.1370213686259525, 0.08930493829231767, 0.15292897808447903, 0.19616610129199386, 0.10029073277254774, 0.14702902061357326, 0.14874878869556474, 0.5150217698929365, 0.48959965919462334, 0.5562321516788449, 0.4686593405368691, 0.4715921196779165, 0.46688102598017345, 0.5078920047272408, 0.49323287774921487, 0.5006529966451121, 0.1495315886666263, 0.08147480835880472, 0.12847309032051457, 0.09925740972970742, 0.11144077579918243, 0.12804137608587007, 0.08791877990029862, 0.08066472749533327, 0.10374047846571066, 0.27585750206714754, 0.17079806182964696, 0.18884814865623034, 0.21580145120568472, 0.13649003078198219, 0.14433180825255276, 0.24849775102407745, 0.17040934369066585, 0.17798873662556292, 0.26890461033931246, 0.2680393488128766, 0.3443633461995136, 0.35227085919969836, 0.3944802646802399, 0.3353832153719213, 0.3966851660159755, 0.28207888549864824, 0.3840214984583592, 0.1947976156394562, 0.28295763616514935, 0.2046253175096262, 0.18702707356269344, 0.2035405803677185, 0.19353370345084586, 0.22191873307822563, 0.2472703280667431, 0.22672561524028656, 0.17621332275590262, 0.20436235196596708, 0.19342706896853756, 0.1862793797815402, 0.1754830840774957, 0.20133212386075205, 0.17912756386867645, 0.1832884620588775, 0.18907558858771023, 0.17085343767215722, 0.18901262555428622, 0.2205012813553825, 0.6041400291209742, 0.21725997855195778, 0.6165851682688048, 0.1954536871306919, 0.21047690409763598, 0.19095292722561308, 0.16818453809578715, 0.736213640155504, 0.8285559116642037, 0.17308680905594742, 0.19113482826387573, 0.15969203592130632, 0.8357312312008385, 0.8308681246417945, 0.804817880541514, 0.4306640319186459, 0.46695371350691306, 0.1987015488540299, 0.48671760941185216, 0.15996254599769233, 0.12404254893197009, 0.1257642636960571, 0.3897521393812392, 0.2056603417237618, 0.18369351633887987, 0.17187384184531607, 0.1780602611016462, 0.18727106735047316, 0.19982851777788324, 0.18523637539176918, 0.18005831626418878, 0.1846641686838678, 0.18974436282206197, 0.08390679816211377, 0.07912359203230557, 0.07006584520149595, 0.07381932229987032, 0.08511693742808124, 0.07762404518202237, 0.08235472393872756, 0.07218078451965271, 0.08427274617036984]}, "mutation_prompt": null}
{"id": "70dd42b0-0131-49f5-9b97-99d320ac93a2", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4\n        self.global_perturbation_prob = 0.2\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = self._adaptive_F()\n        mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        CR = self._adaptive_CR()\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self):\n        return np.random.uniform(0.5, 0.9)\n    \n    def _adaptive_F(self):\n        return np.random.uniform(0.5, 0.9)\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.exponential(0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredDynamicDE", "description": "Quantum-Inspired Dynamic Differential Evolution leveraging adaptive parameters and enhanced perturbation techniques for superior convergence.", "configspace": "", "generation": 54, "fitness": 0.2673136134268582, "feedback": "The algorithm QuantumInspiredDynamicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7974836956061404, 0.8195984432431827, 0.8669356211409944, 0.865462066523687, 0.8648711293046126, 0.8709716245867042, 0.8493201259753193, 0.8350220841196215, 0.8442444921499979, 0.19478612687921493, 9.999999999998899e-05, 0.07970157333261019, 0.04528934707932786, 0.08991275754614547, 0.06431595073031227, 0.14397448738205332, 0.017591349403204726, 0.22125402358809365, 0.17245739686614636, 0.17283591221664607, 0.17166928941710924, 0.48789474747637396, 0.17266181136395464, 0.17194719424701832, 0.135784794050124, 0.16641326719986227, 0.1627008369561227, 0.1323342114405437, 0.43484966915284395, 0.10054147346003228, 0.09822838086120222, 0.1709718756940467, 0.10843332324701438, 0.12303479323992328, 0.12342119405729679, 0.11256464511989617, 0.9348878648524489, 0.9513305914941701, 0.9306141315428468, 0.9244191640492838, 0.9333359570834054, 0.9207906226655104, 0.9472532345034362, 0.9136506056953436, 0.8991095151174316, 0.564167513730025, 0.46870911997408293, 0.4378533939668041, 0.47742706022592507, 0.31037951822765175, 0.44485318029553733, 0.5451117895118923, 0.3714353551033758, 0.347508138249895, 0.3715789314933725, 0.2124639867954785, 0.31738908387558806, 0.2880358152636263, 0.25921091603297797, 0.19671312908183003, 0.21337959714908727, 0.2230532958920467, 0.19326498497193312, 0.20960404603380856, 0.3590216302607834, 0.16967576696380005, 0.11713368210048591, 0.11918268901210072, 0.160845102991776, 0.11962988122981422, 0.11892195193963706, 0.3299219751747696, 0.15262705259145337, 0.10638169031262545, 0.10826412901152704, 0.1606946249949358, 0.14815017534240582, 0.17179530607492854, 0.15903206400722225, 0.11875547669533748, 0.15601154145945306, 0.0014125316861398618, 9.999999999998899e-05, 0.014886613974121832, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008641960818313033, 0.05229187099269661, 9.999999999998899e-05, 9.999999999998899e-05, 0.09943918872776081, 0.10117172389812878, 0.09658630845301452, 0.11757039138104486, 0.06576581766429668, 0.05056989464595063, 0.10140097901058598, 0.16788535197676557, 0.08943524568880423, 0.11870512454596105, 0.05934126208207202, 0.0930524774478606, 0.07397801313213548, 0.07374471017280082, 0.26074543904183434, 0.14451534684123746, 0.16546890706039485, 0.06582868484224058, 0.15145547728863462, 0.14779657751440445, 0.11695484847299975, 0.28194245700359544, 0.1535554208519777, 0.17615116954022902, 0.143247015774156, 0.07398737959788282, 0.14848538222480512, 0.5003291781994015, 0.4983675519510734, 0.5598862743647639, 0.5092480131011194, 0.5106511499472812, 0.5381611639802741, 0.47576891486986705, 0.4879685633867401, 0.4817175682562632, 0.08467681720383968, 0.11173567340226287, 0.09132450692337934, 0.14782997120755736, 0.09305476683340308, 0.14411874132566194, 0.11737739567349059, 0.10421669721239502, 0.08264861961550451, 0.3131429895913409, 0.20154299292266886, 0.1940448425795045, 0.14355450709799156, 0.20782062314150684, 0.16319614341699906, 0.16081966325880714, 0.1579899682335033, 0.12770685775904478, 0.37572872131995516, 0.27141425309676703, 0.3792049077266654, 0.2910433821252312, 0.3717872193038253, 0.4189679720979209, 0.3580513988791486, 0.5032267834047778, 0.4657742461672786, 0.3191079140264744, 0.3470672616570327, 0.23441544692529648, 0.34091722849695616, 0.21934222770380762, 0.2958668708928641, 0.2293981092295464, 0.22171129878023843, 0.23557550949440176, 0.18383691522109147, 0.200234621300159, 0.18353786143825312, 0.17188368543963228, 0.1897849190007349, 0.18828072789674966, 0.1959067379426911, 0.20735829930342742, 0.202611086970509, 0.22662156677589218, 0.202100897839267, 0.2007534035797358, 0.20926640328587642, 0.21507958714764253, 0.21799359453897593, 0.21340611159925849, 0.7663528642845674, 0.22635688729537373, 0.8151791264992968, 0.1757193049189587, 0.1764538705766292, 0.12775215446291077, 0.826631115723085, 0.17337387978394359, 0.1830429575656165, 0.1390497955936868, 0.8596781504190313, 0.16314676253931049, 0.2044902203745863, 0.1539148570524771, 0.20020759053473947, 0.5643072740034065, 0.184465541707298, 0.12459008457958498, 0.2056234066230339, 0.20030764213338237, 0.17379224140106309, 0.17405900624327098, 0.17952267574060665, 0.17844266333797876, 0.1795874655813715, 0.17097064171897514, 0.19732084217458257, 0.18891977452172537, 0.16847037783126528, 0.07132645406016269, 0.07288150441095109, 0.08207544286005908, 0.08234528616033165, 0.06553573278413038, 0.07534577322712666, 0.08480483052248489, 0.07098049371503623, 0.07466767585999712]}, "mutation_prompt": null}
{"id": "be5e2c1b-5bc7-4274-93c1-a7c48fed8ef4", "solution": "import numpy as np\n\nclass ImprovedQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Dynamic local search probability\n        self.global_perturbation_prob = 0.15\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutation_factor = np.random.rand() * self.F  # Adaptive mutation factor\n        mutant = np.clip(self.population[a] + mutation_factor * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93  # Slight adjustment for decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation_intensity = np.random.normal(0, 0.2)  # Dynamic intensity\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * perturbation_intensity\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "ImprovedQuantumAssistedDE", "description": "Enhanced Quantum-Assisted Differential Evolution with dynamic local search intensity and adaptive mutation factor for improved convergence.", "configspace": "", "generation": 55, "fitness": 0.2393551917893739, "feedback": "The algorithm ImprovedQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.784794884530244, 0.8070344312316905, 0.7884847307489037, 0.744357470689591, 0.8053510568519934, 0.7894772414593236, 0.8188236893571326, 0.8581848321980348, 0.7334017177993124, 0.020792130709133883, 0.016870994937871586, 9.999999999998899e-05, 0.029381683604293718, 0.01727101569129863, 9.999999999998899e-05, 0.04564469794132042, 0.0031749394670609332, 0.02560352912623387, 0.1292052817109054, 0.12627048709461908, 0.08369932476129816, 0.14239548776109368, 0.08238480402848525, 0.1403972348697844, 0.1086433394644617, 0.1848422006732029, 0.14048054791368525, 0.09313543217008813, 0.06816110682123433, 0.10593009310374324, 0.14214651139569578, 0.08986275632234741, 0.10601909492989348, 0.11382026054648342, 0.08383961249386263, 0.15218831036446334, 0.8022551322124133, 0.8077052269452516, 0.9007437929361566, 0.9140781630068039, 0.8992004105970113, 0.8720684481427705, 0.9137353699954442, 0.8088010411329385, 0.925294399020753, 0.40499455788821903, 0.45618200089705274, 0.40660799657774305, 0.46495262565033, 0.43546648225428575, 0.4453420502226705, 0.4008739282949394, 0.3491545659917672, 0.37251989514557116, 0.21949846491159386, 0.37602128445234106, 0.1682720917755116, 0.23523719186646452, 0.20568835312167488, 0.19141839033526853, 0.22639938366597256, 0.2317225718372672, 0.14770434884158623, 0.26391975939811785, 0.13071664683561035, 0.13878403465694733, 0.1659688557747191, 0.23437245933410322, 0.26626833468029065, 0.1279817251282871, 0.09313367497398473, 0.1552447723206134, 0.1261597476443198, 0.12472426750351717, 0.15381167165064347, 0.12196218969669281, 0.13398603734311387, 0.14465354206541214, 0.15971492590435787, 0.14735904232932173, 0.1700647126952861, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05026796608744277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009000028663833315, 0.0357301694580725, 0.09519149157050577, 0.06941931120467093, 0.04640165247091521, 0.05167656336935578, 0.14442579754068263, 0.07736058555590042, 0.0880933043609492, 0.03498139107607512, 0.16326271471607912, 0.04640379399829342, 0.21391572063525988, 0.11838089825812148, 0.11261155729942007, 0.21880708211412858, 0.1100976773038096, 0.17197265804384676, 0.1956504220370835, 0.22341799230876014, 0.08883358613399994, 0.20662630346855781, 0.1515770782074849, 0.1267076055851628, 0.10265682453378722, 0.12778354941733827, 0.1853013835571814, 0.10589356319871746, 0.4879041974582957, 0.4507702496068846, 0.4821910548165883, 0.4834591196933542, 0.47592322886801885, 0.4602769455783934, 0.4937296427881719, 0.4706539985440351, 0.47317558089113076, 0.09151364403179996, 0.10553996369573926, 0.09586420734420731, 0.13898174104599603, 0.08319562091034949, 0.08350058816075545, 0.09236383226329348, 0.07570780347253692, 0.07131001216670318, 0.17700289568705374, 0.18344684584646886, 0.1456405902374388, 0.15869520760391298, 0.19929699848900684, 0.154099016242647, 0.17237179145376558, 0.32526389074596407, 0.15522124900553225, 0.20581985286927507, 0.26800914320844105, 0.24654622963273343, 0.1919229950657203, 0.23259671979549923, 0.28515831830393545, 0.21187236137184606, 0.22616843782872997, 0.31296073479469266, 0.1338917762221441, 0.16529197504271997, 0.21790309296107313, 0.21764199834669695, 0.28330249704287924, 0.18558782350505432, 0.1863839392538702, 0.24006138974925106, 0.1835544787468798, 0.19181181136860936, 0.19419885874265053, 0.23386173314811554, 0.22653082574475836, 0.2023677060930973, 0.19402073382664908, 0.27259609252807426, 0.19861629766439182, 0.2118596747452567, 0.19564145067538152, 0.20745341651151517, 0.18714674788735208, 0.22180929678602757, 0.1835825676723104, 0.20865512183950874, 0.18319174128113125, 0.18888813451715147, 0.17013251085544112, 0.8650874362543228, 0.16516145038808738, 0.1513915991964233, 0.7755727284021714, 0.8755199333370219, 0.1928543983943969, 0.14195997266187965, 0.16738947987205888, 0.2090446291582022, 0.4840433537655162, 0.20647502485723312, 0.12209866215727694, 0.10357491045089195, 0.20675803140803162, 0.1646231343623158, 0.10973919087834894, 0.46147466030865136, 0.10307189990618026, 0.1833871477727823, 0.18635570119394262, 0.18576627578787164, 0.17975743484044737, 0.21022628145936195, 0.1982919324848924, 0.18865210471322447, 0.1689218353295764, 0.18977109651563928, 0.11075189276885344, 0.07122470131352243, 0.09855971000924524, 0.09512589620650413, 0.08478485149094817, 0.11230965020434869, 0.08765154903388284, 0.09495409834204216, 0.09806619640239367]}, "mutation_prompt": null}
{"id": "55dafcc1-7dc7-4852-8f7f-12339d9c3641", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly lower F for controlled mutation\n        self.CR = 0.85  # Adjusted CR for a balance of exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.25  # Adjusted probability to enhance global search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Updated decay for more gradual reduction\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum-Assisted Differential Evolution with Dynamic Exploration and Exploitation Balance for Enhanced Solution Accuracy.", "configspace": "", "generation": 56, "fitness": 0.2740866142606161, "feedback": "The algorithm AdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.820080643284563, 0.8255656559143887, 0.816646922790212, 0.840210689536061, 0.8439352083654684, 0.8292722813363199, 0.8336671186126533, 0.8056883477919621, 0.822950341596802, 0.5689678158888024, 0.31355784273750575, 0.4943949519973143, 0.5008452680876716, 0.5369460949639353, 0.5852896260880792, 0.6562812858390685, 0.6855058433607624, 0.3029146804469004, 0.10280974240431717, 0.14474921455951384, 0.13313888667198603, 0.10768436831211381, 0.5413584789824863, 0.1666677154101477, 0.133484088660905, 0.13314295141848143, 0.1714128742573554, 0.14061220183401602, 0.5605866936708878, 0.13870004951521864, 0.08973571872051411, 0.09372168110799195, 0.14120288073792542, 0.13514670082125535, 0.13814763652038842, 0.12253120859945688, 0.9238474868682842, 0.8986451588024914, 0.8937383640919095, 0.93249923450318, 0.9085294616542569, 0.9009571261351014, 0.8994402979379356, 0.9159823050703393, 0.8980398311148167, 0.5130194468019231, 0.3362956891104665, 0.4534360888833189, 0.42004577133271637, 0.42417438201783453, 0.31282129274957493, 0.37641953127981664, 0.3399162501348504, 0.36103085440060656, 0.22441867921848402, 0.2114776891977247, 0.33192849092920584, 0.2614235951033723, 0.32529041986322127, 0.3112926874147546, 0.28118174984855426, 0.22881775386486303, 0.22590881099830373, 0.14038563586557917, 0.14066906494013787, 0.35874921728520515, 0.16667659908219234, 0.1628929315565849, 0.30272017288211706, 0.14655484654000406, 0.16385923883182918, 0.12075316494778221, 0.11959080603863459, 0.1597893767582127, 0.16174498350248523, 0.16431311562728823, 0.11627037836982257, 0.12494773928578584, 0.11970864395752245, 0.1886591680386528, 0.18454523743467277, 0.005334447937248243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01611123152302829, 9.999999999998899e-05, 0.012217234002151578, 9.999999999998899e-05, 9.999999999998899e-05, 0.05843948558422185, 0.11941162410838102, 0.03764240989014034, 0.05722910610867382, 0.09369872975848226, 0.08551848694388942, 0.1000821391750022, 0.08310864754357095, 0.10320786856826702, 0.12796223422701036, 0.16352681117246104, 0.1699244603021356, 0.13855561921901205, 0.14008245602324843, 0.07261973921003706, 0.17449993257016772, 0.1879165080714832, 0.14619994573352746, 0.11085401088293945, 0.21492700390081987, 0.0965955550369797, 0.10502398937360014, 0.07833434291873942, 0.19017257588889946, 0.1306144011885959, 0.05390808561162397, 0.09410622673100988, 0.4559272625159345, 0.4551229331187632, 0.48704167211029614, 0.46206050333649384, 0.49623300371314094, 0.45854716046733235, 0.491743697106959, 0.4960471843934403, 0.49411850157541715, 0.10827473227542372, 0.10894457491149223, 0.12172918774237984, 0.12428247373920187, 0.09454235935710786, 0.16723718334175286, 0.08145708488551429, 0.10138415684909996, 0.12993528835179802, 0.18331211465243946, 0.16880856356728968, 0.18617913889345195, 0.17139430081475182, 0.14353265340451804, 0.15634523125906563, 0.18103399420133293, 0.1636752591686238, 0.13714130700618976, 0.2574836900411942, 0.2765369122266974, 0.2764383059001164, 0.37655677840817703, 0.3199385803353031, 0.23737197094376639, 0.3202120279488282, 0.2752854234499137, 0.27909954974233075, 0.21527198448411078, 0.19787855577717472, 0.23185688591158526, 0.21392914505507477, 0.18090517629080816, 0.2318060170950802, 0.16431530548640239, 0.22558003780997737, 0.20255883102185912, 0.19442175455058086, 0.22111939099835343, 0.18228921925690744, 0.18946088417350726, 0.1791891271449555, 0.1995531122810984, 0.17657040138353097, 0.19285974853429044, 0.18529275341100793, 0.17339517129208248, 0.19160082211570229, 0.15735502664145806, 0.199663704300314, 0.2077341163333174, 0.239346751202699, 0.22691788306145255, 0.1888197245853186, 0.21594760962530513, 0.16163944867748303, 0.8578919963919137, 0.7782615275104573, 0.6606612065553755, 0.8413187128579416, 0.2115278016445412, 0.18725694044116659, 0.17192213167457793, 0.7612549173522082, 0.2016830830502805, 0.20309238641998817, 0.18726747364455287, 0.1994342571882225, 0.1997388271773114, 0.1610139650034318, 0.16806649535862872, 0.20719752653022627, 0.2018998043513911, 0.192441203385891, 0.18951558058520412, 0.18460829341542917, 0.18693631997225335, 0.19681460396299755, 0.19065960496151835, 0.18326590886290428, 0.18233129365847167, 0.1926538974955122, 0.0750768194719712, 0.07751504495705797, 0.08656122601908078, 0.08340565795451871, 0.07460638589752344, 0.06552958673336962, 0.07620375834596727, 0.08916525180288792, 0.08428804908012721]}, "mutation_prompt": null}
{"id": "ec1f1236-a84a-45f9-845c-8023240bd6d5", "solution": "import numpy as np\n\nclass DynamicQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population for better diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for better balance\n        self.CR = 0.8  # Adjusted CR for more precise crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Adjusted for faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Reduced variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "DynamicQuantumAssistedDE", "description": "Dynamic Quantum-Assisted Differential Evolution with adaptive strategies for enhanced exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.27684171257702195, "feedback": "The algorithm DynamicQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8492446925256558, 0.8522432579469702, 0.8511528783362249, 0.8628008884896248, 0.8332611792363503, 0.8677615301530682, 0.8612976305182967, 0.8489791045436977, 0.8589575405691302, 0.6234655207538338, 0.32863832774914137, 0.4651384960104922, 0.4668258460198824, 0.5806157854270777, 0.5615434828565447, 0.7249842942357707, 0.7110238918810976, 0.7131960483177575, 0.13451776112332658, 0.1717575178706522, 0.0950641729731797, 0.17713081072459413, 0.13434778203506959, 0.17416950093118955, 0.1752132340512158, 0.12596553801469512, 0.1120390980801188, 0.14569584322288043, 0.12640918410269808, 0.129270341534655, 0.10460809791449066, 0.1244468595955408, 0.16078177773451785, 0.1508936269851452, 0.10896291885043807, 0.1022916462485387, 0.917096382906208, 0.8949196534015538, 0.8728666525238811, 0.8998662502141656, 0.9114938625542637, 0.9114531914000845, 0.8953072406015519, 0.9085457532647623, 0.8955744065460978, 0.4263310210898149, 0.4337442158113777, 0.36963524814457427, 0.38682022577491804, 0.405182147475007, 0.2923820519351926, 0.38913191365119637, 0.39328049293333855, 0.4034922539038045, 0.22434187354303237, 0.1687001044727462, 0.2347004426930036, 0.20415834843640335, 0.1892771384270744, 0.203266225061845, 0.2240205616772949, 0.22347255389309917, 0.7979508484563629, 0.19322924448403056, 0.17800936093979614, 0.1673848266967639, 0.14778825513101113, 0.28839091686352103, 0.15761641909534685, 0.12014666096322268, 0.1449609621139233, 0.17148478833857295, 0.14954695982642952, 0.1390540064977398, 0.2605548717877507, 0.1668005141330683, 0.18001163382060748, 0.13567033011847707, 0.17004519096409654, 0.11890806043023117, 0.1566890404602369, 9.999999999998899e-05, 0.04245547714036513, 9.999999999998899e-05, 0.15380075602322651, 0.05966192729188646, 9.999999999998899e-05, 0.006300244594165116, 0.011587406219893959, 9.999999999998899e-05, 0.1699214276215587, 0.07586403336963998, 0.16351658502357658, 0.06580492612748512, 0.030722911239509654, 0.1147718087988151, 0.10097855096442365, 0.14262263852273227, 0.07956555195698589, 0.11873195246162471, 0.1798209448776974, 0.11774821480423359, 0.0700761958581303, 0.18477936372817538, 0.08614052003019113, 0.176489381822312, 0.27857606251446954, 0.11646299123356207, 0.2143712623795222, 0.1666477533250762, 0.11707355155782151, 0.09090576405075046, 0.070089909918709, 0.1535787106514236, 0.293140108716456, 0.14805404480627637, 0.15173935731698407, 0.51824642218254, 0.47124707910741737, 0.5768196570176392, 0.48922311800143536, 0.5812625330477925, 0.48818402310416154, 0.5103372984234582, 0.510275267693207, 0.45304963204098936, 0.10474436609559523, 0.11600435434396694, 0.10939225747508208, 0.13503981214897287, 0.10228068537766799, 0.09246409607386574, 0.09998614336576195, 0.11936075061011198, 0.09612277376590805, 0.14553050134159462, 0.17624344056703434, 0.17775641251412144, 0.21429323986477355, 0.14786976416659148, 0.16864774420734285, 0.16047407603035646, 0.22120927290190207, 0.14949392523176908, 0.2650338731412156, 0.3091714705481149, 0.26674089916089516, 0.37918566611715177, 0.31841093344575466, 0.33643207064547254, 0.3415429931622437, 0.36340412519716125, 0.3126854415022029, 0.15607006642096077, 0.18049927026279877, 0.256993796869762, 0.1813815764481851, 0.2735878393839636, 0.21283696431250487, 0.25357574021901397, 0.3237104127661786, 0.19122024689092953, 0.19767068158390644, 0.1975453344477096, 0.22015766163788342, 0.16913191049860266, 0.1995013418546151, 0.1854498068256002, 0.22364544319431634, 0.18730898104893667, 0.2613178124969585, 0.24923442048786726, 0.18702695163781868, 0.18194200098026847, 0.20512422693441412, 0.19577724269374353, 0.742222094810719, 0.23111904219428714, 0.1823354744960618, 0.2176768207939438, 0.15010481547254073, 0.18315691762676, 0.16052875527627652, 0.17404464385038043, 0.1950163662658183, 0.8500251325344159, 0.1527852224324341, 0.16565065956409875, 0.15615113634572098, 0.20247292230037706, 0.16277724807214677, 0.3743600140515737, 0.5923341210853372, 0.3455075237180888, 0.14797643450710352, 0.15805481524858966, 0.3450723444189693, 0.20372015083839545, 0.19426668454500773, 0.18222430966149972, 0.18384949923335447, 0.18613484014692083, 0.19727004012772198, 0.174430350567355, 0.18011687918562835, 0.20347616607675945, 0.19974149896670246, 0.07958774408082558, 0.08604905324778733, 0.0672310121973595, 0.07711716544515201, 0.08470894830375075, 0.07718519582065198, 0.07452959747772714, 0.07748589048258658, 0.0700369896789853]}, "mutation_prompt": null}
{"id": "b25b8fb3-3eeb-4883-9817-e1ad4de813c0", "solution": "import numpy as np\n\nclass EnhancedQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.6  # Lower F for more stability\n        self.CR = 0.7  # Enhanced CR for better convergence\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Improved probability for local search\n        self.global_perturbation_prob = 0.1  # Reduced probability for global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.7 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.4 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for more aggressive convergence\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Reduced variance for less disruption\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumAssistedDE", "description": "Enhanced Quantum-Assisted Differential Evolution with Dynamic Population Sizing and Adaptive Strategies for Faster Convergence.", "configspace": "", "generation": 58, "fitness": 0.24225421511822295, "feedback": "The algorithm EnhancedQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.862870702888004, 0.8448003160344606, 0.8225576786513425, 0.872845654978682, 0.8812341994106188, 0.7922142608779651, 0.8565972610212678, 0.8629206200621489, 0.8422208567747727, 0.24091571693497393, 0.2424980908763109, 0.2984533397007062, 0.1431963206919329, 0.2371214875372215, 0.04976110433890246, 0.8067464310951483, 0.12165176156589608, 0.09233889841100973, 0.18077251883366552, 0.15405442900540567, 0.1536051323437907, 0.15405636039374226, 0.10861216396582296, 0.13889148950384222, 0.12048074141510245, 0.1275309385217972, 0.11787827817873353, 0.127712740789637, 0.11909676881071352, 0.11946500219025746, 0.138644540075485, 0.11211750788847907, 0.09217592185175671, 0.09740207807127754, 0.12763220799520292, 0.08536774946246373, 0.9016480426401585, 0.9031862757019877, 0.8949737490827498, 0.8114675524023367, 0.8836167342457154, 0.8798719631071689, 0.8899982350398222, 0.9043472278687096, 0.903520194652915, 0.4366087665447851, 0.32130244309223244, 0.3702273909354872, 0.2317949311892662, 0.33474417371437826, 0.4693022143491451, 0.3345181673317349, 0.3763649617518552, 0.35491752901744744, 0.35316601526570635, 0.13629333002363764, 0.13547573351521547, 0.2079160062552211, 0.3451120096404269, 0.2236519946670481, 0.19004690222956766, 0.20391973801933128, 0.29421728485772947, 0.13845020434368438, 0.14299234607710254, 0.12734462467563024, 0.11754953962268122, 0.12583082669997636, 0.12572605264582093, 0.15177373488280388, 0.15186452890187452, 0.1222326714725317, 0.11260854091928618, 0.17014574660618842, 0.16629911295018696, 0.12601514443789819, 0.1771291180526534, 0.14867070504806779, 0.25992276917514834, 0.11740666127666577, 0.12368282022371735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052019195237668514, 9.999999999998899e-05, 9.999999999998899e-05, 0.009460007693865347, 0.025880903682885203, 0.11435163691881245, 0.03237926091229115, 0.08905347726032165, 0.05777820519122012, 0.08209724279055897, 0.0008509382123386144, 0.10454261809649157, 0.02905953077699086, 0.09631775661625253, 0.13539765859870512, 0.03620328339104184, 0.09813545216039887, 0.08219380396139608, 0.20489990700547422, 0.20077858398071036, 0.2443319089700312, 0.08530656033835438, 0.20905852346871034, 0.08767334851889463, 0.2174783552598486, 0.2280648853772459, 0.14602738173495522, 0.08401261706908458, 0.11813538092258491, 0.08344147704117766, 0.14155943082063727, 0.18295302963762916, 0.4667031173066455, 0.4441244331734927, 0.45679942238351867, 0.47627056036726, 0.4678255995896068, 0.49420211750744913, 0.5282310523272281, 0.45719175716200544, 0.48139346895640966, 0.11379684845303706, 0.0820956672847647, 0.12308902994708992, 0.10477116344516912, 0.09191932022684413, 0.14929249405296396, 0.10418032750829864, 0.08380693453595811, 0.13995349697517745, 0.15918591192891418, 0.14916040562322108, 0.19137322522986489, 0.13149731714334123, 0.14507494157316636, 0.14480578047701365, 0.14053877615644794, 0.1887015939768384, 0.16080090908280253, 0.373323604897564, 0.26040923834557284, 0.26182732926254815, 0.36217782359949546, 0.3075953744468026, 0.2503517431275074, 0.2572776817330623, 0.2411673428918848, 0.21620886648223003, 0.16863765513674678, 0.21796996488606002, 0.22552270850223965, 0.2664311510130962, 0.1757262157635059, 0.24900457413954935, 0.24907762766506947, 0.19887102798977285, 0.18610204298253952, 0.18329672979928613, 0.19165948180589765, 0.2280381123824372, 0.20998543159959493, 0.21193250330663616, 0.1880672965201, 0.19211325033976068, 0.21529131710877436, 0.20185768630300738, 0.19144920838684698, 0.21657450962205382, 0.20322964983041025, 0.184099738180583, 0.18167031640004894, 0.2195547002745304, 0.1847379241215874, 0.18232468036374538, 0.21986192615597377, 0.15216309064781253, 0.668292079917695, 0.1516689237074672, 0.18801638441295132, 0.1725856043934244, 0.16453750471377404, 0.13915805681597537, 0.16602795906736634, 0.1508468089546734, 0.20512149563529225, 0.1675773186400329, 0.3569348239810576, 0.1995244619821619, 0.16609187116496993, 0.15999397080172384, 0.20303009460493404, 0.3293769392903241, 0.10282086881558661, 0.1858389335139946, 0.17181959118649515, 0.18488682535040057, 0.19445302430361344, 0.18534148863495736, 0.18872327596225402, 0.19271726833826186, 0.19250617727976704, 0.17943990470822224, 0.08371932839069429, 0.08947785463773328, 0.0870819655202939, 0.08466678256738747, 0.0749268636034972, 0.08771516954398662, 0.0682939631915146, 0.07772904216016718, 0.07925429338582668]}, "mutation_prompt": null}
{"id": "2ae64b94-0565-4611-b8a2-e63cc9317977", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        if generation_count % 5 == 0:  # Change population size every 5 generations\n            decay_factor = 0.9  # Accelerated decay\n            self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** (generation_count // 5)))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for greater exploration\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted DE with dynamic population strategies and multi-scale local search for robust convergence.", "configspace": "", "generation": 59, "fitness": 0.2245027011512517, "feedback": "The algorithm AdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.6536479314525898, 0.6317771943842176, 0.6381528504865775, 0.65502103021151, 0.651715167969158, 0.64435102103453, 0.6436209102997943, 0.6608593145780441, 0.6573580932831603, 0.4186358708736512, 0.3450667197739058, 0.4563778023632683, 0.4221777543703785, 0.4570374189352093, 0.4108730500361675, 0.41177247237913406, 0.46723640601696714, 0.3131139208066418, 0.1363766679198838, 0.13521278707868056, 0.11613061393002211, 0.12087777811224643, 0.14250397836373052, 0.13486885768093493, 0.12334815754832451, 0.1182617147862024, 0.10192275566329645, 0.1281564488508502, 0.10389907236721752, 0.0986237428975495, 0.12713141236532466, 0.12937331196690505, 0.1205757810798983, 0.10961544996584238, 0.11201634218737322, 0.12109821015403, 0.8771321696582877, 0.8330017960710399, 0.8935114300696094, 0.8500966034724768, 0.8609182293581668, 0.873999286482352, 0.8764351640632673, 0.7962934659767624, 0.8830445305061667, 0.28573379685941014, 0.2821228391971091, 0.3770596851438218, 0.30121352265904744, 0.318848979109302, 0.27730759599952637, 0.32260008841146837, 0.26502417244594223, 0.2931678437545615, 0.1940246539648638, 0.4105835168002958, 0.1931030085537644, 0.25387953187546086, 0.26233592558918395, 0.28588112341162764, 0.2846888419059175, 0.3012146554090488, 0.31046559712734245, 0.12724626158022656, 0.12450364045955353, 0.12165501289960334, 0.11435877230501756, 0.13092820285356288, 0.12552811186559232, 0.12240887771989128, 0.09905467788580702, 0.14142923217094538, 0.0911797020835533, 0.10198574262505367, 0.0914359448104598, 0.12993892101437254, 0.11562452388431099, 0.13335801977693174, 0.10739543004159202, 0.11459645855064793, 0.13720193854849516, 0.008741295479278377, 0.007962439633591, 9.999999999998899e-05, 0.027531906496388592, 0.012975011054486618, 9.999999999998899e-05, 0.012714159262560143, 0.012413087306597514, 0.015182158487959563, 0.06331548687433464, 0.09325334830810539, 0.08085077401666663, 0.10069217882619197, 0.042269282224062454, 0.046562577172365116, 0.10943923268387823, 0.11637738592173685, 0.08561635402764256, 9.999999999998899e-05, 0.007431492643776405, 9.999999999998899e-05, 0.011475170296792347, 0.015182865584704275, 0.016597457892467027, 0.0036642014504132403, 0.01265727425508012, 0.04760724352648027, 0.09472107307069655, 0.10770724337866233, 0.10636614494410657, 0.11439460662001766, 0.11565876605759584, 0.11666390224449019, 0.10258624797811267, 0.09705501609697298, 0.09799831884373567, 0.44431049085082763, 0.4192051099993881, 0.40599345288386457, 0.4103104388554526, 0.4076552469919408, 0.4102859405326269, 0.418949122913007, 0.3906715395978527, 0.4226089679822197, 0.08267495978595907, 0.09643137850965555, 0.10472456866556312, 0.08202861038242804, 0.07352904208050837, 0.09124379237537616, 0.07795164235357532, 0.0774845855856664, 0.086771117951562, 0.1286139418009994, 0.14574253501201728, 0.1638889151416394, 0.12077472850652937, 0.14874525836292196, 0.14559293774639137, 0.17105070067326145, 0.12495902255038438, 0.15392378533645368, 0.25880208127651627, 0.30194695928366044, 0.2843703538263104, 0.24617364488601456, 0.2857175671285449, 0.25799035122887337, 0.26782798257556684, 0.30858337360317234, 0.28465303128986874, 0.19384423350551716, 0.1913089950177571, 0.18960371245006435, 0.14634018000062587, 0.20054756286555708, 0.15854308684021567, 0.19378856814298728, 0.1651691575651032, 0.18128212211583328, 0.19274195207755807, 0.16986159942493684, 0.16020697581180265, 0.1716084061132035, 0.16681460460576714, 0.17580872305260997, 0.16366598522132503, 0.18032183787939415, 0.19439345940152708, 0.18845556887009052, 0.391230875243024, 0.1827823423036644, 0.20399432252898209, 0.19807571962977488, 0.2127534420065864, 0.2360895022966516, 0.20526321510850032, 0.20553637336056063, 0.14369143637686632, 0.4620212469570163, 0.2090433755385811, 0.17387896095446664, 0.5043703452622341, 0.1851250047875238, 0.1690782156086993, 0.19082851039540716, 0.1848421799668858, 0.33949650976031753, 0.19113600109117113, 0.19298389573206087, 0.17336752808032374, 0.17572751670840903, 0.15467230464979131, 0.19450560889033686, 0.1971587726027053, 0.14573277141129115, 0.18377019853498877, 0.20078059134836734, 0.17760366096268154, 0.17483112130315204, 0.1853143252369912, 0.17312680933120805, 0.17353959892757176, 0.1862261819296207, 0.18188769448019915, 0.07402398433650847, 0.0742690423176966, 0.07082688487408761, 0.06775343888786467, 0.06724394197813288, 0.0627189081655053, 0.06618837764902696, 0.07140737938083752, 0.07482218250100992]}, "mutation_prompt": null}
{"id": "83240449-76cd-440e-8d3d-9327f774f2a7", "solution": "import numpy as np\n\nclass QuantumAdaptiveDEShrinking:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7\n        self.CR = 0.8\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3\n        self.shrinking_factor = 0.9\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        self.pop_size = int(max(5, self.pop_size_initial * (self.shrinking_factor ** generation_count)))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDEShrinking", "description": "Quantum-Inspired Adaptive Differential Evolution using Dynamic Search Space Shrinking for Improved Convergence.", "configspace": "", "generation": 60, "fitness": 0.26562904087760186, "feedback": "The algorithm QuantumAdaptiveDEShrinking got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8812873668534862, 0.8433345860015808, 0.8280730398925443, 0.7926451481728582, 0.8561493793833217, 0.8467953982687955, 0.8283390459328608, 0.8602468410583544, 0.8812679617183014, 0.6356604517898262, 0.5892468294775501, 0.7118741265541849, 0.5263026464175805, 0.4665034351136975, 0.5109582237330212, 0.6842003820805382, 0.7059128638282837, 0.7953002415212032, 0.08860383916692405, 0.10211846525098645, 0.1498763448720547, 0.10640998434335747, 0.10682761348436398, 0.1511949583501453, 0.1190601523344883, 0.12009626734027645, 0.14863202393743813, 0.07269887391925312, 0.10483033465837666, 0.10456950531242692, 0.09359336779200256, 0.10663495401684009, 0.10414426567644675, 0.11544014140515269, 0.10008715339247298, 0.1395956576351689, 0.8813302324191108, 0.8960339346056779, 0.7641025410253663, 0.856398239359496, 0.9207752253484568, 0.8250550192998917, 0.8953497457366381, 0.9180303497806517, 0.8091021154216549, 0.3045198706479554, 0.2891236237791458, 0.25033561071798804, 0.31919974330216805, 0.3699898913554375, 0.5331111700979505, 0.33781656455776354, 0.314079524680447, 0.31780709672981033, 0.22005927592763685, 0.38306795202645794, 0.15989966811444178, 0.230990417240306, 0.25631049395464367, 0.3166996663708791, 0.12761247925325547, 0.16886479221960726, 0.17159873506510992, 0.11772967133765655, 0.15986033522894727, 0.14755792081889252, 0.18835904030597317, 0.1645300805341059, 0.12588273640659375, 0.15649608885355426, 0.1684889385836179, 0.17967959579558157, 0.1245974058573387, 0.1950765588765878, 0.1080334730939354, 0.14524199649894343, 0.1495470251481491, 0.14998787831289717, 0.15499955000041754, 0.12101701362929085, 0.1423492218712401, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05691332613879696, 0.004335295099849867, 0.07954633742589245, 0.07169739234635253, 0.009585622995259335, 0.06656667161701169, 0.060407868929488684, 0.07666647731529808, 0.024457088491810608, 0.03517997128837491, 0.15351034936570962, 0.11518875537587026, 0.030944466430110507, 0.06807101842117658, 0.06792020447811953, 0.06824997332033089, 0.042047185915555896, 0.07852572429135385, 0.08229544809344624, 0.1136299361431582, 0.11790032464486921, 0.22125334027094645, 0.22654429887668082, 0.1974603524227574, 0.1990776348922637, 0.2653203667289208, 0.33113539496104405, 0.061041391535229694, 0.21791560466758797, 0.30668256719524056, 0.16499465422246118, 0.15506677974878746, 0.5127849867860539, 0.5215446520232727, 0.5035490693725202, 0.449329847508407, 0.5136244648955142, 0.49127262948050576, 0.4576016972446375, 0.4797039013541279, 0.48853511125357596, 0.12067528571836561, 0.11297239514998525, 0.14882457064622812, 0.16435273261769923, 0.13706116952928227, 0.0669619580317039, 0.11229080606206188, 0.11530279391053355, 0.10884015319750728, 0.13720788593678335, 0.12090933580112218, 0.14612354614829004, 0.15472188422845778, 0.14675351940542514, 0.1692789998784141, 0.14632630768126076, 0.13635321095685793, 0.14712478073071056, 0.2515666706348023, 0.3114715128595955, 0.24617207293864996, 0.2566728753463461, 0.21706524445141406, 0.25783796681397275, 0.21583766962271345, 0.39020633620533796, 0.42181967869829173, 0.34937199180859246, 0.22750486831063066, 0.19462421600651192, 0.21358252872002403, 0.2387786323981319, 0.27496759990677133, 0.2911525186043261, 0.18969501947662737, 0.34719861967918964, 0.18947782783873457, 0.17360234319729984, 0.1771537478013786, 0.2032024814512361, 0.19307524600107062, 0.22400112806722572, 0.22437576571818507, 0.21569454516303854, 0.2043971694511414, 0.2207196815951633, 0.19571570775286073, 0.21524135913835152, 0.18663842578959244, 0.24512985452685032, 0.1875387059533239, 0.23946648852375862, 0.18295695320652294, 0.17540687020264645, 0.1829383144225224, 0.7681824760350788, 0.16888891348697088, 0.1941624324378589, 0.7501152753764939, 0.1790108274481469, 0.16287678364619185, 0.8489802487735894, 0.1689990225560114, 0.15440755051683586, 0.2064589965245326, 0.16176387658631342, 0.1408885594517444, 0.2042277305176271, 0.15252838448001727, 0.14849675488530412, 0.19728153200932153, 0.20937524655043027, 0.18781628040929577, 0.18542292385395254, 0.18937800120994852, 0.19689777353009863, 0.19528133939976755, 0.19039284414314261, 0.18338497565238843, 0.19071243999450715, 0.18394582223564815, 0.07167583461076754, 0.08596133884295087, 0.08170191345431832, 0.06097423522568679, 0.09005198823371197, 0.07709258857266232, 0.09041678962448296, 0.09223817309707938, 0.0778544178293954]}, "mutation_prompt": null}
{"id": "2d6954ec-012d-48fc-abdf-524db6fd7f19", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Adjusted F for better exploration\n        self.CR = 0.9  # Adjusted CR for greater diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4  # Increased probability for local search\n        self.global_perturbation_prob = 0.2  # Slightly decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Slight adjustment for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted Differential Evolution, integrating adaptive learning rates with quantum-inspired local search to enhance convergence speed and precision.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8401834431641492, 0.8346590961296124, 0.8355072186109646, 0.8376689416710098, 0.8120798120413495, 0.8448928378631488, 0.8405261495406384, 0.8345936276818441, 0.8350593403376865, 0.5360770807734994, 0.6850294957626553, 0.7470652326119098, 0.6622131747774875, 0.2371286309602545, 0.43788833167174934, 0.3740902924075855, 0.7140024175058718, 0.37908246139802115, 0.14139908127792844, 0.11444058400102386, 0.1444672816910012, 0.14715134142219122, 0.14434792837663812, 0.13813380677891596, 0.10910956861822174, 0.1487413030030077, 0.1429430178262412, 0.10655684737894955, 0.10514638232136386, 0.14499556682546155, 0.12402013447603655, 0.14382190042092857, 0.09134967501182267, 0.11246612260796773, 0.10978886789591213, 0.10495196611871838, 0.911738813438452, 0.9017660765748203, 0.9061682525173397, 0.9214549823700747, 0.8964254178902765, 0.8840885216674402, 0.9027108664334987, 0.9336971974782017, 0.8840073033893617, 0.43604410431425655, 0.42623124037432036, 0.39183098915623704, 0.45628797127505727, 0.48434194901133587, 0.3222982975823897, 0.3909128871747335, 0.3894650679260969, 0.45036934434689013, 0.3630250868955701, 0.5340804025791996, 0.8434601369669954, 0.26450760335398205, 0.18566992951526007, 0.2100341028397693, 0.21808631714358717, 0.37287246446774924, 0.7894760701984543, 0.31385596086619294, 0.19210150339434717, 0.15326757052076168, 0.1689841804116573, 0.1504410711872115, 0.18372979655688193, 0.16352724035564659, 0.23658894161486055, 0.15078619626690293, 0.1810200607850081, 0.1993621681545601, 0.1900518699797964, 0.1266347097228514, 0.2271156900413921, 0.16649050908406593, 0.20043470020986764, 0.17341826039850783, 0.22434328068485765, 9.999999999998899e-05, 0.0053312953860726875, 0.008646795455644729, 0.03990893745669377, 0.13101889116533771, 0.06521658647344541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09882850609415039, 0.07058018037916447, 0.06376549943252396, 0.08370541554926691, 0.04061375678448109, 0.05471382573211814, 0.18613944593872933, 0.10343641917492064, 0.16999775276658924, 0.06434988909352579, 0.05311073063261951, 0.11635406505745671, 0.1621851318810109, 0.11065236922109267, 0.14992548378846426, 0.10960961999478114, 0.12609701456435485, 0.15298639130192115, 0.15004334138325826, 0.138392295344955, 0.1370213686259525, 0.08930493829231767, 0.15292897808447903, 0.19616610129199386, 0.10029073277254774, 0.14702902061357326, 0.14874878869556474, 0.5150217698929365, 0.48959965919462334, 0.5562321516788449, 0.4686593405368691, 0.4715921196779165, 0.46688102598017345, 0.5078920047272408, 0.49323287774921487, 0.5006529966451121, 0.1495315886666263, 0.08147480835880472, 0.12847309032051457, 0.09925740972970742, 0.11144077579918243, 0.12804137608587007, 0.08791877990029862, 0.08066472749533327, 0.10374047846571066, 0.27585750206714754, 0.17079806182964696, 0.18884814865623034, 0.21580145120568472, 0.13649003078198219, 0.14433180825255276, 0.24849775102407745, 0.17040934369066585, 0.17798873662556292, 0.26890461033931246, 0.2680393488128766, 0.3443633461995136, 0.35227085919969836, 0.3944802646802399, 0.3353832153719213, 0.3966851660159755, 0.28207888549864824, 0.3840214984583592, 0.1947976156394562, 0.28295763616514935, 0.2046253175096262, 0.18702707356269344, 0.2035405803677185, 0.19353370345084586, 0.22191873307822563, 0.2472703280667431, 0.22672561524028656, 0.17621332275590262, 0.20436235196596708, 0.19342706896853756, 0.1862793797815402, 0.1754830840774957, 0.20133212386075205, 0.17912756386867645, 0.1832884620588775, 0.18907558858771023, 0.17085343767215722, 0.18901262555428622, 0.2205012813553825, 0.6041400291209742, 0.21725997855195778, 0.6165851682688048, 0.1954536871306919, 0.21047690409763598, 0.19095292722561308, 0.16818453809578715, 0.736213640155504, 0.8285559116642037, 0.17308680905594742, 0.19113482826387573, 0.15969203592130632, 0.8357312312008385, 0.8308681246417945, 0.804817880541514, 0.4306640319186459, 0.46695371350691306, 0.1987015488540299, 0.48671760941185216, 0.15996254599769233, 0.12404254893197009, 0.1257642636960571, 0.3897521393812392, 0.2056603417237618, 0.18369351633887987, 0.17187384184531607, 0.1780602611016462, 0.18727106735047316, 0.19982851777788324, 0.18523637539176918, 0.18005831626418878, 0.1846641686838678, 0.18974436282206197, 0.08390679816211377, 0.07912359203230557, 0.07006584520149595, 0.07381932229987032, 0.08511693742808124, 0.07762404518202237, 0.08235472393872756, 0.07218078451965271, 0.08427274617036984]}, "mutation_prompt": null}
{"id": "571ec453-9d9d-461e-8119-12a78fb8951f", "solution": "import numpy as np\n\nclass QuantumGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Modified F for balancing exploration-exploitation\n        self.CR = 0.9  # High crossover rate to ensure diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Higher probability for local search\n        self.global_perturbation_prob = 0.3  # Balanced global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted decay for more gradual population size reduction\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumGuidedAdaptiveDE", "description": "Quantum-Guided Adaptive Differential Evolution, leveraging quantum-inspired operators and dynamic parameter adaptation to enhance global exploration and local exploitation efficiency.", "configspace": "", "generation": 62, "fitness": 0.2648709735922032, "feedback": "The algorithm QuantumGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8019828744893496, 0.8623732768306038, 0.8509139837652008, 0.8170711594275291, 0.8421523325296502, 0.8260682846162108, 0.8475959338486017, 0.8090502067986215, 0.8523776498858814, 0.31760966181045014, 0.42714465170856286, 0.4680244268786917, 0.38702461918265507, 0.36301218837099625, 0.581615003738691, 0.3150227619630205, 0.6653018093578593, 0.5625694907746664, 0.17239860559419484, 0.15012030098832507, 0.17376668609509194, 0.11235266112265563, 0.12709594666097124, 0.11957983457633836, 0.13801922948075374, 0.11119213180540533, 0.17488198027750568, 0.11017573783367518, 0.17781357435264977, 0.10527362744483448, 0.11130206510940044, 0.08646399647821545, 0.10352254045117482, 0.1125376837237616, 0.12422467389125702, 0.1486598619751317, 0.9130652527992535, 0.9105644506922667, 0.8977713788100284, 0.886327693174183, 0.901070451349735, 0.8984651829598815, 0.8718649973639023, 0.9089255837021247, 0.8898797851760947, 0.2740003137975604, 0.38616043305392633, 0.4521563722670223, 0.4459889867789464, 0.4685178987589953, 0.4733497824481613, 0.35265443448829015, 0.33881122863890367, 0.3755472079844864, 0.19440592505196763, 0.21524846331080305, 0.3503638192430861, 0.18680834798477164, 0.27105640303891365, 0.21127489160564172, 0.23800670797001444, 0.317165019919735, 0.8279168111331856, 0.1902284422681364, 0.20007986539449174, 0.16429886652434433, 0.1791362197653703, 0.12349749953276912, 0.17656491943226504, 0.20204914544346497, 0.12010074442925689, 0.15234395350571994, 0.1663516103520618, 0.3007908141821002, 0.12164611524079605, 0.4156965864294154, 0.13979411965176147, 0.13753725823058338, 0.32246076816383007, 0.13173652017733184, 0.12173815414651923, 0.008396238571941828, 0.07590061069445508, 9.999999999998899e-05, 9.999999999998899e-05, 0.033929577847741754, 9.999999999998899e-05, 0.0007989435119296617, 9.999999999998899e-05, 0.01505988018601545, 0.08430123027923653, 0.07138720229570972, 0.03501172038531075, 0.13540860832322554, 0.07975608265568512, 0.05322410008039902, 0.1107566725956809, 0.1564408610902367, 0.13666755858845625, 0.03326500197250548, 0.08628315158438327, 0.06618714005656345, 0.11238209320009351, 0.09969341534487597, 9.999999999998899e-05, 0.23721968729490417, 0.1622668667312791, 0.1295845181125549, 0.25638574416118654, 0.13653629459421135, 0.1408595219305958, 0.04383849148413954, 0.11650991003203548, 0.20506422358534449, 0.0968761526244043, 0.14987883983675854, 0.11466803095560207, 0.5077203522422269, 0.5678352447300826, 0.4789535514968737, 0.42791756702269557, 0.5014847481489219, 0.48541818641832446, 0.5403417953720956, 0.4917044112802319, 0.4785587985714196, 0.12005904605940487, 0.11813567162538896, 0.08598999805414764, 0.1234769348528515, 0.13536101584817128, 0.08046124034843238, 0.15090204802301888, 0.09976970562323872, 0.09886171304678415, 0.23488126053444125, 0.14717130298050884, 0.20377695529526585, 0.27690639284981966, 0.16241297746795258, 0.12824041582940915, 0.14621397525454127, 0.14968690751739655, 0.1797322287335641, 0.24239511304590622, 0.2743237577162182, 0.3392524321310946, 0.268349385308424, 0.3208997451611988, 0.35280458489486144, 0.2670060454129337, 0.31298194264650125, 0.3655910446358731, 0.22543431707138073, 0.2169132991207109, 0.20519751395922092, 0.20003501106099653, 0.1887379646302496, 0.20129886702197541, 0.1975149295763846, 0.2143356150226592, 0.26631928409770156, 0.20449679766824214, 0.1936905375147584, 0.20457872794619958, 0.1877156749022424, 0.21058483511185855, 0.18536879295650166, 0.18663695763239452, 0.1851078659394475, 0.18229082466506163, 0.20125386056646388, 0.21441997279209024, 0.208236626360492, 0.20164732877623692, 0.21377300365451501, 0.21461881879564937, 0.19152797559467782, 0.21388318101185366, 0.17335607849894363, 0.1779326331790324, 0.7732311652849513, 0.15426652266022467, 0.1808874635614648, 0.1945281322460426, 0.1657464697888278, 0.7427816230672987, 0.170037301707905, 0.14473075764266907, 0.19792538139258165, 0.16375836932162324, 0.33001532796349364, 0.16789641041604586, 0.12344511364469057, 0.22686348246570243, 0.2034463083313226, 0.20398612671060168, 0.20128798691570104, 0.1939882429950741, 0.17685743241923668, 0.1835270876993158, 0.177946434142221, 0.17985643899541814, 0.1938169531028704, 0.1939309523391839, 0.16556579778508007, 0.20122065953131585, 0.07624683591635262, 0.09438149297604281, 0.07874328247605877, 0.07474957908816526, 0.07554254331668742, 0.07581935783640925, 0.07548747131715572, 0.07009826700141075, 0.08228248173043318]}, "mutation_prompt": null}
{"id": "d112cbaa-3d32-45d1-8b20-59d8b9b616b8", "solution": "import numpy as np\n\nclass EnhancedQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for enhanced exploration\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Tuned F for improved balance between exploration and exploitation\n        self.CR = 0.85  # Tuned CR for more controlled diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93  # Further adjusted decay for population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.05)  # Reduced variance for finer local search\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Tuned variance for more effective perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumDifferentialEvolution", "description": "Enhanced Quantum Differential Evolution with adaptive mutation/crossover strategies and stochastic learning to improve exploration and exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.2562969256537605, "feedback": "The algorithm EnhancedQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7774584900920828, 0.7953467242030599, 0.8077902512490955, 0.8272953168308325, 0.8101481553159462, 0.7852181766282624, 0.7991652888671806, 0.8152183765766705, 0.7873825872970555, 0.5456971725837996, 0.22711359112386365, 0.5972321242169781, 0.3716912464140495, 0.19692175397296097, 0.6038389856293819, 0.6086711118508483, 0.11772522633694282, 0.42063350903384866, 0.16394916197127818, 0.1299212128134668, 0.14260272200469148, 0.17727210270387717, 0.1211795916042081, 0.1316565240976323, 0.16477992478838388, 0.15964774695038975, 0.4894861723354146, 0.11354583480435687, 0.10321586925904502, 0.1298566363733964, 0.12692963700215532, 0.11303145533310233, 0.12070796115098525, 0.11914057810041445, 0.1614452001766873, 0.09370467451984965, 0.8876285594615165, 0.9060741383260023, 0.8915252502216326, 0.927192918991073, 0.9085387437121202, 0.9043705900551158, 0.891864167958549, 0.9000276393097261, 0.8934659606394877, 0.42623214264651377, 0.39907881443214577, 0.42934126883402346, 0.3647604910525891, 0.3954118923400717, 0.44121601624200135, 0.3534250457558895, 0.3835951759559465, 0.3438085277395043, 0.20959392216286943, 0.29117489263655405, 0.19299217330166385, 0.3167189573480499, 0.3286920242032991, 0.24802663695115756, 0.21703689552756555, 0.22159641503078864, 0.22506659342973567, 0.15376661961584015, 0.15750733208262768, 0.15971550121632083, 0.11739332197800234, 0.15892657225983908, 0.11814317300322075, 0.12032461980629883, 0.18007729080125423, 0.13022089141797444, 0.10513362914772928, 0.10440247749366349, 0.10492748257441731, 0.28610653016061716, 0.11683008251962723, 0.1610330021887756, 0.26929236131674905, 0.17345177134332002, 0.13738729686458906, 9.999999999998899e-05, 0.08959910102775281, 9.999999999998899e-05, 9.999999999998899e-05, 0.007909158375460579, 9.999999999998899e-05, 0.031855621529265354, 9.999999999998899e-05, 9.999999999998899e-05, 0.07687488482789029, 0.10594313073384676, 0.16942057088632734, 0.028443602595830453, 0.021770758077951924, 0.04373438708816879, 0.1306398438305021, 0.0805132257220963, 0.0786225978195122, 0.0766754712403721, 0.04638294400353138, 0.08881442778322912, 0.07003865623906236, 0.09146085377398028, 0.12061131165016847, 0.022349629640113333, 0.1006330403221336, 0.0918081158820302, 0.14666505944129127, 0.15977405793964994, 0.16459382788799215, 0.18111303218410035, 0.12409803651075912, 0.19808734934905192, 0.08118824549480719, 0.13399295679622625, 0.1257996768889369, 0.44360662335918777, 0.45437980621362484, 0.4626870645573542, 0.471931788540209, 0.47946780653840304, 0.4854630688968248, 0.4846601483263655, 0.47274929463927085, 0.48921558115130725, 0.11419391097206555, 0.10287645631544451, 0.12070009792628678, 0.11046886303051273, 0.08950580162212851, 0.1483844723027179, 0.09084592412720816, 0.12369183276337659, 0.09953546288333515, 0.14404988453006495, 0.12682952336268916, 0.1552168909961632, 0.137743522720701, 0.13972586416767951, 0.15036059722520112, 0.1798755409362962, 0.18123246752540245, 0.15642286529017524, 0.2324584097170529, 0.2771866514773106, 0.2898087857655447, 0.28904241869120006, 0.24475080624419965, 0.2566730823847052, 0.3230038620181779, 0.33894091930753756, 0.22580989003996788, 0.25868648313903697, 0.20709326837230302, 0.2204457341590239, 0.2250090191902655, 0.21899473398992653, 0.21456183022334607, 0.2685682249104637, 0.2522507347840234, 0.30418679518809455, 0.194996461053345, 0.17442986490485068, 0.1639123451911919, 0.1740003165456634, 0.1884977996030558, 0.18306112140936714, 0.1731873348614501, 0.19438951156606088, 0.21002355109348536, 0.4212635687586509, 0.1744358907730582, 0.1911893062942146, 0.1914862295320997, 0.18146370005572765, 0.16752992415850165, 0.19633124460264717, 0.2960233310400192, 0.2635284171401143, 0.8224452206715843, 0.18768556023493088, 0.1901310540590797, 0.1613067814308895, 0.1866036488943067, 0.1618747261892466, 0.1680952329758718, 0.7816733202313286, 0.1694435157236579, 0.1633501338255019, 0.1990463051534873, 0.1599478613387575, 0.19636933131552603, 0.15170692524180418, 0.1579241760808442, 0.19589013941249, 0.12578805740961563, 0.5700350222501935, 0.19935410228798367, 0.1847628205736278, 0.1727061235694799, 0.19597979001188703, 0.18878644179950255, 0.17359961665521018, 0.20153558949959816, 0.20785599896957097, 0.23408138414859436, 0.06760134425357867, 0.0644137430266144, 0.07374987892570739, 0.07113921879317298, 0.07237293353935526, 0.08022448805622662, 0.06853911465398632, 0.07867494876995929, 0.07266818232272054]}, "mutation_prompt": null}
{"id": "acea2683-247d-45c3-b822-706e76ff28d7", "solution": "import numpy as np\n\nclass QuantumAssistedDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Modified F for balanced exploration and exploitation\n        self.CR = 0.8  # Adjusted CR for increased diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Modified probability for local search\n        self.global_perturbation_prob = 0.25  # Adjusted probability for global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.65 + 0.25 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted for faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAssistedDynamicDE", "description": "Quantum-Assisted Adaptive Differential Evolution with Dynamic Population Scaling, incorporating quantum perturbations, adaptive parameters, and dynamic population scaling to improve exploration and precision.", "configspace": "", "generation": 64, "fitness": 0.26664688072804343, "feedback": "The algorithm QuantumAssistedDynamicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8318314156216492, 0.8790324219491132, 0.8292911909346973, 0.8542317125196278, 0.8333126445048218, 0.8274303639235294, 0.8257135477342717, 0.8784230757388469, 0.8454035192877052, 0.45909315257474614, 0.5120304275553261, 0.5687217581526427, 0.7060370945156884, 0.45602242639812895, 0.35667318761070077, 0.4405803028422455, 0.4171956342332698, 0.5757283463886171, 0.5942972260378614, 0.10984937591454158, 0.13585437278798929, 0.10802854492151526, 0.071066914074017, 0.12367551237064833, 0.14679136429603623, 0.11805173895874377, 0.12425805491525332, 0.14732118142335549, 0.10335458539387432, 0.13558130315631622, 0.12465155934055039, 0.09100569499491051, 0.0923150733411583, 0.09077653589595192, 0.07313637718977062, 0.12516489208158033, 0.9303328351732886, 0.9258301555484024, 0.9150467367737976, 0.940214360242871, 0.9284034020559223, 0.9413299202524048, 0.9218764295568773, 0.9333713567656251, 0.9431265095242252, 0.48496670327479274, 0.31943194014083287, 0.44194477162257917, 0.3392534964507975, 0.4459140900158992, 0.4525946685516036, 0.3403116764742209, 0.34519541238981266, 0.35595203475126136, 0.24687799081939077, 0.2179724009741908, 0.18369264591399237, 0.17324824574423747, 0.33876487493689067, 0.19971629866259122, 0.23272135329789212, 0.18883233273142142, 0.2109143814256127, 0.22405869605413198, 0.11184161348580945, 0.14892785483791937, 0.12659620394499038, 0.11344044994673863, 0.16882050571883989, 0.16202475830617857, 0.1604700853948975, 0.11878518741966726, 0.11013201476969858, 0.20560688441847452, 0.12708872900299706, 0.15132807296312034, 0.21163446887033655, 0.13696420371007167, 0.15410372353909751, 0.18112292071929637, 0.15262556591459342, 0.027816315977930883, 0.020557339854051504, 9.999999999998899e-05, 0.010605203531217744, 0.019626307299122847, 0.0751220970989982, 0.0395200018028119, 9.999999999998899e-05, 0.06934811222121029, 0.11609345862194753, 0.13765949984994763, 0.1131905790118064, 0.07451673032429429, 0.059716364180783965, 0.041855133131845634, 0.09294392623686454, 0.17461789727106136, 0.04333387369316366, 0.2065272107157985, 0.037410559756172135, 0.036654662123257964, 0.07780457630645521, 0.25177956920922695, 0.18063873953938236, 0.10597638554910171, 0.12093946718477533, 0.10059161573472064, 0.05222488744915266, 0.2457598650172862, 0.07083601615763013, 0.05418060942991465, 0.01777682742024067, 0.0651336949128054, 0.2360439023616896, 0.2696800843994873, 0.07221196066187097, 0.5432089703356846, 0.5138716729564616, 0.49586310863444705, 0.48523428142428593, 0.482817412990717, 0.4904570470945264, 0.48775017785282293, 0.5472120838635218, 0.4891589556322299, 0.12423673812190572, 0.11357704877757735, 0.09074535564627217, 0.12633946662140882, 0.09846573415000148, 0.09524436294828031, 0.11642538473190378, 0.12517694843200677, 0.12512218476264425, 0.1724111176101667, 0.14939802031133786, 0.1572442739989014, 0.21410417388252634, 0.1680589013883449, 0.2400153587827546, 0.16069853123666122, 0.17896533046132956, 0.17138461521103676, 0.26884910923362426, 0.3805760931974782, 0.2457598922637667, 0.3444314803774199, 0.23363508720076298, 0.30710662743691886, 0.3573837160790422, 0.24053635133082996, 0.2122468859296437, 0.23972638053533424, 0.20393045936534981, 0.20360331192310877, 0.1912743604629905, 0.25114123666631016, 0.20671222836669945, 0.29167245168753253, 0.248545749827366, 0.22647352662337672, 0.19427809442763955, 0.17317263231302882, 0.16623032346800282, 0.18109456731275408, 0.18676152982795136, 0.1853423528577246, 0.18120807043841314, 0.19422535816742104, 0.1875041728781448, 0.2108686526051914, 0.20529670585444115, 0.18455525145982044, 0.23837387905999996, 0.19918135898732559, 0.6716871564800755, 0.2312930236176255, 0.19687559986585934, 0.19280227481043644, 0.1610232763274414, 0.17785931801179578, 0.16926603312898203, 0.7749703136828382, 0.16525786901815176, 0.1691686273630637, 0.162889069800924, 0.16653852579993067, 0.8557979941873693, 0.20555842614179742, 0.1656981990152686, 0.34456156085486367, 0.14804037781655133, 0.20621686737829936, 0.4930249425501343, 0.12611048840040784, 0.14728138324564188, 0.2090086362700394, 0.1829463802814405, 0.1851903822317824, 0.1719118010845716, 0.18249292179360987, 0.18856385653965657, 0.17478671104005594, 0.19097810918518654, 0.1835378009473717, 0.17658799704870998, 0.0769953440165535, 0.07989883873500059, 0.07728026054645976, 0.10070651461698177, 0.07318856980874866, 0.0738410417841433, 0.07718247354126306, 0.07530199389496683, 0.0842851536641871]}, "mutation_prompt": null}
{"id": "1cf623ba-337d-494e-919e-b211d41608f5", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4\n        self.global_perturbation_prob = 0.2\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.96\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum Adaptive Differential Evolution with Dynamic Strategies utilizing a blend of local and global search techniques optimized through adaptively tuned parameters and quantum-inspired perturbations.", "configspace": "", "generation": 65, "fitness": 0.2909522710460561, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8324365425298271, 0.819366638103888, 0.8093448629623263, 0.8137017196496278, 0.8220071668058093, 0.8369249950279637, 0.8261190896470215, 0.818785567288907, 0.8437357897465615, 0.648758648098527, 0.13957507476619635, 0.6634315439319072, 0.6338523634338418, 0.6819746961886051, 0.5777986085550457, 0.5945850320399915, 0.7257662301395337, 0.6684409478025455, 0.12471286650112123, 0.13491898169840078, 0.1417132293450255, 0.1621026296513257, 0.168439709512767, 0.160525219769739, 0.16408488790316078, 0.16109908830579556, 0.13268425050723254, 0.10762966298605059, 0.10031148685808844, 0.16107242822987533, 0.09674071100267378, 0.5134562661153825, 0.0933761420482766, 0.08701239259459126, 0.09952575794171548, 0.11318121998835795, 0.8765849279986325, 0.8737246929017063, 0.8876279113456321, 0.8812764190276942, 0.8659196046841954, 0.9027061275705672, 0.8676754168325187, 0.9183964995778586, 0.8506144900674417, 0.4147530260778213, 0.3426598739890683, 0.41413156155080955, 0.4833479377494846, 0.4019545876813587, 0.4385753748178638, 0.3795422763086935, 0.4253057930147862, 0.4487508819314979, 0.22278314061624505, 0.28325561055683357, 0.3634507553170351, 0.8175775392973968, 0.7981713751184418, 0.7765657431181264, 0.7557692244007788, 0.22584995232865435, 0.32194715101233173, 0.17238601304578893, 0.15432789135319291, 0.24856932897433726, 0.14840285806130504, 0.16914957404869402, 0.16345868668784047, 0.16204225540259654, 0.19438589448183075, 0.1523556424422171, 0.14688265414167667, 0.10186485873434103, 0.1369264214044863, 0.12268009704494709, 0.17644796081881853, 0.1594851558072824, 0.14496475070242576, 0.14834118959543174, 0.14257485235685652, 0.0662108061183837, 0.018799229288045338, 0.02185829969323838, 9.999999999998899e-05, 0.02384402297212529, 0.014962585789511151, 0.022504638558898615, 0.06556454289287883, 0.0008751266071543862, 0.13208027187893423, 0.10021997269443639, 0.1920640898838203, 0.07211421866246315, 0.09126934920706176, 0.05017528960054296, 0.10835512609724829, 0.22681415416062323, 0.18072759591030785, 0.07699957439339256, 0.03793312877513921, 0.03801537363657048, 0.12827547977198883, 0.13152340065239254, 0.249855393615821, 0.1522145815772803, 0.16309968648358775, 0.10777898577565481, 0.11797297931148865, 0.08820221036336773, 0.0664781499893683, 0.22491985227401112, 0.13271517119627663, 0.19182626439102513, 0.11419248155508643, 0.20437325461690647, 0.15683453587791096, 0.4723356176315039, 0.458563378882375, 0.4655233902970991, 0.4498146867949986, 0.47467589696560397, 0.4507139031916835, 0.4774711920852165, 0.48237591013112924, 0.5327609573858604, 0.09049596402914872, 0.09076475727900946, 0.11938500869445656, 0.0993452008322172, 0.11089061316656901, 0.08902729968770728, 0.08092688872079001, 0.10409430094787164, 0.08174640846979642, 0.23823482944683883, 0.1990974705267633, 0.16276429648549962, 0.1985891596208884, 0.16774169700776853, 0.16344468456862848, 0.1734460245045284, 0.13217217625450317, 0.2033236510487011, 0.33608111426002285, 0.28408523522651963, 0.3048040569308189, 0.32888944216238625, 0.2688298438901904, 0.3561570514237574, 0.2871910942368622, 0.28576037302786583, 0.29301966593947215, 0.26810936138003894, 0.23177319745544867, 0.3381689070235744, 0.2862885970914051, 0.19538564568380068, 0.24454229452737264, 0.24899493418877405, 0.3047588489985422, 0.2854473502485947, 0.2118302495753429, 0.190210374702099, 0.17410506496702816, 0.18468854142144187, 0.19202291843863328, 0.16500486615353815, 0.18500697622398843, 0.17613170193097594, 0.1881516121866914, 0.20067690899921664, 0.5741200674559352, 0.21489109419907304, 0.21087204522021552, 0.2234071260304289, 0.2001966928464547, 0.19699747163134929, 0.19469459271986111, 0.19190327215247993, 0.20568562712636262, 0.15824252043717346, 0.7658473673459123, 0.1725725684400724, 0.18843518731754116, 0.6787460816575961, 0.7590678040944043, 0.7781825604040017, 0.15936447162234402, 0.3858104783094485, 0.33810612526536177, 0.1612037212159737, 0.19468229302486306, 0.2040007291774414, 0.694962674513526, 0.15100792155379317, 0.200252560943052, 0.19310895564145003, 0.18762541836371271, 0.17878515508934711, 0.17587344802117244, 0.1989637163640977, 0.1787316789560497, 0.18430410984753554, 0.1752017363960815, 0.176711348730632, 0.17974346034823352, 0.08093099049055275, 0.07952662867163929, 0.07673593364669873, 0.08329664541513593, 0.06927246218933558, 0.07609571466235543, 0.07731187165522702, 0.07706822069563712, 0.07220215115880824]}, "mutation_prompt": null}
{"id": "7ca0414d-ffba-4e35-bff5-fb18d3510c8a", "solution": "import numpy as np\n\nclass EnhancedQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Adjusted probability for local search to increase exploration\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability for diversification\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = np.random.uniform(0.5, 0.9)  # Time-varying F for diverse mutations\n        mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        CR = np.random.uniform(0.6, 0.95)  # Time-varying CR for flexible crossover\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumDE", "description": "Enhanced Quantum Differential Evolution with Time-Varying Parameters for adaptive exploration-exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.17676904199648405, "feedback": "The algorithm EnhancedQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.42834096696449486, 0.417427432113208, 0.4243691222451813, 0.43543232588877545, 0.43048412771141065, 0.4227653874628694, 0.40637580103790083, 0.41505679834183684, 0.41430633618904056, 0.10368588416108993, 0.10813501717821927, 0.11214479994923754, 0.08069014389454443, 0.0975445209339676, 0.10848490630285723, 0.12338173665789431, 0.10085049500491827, 0.11319909967227937, 0.08778900656418209, 0.10718128262253157, 0.10007955357628884, 0.09815384276858508, 0.08732256450072529, 0.07095262103821476, 0.08117174795386128, 0.08495190800617025, 0.08499763329130072, 0.07877044743499428, 0.08551167757819489, 0.07384468710206271, 0.07982944319983487, 0.08380290605657226, 0.08183796194525528, 0.06480476254748369, 0.07632011334493449, 0.07493412068099625, 0.8650939502597255, 0.8435899056967483, 0.9261084618212422, 0.8569816481944905, 0.8936061634696483, 0.9004239292540925, 0.8489022991841304, 0.8767606412866669, 0.8719854979617089, 0.1573708399166298, 0.15947445011349193, 0.16156484007549754, 0.16741902408105347, 0.16429929305902058, 0.17306387975444193, 0.1760887476671773, 0.19374623162777693, 0.19553949157464545, 0.19538271931401618, 0.22803259690470545, 0.2511263886571422, 0.2144218708066853, 0.2259218561848193, 0.2367182373919331, 0.23795600383255833, 0.2435847906812001, 0.23910783599660623, 0.11874461602083253, 0.11660836229123728, 0.11073327041822834, 0.1125211548720999, 0.09351340688770815, 0.1138033672553338, 0.10289579857282294, 0.10725605409805994, 0.11912399436652232, 0.09481031559581021, 0.06935526455006968, 0.12040411770483683, 0.11061363901808186, 0.10644737550654504, 0.11355549107518759, 0.09676265197700518, 0.09663730164488338, 0.1062145695504545, 0.0001330631635051427, 0.0011264228707861257, 0.024803006327666632, 0.003444448955921664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031437120978098365, 0.08659883260272361, 0.074788893772478, 0.1033246642643133, 0.08146692170441605, 0.07895175285360057, 0.05871688073309289, 0.12500099539286824, 0.09925086848920783, 0.10470075209969054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06063260457853481, 0.05370468393371297, 0.060831045852808185, 0.07504354490662213, 0.07742854521362441, 0.060049551664105416, 0.06404697485370447, 0.06278259030211009, 0.059866214619619496, 0.3545702472608737, 0.3466782042331159, 0.35305762969814725, 0.3658534884570458, 0.3461041160188866, 0.36040817848677165, 0.3457500599421989, 0.3573726073254624, 0.3458547544657071, 0.072902391957402, 0.07476108339488985, 0.08778052670262604, 0.06991861409817379, 0.07811054628069725, 0.06946668198058836, 0.07442826211200226, 0.07775660327656841, 0.08157251671492105, 0.12544707093154306, 0.13599931276359112, 0.13711868341772349, 0.13862289056018617, 0.146669433589807, 0.12157968320028789, 0.123685023109121, 0.13361310338846089, 0.16561643581101748, 0.21733812325344504, 0.23447583169475816, 0.2267851252732095, 0.22550502769536684, 0.20448062707990133, 0.22373318023933075, 0.23960240782031073, 0.24055649524516942, 0.2263523949105506, 0.15308164078646203, 0.16798327285384274, 0.15033915403756404, 0.15051945772792785, 0.141495986764979, 0.14818352504274568, 0.18111124141506452, 0.1785726910863319, 0.16706725128808342, 0.17552900212763978, 0.16800798595938982, 0.16610855513663536, 0.18481551777783056, 0.1714562497756975, 0.18318926817543246, 0.17562358928356603, 0.17728394738997577, 0.1679786025717772, 0.16962278433103362, 0.1766685150355608, 0.16862991929176474, 0.1749316402374419, 0.16189280570699904, 0.1567584837213497, 0.16720589915534234, 0.17034501506175148, 0.16910680071203021, 0.19489757924005324, 0.16827992332025898, 0.18643296177098734, 0.19545548122898915, 0.16690490947261716, 0.12936002558289206, 0.19989639228907974, 0.1595684774815671, 0.14332009526358036, 0.17007164590308899, 0.18283969926368382, 0.24595737822984198, 0.16296876152899908, 0.14862897187361435, 0.1875498911545982, 0.18807666340917728, 0.19235007497245393, 0.2023556283510234, 0.18092704179135655, 0.1908637170476749, 0.173921955942681, 0.18221842544205247, 0.1719649719812103, 0.17213982297195585, 0.17774934449084012, 0.18237943090685804, 0.1929811636675638, 0.05979672669770186, 0.06594724115036965, 0.0629052323817586, 0.0651979704449106, 0.07097006295221708, 0.06746348655633605, 0.06792032739331555, 0.06402538534831292, 0.074449539544451]}, "mutation_prompt": null}
{"id": "c3188193-c92e-4ecb-9ee1-7e1e9b3f8e29", "solution": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.75  # Adjusted F for balanced exploration\n        self.CR = 0.85  # Adjusted CR for improved diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.6  # Increased probability for local search\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Adjusted for slightly faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.9, self.dim)  # Adjusted variance for higher perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Convergence Control utilizing adaptive crossover rates and strategic local and global perturbations to refine search efficiency.", "configspace": "", "generation": 67, "fitness": 0.2795738309547968, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8273977908911999, 0.8032541388878444, 0.8392196163428592, 0.831566190952287, 0.7920291719707624, 0.8349091498482234, 0.8345067908501751, 0.8091409138007826, 0.8437614966997938, 0.18208895853077378, 0.48801313269992963, 0.24731086184380346, 0.12321663212318257, 0.24289444155425755, 0.5238743019543816, 0.2683442719788538, 0.48498274763481375, 0.40291308342167576, 0.1080933654281353, 0.126910858545502, 0.16661000728278685, 0.6728101938866208, 0.4699000055841226, 0.10852197274966313, 0.14576911199275533, 0.10067763552470366, 0.5027775771480207, 0.12934894885907777, 0.14744226934987748, 0.08689677374598381, 0.10995333515983308, 0.10465643023829996, 0.12307242055221324, 0.14757068814118046, 0.13417816269097638, 0.07286251283396705, 0.9202928267284431, 0.9077598473718763, 0.8807419099661101, 0.9714289152188629, 0.9148380488523271, 0.939754968830229, 0.9161829078424645, 0.9088329773349497, 0.9462900543795687, 0.4084867766297321, 0.404862962090228, 0.3961567228950281, 0.44247482520303116, 0.37453077706109417, 0.41683114763569273, 0.32832811682217633, 0.4420077392227566, 0.27185773566086724, 0.3396866144387579, 0.6966922572927656, 0.34175251551187813, 0.22315051241409634, 0.2045063293849475, 0.20279672582159336, 0.2673701455567924, 0.19237511297149334, 0.6217562433773272, 0.12774878457545524, 0.1624810747276937, 0.16899837088657554, 0.17329713206139952, 0.16035688999372, 0.12498721615992259, 0.16160698926816808, 0.16521122039816305, 0.26956730115109984, 0.1744368778261911, 0.11206456046509339, 0.18875381612268127, 0.17078979122450255, 0.12805596551253862, 0.1664318337652554, 0.1747175967596104, 0.12501219300024968, 0.2445299585653461, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041771882465115984, 0.05499681068821405, 9.999999999998899e-05, 0.07203253364689044, 9.999999999998899e-05, 9.999999999998899e-05, 0.12151644069796896, 0.17518228739571529, 0.12789555005590214, 0.09317836602555163, 0.11459428636460411, 0.1087808567996188, 0.11445567509841925, 0.13538254054293464, 0.16765429437089518, 0.058538166056645635, 0.05613477943849954, 0.04007272661865735, 0.10184182132527708, 0.08795709506955607, 0.005618241159933812, 0.12326676499808964, 0.1324184281021077, 0.025711904463313617, 0.20021813164823266, 0.22710939278635756, 0.08999415574035352, 0.2813198809305165, 0.29744903819896473, 0.202398816683788, 0.10471166551564237, 0.1212507315287743, 0.18332307284540794, 0.48778984164205075, 0.4858968441888125, 0.4527742872718218, 0.47628289449644345, 0.523601088590369, 0.4586165371824381, 0.5131126729806733, 0.4721355043195765, 0.47638535961473283, 0.1154231169559482, 0.12028930844773444, 0.10638858597865652, 0.12188490087451576, 0.08919911861346086, 0.08614874783453019, 0.09654799554068505, 0.13512537819464998, 0.10610333740587197, 0.14064697117463676, 0.15828122970943515, 0.18511395828840327, 0.17944357479794526, 0.1443565915465551, 0.43080751042233434, 0.13726118932625253, 0.15838845809798863, 0.3128911254752753, 0.32115237381670136, 0.3385198470713858, 0.29868934866835106, 0.2801776560681418, 0.3487568031593472, 0.363170316860856, 0.3558213141626919, 0.2659601691995195, 0.2898150461467818, 0.21777111190359277, 0.2364990351791607, 0.24658183439952885, 0.2178278101484984, 0.22010102843806512, 0.2054819231142706, 0.1972468833893012, 0.29491832192466394, 0.2319212395920971, 0.17075419583295803, 0.17440852578498567, 0.17913262634099303, 0.183314003282658, 0.1707119815640208, 0.17498207227215457, 0.212593265607526, 0.18337521208169227, 0.2083919743162843, 0.20514978893731495, 0.2072643164421445, 0.201973085991202, 0.5102034059540925, 0.17643926310660263, 0.6238930566890905, 0.2289445630329897, 0.1833863434415931, 0.20781203904537648, 0.8624348758917111, 0.16001058493190212, 0.16636054899997887, 0.7439093250668034, 0.19565321814478376, 0.8008531264068908, 0.1622221875945623, 0.1681721558989182, 0.8840493925771615, 0.6470669378175783, 0.16775911993869852, 0.16301745727392936, 0.2007088194918415, 0.19773663259669194, 0.16305550533231183, 0.205931498681991, 0.20168056547970847, 0.20775439762680792, 0.1710620683277546, 0.20753741518364155, 0.19803700288233372, 0.19598369025839146, 0.17776522852877275, 0.18019940078383456, 0.18200234059758347, 0.17876866250285717, 0.17896396251073443, 0.08564492200188922, 0.08910126891723524, 0.08900593295314152, 0.07754616528444147, 0.08835516282733957, 0.07668812382066315, 0.08463490877672852, 0.06998584091460125, 0.06860553953344095]}, "mutation_prompt": null}
{"id": "b88e9241-0149-43a4-9661-fa0b0705b1a0", "solution": "import numpy as np\n\nclass QuantumAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration and exploitation\n        self.CR = 0.85  # Adjusted CR for dynamic diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.45  # Adjusted probability for more frequent local search\n        self.global_perturbation_prob = 0.25  # Adjusted probability for enhanced global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Adjusted for a more dynamic population decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for stronger perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDifferentialEvolution", "description": "Quantum Adaptive Differential Evolution with Enhanced Global Perturbation and Dynamic Local Search adapting exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.265722546785143, "feedback": "The algorithm QuantumAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8566858167365549, 0.847501343630692, 0.8683049826917988, 0.8025287303036871, 0.8734262942817641, 0.8109472876781356, 0.8553607360909348, 0.8607556653684817, 0.8360321825704838, 0.24903721820906333, 0.208528579662007, 0.46431386390124096, 0.3737655289092241, 0.4809428075280541, 0.44445396967295503, 0.2597129391382934, 0.22120748877794594, 0.5197742938373007, 0.15510735291353572, 0.14477361268097044, 0.11151678081558691, 0.1375574581231378, 0.14962257022458014, 0.13700960518110206, 0.08696773759462773, 0.12752409048708802, 0.1765478829145819, 0.10489206483043056, 0.0984243208984995, 0.10064439915803813, 0.09324815869993452, 0.1034326534722142, 0.14509589825229263, 0.1027467975303007, 0.17795770975706615, 0.1015933284999675, 0.9013761350238049, 0.9178601657692403, 0.9227121665430531, 0.9264344642865642, 0.9053809720042908, 0.9200479749060055, 0.9278109125301188, 0.9274932349319127, 0.9190996169358825, 0.4608374256251605, 0.4420570079755448, 0.34943050594606495, 0.3303372853820682, 0.4075870824621223, 0.4175021663024684, 0.3915112507372346, 0.3670820628056314, 0.4205703761049042, 0.20750169850137468, 0.2044019062600172, 0.3362945352564115, 0.2720132878045537, 0.20469501196385276, 0.21293703829471178, 0.49837804624240567, 0.23049231259298064, 0.3794267290281227, 0.16366873925384828, 0.14185250164434038, 0.15283484926696655, 0.3843532657312114, 0.21486188912216408, 0.12606783633973284, 0.34769451984647815, 0.12505614830900635, 0.17045676158380196, 0.14506236882368284, 0.10338182738004309, 0.2827304255072114, 0.15724701799913876, 0.32581251538585554, 0.12145243673027306, 0.1241068801145584, 0.12294782430279916, 0.12153682144769429, 0.04695066409317383, 9.999999999998899e-05, 9.999999999998899e-05, 0.009012356247524389, 0.023619443629004255, 9.999999999998899e-05, 0.004320968545785231, 9.999999999998899e-05, 0.03996419189788081, 0.1728056350312248, 0.06150478617220401, 0.08075179881074523, 0.04401795373966999, 0.04511359078092825, 0.0015088419411130038, 0.1962674450573597, 0.12921006327554208, 0.09416920944651597, 0.14317618444537916, 0.1714765914255586, 0.09981545209584852, 0.14988009910586952, 0.19631053311021918, 0.1398160087411925, 0.20466120361319884, 0.12500072696019338, 0.26347745536094025, 0.1817988404324825, 0.1228654137773616, 0.08964220121910382, 0.1257578009554361, 0.12769566330312443, 0.27328879161837993, 0.11222227885638258, 0.0777449428350585, 0.19575528337564352, 0.5270581011545807, 0.44686615864109835, 0.5073861916747151, 0.4987211685627597, 0.5313799145558911, 0.4730177554139484, 0.4811659598588004, 0.48898547917572843, 0.49938806026253235, 0.1005332776075114, 0.10965590857249485, 0.11968788125776098, 0.10832853421195754, 0.13631330709149247, 0.10536032431001019, 0.07301976000202559, 0.09383129274171609, 0.10777079896686703, 0.15473510351019382, 0.12620506686188604, 0.22973084773837282, 0.1437794803974819, 0.16074034822878636, 0.17198017363489748, 0.2102645499699537, 0.3039419151260233, 0.19413636506132015, 0.30721189233682933, 0.25006072150750747, 0.2571107090265772, 0.2603315075472078, 0.3028250191162417, 0.4122291915966886, 0.29578313205708895, 0.2880413215341351, 0.2451262918656727, 0.3094111625288255, 0.18523216287486044, 0.2640841281624041, 0.21104874149631592, 0.2942199668616676, 0.25207969570855726, 0.2720839291236592, 0.23673781578711928, 0.18285345766353323, 0.191170836562356, 0.1900927909849316, 0.18490316930964568, 0.19344296681648243, 0.18378363390259111, 0.17623818186819795, 0.19127362849840457, 0.21642670208727344, 0.19080957446456215, 0.19169087185668365, 0.19566160942752586, 0.1848402924063025, 0.2196786246181246, 0.16985703929370777, 0.22509475730971829, 0.21299648721427533, 0.2077227032768446, 0.18644545597047157, 0.1663874327180438, 0.10782506368255051, 0.7953151892594644, 0.865410450113659, 0.19260332534169156, 0.16131752672922062, 0.2021966039763553, 0.1579034274368496, 0.16206401655394242, 0.4854764905465363, 0.16466884203285026, 0.16426948812904807, 0.1999822761116664, 0.4343739524519947, 0.20535223398897084, 0.16301492188888278, 0.20365953690757355, 0.208227202377403, 0.17221030399424653, 0.183422703691143, 0.18727412936772125, 0.1858709604207276, 0.1805687036080761, 0.178132255133561, 0.17277729119095386, 0.21277540708668763, 0.17657823197044797, 0.08077302046345991, 0.07471735766638954, 0.08542683963124453, 0.07553263648030062, 0.07158958013200156, 0.07431216799068674, 0.07402518518115864, 0.07979371974437566, 0.07731716240928421]}, "mutation_prompt": null}
{"id": "5052b897-a229-435e-8e24-be200a813b71", "solution": "import numpy as np\n\nclass QuantumAdaptivePopDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Reduced F for finer adjustments\n        self.CR = 0.85  # Adjusted CR for diversity balance\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Further increased probability for local search\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for dynamic adaptability\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)  # Adjusted perturbation range\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptivePopDE", "description": "Quantum-Inspired Adaptive Population Differential Evolution, integrating dynamic population resizing with quantum local search for enhanced adaptability and convergence.", "configspace": "", "generation": 69, "fitness": 0.25672043445850473, "feedback": "The algorithm QuantumAdaptivePopDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8881735300881187, 0.8827010782112659, 0.8426933262466675, 0.8676988450276646, 0.8519961835654187, 0.8675578103870263, 0.8737724104584708, 0.8540792181642651, 0.8727801867243188, 0.2238197230206137, 0.10850890763643206, 0.39822442686948867, 0.2868257679786056, 0.45144939917596816, 0.4146932852879345, 0.30889288548935667, 0.3642315777205971, 0.14979802103839324, 0.13925350011034154, 0.1188092801332512, 0.12343583709926609, 0.1181692430217729, 0.11841822064396634, 0.15566224749170998, 0.6686777214363362, 0.15126431234539217, 0.10086435779680847, 0.11816017090340414, 0.12007929193622235, 0.14732481605529424, 0.08344140413335843, 0.11065160515131589, 0.10089384985748107, 0.11211341118232898, 0.15518841770853575, 0.11857094474131391, 0.8970794877824617, 0.9100222500815087, 0.9002621579609964, 0.9037697879678458, 0.9061845467267148, 0.9024869898825082, 0.8995228741007718, 0.8971904948428706, 0.8615635277223187, 0.24592974608087248, 0.3188422653474956, 0.23762931714690894, 0.49959229409708394, 0.5560811301225372, 0.370744427360043, 0.30383024243259293, 0.2951363470436146, 0.32765265433393, 0.20979101456894855, 0.14215537971025582, 0.1661994097768813, 0.20789267262463962, 0.3695231913795788, 0.3415939598066976, 0.14275372698856448, 0.12525276151051534, 0.1729400930831918, 0.26390816439143905, 0.15017656067199914, 0.13221651033246185, 0.25933626528080733, 0.16944691848583682, 0.16040178863973198, 0.12030016517399689, 0.12407205214157802, 0.1481648223065153, 0.16030784431177358, 0.1071146872339872, 0.13303094856777953, 0.21209346093863124, 0.11945926527723272, 0.15403228865981744, 0.12682200776387564, 0.1222661636220197, 0.1530712586502181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00145595603926707, 0.06016554691892961, 0.05241497869574341, 0.03678627065693696, 0.11251674222298713, 0.09718694769392078, 0.12204004082830633, 0.06018157461764717, 9.999999999998899e-05, 0.08780921590274104, 0.11461247247702067, 0.07259632611819344, 0.11164546214996518, 0.046893936542620085, 0.08915905068739971, 0.044546584422304525, 0.08639036494319319, 0.08056185304397256, 0.09809359242436222, 0.14999150494586233, 0.13027125656298721, 0.3739252357021745, 0.24287636026286952, 0.16945500613816877, 0.09548878984024667, 0.14125139052803226, 0.08334345384951125, 0.1651684843838953, 0.07195853963347676, 0.12598232971620205, 0.1548996240478886, 0.472138359905804, 0.4492329508505597, 0.5001958318334044, 0.44679835733089657, 0.5389277356163424, 0.48269859222492173, 0.4601381066925987, 0.5239372720362799, 0.5468643131879392, 0.14335771439435707, 0.127922656123599, 0.12401352274953736, 0.1247141601747066, 0.10378213835330263, 0.12826118803889308, 0.12285100217241762, 0.15215755250283547, 0.13166586035754368, 0.11914275789622697, 0.25670719938508957, 0.14215263248017052, 0.290030775278881, 0.14770578018772307, 0.24314208325638342, 0.12287447693237286, 0.20800061126813452, 0.1482343462532919, 0.3454252177323808, 0.20188275965175484, 0.22930938544922463, 0.2962323040220134, 0.3218536529544592, 0.22129448349606018, 0.1828469075421092, 0.2551605764845334, 0.18636880362088826, 0.2177398770900354, 0.2188083750631229, 0.3094325271084354, 0.19232748919249953, 0.2100089777523343, 0.19308600859959513, 0.1847955564926228, 0.2640100790251164, 0.15826760559779252, 0.19972069597350417, 0.1946918943944368, 0.18910957310037846, 0.2036920090555343, 0.19324367962933497, 0.21656028060786092, 0.21776869560147338, 0.20907691689385344, 0.19886321087621217, 0.1726181779041135, 0.17618010106623372, 0.21740526401158555, 0.24241956276294818, 0.2020928033924575, 0.23923572948455774, 0.20187896046359344, 0.17793206717977594, 0.1641725346508216, 0.16203906760710396, 0.8047407809760927, 0.1621720028455742, 0.8508882776314425, 0.19444399067819518, 0.16827588861982767, 0.7629384990774266, 0.17361691869927054, 0.202102272811287, 0.3334025861069958, 0.16439391722669694, 0.1250349754792336, 0.3392390487264695, 0.1606193773263247, 0.20264387116590543, 0.20451743221096708, 0.1262842785504965, 0.2004733011391424, 0.19044216877049636, 0.19360341191313146, 0.19185056772539444, 0.21412344056939714, 0.19274425897525993, 0.1901722188825189, 0.1700491579320984, 0.21470863636809268, 0.18993348492058104, 0.07913012939771613, 0.09602901864812508, 0.0905161573395189, 0.08178166964278277, 0.09193397791145796, 0.10561054760864541, 0.09877127556372556, 0.08784134426878354, 0.0943971385453829]}, "mutation_prompt": null}
{"id": "5451815e-c774-4a2b-9ccb-441120826909", "solution": "import numpy as np\n\nclass QuantumAnnealingDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Adjusted population size for better exploration\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adaptive F for balanced exploration\n        self.CR = 0.85  # Adjusted CR for better preservation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.1  # Reduced global perturbation probability for stability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Modified adjustment for more controlled decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Adjusted variance for more gradual perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAnnealingDifferentialEvolution", "description": "QuantumAnnealingDifferentialEvolution, integrating quantum annealing inspired local search with adaptive mutation rates for improved exploration and convergence.", "configspace": "", "generation": 70, "fitness": 0.27925413178610164, "feedback": "The algorithm QuantumAnnealingDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8156352436416321, 0.8390865505309193, 0.8377306539717628, 0.8480118360662535, 0.8132571010616663, 0.8146860110570289, 0.8445724196926474, 0.8075833486721995, 0.8289761461549292, 0.4643251550600337, 0.6354633864347166, 0.6442698043242984, 0.6024809092491707, 0.6184711955701632, 0.48998809739720905, 0.5173398822427099, 0.6146803301077599, 0.665769002633932, 0.1251873486803723, 0.1699828593478514, 0.1497358405147945, 0.14838042474655777, 0.10891161170142005, 0.11675982883774672, 0.14716757546745407, 0.11019820768937838, 0.14288852318440182, 0.12328329654744519, 0.10405914488066592, 0.11297705052833718, 0.532172148296431, 0.08991141406311054, 0.14441997878064816, 0.1344189561448237, 0.13001538543177227, 0.11350648291301335, 0.87910125493459, 0.8997479964971534, 0.8929902486882466, 0.8942458080623816, 0.8968835268764356, 0.9131382923678661, 0.8929326725933764, 0.8893015945552493, 0.9008025338960158, 0.48558042086461817, 0.4833144734191941, 0.439572320453661, 0.39198629124361795, 0.46370293131292495, 0.4562446605944024, 0.4157792629921926, 0.46427701965932755, 0.4079181483322998, 0.8447953249300415, 0.20662369209153297, 0.3285890341915776, 0.7158243238435296, 0.1716739347686589, 0.3405954129161092, 0.1855893528127487, 0.3718450513455477, 0.23758172052871118, 0.20223760835837534, 0.17361092517850119, 0.14196908314365353, 0.17157133617756004, 0.1231203811103444, 0.18442321912522885, 0.19592214947787567, 0.18663964920204068, 0.12004495718036179, 0.18081036726429733, 0.21006402035066363, 0.10952676298340647, 0.19815145871324147, 0.16030373501064454, 0.13400048423584798, 0.1582950347199754, 0.1717432638177524, 0.16331351415544526, 9.999999999998899e-05, 0.016933610106784958, 0.06827531899786243, 0.10140407125795481, 9.999999999998899e-05, 0.01395744094451945, 0.009749734078315475, 9.999999999998899e-05, 0.05817298700152007, 0.1272569740869096, 0.059203832199005046, 0.1772154101258826, 0.06719183063848178, 0.02485781292455924, 0.05930904466746323, 0.19989312825141092, 0.053492154017668825, 0.08131732105418321, 0.09763818395616364, 0.08576575531519626, 0.23240746501883736, 0.11448347733469177, 0.13965259098733718, 0.16986197310710416, 0.08876206958439048, 0.17120442152329873, 0.12322485996080845, 0.21336063158909468, 0.09611899328080475, 0.060560599056699305, 0.12744082546616753, 0.15006824425012177, 0.07968074467459263, 0.24453906839723594, 0.15766407188136122, 0.18239310300113942, 0.5380444227796548, 0.5575835640393179, 0.484642555711603, 0.5537936514339477, 0.4975402611163948, 0.48054550179977673, 0.5359178913854856, 0.48361428321970323, 0.4855037370444607, 0.12103009118175445, 0.11188389187446668, 0.13046935988265473, 0.0958256146264792, 0.10945460372213833, 0.1034631870648709, 0.11219666993030808, 0.07847057115302736, 0.07504308724442721, 0.14843850695662242, 0.142962112449334, 0.18025147434331446, 0.18042463769427863, 0.13557043408413405, 0.2081777401240701, 0.1289957416501275, 0.1455425238329786, 0.15182425137222366, 0.26772709392193283, 0.38093179733680027, 0.29031807842681234, 0.41664619937466174, 0.3756105874832094, 0.31434748437630033, 0.3354568831752168, 0.3716291041594122, 0.33157557030713747, 0.21711112972784785, 0.2384061447601573, 0.23173170994515258, 0.192232111209086, 0.2329361781710928, 0.21801446444942962, 0.24992819153535828, 0.2472713795692505, 0.19596352104308346, 0.16913964794116454, 0.18784087496960578, 0.2142476907666715, 0.19136178506223944, 0.18485996073760147, 0.1884447898963557, 0.19090988412794707, 0.17423891683656878, 0.18913029580520224, 0.18693234522733293, 0.21270988976328498, 0.18033533061369578, 0.1917513183218229, 0.23416450340568373, 0.176433786526893, 0.1898155412955682, 0.17079126068377504, 0.17501220800842243, 0.1618478751687249, 0.17930260090911, 0.16612089462725688, 0.17200345467903644, 0.8378503009389445, 0.8150785961036469, 0.19132203047589247, 0.17874600668733076, 0.15075494062558814, 0.2804793139903602, 0.28952407689005655, 0.14914758036436926, 0.19553742080045555, 0.09971817946217543, 0.532824264430431, 0.20696448888373875, 0.12577749698506702, 0.20568333571188524, 0.18927259112096895, 0.17756839206384978, 0.19442995739726687, 0.2102465925077367, 0.19291604006757856, 0.1797001472799673, 0.18373627161395067, 0.17179486098555774, 0.1794700523376399, 0.08627593781624532, 0.0782849412857749, 0.07230765711460263, 0.07188170417352668, 0.08718988203571865, 0.07289373112802244, 0.07387401729761589, 0.0771350594086394, 0.07201759040983402]}, "mutation_prompt": null}
{"id": "b671592c-d3b9-4c88-8272-4b1f41367cd3", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Slightly increased probability for local search\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n        self.elitism_fraction = 0.1  # Implemented elitism strategy\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for a more aggressive reduction in population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim) * np.random.normal(0, 0.1)  # Larger exploration space\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for more controlled perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n        \n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n            elite_count = int(self.elitism_fraction * self.pop_size)\n            elite_indices = np.argsort([func(ind) for ind in self.population[:self.pop_size]])[:elite_count]\n            elites = self.population[elite_indices]\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = np.vstack((new_population, elites))[:self.pop_size]\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted Differential Evolution with enhanced perturbation schedule and elitism strategy to improve convergence and solution quality.", "configspace": "", "generation": 71, "fitness": 0.23828514915349536, "feedback": "The algorithm AdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7849898288221845, 0.7558614616098729, 0.7688117545139954, 0.7491915444862692, 0.7517027154811998, 0.7766198615276916, 0.7817664683647949, 0.8077157248546085, 0.7870084701565829, 0.4481721216599204, 0.1603699350244786, 0.21973960534536918, 0.44743366010223085, 0.15919464236140013, 0.28197666967921176, 0.1572190488451386, 0.1443552585843163, 0.22971471860375958, 0.10140784876615339, 0.4221066955917093, 0.1160396240641337, 0.07186301271894624, 0.12038431422018425, 0.10697799083786208, 0.15378963562499304, 0.4164860117155714, 0.1292605070970536, 0.14402973413118492, 0.08582263101824761, 0.10732919708572353, 0.12151778212472708, 0.0846186064148775, 0.14742582474835908, 0.10577964772281734, 0.1081289487186583, 0.28249882037255836, 0.8470675037111804, 0.8628477454598027, 0.8572604893013741, 0.8809831789978418, 0.8954264893305053, 0.8618048336541674, 0.8850580711734366, 0.8707276167027489, 0.8555332428909446, 0.32437298679592286, 0.25257763428728364, 0.37481749371593953, 0.2919085189756345, 0.4086304837592699, 0.2769259614923274, 0.31589759999474887, 0.3571094478545238, 0.3266250484992931, 0.17066975786536298, 0.21404748565691667, 0.23088010769214984, 0.3206715189607272, 0.7360276370625527, 0.20134441242525614, 0.21289250651759783, 0.31946417487743983, 0.1606576057771637, 0.15820110083855432, 0.18239717376979903, 0.1237445996821207, 0.11883788880567003, 0.13722971818283658, 0.11970617269873496, 0.12035281593625002, 0.14717224730577927, 0.11111420166210806, 0.10656836860163421, 0.1401357714074296, 0.1599571853744607, 0.1277874196736113, 0.14023036639207254, 0.17644997196311196, 0.1367558363641208, 0.17259535619846933, 0.2369823242361625, 9.999999999998899e-05, 0.11430151223209684, 9.999999999998899e-05, 9.999999999998899e-05, 0.07860620612375824, 0.015016724306375906, 0.04768534253865475, 9.999999999998899e-05, 0.00680952365140397, 0.07332174196706798, 0.03355878298067305, 0.07352068283962765, 0.0854346881631789, 0.03946803489438644, 0.04712443323882254, 0.061572910696570005, 0.019790028580810914, 0.1332424116218166, 0.13159327562465328, 0.025534657660471582, 0.07140353272399114, 0.17206263192241134, 0.11768105792858896, 0.0837590977024556, 0.03998858039516584, 0.09771132334029808, 0.06164724670475552, 0.08263459069044676, 0.08310556420553072, 0.1487337808792063, 0.13335979895108763, 0.04838073476624105, 0.12505838194961538, 0.07397129188586293, 0.144093467209934, 0.07994225827100276, 0.4640937011996147, 0.4668315902038106, 0.47670811869710183, 0.4464451740334823, 0.43857280045724145, 0.4167842932373498, 0.5008207525361583, 0.4704340896311784, 0.4895930262180437, 0.07882355207320357, 0.09504107642517212, 0.12418248223535977, 0.09905987023518559, 0.09218379144214228, 0.16221219979199886, 0.10223938604036953, 0.08174326192034209, 0.09491591609084293, 0.14358960217931616, 0.30633303015939994, 0.1519899087729657, 0.1557631411871243, 0.1509074089746073, 0.23883584492283783, 0.16882098370862753, 0.12940552891138557, 0.15478801054573976, 0.23019853428491865, 0.3095068160774467, 0.2723061497716228, 0.31079392076469514, 0.28258093964250897, 0.2369415040502061, 0.31618493526855496, 0.336585920381399, 0.3449634818926022, 0.2260535434873292, 0.21960963308303516, 0.19580456359562382, 0.2006438063300674, 0.18519818556465684, 0.31163833479937153, 0.2281673806181398, 0.20361354724190128, 0.2366899112355273, 0.18977096266120874, 0.18041348113151612, 0.18233242588415177, 0.17670099433866693, 0.18491735617995742, 0.18001261892877196, 0.1909240855932769, 0.15934906997748854, 0.19201478875333078, 0.18303349963014193, 0.17828151639420808, 0.20958855009882105, 0.19712667447598076, 0.19928737905273286, 0.2240981757980065, 0.1972059197149607, 0.16821537724120483, 0.20378463761853005, 0.15849927081295778, 0.19965610600919292, 0.13329364665460797, 0.7610813033337834, 0.7071832047885483, 0.1283204739749415, 0.1583351045635556, 0.1788237357474627, 0.15348486435549602, 0.14711804419653418, 0.20344625669329675, 0.14899094413531888, 0.12659889106925326, 0.19238993244503466, 0.1960911177122131, 0.11007907222558355, 0.20023244075362823, 0.1020090136352303, 0.188006943521843, 0.17345995972489103, 0.16829303468752133, 0.183445157972418, 0.19299037176128875, 0.17193702873861372, 0.1848729887534748, 0.17794129206726117, 0.161527090170964, 0.06952351849340543, 0.06901417325174675, 0.07393509430823397, 0.06771191983377978, 0.07283457360981993, 0.06356785509717389, 0.061606389242768844, 0.06181748625966377, 0.059544060991543524]}, "mutation_prompt": null}
{"id": "e14ba9ff-290d-4a87-911d-199732cfe7ff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Exploration factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4\n        self.global_perturbation_prob = 0.2\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        # Incorporating dynamic mutation scaling\n        scaling_factor = np.random.rand()\n        mutant = np.clip(self.population[a] + scaling_factor * self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        # More gradual adaptation of CR\n        return 0.9 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.94  # Slower decay for population reduction\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedAdaptiveQuantumAssistedDE", "description": "Enhanced Adaptive Quantum Assisted Differential Evolution, employing dynamic population control and an innovative mutation strategy for improved convergence and robustness in diverse optimization landscapes.", "configspace": "", "generation": 72, "fitness": 0.25258785366597286, "feedback": "The algorithm EnhancedAdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7883226542023358, 0.828443527564612, 0.7453331133133758, 0.8339386103864292, 0.8317640495922117, 0.8284520337933644, 0.8336816983286996, 0.8161662574988446, 0.7834657763176646, 0.004077855422026544, 0.03202319189041303, 0.14526516091374675, 0.00019029658549718498, 0.1907463970501344, 0.15097445000531262, 0.024986934733197685, 0.15545808796786875, 0.014580544573964516, 0.11336575793606984, 0.12259075902996885, 0.08397762905684814, 0.11363987407314868, 0.11275937371781075, 0.1285595890166985, 0.11316209719716663, 0.09709747608758879, 0.09394843115521723, 0.10741440535654168, 0.11202672444841377, 0.10615836746649288, 0.10687307342040908, 0.1171374185740236, 0.0913486533876039, 0.12667733282060922, 0.1831541213104756, 0.09103843464607142, 0.8962968316215961, 0.904382057980706, 0.8841826730171195, 0.8738582933793326, 0.8891177329033499, 0.8221534108080718, 0.8920194749276065, 0.8759593486024622, 0.920840675318579, 0.42379051513519517, 0.4524465644833091, 0.34967879030730165, 0.501751885219892, 0.27879203424415433, 0.3724200663224315, 0.4224901560495834, 0.2838856785921656, 0.48080608469704667, 0.21852514850433413, 0.20294739732604583, 0.22011914128995813, 0.3255616679239399, 0.20551554126119942, 0.2335628864519499, 0.1908117810499953, 0.18426964207337482, 0.6268028660639038, 0.15994103879963328, 0.1477446461042211, 0.24066827773171695, 0.1458384327672726, 0.19775367582555914, 0.29646741926694176, 0.2311322204312214, 0.14505442616932362, 0.1824263831832268, 0.12642328608861586, 0.2387459619532727, 0.12669473991186664, 0.14454421615365431, 0.2265034575777971, 0.143550094756408, 0.14252331524556083, 0.1500211147659991, 0.14939400469591746, 9.999999999998899e-05, 0.030931458433616665, 0.1328669594404448, 0.04195120224062843, 0.032681617211233416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02076775022329891, 0.1234330069149513, 0.03954398842882112, 0.10504759325930879, 0.11037061163146189, 0.08030377574506475, 0.1471054396835889, 0.1736087971686846, 0.08720748479167562, 0.11689458695461707, 0.08352586901807046, 0.0720881177158913, 0.11317573423932259, 0.08995487491804177, 0.13137171787357493, 0.1664190470768555, 0.1538913340248832, 0.2354881135820498, 0.14921917711204313, 0.09812969125416571, 0.09261108361896642, 0.3213025131807057, 0.06387815895969085, 0.26382969367040254, 0.21396542265536855, 0.19972610908047184, 0.054829133788148465, 0.07303034441673373, 0.4607266127503976, 0.4508424683952522, 0.4710069495404835, 0.4686785777388073, 0.43840306551601993, 0.5069247128198562, 0.5033417393879356, 0.4766982416455191, 0.46520319596928206, 0.15248271804317137, 0.11003445507334586, 0.08357698431903571, 0.09487651346492598, 0.11489529637324847, 0.0708802686984944, 0.12030661719069047, 0.17258694154455456, 0.09526060797858305, 0.19827995819124677, 0.21303853812759665, 0.19108981681231485, 0.131804822998153, 0.17670935571229163, 0.1559162000714428, 0.19259504963769092, 0.12390382905867703, 0.17639235518738883, 0.253924181472983, 0.4152777249933042, 0.24882200045760705, 0.21888891314842607, 0.2237838297900474, 0.3203144962375084, 0.21668686571845897, 0.329804066226173, 0.2327497675779039, 0.20471104910318838, 0.2635346504864162, 0.20779903416953416, 0.19823452357143012, 0.21106056377056182, 0.18740847041655317, 0.26250731210718337, 0.15871814350592395, 0.24868860746758714, 0.18080276883696333, 0.22362258941342505, 0.18345403073927713, 0.2392601220229139, 0.21401472813154276, 0.19990390436937122, 0.24006297916071784, 0.21084034854905276, 0.2020668574689185, 0.18865281798781275, 0.16163327049931486, 0.20456179126935803, 0.20242090788185607, 0.18423732456305586, 0.18405407443293764, 0.18186902124872228, 0.21621872554289745, 0.1601756834783613, 0.1816685108889503, 0.16663946195949286, 0.1506233550624373, 0.8661628665736782, 0.7508083049711805, 0.19468544130846066, 0.6503029316757554, 0.20562666604466262, 0.7032877547602967, 0.34379907795203046, 0.200538009947404, 0.32730247454950345, 0.08223033117592526, 0.15291043569335538, 0.4924298900869515, 0.284978763659135, 0.20417355794261993, 0.21776406535996984, 0.18697781744588837, 0.18407438533630616, 0.18567712417758908, 0.17938512119772765, 0.20141330114595934, 0.1852547258208167, 0.19009471898189945, 0.2480896399213457, 0.23255717628254202, 0.08008802578828922, 0.09872134925128118, 0.07373226905569097, 0.09308861395706647, 0.09020972062419352, 0.09111569631579275, 0.09535184136053754, 0.08193792926604437, 0.11128737410920764]}, "mutation_prompt": null}
{"id": "3adf8554-64d4-4d46-b9fc-007df9fb7542", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration\n        self.CR = 0.85  # Adjusted CR for slight diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Adjusted probability for quantum local search\n        self.global_perturbation_prob = 0.3  # Enhanced probability for global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Slower decay for population size to maintain diversity\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Population, integrating quantum-inspired local search and dynamic population control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.27006582425121395, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8343991815431763, 0.8224587055050665, 0.8721007318945556, 0.8412746682047829, 0.8291316676133005, 0.8839416511815498, 0.8691492355467628, 0.8662323364781048, 0.815422986276318, 0.5414209992598882, 0.33749176793116764, 0.37731731011587366, 0.39178642768549155, 0.12980089202991152, 0.5724712202254565, 0.2673825417125607, 0.19213996086476937, 0.5111490504484753, 0.12622178781784188, 0.11213986435135981, 0.13813291616339285, 0.15213936605455325, 0.17109626543681256, 0.15123033784059003, 0.5172785083137659, 0.16512354797592432, 0.17398219707993723, 0.1287584605471358, 0.10524691537189135, 0.12414467094437254, 0.07471149476993433, 0.07893566814880104, 0.07546432122262992, 0.11808007689044575, 0.14102306394459008, 0.13603671594383226, 0.9144136259672784, 0.9095194289871827, 0.9182785787043127, 0.9228203458198293, 0.9311305199478854, 0.9328663083006025, 0.9132451423248275, 0.9196452965900893, 0.9266344060950555, 0.3574201225226449, 0.3694712162506585, 0.3348128124897397, 0.4141762874509135, 0.4780654517152556, 0.458381254470155, 0.4692320888914837, 0.3275558075478471, 0.3945560379530775, 0.25442018103748765, 0.7168994439727643, 0.6587898346799372, 0.3248095808225877, 0.26909607173602335, 0.2618107984187489, 0.5384542397890855, 0.2181888517120717, 0.17299572073027325, 0.16722470188575222, 0.1682828106989649, 0.11866760423240863, 0.12361512304349487, 0.1581183028450579, 0.16126485293757264, 0.2089581397203797, 0.1627306503649637, 0.1506102203747507, 0.14378574436429714, 0.3077761155659028, 0.15067751498495985, 0.1301852275301273, 0.13471459167669253, 0.15284608576521164, 0.1433344770304218, 0.19240471049772878, 0.16429097007892268, 0.062150499848674046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050256264118559546, 9.999999999998899e-05, 9.999999999998899e-05, 0.06277932567690492, 0.03084307790169971, 0.09316364730453897, 0.11396052994429595, 0.04994877344245541, 0.06747379522620578, 0.07606752308016329, 0.12041394319981469, 0.09798729276015261, 0.17800762656924385, 0.10500673569162755, 0.15204044351547696, 0.07403928999533749, 0.1411234055909616, 0.07640550828079051, 0.15234400306368368, 0.18568788630753874, 0.1511647161031866, 0.2010094964322956, 0.13469503607620226, 0.07574132182076809, 0.08783832143117232, 0.21802938439437392, 0.11354825965114002, 0.0899991688898808, 0.10724397872295233, 0.08514177585661198, 0.49262792747026896, 0.5591333347002115, 0.4823413708316484, 0.49220159784645945, 0.5487768081574412, 0.4687868593501645, 0.4924350669178692, 0.47985346854199196, 0.5188214323920507, 0.1003388705837257, 0.13425800088963225, 0.1378488600057668, 0.11607642676072372, 0.11761095782417874, 0.08891096059795722, 0.15317329854680595, 0.1104835651749958, 0.08960564486969125, 0.1606226656003118, 0.12984848599628018, 0.18932409180293985, 0.26543846538168014, 0.14792235008008825, 0.2585281941419765, 0.19232203554579874, 0.13849527191954092, 0.15978191134581632, 0.2710717480990599, 0.28361325598974907, 0.28229563903781874, 0.3097328786136141, 0.3617700356383937, 0.24210325164488766, 0.3547245887675986, 0.3682308795698567, 0.3033082308069246, 0.22009707287172908, 0.21312656812121922, 0.2507935758885118, 0.19793415899940248, 0.3171557710461602, 0.20531917420675805, 0.21774568577929854, 0.2608343170752452, 0.31037454169099754, 0.1853679844695173, 0.19287746611134682, 0.20107456523340328, 0.22567753301475824, 0.19698474791302445, 0.17894622070518196, 0.1925227174170736, 0.20299202595543553, 0.19203563399967327, 0.18708295088961846, 0.2343129587119135, 0.2056142027370721, 0.1857826901473899, 0.1776036122607757, 0.21074632268082005, 0.1813819924478457, 0.2136484007814119, 0.1912861397446256, 0.8677202260631018, 0.1805800147854354, 0.18176999964504426, 0.15894113688211386, 0.19676411748182332, 0.19364878582191114, 0.1437975127236013, 0.7944619617846286, 0.16277479853198495, 0.5509901390554721, 0.16357740908684004, 0.44342939620824084, 0.16113921536321396, 0.19774939031203498, 0.09658545781740557, 0.2916103763011766, 0.20019941320181422, 0.2077051309168716, 0.18592688384854905, 0.18681104153864692, 0.1811795838153707, 0.1816698938909762, 0.17775509647700183, 0.19599725892493147, 0.17394479115767936, 0.1721123750133513, 0.17694527883314493, 0.0802546340140472, 0.08777594746734607, 0.079516372783768, 0.0757447651912635, 0.0713125241864977, 0.080965771186295, 0.07234576399721515, 0.08324673204157518, 0.07872553681055194]}, "mutation_prompt": null}
{"id": "cd28d1c6-02ff-4bd0-bb1e-f1ea172bc777", "solution": "import numpy as np\n\nclass QuantumAdaptiveEvolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Slightly increased initial population for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9  # More aggressive exploration factor\n        self.CR = 0.8  # Slightly more conservative crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search for enhanced refinement\n        self.global_perturbation_prob = 0.25  # Balanced global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Modified decay factor for smoother population size transition\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for exploration and exploitation balance\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveEvolutionarySearch", "description": "Quantum Adaptive Evolutionary Search (QAES) blends quantum-inspired local exploration with adaptive control of parameters for robust global convergence.", "configspace": "", "generation": 74, "fitness": 0.2593519924639783, "feedback": "The algorithm QuantumAdaptiveEvolutionarySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.815967929531898, 0.8124670500143283, 0.7865761699488302, 0.8283063320221826, 0.8123655588212725, 0.8020033546231331, 0.8245627984352147, 0.8295449974535943, 0.8301632731395638, 0.38702344821695056, 0.3404023133275407, 0.5198879524027844, 0.5200362677937338, 0.658678334558448, 0.4107801665864217, 0.29613730337059185, 0.5111926355802747, 0.6279907063234627, 0.10154640867777376, 0.15265948485186887, 0.11531322172363012, 0.5503612670413361, 0.1671628690698953, 0.12953719396783658, 0.16875979883391068, 0.14168362027520265, 0.16586939561582514, 0.11335099982240882, 0.16558864525082406, 0.13052385897079533, 0.09598691625760325, 0.09733368765676242, 0.09890646734855213, 0.1034858277708578, 0.09920676832801201, 0.14547683320365956, 0.9258639055246503, 0.8888356052351587, 0.8954537750095224, 0.8982145878601934, 0.9034546340133842, 0.8994189831005772, 0.9115757450513805, 0.9226175402424541, 0.8938490814060109, 0.4425145677987682, 0.4167442194899097, 0.4610538812671924, 0.39658185917301303, 0.35986039287852545, 0.36194190496457135, 0.3486614188853123, 0.32987810127206596, 0.35212562677321935, 0.2108985022700106, 0.24275554219481998, 0.32755197740227915, 0.20166144833024657, 0.3389967247326523, 0.2633230383627365, 0.7550081945022015, 0.22852995223112604, 0.2739172788326102, 0.1504790996515738, 0.18830582806985607, 0.12825466564315102, 0.16291863007922636, 0.1153099852152022, 0.1850604953061572, 0.12382467792872154, 0.17781351736787365, 0.158160670717316, 0.1450443203183599, 0.15278787573409391, 0.13981959735648453, 0.16339372264347984, 0.1772844588145397, 0.1337297997971787, 0.09110984256138976, 0.1878368920558271, 0.17132470186268622, 9.999999999998899e-05, 0.013176121946936847, 0.010386674063033619, 9.999999999998899e-05, 0.028721933189748028, 0.0298199425787119, 0.01202966121574467, 0.0416385819906987, 0.015884317143449844, 0.04831077403056949, 0.061652501205498256, 0.07161059368064293, 0.04746495295693709, 9.999999999998899e-05, 0.0568418355532091, 0.055998793773441524, 0.04876159644528566, 0.09901559614845123, 0.06944457183837638, 0.04144553372951432, 0.08114235845407924, 9.999999999998899e-05, 0.10892547224315763, 0.14716697460503003, 0.018657185206128135, 0.10317478475595743, 0.2252271536551027, 0.1022433567520038, 0.11537690870320116, 0.15375064491285606, 0.1596197429049846, 0.16223920016887516, 0.18525170453850492, 0.10606207173024051, 0.1151663258428336, 0.14326064069691768, 0.5517041378018086, 0.47600618202351674, 0.4705702566456347, 0.5107162785391246, 0.49176527752270216, 0.4755897817690181, 0.4981089883899864, 0.4932502868512062, 0.4842509327887742, 0.10971407931246902, 0.08729074800452985, 0.13365506297538232, 0.08893990128979601, 0.13076106553853317, 0.11916061893489949, 0.10255226297713504, 0.08225962109348561, 0.0909458561498987, 0.15910414591180455, 0.15096023495262068, 0.14534517710147343, 0.2988738888748451, 0.1260430919353812, 0.15304592868912692, 0.15372395191725285, 0.1323548621516698, 0.16033967836409357, 0.26726887655137366, 0.303686576068133, 0.3197272167982773, 0.26390002012913916, 0.2204300817408218, 0.29847731844805514, 0.3025707528976048, 0.3559410740005673, 0.36347440923067365, 0.2086770467757061, 0.1918093059135999, 0.2478780868199265, 0.18036912060446342, 0.2535699991301228, 0.20440339455645284, 0.20761678901426606, 0.1822176827445483, 0.17203181898519848, 0.1990053427377516, 0.17810076858119805, 0.16725789633933652, 0.18852065057205603, 0.17876306969697253, 0.1787415844478617, 0.17569157468879826, 0.18094764081664105, 0.19645431304535732, 0.20284124425370453, 0.22156986793204436, 0.18232361976054412, 0.20453479897244264, 0.20164927690921153, 0.19007909607419493, 0.6386618746366135, 0.21230787507203208, 0.22087644941700768, 0.14953366448404193, 0.7552451944246554, 0.1659175861016442, 0.16362367555177426, 0.19098940142207033, 0.1621763636780572, 0.17897813418698805, 0.17709932378921822, 0.16687682230272094, 0.2869114795771478, 0.15692318613655498, 0.21350394119261973, 0.1979277330545548, 0.19885745555676249, 0.1897134811123592, 0.10210970944179076, 0.2028720289194379, 0.41743251648804525, 0.187957479111604, 0.16944748723459102, 0.18839069267947517, 0.20287821649535054, 0.19458149113604473, 0.1790801520676112, 0.1768372965760916, 0.18385564265644494, 0.18999580867012078, 0.07801600245266549, 0.07250232572240911, 0.06819434883467768, 0.07167149333389422, 0.08484603166842208, 0.07915892866782814, 0.08873325949119149, 0.07071571604542792, 0.07661185568133455]}, "mutation_prompt": null}
{"id": "4274eb5a-88c1-44d1-ab71-3246a869be8c", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better exploration\n        self.pop_size = self.pop_size_initial\n        self.F = 0.5  # Self-adaptive F\n        self.CR = 0.8  # Self-adaptive CR\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Higher probability for local search\n        self.global_perturbation_prob = 0.1  # Lower global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * np.random.rand()  # Random component for exploration\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay to focus search over time\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for finer adjustments\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n\n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n\n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum Adaptive Differential Evolution with Self-Adaptive Control, integrating dynamic parameter tuning and quantum-inspired optimization for robust convergence across diverse landscapes.", "configspace": "", "generation": 75, "fitness": 0.24575163793399035, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8381484765943985, 0.8740064248549546, 0.8272710646501809, 0.8300978098447407, 0.8611033872904448, 0.8438791018675456, 0.8719919837089373, 0.8697714057064335, 0.8747859202660717, 0.13269601677131992, 0.05397837700318997, 0.18877521917100937, 0.1796468600626484, 0.0016179107361916634, 0.1129461783893475, 0.02708607584109546, 0.03717063017023503, 0.06761097060321664, 0.12033501251966805, 0.39690653248746655, 0.1620156110570553, 0.13663430725172498, 0.12843426579562023, 0.11866552502165884, 0.11365187780078234, 0.13837845466322374, 0.1194802597934842, 0.16458528000862316, 0.14738279026768397, 0.1489415105487356, 0.12663931716026477, 0.10242556968561889, 0.11136782242088517, 0.10388370179056272, 0.12247224727432127, 0.0993805472400141, 0.9169937585860434, 0.9081679510997304, 0.9211718774940825, 0.9105209669049927, 0.9223389022843467, 0.9022863532830118, 0.9107854633219248, 0.9119911510860991, 0.9004539461193486, 0.46775554789176943, 0.38095642425643295, 0.47030697469079263, 0.49840616232745527, 0.48004486944485125, 0.45109749366481733, 0.32326984984384777, 0.4269237139239219, 0.3755480382397466, 0.16770941640226034, 0.3582889050449145, 0.2898591327236322, 0.3371777013988395, 0.26972471090277694, 0.18387952768482485, 0.14657964657557565, 0.47774447914104556, 0.31677026306962386, 0.1521657095146851, 0.15424441020660706, 0.24382512202733686, 0.12455760455447562, 0.13847949108285906, 0.15566382086201613, 0.14939975970116026, 0.21891278518085522, 0.12732419204760426, 0.17938978416757623, 0.1342889537256562, 0.15278367966190765, 0.2023732222259348, 0.14563826915313294, 0.14262079123316818, 0.14897762289055427, 0.26417937125953117, 0.19345327537096302, 9.999999999998899e-05, 9.999999999998899e-05, 0.000100235309767438, 9.999999999998899e-05, 0.05219257793885901, 9.999999999998899e-05, 0.059644068603316946, 9.999999999998899e-05, 0.029616532799633388, 0.06767522448036711, 0.01948485000492528, 0.11934748026393549, 0.0941773304465574, 0.11118395077143794, 0.0949152866229801, 0.05456287741342736, 0.07358063295740791, 0.07890561877579039, 0.03546816759781446, 0.08120249591696105, 0.07514615687005843, 0.07574534347597672, 0.29381860098316603, 0.11906950600255606, 0.1480848950328182, 0.2279226865675017, 0.1642963930098742, 0.1656160688842847, 0.21269685653202264, 0.2175672219534578, 0.16423585601699997, 0.22022759509694279, 0.08309450632252646, 0.05604535515206266, 0.05662630869058083, 0.07995848653651005, 0.4646234623819482, 0.47346159370487995, 0.49709483178195246, 0.47178689200047497, 0.5007449230463248, 0.47603561592751276, 0.5074294505532632, 0.48081258197922694, 0.4861813361715134, 0.08102171325894647, 0.10867131863988166, 0.11598945329983523, 0.09529847359219945, 0.11392754686824413, 0.11590817420275124, 0.10488610875626836, 0.10694490201033036, 0.10531196534238352, 0.15569861025860465, 0.1508588688717094, 0.1446381274541345, 0.15243515479780145, 0.17562331401609754, 0.1586289384560421, 0.15835823516006298, 0.1598457285953031, 0.1700283582241966, 0.20599447483163236, 0.2591773741053903, 0.17669299154394413, 0.341964959502026, 0.1743935502355647, 0.33305746248295387, 0.2493950135932973, 0.32387392416672656, 0.4241504373377818, 0.2811546821438454, 0.12605665775118524, 0.1757510633164755, 0.18946881392792603, 0.19663708698148885, 0.191740734860687, 0.18687617892447217, 0.1989941136914617, 0.28079975563928905, 0.19870912330535895, 0.23068856687922334, 0.18234170034125396, 0.19600948080280134, 0.20722072032803707, 0.1940304361420081, 0.180719970522091, 0.2153560776987561, 0.21804606542647853, 0.23019261045371708, 0.1932919388643044, 0.19939097059832822, 0.17471166996888954, 0.18953520734028761, 0.23879157583157418, 0.198810590497415, 0.16668756016560005, 0.18640012099034553, 0.17066938679742616, 0.1884720430629444, 0.1886596464383341, 0.4547809726411459, 0.17227607896774366, 0.16176112101488338, 0.11427880748345032, 0.19732265318129127, 0.16407007307521448, 0.4806468091725752, 0.19720966484541247, 0.14857966307982606, 0.18301457591827008, 0.22466263389449925, 0.3511474996814946, 0.20795183629712266, 0.15135494277404982, 0.20326071959437364, 0.18524069577159263, 0.20583837996111387, 0.1935922430887589, 0.2018688548390205, 0.19806017992520508, 0.1827771704852389, 0.1965748020415634, 0.18442708574563527, 0.19344550955585504, 0.07518784856311467, 0.08931400099746623, 0.08657366541391187, 0.08787927004953977, 0.06101992437991066, 0.07025857466740204, 0.068832650935853, 0.07704942864148745, 0.07303033459207309]}, "mutation_prompt": null}
{"id": "e675e2ae-7c79-4a8b-8f9e-f7aa9f5eb4d4", "solution": "import numpy as np\n\nclass QuantumInspiredADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4\n        self.global_perturbation_prob = 0.2\n        self.dynamic_prob_factor = 0.5  # New dynamic factor for strategy shifts\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        if np.random.rand() < self.dynamic_prob_factor:  # Dynamic mutation adjustment\n            mutant += np.random.normal(0, 0.1, self.dim)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredADE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Probability, leveraging variable crossover and mutation rates with stochastic strategy shifts for enhanced optimization.", "configspace": "", "generation": 76, "fitness": 0.26399459409703885, "feedback": "The algorithm QuantumInspiredADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.7876222009332152, 0.7710194993544224, 0.7860040824173302, 0.7976037118872732, 0.7436424789199644, 0.8005027603195867, 0.787954100326004, 0.7659226318298371, 0.7703450545576226, 0.4267746056142926, 0.45841655016927174, 0.35523993326047554, 0.48759561879016233, 0.46137389900493897, 0.4969746572617897, 0.46583991273163805, 0.47874988671011787, 0.3176999391227632, 0.3734586288205697, 0.1332092193011224, 0.4586630052766004, 0.11904351202812158, 0.16251159963918582, 0.1302902164561055, 0.12098793337927327, 0.15840421494945744, 0.12282766058648686, 0.08705336647748796, 0.147131348369972, 0.35811725146207785, 0.11352078911275254, 0.10724255274303429, 0.13391701087360142, 0.07938118009131612, 0.10170678236677233, 0.13387677764924522, 0.8886949351035984, 0.8845848322003398, 0.8951972320700418, 0.8773307741908835, 0.8867542946807268, 0.8943086268342048, 0.8899223667659151, 0.9028672333344665, 0.9182245497589208, 0.3662377471772561, 0.3975394629046286, 0.32442392985830115, 0.39524600511022323, 0.3563792304997154, 0.3788919768456497, 0.38966697416877094, 0.36452500304447744, 0.4012629802567924, 0.2177865565657484, 0.35282017394367693, 0.35969846265367533, 0.775612551784687, 0.2602135028127429, 0.349726259854498, 0.34542905560488935, 0.8141761970795327, 0.22883552028929166, 0.17254054898296434, 0.1720160460059884, 0.14214043668332654, 0.1627503258744426, 0.14822518657682993, 0.19566933350275972, 0.12010770773816493, 0.11592486904703603, 0.16473905860243176, 0.11712138344275869, 0.13884171898606967, 0.1695531439240674, 0.1670289708370275, 0.15834016527818184, 0.13594443748599716, 0.16233290406844048, 0.1937926737388771, 0.11716821003909339, 9.999999999998899e-05, 0.03558734023990051, 9.999999999998899e-05, 9.999999999998899e-05, 0.0619174289978226, 0.06960302177597222, 0.09815248027816381, 9.999999999998899e-05, 9.999999999998899e-05, 0.12803763658052392, 0.12777849216677806, 0.12324612340008645, 0.04635179801771505, 0.11482338315242269, 0.07523358827630144, 0.07425112073656204, 0.06697848446642873, 0.12341848983616877, 0.001227411393381228, 0.026241567256403142, 0.013395598326545022, 0.10434525476333989, 0.061124905710865485, 0.08592766983446143, 0.21114025912885748, 0.016824194992499764, 0.0543045635416034, 0.14352056170763394, 0.15269988978484672, 0.16561006271182088, 0.17977249595373435, 0.16889356952543932, 0.1951508666010291, 0.07626197781462474, 0.14568149714891354, 0.10797234415436086, 0.4660584254301494, 0.49256121788036333, 0.49292746386487274, 0.4655609405638258, 0.46476974483273836, 0.5114601196772575, 0.46746693355697233, 0.43069575401994775, 0.4983549325755725, 0.09145475306993212, 0.08727057024894369, 0.11296813919036197, 0.15059948074833007, 0.1136813125115359, 0.10670395498026486, 0.14131868319472674, 0.09972970350037502, 0.1357940629095743, 0.3445200531859903, 0.13744184894807399, 0.16905141350170072, 0.1318302607166676, 0.15348815314095354, 0.13638803349405915, 0.15663854710462288, 0.12794635872914206, 0.16250645466697733, 0.34962671207313856, 0.30825572601630846, 0.2932618217548012, 0.3207266945202598, 0.32565345907738974, 0.29262122051709016, 0.357517182747662, 0.3256924263676678, 0.33290783999423756, 0.3026989753193631, 0.26479866569787913, 0.22579543844708794, 0.28400419377931496, 0.2499155221960292, 0.22047835001589366, 0.23901885377425403, 0.2645699349933106, 0.26017998143759546, 0.18453907700336813, 0.17791694341994901, 0.1958798480537255, 0.17226071949040456, 0.1620929755651196, 0.19440048147916056, 0.18858655658660028, 0.17400783222239846, 0.20317657161212888, 0.19152632534857017, 0.1878764447747221, 0.5164658973012717, 0.18959077013260417, 0.26882316391341043, 0.22179477361829314, 0.2166305803684937, 0.18217237370153583, 0.19849699021612566, 0.1637316432305128, 0.817439163612638, 0.14864329277917876, 0.17112959374769066, 0.1882085707101957, 0.14503693609500556, 0.1390350988756227, 0.20017502424926226, 0.1672622684823093, 0.1647538673976836, 0.20258953886231867, 0.1999416815598828, 0.1974299039580687, 0.19994469569174156, 0.19849825031931845, 0.20447860759931402, 0.15120207407186392, 0.20444055560056973, 0.18369659510916048, 0.1730341401897536, 0.18173664524158462, 0.1652705528489763, 0.21512054515032109, 0.17215774797187056, 0.190802935175432, 0.19008766245544295, 0.18517351952552064, 0.08540024233062782, 0.07716234758522966, 0.0745872988890498, 0.06563822232379757, 0.0746517664448666, 0.06711462033479931, 0.08180864743876104, 0.07820198389584454, 0.07690523814787553]}, "mutation_prompt": null}
{"id": "9825934d-3562-47a7-a077-1dcf886c108b", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Different F value for balancing exploration and exploitation\n        self.CR = 0.85  # Slightly reduced CR for increased exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Enhanced probability for local search focus\n        self.global_perturbation_prob = 0.1  # Reduced global perturbation for stability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # More aggressive decay factor for faster convergence\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.2)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Tighter control on perturbation magnitude\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum Enhanced Adaptive Differential Evolution with Dynamic Strategy, integrating environment-aware parameters and a quantum-driven local search for robust and efficient convergence.", "configspace": "", "generation": 77, "fitness": 0.2868883462388399, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8535657825913553, 0.8428473399429398, 0.8554206850618251, 0.8589448475532184, 0.8473718760493439, 0.874821823006128, 0.8396741060362354, 0.8681133030777308, 0.8325049565783595, 0.5319964090762938, 0.42736055521086236, 0.37614631798974363, 0.4186805227332626, 0.7514319411606163, 0.5302697897745423, 0.5857232429179287, 0.4261839767023212, 0.5566546350771724, 0.14554909541111083, 0.14991545724123456, 0.1452860625954394, 0.128126264720838, 0.5977274744799247, 0.11187488225834308, 0.172405158303644, 0.11111323569366394, 0.1758384371679449, 0.09875219745509078, 0.13084231146569147, 0.1260768376149477, 0.092150660177298, 0.13346427197132704, 0.1281532731497762, 0.1514256285143838, 0.14175680621107845, 0.10924686032829034, 0.902462297037639, 0.8957585597858585, 0.8921097376247521, 0.8925790618512958, 0.8986035829246809, 0.9056295979016453, 0.8775825840750905, 0.8555666353157522, 0.9021793924781523, 0.42272426574805, 0.3839608919324303, 0.3228176218667119, 0.5350684613256341, 0.5297696857846597, 0.42592219059351055, 0.34039008514028113, 0.41205232243954526, 0.37917654427936764, 0.20305340905189373, 0.49723869219892847, 0.2708625617616266, 0.1840283724296813, 0.2656989523254156, 0.8551807152376887, 0.8453636397962356, 0.8510906916682573, 0.7148373654075095, 0.20275283341273842, 0.16201342708270017, 0.18733464538501654, 0.15296110168761767, 0.17245771062349435, 0.14892936044313287, 0.16466073770706047, 0.3367062528240795, 0.1754285822592403, 0.19011652965557146, 0.19611842734512253, 0.15073208086162782, 0.15416313702940365, 0.1912121778276038, 0.14720274459611904, 0.3062252249007126, 0.12498544779030052, 0.1908732350316783, 0.04387360606503843, 0.026920563740885473, 9.999999999998899e-05, 0.02323468465166334, 0.0005640392230822355, 0.022340900150244147, 0.04183186114921755, 0.06156208380006223, 0.02281412227769508, 0.04389723074641538, 0.12830429212018102, 0.05590420658544171, 0.056967335610289216, 0.11763582582388188, 0.053124523087349385, 0.05472371886967686, 0.10521428559841173, 0.07595000586852074, 0.06493782313002394, 0.10158650558621962, 0.08820361054534065, 0.23964392774280474, 0.19560229166344878, 0.13355016718047208, 0.2356140633953031, 0.1510624291570153, 0.08362129169290589, 0.20154661678986763, 0.07683370522886146, 0.10656578610861456, 0.15882018923440555, 0.12593790141315897, 0.17006056595826613, 0.21479355091905195, 0.07113768818330923, 0.1802388502740312, 0.46748660998351477, 0.4911987816733735, 0.47677935256755843, 0.47271625305482945, 0.45934621741097703, 0.4648744652933514, 0.5401895974259734, 0.5175096575958902, 0.4803537174600221, 0.15356777722393777, 0.1498232385564412, 0.0918837112791362, 0.14169884787723785, 0.10408211620063235, 0.11665571479751358, 0.09829842349650952, 0.13605917636570142, 0.11116330761784188, 0.14041978733151095, 0.18290019999124218, 0.2075692106033865, 0.17706747305241954, 0.27234597560273055, 0.18888697210181515, 0.17769161573669534, 0.1890992069103331, 0.15174412974553908, 0.2821597394617238, 0.23452262396822643, 0.2556530422772605, 0.32697396101842857, 0.3029004458897945, 0.361749791449539, 0.4190325055658458, 0.3229941681583397, 0.4306103369149413, 0.16511676270098852, 0.23899281553749774, 0.26360601319759724, 0.2234610351757087, 0.17328448621470194, 0.2660305489768573, 0.1870474773036247, 0.23980779590877932, 0.1814155574807781, 0.18782293934057792, 0.17247555424878158, 0.17765612112372653, 0.18959884000539406, 0.2023459765305603, 0.17780643295414322, 0.18207127826941938, 0.2200161005556377, 0.18169012036112508, 0.18778360406182615, 0.1976384841450496, 0.20180196155425834, 0.19951206217347228, 0.21311472443175383, 0.20336547837500496, 0.32016023681254036, 0.20066792816183676, 0.2031534292570666, 0.17932613370711004, 0.18424012794167488, 0.14921480290646383, 0.47911217346748114, 0.792299345553389, 0.16916210926174569, 0.83923827808709, 0.1654283145388581, 0.15729030561760204, 0.16526698424334607, 0.5618274504062897, 0.16186553049658214, 0.16103890885628402, 0.42530101590983127, 0.20433450347387583, 0.20197896685505978, 0.20342804587623264, 0.199466291735236, 0.19459658387492573, 0.18973934460913255, 0.18583331718082874, 0.19495219644634476, 0.21032313972202477, 0.17710010187928604, 0.20102562149825387, 0.18840477386943177, 0.1817753704963293, 0.08601968189052389, 0.0738898026809478, 0.08071119532461557, 0.07610722811178061, 0.08903707485986945, 0.07314204244440592, 0.07025674881055055, 0.07423544294507267, 0.08674306617544103]}, "mutation_prompt": null}
{"id": "f3c31345-73a7-47bb-93bb-a05a5458ea17", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for effective local search\n        self.global_perturbation_prob = 0.25  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * np.tanh(0.5 * generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Further adjusted for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for broader search\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution with enhanced exploration via strategic perturbations and self-adaptive parameters for improved global optimization.", "configspace": "", "generation": 78, "fitness": 0.2612472575449858, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8690182912894077, 0.8529307046171943, 0.7939116072796509, 0.8412872453795333, 0.850655089265444, 0.8505841754778343, 0.863582917429935, 0.8608434965852421, 0.7603895859898436, 0.06719201177570688, 0.09136947035085163, 0.1773829318171769, 0.05833435006255383, 0.7428391806784529, 0.13923728284787829, 0.07334552254169446, 0.00034424632558616164, 0.06501076528095728, 0.10427222046125773, 0.15275661931259332, 0.17125603169780756, 0.14109611038999015, 0.11267068732346275, 0.1053896577087684, 0.13720901762034132, 0.13575876363993444, 0.1517502664727972, 0.11041591088393221, 0.10571755022366702, 0.12400322677573716, 0.1533134644667743, 0.09465966992616814, 0.11801138364869879, 0.1040596969363713, 0.11761729794847742, 0.10602166398590984, 0.9067576929627219, 0.9088830872819623, 0.9019726210711763, 0.9257327675152865, 0.8998178500049878, 0.89354312571095, 0.9183309939468315, 0.9000938598868732, 0.9227109899759566, 0.4470012155262033, 0.4068497283068081, 0.31092732616613794, 0.35359990176237255, 0.38854840873069796, 0.32521623310664993, 0.4950580933221054, 0.33150403251405036, 0.41586379391190653, 0.2503573409915779, 0.19212491413392707, 0.2431409875976327, 0.20884351737789963, 0.20547361181364165, 0.6086979222279038, 0.22904549234640303, 0.23165183186542337, 0.8699672427597576, 0.12114593293608178, 0.1354060753490961, 0.12165649624184205, 0.14774986253720568, 0.15043106114738514, 0.1233176592595191, 0.12218011972011023, 0.1795389132930264, 0.15775516592265137, 0.207200167321671, 0.19138237925838808, 0.1779064192807267, 0.16351099954463677, 0.15530476548736893, 0.19846868346403623, 0.15881356451742135, 0.1576788944500942, 0.12572773129374348, 0.01613266568445615, 9.999999999998899e-05, 0.018006759182986887, 9.999999999998899e-05, 9.999999999998899e-05, 0.07918527482687299, 0.035981272472594306, 0.009291325100279746, 0.014623858890325248, 0.08573806446745857, 0.09123179753811861, 0.08995198243742875, 0.06964483136124178, 0.05808116604506264, 0.13217480494445166, 0.1326507714416284, 0.18753648892121033, 0.1527898063025558, 0.2066597040673659, 0.08353472028095732, 0.13760968374252136, 0.1314065420754974, 0.09249490881058897, 0.11127709314139211, 0.20267694496950295, 0.1447813081665963, 0.0894217352818587, 0.11147135076328762, 0.06773558910834654, 0.1541102524568, 0.14337574801410413, 0.211564959539418, 0.1732065322746077, 0.11808385644047992, 0.12735420291732857, 0.19367647914289987, 0.4739713123699627, 0.46796259667244955, 0.5456461162818642, 0.4834238366127994, 0.48578299203967235, 0.4681133034615922, 0.4803999150798265, 0.4594780481491436, 0.4635398747952806, 0.08976505375494948, 0.10464842014635778, 0.08794813641910892, 0.15070596145346626, 0.13036151519183004, 0.07644222744329232, 0.11047015913387825, 0.11704502622951063, 0.09822414650921185, 0.23505872613744028, 0.12111800563134634, 0.12669590824838828, 0.19419191233362465, 0.22318943145572612, 0.18656821996747908, 0.18881588853324427, 0.165830134252674, 0.23426156378698737, 0.2572755105015454, 0.32235279353110124, 0.24865844452969377, 0.3029357115900051, 0.3718715379223879, 0.2910674258065007, 0.21843323973761752, 0.27974858929509505, 0.44574519787401623, 0.23690244855229237, 0.25050978979783756, 0.2090966639261974, 0.18397021896413168, 0.24321208455087961, 0.22196400898145974, 0.18072218984165245, 0.251530487338987, 0.3333127242823597, 0.21061509208493268, 0.19822845652320598, 0.2208603752232453, 0.193795301144021, 0.17915271707979352, 0.22231388184172707, 0.21036464327968485, 0.23901405771951922, 0.23480072480053094, 0.2227557004852473, 0.18979984524475713, 0.18910076708092072, 0.6974419240921758, 0.16032831727657326, 0.2332243217045935, 0.19431422509283736, 0.19495312236424045, 0.7162242766644732, 0.17692188067069348, 0.8248006755117157, 0.14962355142138473, 0.16996112888677528, 0.18452291457770464, 0.1617763607225603, 0.15574783667843817, 0.8214173481099512, 0.15435708965296613, 0.447713873978424, 0.20002062872138382, 0.15139569724603474, 0.5561631583387152, 0.16500765059443112, 0.19813707114455537, 0.20804813235715336, 0.20658171850031237, 0.2071684602189564, 0.18506164374008705, 0.1789711124419382, 0.19377732524768543, 0.17248975545161738, 0.1763735315140399, 0.17419972414304996, 0.18834781961367175, 0.2071651042822953, 0.1729616276254401, 0.07360601780835874, 0.08218068590178496, 0.0659584087677566, 0.08910554842488816, 0.08619075589796288, 0.09671619756501915, 0.08446826424055476, 0.0890682440558237, 0.08225536777475262]}, "mutation_prompt": null}
{"id": "851c93e4-bcfb-47e5-a86a-09088fc37644", "solution": "import numpy as np\n\nclass EnhancedQuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration and exploitation\n        self.CR = 0.85  # Adjusted CR for dynamic crossover control\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Slightly decreased probability for local search\n        self.global_perturbation_prob = 0.15  # Further decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.98  # Further adjustment for population decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumAdaptiveDE", "description": "Enhanced Quantum Adaptive Differential Evolution combining gradual population decay and dynamic crossover with strategic perturbations for improved convergence.", "configspace": "", "generation": 79, "fitness": 0.24587408770086677, "feedback": "The algorithm EnhancedQuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.6767028707613296, 0.6624754746152777, 0.6946318986342239, 0.6743807018232375, 0.685655630384904, 0.6805838495030143, 0.6815068256867676, 0.6746455099644579, 0.6779982136844258, 0.4112882931400236, 0.48608830159257066, 0.4974560823815778, 0.46607244502562106, 0.5052171071429568, 0.48985118251658477, 0.50442386327755, 0.4810089103777182, 0.48805751843248824, 0.14715709820884804, 0.10562067288160504, 0.13658016447875743, 0.12685610240901102, 0.13780571098427097, 0.14211385035817747, 0.12696962463657546, 0.13518644884977216, 0.3790627092484985, 0.09222334452226932, 0.1042662651241808, 0.113469310454126, 0.13248306247701835, 0.12940216260666038, 0.1161147753341345, 0.1315831611231626, 0.11069820532802899, 0.1138345906823095, 0.8833155329637535, 0.8702498633488012, 0.8516508393148103, 0.933316571463828, 0.8845529941595347, 0.8709161453934662, 0.8526597390306639, 0.8201581661822075, 0.8155592773180829, 0.3164586310294458, 0.33633788892213157, 0.3423669851390472, 0.3397256919249717, 0.39923388825201744, 0.320802490958655, 0.28937919167298043, 0.35958929874883183, 0.3428203582817385, 0.6451387228932701, 0.4722753487650918, 0.2593387628620675, 0.2967461861867554, 0.6417028464532651, 0.28924481578416195, 0.5498664125501265, 0.26771186513443834, 0.5639839252913439, 0.12996624670158075, 0.1682105996371549, 0.13865517428695862, 0.13784242851036776, 0.13919830387093002, 0.13984406446234732, 0.1340338034242352, 0.13448078855723855, 0.1322556105722582, 0.10100055338482838, 0.1090009536517671, 0.0876941411140113, 0.1368812673368871, 0.16533846526984053, 0.13618245922019867, 0.14429452770755813, 0.15715293215780402, 0.17920757478787275, 0.018343942620432596, 0.038297569311247726, 9.999999999998899e-05, 9.999999999998899e-05, 0.017851376637055494, 9.999999999998899e-05, 0.03196177087417129, 0.020475038555377578, 0.008607688038904104, 0.11509077880765306, 0.07422909377511588, 0.09448199621565911, 0.09872158913678708, 0.06950847892269796, 0.04664254864767248, 0.13220024400989072, 0.11984974590182118, 0.11666421884898481, 0.04270197590584468, 0.034763759988080345, 0.013446394483979884, 0.037401250927524554, 0.032411859233480556, 0.08430202906852935, 0.09437190775499182, 0.033730790319821624, 0.03282042647287342, 0.10907956539497987, 0.14872487878341822, 0.1303273250686794, 0.15593320798483945, 0.1511493165724338, 0.1043199420148403, 0.12602470420663336, 0.09599552909916742, 0.10890905751873503, 0.4169314698964979, 0.4714991202209413, 0.4556415601113848, 0.4677207248945542, 0.4210870737019481, 0.4487769844740426, 0.4317267613673329, 0.4075263460400669, 0.41624130140291293, 0.10969182622554396, 0.08838978773486961, 0.09317974662139328, 0.11151915045021721, 0.08816400297627858, 0.10689428974546844, 0.10525669335448207, 0.09706064769201461, 0.08911670339271804, 0.11855263034311281, 0.180417109861278, 0.14167950627051873, 0.141720180615728, 0.14810012934668504, 0.15913892415135122, 0.1562912597177223, 0.1411255220422556, 0.1772615179518915, 0.29200307069846276, 0.2939287874102141, 0.28771647330558503, 0.25885800886163934, 0.2659897290638281, 0.28759604799965477, 0.3057601085974323, 0.33478059851855013, 0.31079669020122114, 0.18735887641520244, 0.20254223862238163, 0.2236737164007644, 0.18775167346015587, 0.20269607519109145, 0.18186363763645974, 0.18208921047808613, 0.20887700293659195, 0.23456048869039492, 0.1798998869597792, 0.17410248416160046, 0.17119131117636355, 0.17746934521697966, 0.18384795929579545, 0.17136474767321652, 0.17811607147826802, 0.17759604798194473, 0.16852811690938763, 0.1973502885543743, 0.1830110909641791, 0.19391090592710625, 0.1864129143093265, 0.197722052295229, 0.189642819565505, 0.178920763048789, 0.2120898644792032, 0.18954451405961847, 0.20678375835085716, 0.6521913741023905, 0.17456020950930562, 0.5519387616315666, 0.16722350046517298, 0.15530390276045014, 0.13448113601020872, 0.17101915293711212, 0.1570283168931419, 0.30846343647018426, 0.17727485305993107, 0.26159947052801413, 0.19836418744708473, 0.17236105172020577, 0.11798074836817996, 0.19489117755612073, 0.18787329421863652, 0.1944659933349382, 0.17722290148152353, 0.17483203467171826, 0.17067989113858206, 0.17238354175785187, 0.18944620396482803, 0.1757598777331606, 0.16821101809804806, 0.17153219265926978, 0.19196898631042625, 0.07141744366477765, 0.0697575982355988, 0.06486634534259028, 0.06135585481418315, 0.07033590838718518, 0.07323361896067548, 0.08406363874348499, 0.06890047074807193, 0.07330222773036299]}, "mutation_prompt": null}
{"id": "ef7cea12-1173-49d5-807a-d5b8a5bdda60", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Slightly increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Modified F for balanced exploration and exploitation\n        self.CR = 0.8  # Lower CR for more concentrated crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Higher probability for local search to refine solutions\n        self.q_perturbation_mag = 0.1  # Quantum perturbation magnitude for local search\n        self.noise_resistant_strategy = True  # Switch to toggle noise handling strategy\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.98  # Slower decay for maintaining diversity\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-self.q_perturbation_mag, self.q_perturbation_mag, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _noise_resistant_evaluation(self, individual, func):\n        evaluations = [func(individual + np.random.normal(0, 0.01, self.dim)) for _ in range(3)]\n        return np.median(evaluations)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                if self.noise_resistant_strategy:\n                    trial_val = self._noise_resistant_evaluation(trial, func)\n                else:\n                    trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution, enhancing local and global exploration with dynamic strategy adjustments and noise-resistant operations.", "configspace": "", "generation": 80, "fitness": 0.17646377409051525, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.4100666451494408, 0.39876325182218575, 0.4078761394847432, 0.40488704191223135, 0.4065915607682734, 0.4100681030807408, 0.43241756720885816, 0.42966828616846975, 0.38111995021788947, 0.11451383026607087, 0.08505479433715157, 0.09154609248825085, 0.0969832546703634, 0.10375027279265903, 0.08250412352529801, 0.09135604188109914, 0.09261763262045275, 0.09290004308005795, 0.10398974225572932, 0.08364352871338032, 0.09102948786852216, 0.08255259069281873, 0.08584107209621472, 0.0894795054303924, 0.08465814710522113, 0.08819437680685693, 0.07457953257424399, 0.0758409282924627, 0.07313583055877337, 0.08806470842038272, 0.07806324331809444, 0.0726024226183899, 0.06731618210931811, 0.07189471075558962, 0.07368638501969849, 0.08373886908484363, 0.6998864894294531, 0.7999994399491346, 0.7228572969868496, 0.6621348579147319, 0.5396247789976387, 0.6585030546770367, 0.6926536549087579, 0.7024728808795493, 0.6592903303024531, 0.20069859438449078, 0.17627724654149912, 0.18387219060839377, 0.15907149826284894, 0.17654778948357375, 0.1783189038891072, 0.1665654142479308, 0.14149393246478903, 0.20259558169863878, 0.2960851463606775, 0.24092752400118445, 0.3039046816888116, 0.3567266836631563, 0.2250728896957519, 0.3506610100002354, 0.37214100547188667, 0.2296928480181124, 0.23028511920460182, 0.10654142058598737, 0.10869093875249158, 0.10723602086399242, 0.10359890613567002, 0.09358959790904064, 0.12566383674050996, 0.08986827533753916, 0.09978990496368478, 0.117180226728546, 0.09443094159983612, 0.06146290588272818, 0.12134845685294882, 0.10416286923582396, 0.12019054206979085, 0.10178209759035906, 0.11449491220766195, 0.09789393256980383, 0.1321508320418665, 0.00043802010200089114, 0.01553425772595729, 0.024791482059446368, 0.05294591841824492, 0.018215760720981078, 0.008074016102215142, 0.029344421321255143, 0.01586096159378725, 0.017399588102260166, 0.09242578402317214, 0.10056309787001538, 0.12081974745619906, 0.08558470302392585, 0.05734170236601388, 0.08936863606649281, 0.1079212225617654, 0.11369133647326435, 0.1255244678328552, 0.0027211256215782242, 0.0006487733680425878, 0.007227635270437349, 0.0016864080828925543, 0.0062427089423375826, 0.006310743650045358, 0.010190184592782314, 9.999999999998899e-05, 0.0033960708455195165, 0.07484040968886252, 0.08181391833014973, 0.06867708307828668, 0.0758648985286623, 0.08181413908857926, 0.08420813951974793, 0.0692284396654933, 0.07575526751050343, 0.07184727165366545, 0.3860517987376342, 0.35144500380421095, 0.37406451425578946, 0.35404641765299594, 0.36285488647361985, 0.3861091609544893, 0.3500404482019629, 0.3387523652268808, 0.3602903148007719, 0.06776300667338941, 0.07254180793709442, 0.07695930675787932, 0.08841324509392356, 0.07172070684679999, 0.08034246036067216, 0.06674354447781794, 0.059264914944360814, 0.07394223970144254, 0.12427410648645965, 0.13383961049809656, 0.1840755009968854, 0.11303316084538928, 0.15623616988028277, 0.14395366417465194, 0.11561252835404934, 0.12456832623993341, 0.12797556526019582, 0.24542185255192928, 0.23381905016584636, 0.21962088732578744, 0.24303287565870701, 0.2348853749713371, 0.24133293604015893, 0.249267761688459, 0.2612350894237234, 0.2597129454127701, 0.16838150357032355, 0.17588053058443998, 0.17854092166252744, 0.18610707635753265, 0.16288531647285742, 0.18201091255055235, 0.1845475723990786, 0.19093952980328532, 0.18500693245897715, 0.19425814182514112, 0.18997503279065908, 0.20317075606919088, 0.186941653244309, 0.1974416724752912, 0.17571484504360246, 0.18119261518384322, 0.19084501774376472, 0.18589163356393523, 0.15472673195731446, 0.17567037500368476, 0.1901689288350049, 0.1637209196930437, 0.17239297577066792, 0.170651913652616, 0.17769441563439392, 0.1640971580347379, 0.1617092606701923, 0.14297426461299279, 0.1556173752235379, 0.31051336384868045, 0.17416818448992288, 0.15865263227432713, 0.3295043699561686, 0.12385499341528938, 0.23679631752121644, 0.23311368132375676, 0.3475126659011287, 0.17596310369213586, 0.17801410023978848, 0.13676736240887843, 0.16389536564674778, 0.14590235375590088, 0.20107438977387493, 0.20829453190683012, 0.18770481698505137, 0.18448400867132375, 0.17831881070985234, 0.191690784353304, 0.17758527297158067, 0.1811234277490984, 0.17489543821221598, 0.19404288606224018, 0.17902248227699025, 0.18730115594784658, 0.07108197526968774, 0.07175836303189431, 0.06671026509996658, 0.08107270178414983, 0.07225026548381919, 0.07051457982631748, 0.07090010211007358, 0.07303643906226276, 0.06840278177288894]}, "mutation_prompt": null}
{"id": "2dc6ea3a-e431-4c3f-9ecf-af587646e9a0", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.9  # Enhanced F for improved exploration\n        self.CR = 0.85  # Adjusted CR for optimal diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.1  # Further decreased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.25 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Enhanced adjustment for faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired DE with Adaptive Exponential Decay, refining exploration and convergence through dynamic parameter tuning and strategic local exploitation.", "configspace": "", "generation": 81, "fitness": 0.2817490575017672, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.848188664966631, 0.8677233824528512, 0.8563305649036755, 0.8466565390081329, 0.8464833821438263, 0.8816337009174152, 0.8723847220641531, 0.8670943456373446, 0.845482419266536, 0.6821180584776825, 0.4809458916161369, 0.7057326575038698, 0.7068975490591354, 0.632176396158787, 0.5485769650999628, 0.6658497789069096, 0.7144661281832068, 0.6548321495276557, 0.15435867746771526, 0.6520871296994999, 0.140596899891964, 0.17382136441617857, 0.14852835610882953, 0.1856535370479433, 0.1361271997929907, 0.15266509626011504, 0.17573507678846345, 0.05874186476729171, 0.13290748660438112, 0.10249459561684848, 0.11411605954412485, 0.06588561275982296, 0.13761746192041624, 0.1441171300975691, 0.1487780268157196, 0.08262405225950475, 0.9177693175878421, 0.8886760904731305, 0.922938387448291, 0.9086843039584296, 0.9167000716921386, 0.927686790529958, 0.9191950063856358, 0.9369238117363371, 0.9229046387203825, 0.41385537429764485, 0.44721573572551276, 0.35500591098157386, 0.5607581736544468, 0.370780179127568, 0.43976685129943927, 0.3821798518659625, 0.44599758920178956, 0.385743374779832, 0.21774444605442245, 0.7905361424672768, 0.3575842118890735, 0.21693062447155098, 0.18754438895250758, 0.3657095015843753, 0.16702743398965303, 0.3414990573479989, 0.19862027579895802, 0.4735968032600878, 0.12518285318219025, 0.18496307531066902, 0.16523155345162654, 0.1260846037338471, 0.1784290434051582, 0.1818387126545895, 0.17859905562595868, 0.18328702048883383, 0.1386458347415993, 0.12886520980223815, 0.1925092247350093, 0.15306851446687086, 0.22954619223693895, 0.12620214733875457, 0.16055860671540723, 0.19683732074616678, 0.12319956969551837, 9.999999999998899e-05, 0.10748237224522095, 9.999999999998899e-05, 9.999999999998899e-05, 0.061543909328015234, 0.04317625774382672, 0.09117361979833893, 9.999999999998899e-05, 0.003143624869523909, 0.23666410895070467, 0.10109929031992615, 0.10643185110927789, 0.07906367829108962, 0.01773361860372591, 0.03358297786924069, 0.06739537714034383, 0.21751889497008337, 0.0669255489495667, 0.16530417794326346, 0.16952559039455284, 0.09596099536107017, 0.09174783430064148, 0.0796846804575041, 0.05273340398452386, 0.10393146000175835, 0.15050087773456777, 0.2310947710723723, 0.06335842640729572, 0.16277277064593076, 0.1250103210287814, 0.2331871954998478, 0.11822398019633962, 0.03479968776974962, 0.21881799486410003, 0.14767612736981373, 0.23757915526323004, 0.48625248989068715, 0.4698645899762953, 0.47907712663785174, 0.5005506232226316, 0.4584624505593763, 0.47853148763325604, 0.48146857342023996, 0.5043697785483771, 0.4689101751696647, 0.10460415912837051, 0.12227598992259958, 0.12345151593953019, 0.13418005907952701, 0.09941208214518704, 0.08238284167336096, 0.10918169562913393, 0.1532145311841725, 0.13612011835029003, 0.23126861353843942, 0.140289566013028, 0.15135368059107057, 0.21088517727625444, 0.15063413523859726, 0.1328053904090537, 0.1675833901767626, 0.2551740478212374, 0.15470404673086957, 0.2509547065439369, 0.2355341101056082, 0.29508016225701716, 0.25218903242143975, 0.24609512555689217, 0.29558644869198747, 0.4114799058811155, 0.27529149365614625, 0.3451428018246756, 0.2916739263174135, 0.1760338618371592, 0.34257576140408075, 0.29688419433689484, 0.15846158345798234, 0.17884515704933834, 0.1503819594970227, 0.25770279599254375, 0.199118983254715, 0.20629253251350854, 0.19509966041678684, 0.195717404871378, 0.20402755177054877, 0.16822045875157887, 0.16610466694412807, 0.18724083867041041, 0.1664382127951045, 0.23032288720219396, 0.24204772576189626, 0.19652163091418362, 0.20126753284658883, 0.18576965893864106, 0.8203508354471608, 0.16714742400673754, 0.20642686305058022, 0.1762539342281232, 0.2010461370701102, 0.16821353677897843, 0.1808367692634001, 0.7389544840147207, 0.17285383361070072, 0.1930827939727573, 0.6400681537987154, 0.17023331646290663, 0.16495811771246938, 0.11649116221110012, 0.16820824113163357, 0.15278424277701574, 0.2069616190195116, 0.4317383119324568, 0.22078069382614107, 0.19513762236271137, 0.12486068920744942, 0.20878615577432968, 0.12551471541965997, 0.17934836504852614, 0.2055644566603675, 0.1769713463029835, 0.1889335780188085, 0.17705715569588576, 0.1903500602748095, 0.17602416302585222, 0.18904859442744748, 0.1777939501704403, 0.09961743793089917, 0.07583767992862067, 0.0796485461932529, 0.07251722080205669, 0.06629210569308908, 0.12125011203904801, 0.06722241054061506, 0.08703161406190851, 0.08619047424824333]}, "mutation_prompt": null}
{"id": "5bc82139-30f5-46b9-ae76-d2a7f2d81fcd", "solution": "import numpy as np\n\nclass EnhancedQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adaptive F initialized for balanced exploration-exploitation\n        self.CR = 0.8  # Adaptive CR initialized for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search to enhance exploitation\n        self.global_perturbation_prob = 0.25  # Adjusted global perturbation probability for exploration\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))  # Adaptive CR for dynamic diversity adjustment\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))  # Adaptive F for dynamic exploration-adjustment\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93  # Slight adjustment for slower population size decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.normal(0, 0.3, self.dim) * np.random.normal(0, 0.2)  # Increased variance for local perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Adjusted variance for global perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "EnhancedQuantumAssistedDE", "description": "Enhanced Quantum Assisted Differential Evolution with dynamic adaptation and hybrid local-global perturbation strategies for robust optimization.", "configspace": "", "generation": 82, "fitness": 0.261769561476281, "feedback": "The algorithm EnhancedQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8204316779028726, 0.8130901507309509, 0.8176017911595947, 0.8204612135229074, 0.8215329048080167, 0.8284724007276802, 0.8338972623036373, 0.8174683474586484, 0.8217893990714804, 0.5814484224409943, 0.5258277695672877, 0.6956263414627739, 0.425124626366443, 0.6768601916752788, 0.49982414298443234, 0.6779388583829378, 0.5339855176043087, 0.6091234632863991, 0.17181439977014656, 0.1464547251162781, 0.11508765640571239, 0.16869023958871054, 0.14333485934861823, 0.1369942344545385, 0.14432661738119368, 0.5428700933779678, 0.13477564703473033, 0.11042760688078812, 0.12659992814479648, 0.1093849006051727, 0.12062283973504306, 0.11497912979225766, 0.10673089030028182, 0.1314845082886652, 0.08618661699814689, 0.1652400561013856, 0.8884997001409954, 0.9038240165685271, 0.8656607513776845, 0.8898885195047461, 0.8954746686525741, 0.8948836773620581, 0.8845518114536739, 0.880556928096801, 0.8780465829491013, 0.4269488052235415, 0.34138231335289293, 0.4007447650526167, 0.3888103681332694, 0.40000406894483265, 0.35170472772662265, 0.33088611102858745, 0.3678287338680286, 0.34922993732484753, 0.34030770603896054, 0.2587352817385411, 0.2388502283168149, 0.2538196964846473, 0.31595470267285153, 0.2642122593627928, 0.20411872727031244, 0.3069545597620902, 0.2217169556830053, 0.1508784285091842, 0.14587745097659865, 0.16856169729236503, 0.16957154537000219, 0.1485544521751535, 0.13707785959742014, 0.183699445150315, 0.30100397449100924, 0.11995449157479066, 0.15990811611631184, 0.1409440408107936, 0.1445410661221438, 0.13462062589863577, 0.27840299884152, 0.13903486248561037, 0.12012447418120986, 0.1282430083830508, 0.12310382754677596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058619441204794565, 0.07084243313315242, 0.053223952992949464, 0.10220737609390029, 0.028028853134385412, 0.07697069779152721, 0.04161014703197474, 0.04016095036959999, 0.1407746786417916, 0.08780785836054672, 0.15919739412570855, 0.09921568774925438, 9.999999999998899e-05, 9.999999999998899e-05, 0.09263220212904666, 0.08864503788946965, 0.10701376586240186, 0.11573562845650798, 0.047569384162520656, 0.1538239524634779, 0.09808843484148233, 0.13703758967457147, 0.17588485201624993, 0.17414137595399515, 0.13903275956202155, 0.22065085990571254, 0.17328846559692246, 0.08496056630130588, 0.46450060307516583, 0.44874282612406646, 0.46198995728723025, 0.4690004025894986, 0.4799796208201206, 0.44833313996148594, 0.47435159965687257, 0.4796187738052812, 0.4389217367196864, 0.0977053333260599, 0.08685811666507504, 0.10712757650851001, 0.11868998940688269, 0.09937797113300362, 0.1026853765268555, 0.10770129135204098, 0.09385707843529234, 0.1211655698951618, 0.14313732295649262, 0.16360430465908415, 0.14933763740142936, 0.1984296667952934, 0.14614564873089841, 0.15419924305137134, 0.1934567013791908, 0.1835558319709305, 0.13910168520408295, 0.3196557536961685, 0.20678287501248238, 0.31141701089987994, 0.3334279110560574, 0.3982751911150165, 0.2896264081651462, 0.32498378321254207, 0.3344745167808746, 0.3393137600808932, 0.27867021353091115, 0.23056749769446783, 0.18039312670893182, 0.2569394128100475, 0.21243136628599135, 0.19605272376377503, 0.23083878058629315, 0.2532049053258558, 0.18845886725534278, 0.18749883706820725, 0.20439842945546804, 0.2166437751777961, 0.266195728447027, 0.17369572579295678, 0.18449711012377634, 0.20664946234541048, 0.1778372013070737, 0.20059128662805925, 0.3100795591375096, 0.3119769040752859, 0.2162392607902056, 0.28776701101898694, 0.21003686007599087, 0.3179096308457683, 0.21972777785062636, 0.2764056719327296, 0.19942006655212885, 0.3210423734235236, 0.15695199225725098, 0.14756547930865238, 0.16494083151907857, 0.17570487659666156, 0.1693222611466001, 0.19977829455509644, 0.19745661341982312, 0.19485707869980562, 0.15334665446084805, 0.20322414449281745, 0.249807879357001, 0.19426326154444928, 0.25251326052504985, 0.20049041689812475, 0.2097334887695933, 0.4093294260195628, 0.19688399232240905, 0.17128324740600676, 0.1696028752972759, 0.18637828989020377, 0.18131982520925305, 0.18989073311228744, 0.1812164182231274, 0.18146084102001636, 0.18572463347216517, 0.17109240197169007, 0.07663165541164985, 0.07502449400497169, 0.09532595828628598, 0.07233971793036509, 0.07029460078684702, 0.09222824468374968, 0.06840268847038844, 0.07288030654112476, 0.07688386795953994]}, "mutation_prompt": null}
{"id": "b2676e82-03d0-4011-8bf9-5b8eba84467e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for better exploration\n        self.CR = 0.85  # Adjusted CR for greater diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.3  # Adjusted global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # More aggressive decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Perturbation, enhancing exploration and exploitation balance through dynamic local/global search adaptations.", "configspace": "", "generation": 83, "fitness": 0.2606885323278223, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8632436158293441, 0.8701556795996344, 0.8927330265372979, 0.8683341616761691, 0.8650409774467126, 0.8554784553517478, 0.8630636998993789, 0.8654442724413693, 0.8649223058001825, 0.393322330093557, 0.4478110428976583, 0.32614472340103584, 0.2033428826724567, 0.4609682587439041, 0.34024018881554974, 0.30283682774267195, 0.37857566267718035, 0.28709688452828197, 0.14910074452435162, 0.15211508456940936, 0.5955678045111812, 0.12264663516413477, 0.11136823430450837, 0.13405836313464992, 0.128030275690738, 0.12440646302110347, 0.15111263333723568, 0.15362853055913206, 0.08280822193537318, 0.10645567188328242, 0.1476520782209354, 0.12723650477876913, 0.11084526244748394, 0.07853486247320285, 0.09384708486001969, 0.10525836263592969, 0.9031763318415502, 0.8978150076109729, 0.888508755057524, 0.9119294212806571, 0.9224850555703126, 0.910608902492923, 0.9183469448851846, 0.9239834163515904, 0.915364855692855, 0.49021437685909697, 0.43494887705600027, 0.4755258502447447, 0.4057105671458282, 0.42291475325075767, 0.34524714853785554, 0.3520479589402936, 0.384564151558186, 0.408387582895947, 0.21077923217078753, 0.2247867350871655, 0.2486928977436239, 0.3332781244994103, 0.19738512073042935, 0.2192131781757597, 0.32863247546343644, 0.16802018165890154, 0.31655160325003284, 0.17250203836745281, 0.30361193609683557, 0.18136545342597155, 0.12551015872085058, 0.2026164450680661, 0.1724702675654879, 0.12608659388526977, 0.15164326058757893, 0.17387031436518752, 0.13685142009841222, 0.1796828278146524, 0.1420790762201274, 0.17379664364460023, 0.12617374199889142, 0.1675696679897546, 0.12582512332117568, 0.1656392955125774, 0.18564292350033118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001000576804246478, 9.999999999998899e-05, 9.999999999998899e-05, 0.010925980226531129, 9.999999999998899e-05, 9.999999999998899e-05, 0.12495082013114478, 0.16209865186195416, 0.13774336688040423, 0.0624346334604341, 0.05576894394791365, 0.04068487056096637, 0.15217319460606027, 0.056855560587161236, 0.11856483597861422, 0.19756675405785806, 0.09561454888089704, 0.1619786706969648, 0.1544900477158544, 0.12396607559491113, 0.11127672293951185, 0.07341647825516806, 0.09548714982003881, 0.14962830217679546, 0.13491388178790387, 0.06336170050332823, 0.1354076387997284, 0.15716873541817744, 0.06125196602513516, 0.125488248029472, 0.16651084361462076, 0.08287398259510792, 0.11317263210282713, 0.5104020377867877, 0.479755013704632, 0.47544748608321274, 0.5239677615915264, 0.5057163096693167, 0.45778787888146344, 0.5049809832341163, 0.4698906293921694, 0.480278021641555, 0.12338739726106085, 0.09911127119128782, 0.11117414091851863, 0.12682900817288778, 0.1303481553564414, 0.10087073751363296, 0.11903724102821545, 0.112799653924616, 0.11110980377524793, 0.15734207643232112, 0.16418981346739925, 0.15297409509428994, 0.15621044944431872, 0.14925722047827839, 0.1603459629344659, 0.19640938875473812, 0.17061128676490755, 0.14823415154657704, 0.2145368176445096, 0.2990553412442378, 0.27727441085077376, 0.2683506752457121, 0.278703028091587, 0.29863399845096794, 0.29635838184242325, 0.3107131427792206, 0.28492700274809524, 0.14491019852503506, 0.20038996997781477, 0.2829757823043684, 0.22638006609147454, 0.1745630350615951, 0.1853927824809315, 0.1736333845944551, 0.15330402128350928, 0.3124276028470305, 0.18120902347964518, 0.1802078050668462, 0.22998265367236914, 0.1892301312635314, 0.19552226251336047, 0.19269857552752678, 0.1899850704903262, 0.19989831101015265, 0.1936491130659992, 0.21042953704824507, 0.1866082217393249, 0.19689418077554044, 0.20009535569115855, 0.2011438135736613, 0.1941818758528273, 0.19642711497057697, 0.1962429070069701, 0.23898493824356193, 0.823791726193786, 0.19949292552032183, 0.7083679393841055, 0.16913246116785563, 0.8589157611181193, 0.17577794600809704, 0.15769521291059296, 0.1524555290809958, 0.15911489016170488, 0.1548111540847258, 0.16658340012542194, 0.35574013204171295, 0.1647877116340234, 0.2065349582124376, 0.20318260491414808, 0.2056200407761528, 0.12792024688880288, 0.20774726450886727, 0.1791891267950888, 0.18938299324378516, 0.17357696034223846, 0.1837087053153561, 0.18419096026390858, 0.17116861265843886, 0.17394954690759024, 0.1721503816402512, 0.19090350011477908, 0.08633060819222882, 0.08950342475307038, 0.07484928445197914, 0.0763158504321465, 0.06477329390679476, 0.0884974621657666, 0.07158328050269136, 0.08305703259791408, 0.08147174131784019]}, "mutation_prompt": null}
{"id": "637f8895-2c76-4bed-8bda-e3ca5ce6acd1", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for a balance between exploration and exploitation\n        self.CR = 0.8  # Adjusted CR for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased local search probability for more refinement\n        self.global_perturbation_prob = 0.15  # Reduced global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted for faster decay\n        self.pop_size = int(max(6, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Local Search, leveraging adaptive strategies and probability-driven local enhancements for robust convergence.", "configspace": "", "generation": 84, "fitness": 0.287176319781497, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8641063763478465, 0.8424885067887347, 0.821358095495131, 0.8450678231603906, 0.8647176980766607, 0.8678653042978178, 0.8169116658540405, 0.8513948317803668, 0.8696635241966427, 0.48380825285569473, 0.6152061464035053, 0.6553440002997615, 0.32577790277559393, 0.5219143492410507, 0.3460280344171214, 0.6095005733105655, 0.5121337051547038, 0.6646541363380245, 0.1177267289735422, 0.1736258721530134, 0.15350873422245226, 0.11984452846396221, 0.13771573152860472, 0.15475448439532624, 0.6174486203007427, 0.1353247472471032, 0.13579729591721246, 0.1706996465610564, 0.1507404674993944, 0.12360812512137886, 0.16959473317646334, 0.11177896957720945, 0.12754252077955186, 0.10289764115210842, 0.41568648653127405, 0.1073027178174285, 0.8958338241813804, 0.9079755927499267, 0.9116879225869703, 0.9193747354201295, 0.9195111427146481, 0.9116696935396291, 0.9076167539475072, 0.923140180204836, 0.8998506013313327, 0.4364108756648267, 0.27925603573765245, 0.2841755472568278, 0.5120385907973142, 0.46516084111024714, 0.3380546287902113, 0.3795731612395704, 0.42680175841238677, 0.3664895454502566, 0.37335061149978854, 0.24162278555848016, 0.25976774356723886, 0.8538486168273203, 0.4508063191952084, 0.3420230035512133, 0.5925493321310737, 0.24822278983443802, 0.22491398033440302, 0.14458683314285914, 0.11967354934715935, 0.12543193637117833, 0.21690245861376567, 0.18420678398549362, 0.16865962108891885, 0.12051591859523014, 0.14863148431919015, 0.16033665972571054, 0.1923463602113673, 0.11160217874650769, 0.2206256039384773, 0.1738854078053107, 0.16891314894786025, 0.14490480041501796, 0.15560120054609228, 0.18100670069116054, 0.20640994065587714, 0.06742541030773641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06778161112746561, 0.04752230069233232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060695693464405176, 0.08569987112785815, 0.04928144144923685, 0.11022134244945159, 0.01841650639488579, 0.08143806881439741, 0.082322227289368, 0.08689460697972429, 0.12299017008397461, 0.21859918927961786, 0.03749969471485115, 0.10361142860152706, 0.028536688564961388, 0.21359570303240027, 0.1544169492762747, 0.21525077530234882, 0.16076657284916873, 0.14796391932181163, 0.10401718821452466, 0.16795142074559644, 0.07306967993341118, 0.21853484843780158, 0.04223360537842924, 0.1953725042136799, 0.1324000029514335, 0.12213363413695588, 0.16158674882756008, 0.5252410863337231, 0.48340307361805, 0.4616726020156352, 0.4723354799275644, 0.4913682490336808, 0.49140680038162954, 0.5314320422950337, 0.4968226671955671, 0.5546798120555871, 0.10276430501195921, 0.10770275539723118, 0.0886507815500126, 0.1098645920701552, 0.1086025490090986, 0.1082773706968605, 0.10891607444359319, 0.1013568631395414, 0.12286888611995073, 0.16485533318581747, 0.15892853413850438, 0.2687016783482844, 0.16495207363231856, 0.14098282326654932, 0.1381302945039542, 0.1769362826574863, 0.14427243994339134, 0.13451618728255033, 0.29519618722948426, 0.33009545320460953, 0.3413995849765814, 0.3160274793839537, 0.26531962893014727, 0.4035071368359855, 0.3136484982100606, 0.35281739099488585, 0.2920214197515969, 0.18287986651200372, 0.3067518315157298, 0.2449470715100882, 0.24901269055523056, 0.21181458659246744, 0.26692208267531503, 0.3450915698956274, 0.3226745508941854, 0.28920289256613774, 0.19099874553730034, 0.1824051896423895, 0.27528705206256066, 0.1747954966625762, 0.17844754048540212, 0.17796611644884486, 0.2085496056404319, 0.18110804820111148, 0.19622076170490654, 0.21407962059589658, 0.20708530552204207, 0.2146076258649814, 0.5836513921216435, 0.21682682443853962, 0.6690216126291979, 0.4027954200091727, 0.17876840392246163, 0.1742384414359467, 0.1466052492180988, 0.6195465623482423, 0.19429936473239473, 0.19196613162291187, 0.20610947493237497, 0.8596064478425818, 0.17939890830349925, 0.19821432160263308, 0.6105973188328047, 0.18902345513506147, 0.1643276837383022, 0.20233545611272652, 0.35034026869050183, 0.6579037521784679, 0.16262712625076148, 0.20080771988641133, 0.20492354824721426, 0.14943144992332325, 0.18331272550906375, 0.16976572978951932, 0.1734316460588301, 0.18822816403991316, 0.18614743281119717, 0.19965837255215146, 0.19765150978808776, 0.19111166947302827, 0.1962170373851413, 0.08471823597560346, 0.08702766830100284, 0.09206514777324248, 0.07994805098574231, 0.06881475321435226, 0.08271713174228501, 0.0906133218441304, 0.07304605493242966, 0.08338543565942202]}, "mutation_prompt": null}
{"id": "1185bbfd-673c-4b63-9067-87ef956c8c64", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Adjusted local search probability for better exploration\n        self.global_perturbation_prob = 0.3  # Increase global perturbation probability for diversity\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))  # Softer decay for CR\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))  # Narrower range for F\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for adaptive population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive DE leverages dynamic population control and enhanced local/global exploration to improve convergence and solution quality.", "configspace": "", "generation": 85, "fitness": 0.26844684050205325, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8311240374713177, 0.8210886938631717, 0.8602554351596516, 0.8356943204251484, 0.8119130492361832, 0.8517278357397242, 0.8382019293553953, 0.8235988921596626, 0.8053295201555406, 0.5847713773485961, 0.4622637844359522, 0.4876559692402257, 0.5611101083719927, 0.6721566720098884, 0.6545813315262172, 0.2824377937076511, 0.5468627502258003, 0.297105906670617, 0.1270844039680189, 0.14991547246083425, 0.14715411331199924, 0.14825769312622905, 0.15280048132864155, 0.1683416730162911, 0.13837915475126117, 0.13390495571175054, 0.11224062410868174, 0.48865325313545227, 0.11143246535236107, 0.08612006664181371, 0.10562053156736761, 0.10743456212441527, 0.10819351349115258, 0.08711703557465023, 0.14807240618171214, 0.08642001966950463, 0.9131615599323494, 0.9184500169221617, 0.910610341224129, 0.9201095747675478, 0.9216996041348451, 0.899077356640693, 0.9788108368035738, 0.921017673794817, 0.9202896250909551, 0.44897738149455324, 0.43782726138844896, 0.45761363568881475, 0.48365959308994677, 0.4102013199523272, 0.41396833969415825, 0.43889554736173864, 0.4675506421207315, 0.38828236736640087, 0.2423162773985632, 0.2942156437490492, 0.22258842160773096, 0.2549602959467897, 0.788726879660128, 0.26159902302783067, 0.2164885693705506, 0.3519999138635752, 0.3797341488062165, 0.3455287458142098, 0.12786843828844574, 0.17263939653866345, 0.12113337291094217, 0.1676590550795407, 0.17577747571525126, 0.1595059559316383, 0.17976646976221422, 0.16322733902160524, 0.1038771702638085, 0.21778658144992258, 0.19634805976889136, 0.17180039614130405, 0.322538911889515, 0.25504120893085935, 0.12777493262265338, 0.11841900892045454, 0.1289843532503726, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09671403958062241, 0.044694353568692, 9.999999999998899e-05, 9.999999999998899e-05, 0.013929154257683152, 0.07810198910541422, 0.06544716787952876, 0.1116084627835604, 0.08454582034181024, 0.08554672897955296, 0.0224365398856462, 0.07033792577533149, 0.14309052455734705, 0.1443176156131678, 0.1907758272694149, 0.07170866991683056, 0.049441898431467624, 0.05431016058315019, 0.10685777302583233, 0.25856607304556567, 0.07865018770052012, 0.08018052483270188, 0.12331877480749809, 0.0869540684404192, 0.055580244634887976, 0.11239207620711511, 0.21291777435829595, 0.16083097583322958, 0.16437630048741614, 0.0561793694887216, 0.11338724659442301, 0.057323473830006355, 0.1268468686088967, 0.4980694102198878, 0.548624995862355, 0.5312195571105054, 0.5209745258692159, 0.5397339536224247, 0.45909707452452664, 0.49714748400781783, 0.5707409340600353, 0.4533448289855515, 0.09350619057069509, 0.13901789758941163, 0.12401684951668812, 0.11945556324368134, 0.07967560769026183, 0.13196676712504618, 0.09614623743236683, 0.0993719597575935, 0.0994185752291572, 0.19770353826067744, 0.1479332567573316, 0.15048006441385153, 0.16123249714556387, 0.16349472764667228, 0.14173539996113926, 0.18988997808212493, 0.1310175529369002, 0.1730248677070777, 0.3073821604159993, 0.28867607696831254, 0.3833527401650938, 0.2778082893951259, 0.3627316199730444, 0.21762884287273432, 0.26341239854809706, 0.24689199821265195, 0.4120009538900886, 0.267660919543268, 0.21369090403431767, 0.21877048265490706, 0.20971129269852395, 0.21173408014014716, 0.19335407551510908, 0.217432925346417, 0.35451555335335316, 0.18909306086108013, 0.21704993774451908, 0.17558878417617652, 0.1793553660044419, 0.19698619337046852, 0.19602185402749828, 0.17889058353228215, 0.16658776188850366, 0.17420511640073366, 0.18283614444632568, 0.20140617605374556, 0.23203019871079456, 0.21884177856122033, 0.20255675734699263, 0.20805084721197054, 0.1955662172963467, 0.1762812537719377, 0.23668591206383005, 0.20017428478464028, 0.16157101821724995, 0.1555326102499086, 0.15162629892159663, 0.7903394196707918, 0.1762867712328765, 0.18417752688079425, 0.14410016950321947, 0.18323483318713074, 0.16194938951673998, 0.15472904589735825, 0.19648066137579523, 0.1510544667441529, 0.21013388812312628, 0.18217480102122685, 0.20100820680102705, 0.2538314227063514, 0.20755880139640526, 0.15096461432064046, 0.18218479581062297, 0.21348449864299923, 0.18694801590265608, 0.1794821926804585, 0.2064883239658496, 0.16163263288515806, 0.2233656337659472, 0.17797806967448448, 0.17978063576298353, 0.08551092368843183, 0.07740592736509466, 0.0801358653889751, 0.08345503275985033, 0.0823282552604171, 0.07824702351160562, 0.09811906550428395, 0.08946031440540314, 0.07335339214409653]}, "mutation_prompt": null}
{"id": "9393d3a3-9370-46db-ba74-b02e246a1245", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Slightly increased initial population\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration-exploitation\n        self.CR = 0.8  # Adjusted CR for improved diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.3  # Decreased probability for local search\n        self.global_perturbation_prob = 0.25  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # More aggressive decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Increased variance for global exploration\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Population Dynamics and Perturbation Strategies for Robust Global Optimization.", "configspace": "", "generation": 86, "fitness": 0.26271304564509457, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8713886192196394, 0.815221567385184, 0.8357174620659006, 0.8377320016502846, 0.8132845047093198, 0.8459044600656992, 0.8427644306411535, 0.8195314024447004, 0.7286232236400182, 0.49485093003111746, 0.47609348253123884, 0.5263035412086463, 0.4470827336031824, 0.6320774395545385, 0.30789832007432527, 0.6429414268393945, 0.5568254138146662, 0.32724538107238865, 0.1771378736165925, 0.15509431933921713, 0.13560394458061165, 0.14671982709851017, 0.1493507458806529, 0.14885776994659117, 0.12554916573794328, 0.13961042387814504, 0.09151337966948903, 0.08417619705762613, 0.13265612219529233, 0.1353120001724878, 0.15363952693925165, 0.12435895774715278, 0.08884461178189618, 0.1294276112305328, 0.13604523076603237, 0.10368252553121438, 0.9239208165559957, 0.9209632859199676, 0.9092535337678477, 0.9218785050358025, 0.9091218756918613, 0.9240998400441042, 0.8934797880006017, 0.900715399307796, 0.9130227279104025, 0.30540012560461705, 0.3303056475054118, 0.3628893860586594, 0.2808298906725458, 0.25476371814689136, 0.4303608745574977, 0.2848648377134648, 0.26046907345737214, 0.32348061781482107, 0.16927350955093312, 0.1649567051189097, 0.3270826633023317, 0.23381567609381582, 0.26578596756381867, 0.2667468083244048, 0.18661982119650233, 0.2126157673403959, 0.17350541704541178, 0.1765130855036965, 0.15192691158645344, 0.1565726951956874, 0.12267503972497451, 0.1225359164920996, 0.22119310475436393, 0.1478859635771631, 0.11874499839463626, 0.15663902672769814, 0.13427533065406538, 0.13687532650083634, 0.12482632341646316, 0.12334627298348366, 0.134665275143536, 0.22510050879837218, 0.1265531626303129, 0.18238889720445184, 0.20989566166833884, 0.006537824495039368, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010019156226417913, 9.999999999998899e-05, 0.0077438281201990256, 9.999999999998899e-05, 9.999999999998899e-05, 0.1137461775998374, 0.041536378439290145, 0.04458937315926648, 0.05705223971175222, 0.09200741037501814, 0.0543504693098672, 0.04096315951484142, 0.08087702463238022, 0.08043714159953941, 0.035181848409860716, 0.11097467528608773, 0.05190500155851008, 0.14847163377755623, 0.23678466355976724, 0.07939894885335286, 0.22002945344490055, 0.08730775998026363, 0.0873257217280996, 0.1670018988255042, 0.08630863265642386, 0.0527453533243426, 0.2612560879246665, 0.2391340935263081, 0.08062069765849333, 0.08411964656901161, 0.12732083881366796, 0.0747874630517743, 0.46051984773920984, 0.45746935903189856, 0.48005424866908175, 0.5260847572715628, 0.4286972048884684, 0.49001882171662714, 0.47458361256205317, 0.49690315488325154, 0.5066457525641599, 0.07814020950040101, 0.1282746845054098, 0.10253110881201011, 0.15330635386126945, 0.11078603737751858, 0.10532102423646206, 0.1238933473577355, 0.08603003490306527, 0.09594481102968999, 0.1467167035655883, 0.2024846744762946, 0.18809399091225865, 0.1414122540037166, 0.13179309826976915, 0.13818962628445697, 0.15441965047118789, 0.1661047701995222, 0.13641500086452651, 0.34769893559695497, 0.2645633949829702, 0.3680473571194506, 0.32132232730745025, 0.2800283437810255, 0.26863412921805996, 0.23565036536914896, 0.2627309314445788, 0.40457072034067876, 0.19431855512724128, 0.24166855493818074, 0.20910011668059036, 0.20972408473458715, 0.23176928138969588, 0.24894738871937783, 0.21073546993002312, 0.19358356241760377, 0.24678033082413908, 0.19628043251297433, 0.19160157953394397, 0.19345473644059152, 0.2179950440953614, 0.19588815634443124, 0.2331989144389477, 0.22376921271670958, 0.18479968537026514, 0.2667420353601647, 0.20718470850323678, 0.1639711441173406, 0.19321725922611943, 0.7917098841003821, 0.21321556035130307, 0.2015759414409295, 0.23584855526147008, 0.18987332030458293, 0.2418801258761436, 0.1673533416018712, 0.5473962155743795, 0.16109351586414178, 0.17147775020510359, 0.19200921615355449, 0.6389016467817608, 0.7170753970412735, 0.7160931571279308, 0.1244819563814199, 0.4054819073885588, 0.15061087560927788, 0.1642906018374457, 0.7347997921797862, 0.12131691364493002, 0.19840921789650467, 0.14903465315649278, 0.15224031389765336, 0.15077595824348644, 0.18492364579067055, 0.1861056717780225, 0.18840123979182966, 0.18215415010456704, 0.20217613286576164, 0.18444416909883954, 0.19442416944495267, 0.18174127697973286, 0.1794833924029079, 0.0880424001636253, 0.08189955981871244, 0.07591710298430376, 0.08645610029818473, 0.07829840734963422, 0.09095337391925218, 0.08076435886574707, 0.082940929389546, 0.07809810572322184]}, "mutation_prompt": null}
{"id": "a0260e97-a03f-420f-af17-6f0ca9757e52", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better exploration\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Initially set F for a balance between exploration and exploitation\n        self.CR = 0.85  # Cross-over rate adjusted for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_strategy_prob = 0.3  # Probability of applying a global strategy\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.93  # Adjusted for a smoother reduction\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_strategy(self, individual):\n        if np.random.rand() < self.global_strategy_prob:\n            perturbation = np.random.normal(0, 1.0, self.dim)  # Higher variance for global exploration\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_strategy(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Global Exploration and Dynamic Strategy Selection.", "configspace": "", "generation": 87, "fitness": 0.26459499760903904, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8377980113026442, 0.8256278942457568, 0.8433997389201537, 0.793238032599169, 0.8140152631097562, 0.8185683333812872, 0.8354556425411115, 0.8034473703966016, 0.7827232032568668, 0.25468787999975406, 0.13649219540858304, 0.20912286199991537, 0.2302374908240984, 0.2974588733675343, 0.6413919596251687, 0.4489994509061149, 0.14992221166577768, 0.5818773809970476, 0.10759850630132262, 0.12196251109313794, 0.1449628587676609, 0.1287472136722777, 0.14608684109369752, 0.10694711930653844, 0.11608383301727809, 0.11666970682940425, 0.1447870084201509, 0.1025507022487192, 0.09958721753877031, 0.11218499963767736, 0.12880280522753496, 0.12811455709811648, 0.12036558572307021, 0.10715963872240941, 0.11127256377506378, 0.14342990181770532, 0.9083875972954365, 0.8879333840660433, 0.9187694194404572, 0.9058977324504374, 0.8611264771102811, 0.9013557694987745, 0.9033424119299522, 0.9126540280106206, 0.9072132681912035, 0.3995575085523301, 0.32150977741036124, 0.370491629502397, 0.255637882142125, 0.26550468995595755, 0.23089361052078639, 0.27176886723887894, 0.2610719463175506, 0.4558415614951301, 0.21782647777388175, 0.301330649027845, 0.23825905084862709, 0.31852628151222395, 0.865511123414088, 0.2551590057588692, 0.3686715551459788, 0.217340160841216, 0.27325483917351234, 0.224216254506732, 0.13676578802264627, 0.1517701066790199, 0.14009545373765409, 0.16666627212194185, 0.14254374319588792, 0.15657443987922448, 0.15941431377606763, 0.1533424960461376, 0.12347559996109381, 0.11564758507124973, 0.13983575954693117, 0.1868115314941461, 0.13291232381318618, 0.14350561665609296, 0.11928793076853383, 0.11728920584330804, 0.17084935041664595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013217182488783008, 9.999999999998899e-05, 0.029670347642116623, 9.999999999998899e-05, 9.999999999998899e-05, 0.014768873494812707, 0.07307100888089169, 0.051934294623141586, 0.07265749289308865, 0.07298196612040864, 0.08753532867349767, 0.11134517839205205, 0.09570227138695497, 0.08708730432001799, 0.17497179793506623, 0.10214932595920123, 0.24575009173011575, 0.03233356616154892, 0.17648104488029748, 0.11560803312833245, 0.0873483038846391, 0.07984403600204482, 0.11422097817837262, 0.12281371663980023, 0.28633017986565823, 0.07184881872456739, 0.17752613370355796, 0.2112660517604933, 0.07185085867221974, 0.2334071388291239, 0.07737370232650687, 0.22230063899733898, 0.07679450263791454, 0.46487490070478865, 0.45347833829067763, 0.5000915865325657, 0.4196104671993146, 0.4451314535342408, 0.45501323793549864, 0.41824965809519776, 0.46173707683881626, 0.511055014835448, 0.0839120475076166, 0.0942592284768029, 0.1098862852824033, 0.0863181512189296, 0.11028079748912512, 0.0994224130459066, 0.11514329135745249, 0.110010807570464, 0.10119637696558803, 0.15262730401425018, 0.16662519053222857, 0.14982100118238872, 0.16327707515361822, 0.17816221977667335, 0.13994836725104343, 0.14343880709859735, 0.20835392773804473, 0.1557241556932677, 0.2873107457755406, 0.32623828307164926, 0.37657048136028093, 0.31357310500376256, 0.24013321223833728, 0.30529920915514186, 0.3231444264177772, 0.2714720287554261, 0.25155119213846644, 0.17417010892199958, 0.2720812116868433, 0.21323117169558858, 0.2608427868249579, 0.26282887634528584, 0.16895468658348767, 0.22251707249647545, 0.27921551603042005, 0.2259307854829472, 0.19388952123267866, 0.19742551284651233, 0.20851612282162513, 0.2220921986783052, 0.19200651166103044, 0.20910818408172505, 0.1740862949761638, 0.18873555658083574, 0.20537690261701513, 0.1877966538036523, 0.20376769764466718, 0.19836631909642777, 0.17503187562493494, 0.20866867547861678, 0.17926669900188386, 0.2015511495890533, 0.1996830460652662, 0.17226312323600868, 0.46935436960143606, 0.15766564970366526, 0.15930812513064463, 0.6687394744270815, 0.7436502243607801, 0.8204157669187757, 0.2030542141042001, 0.17954662542128952, 0.7280489351548223, 0.6494495982299697, 0.20219003056331386, 0.6065608389167818, 0.16608321699145623, 0.27176657144154903, 0.46777768975546596, 0.20324761038249006, 0.4245951814084027, 0.2892151446036111, 0.184794054252009, 0.19141719606624352, 0.18198022877192777, 0.19978736813186382, 0.20385187278369699, 0.18180852107031287, 0.18613179521558587, 0.18507174275165117, 0.17774919061494643, 0.088557340457327, 0.07810959908234949, 0.07611532973768276, 0.07409386972601928, 0.07510806968665729, 0.07810156826873171, 0.07467124343553622, 0.08018640922283105, 0.07556068088767243]}, "mutation_prompt": null}
{"id": "67b2c0f9-85d6-4746-b168-7df8566d57f4", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Improved exploration with F\n        self.CR = 0.7  # Balanced crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Higher local search probability\n        self.global_perturbation_prob = 0.3  # Enhanced global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.2)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Fine-tuned variance\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Local Search and Dynamic Population Control for Robust Optimization.", "configspace": "", "generation": 88, "fitness": 0.26691259174054777, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8571284843612712, 0.8514384360820487, 0.8535415807495439, 0.845491278862234, 0.8310704470953699, 0.83443562177304, 0.8768559947863567, 0.8353505621350272, 0.8640367138279115, 0.7121558172831272, 0.5263543246876787, 0.2419842614136699, 0.5115017070988561, 0.4161940131134241, 0.4721450159254994, 0.40556187691597934, 0.3013948220966963, 0.592516674671734, 0.5570414529190497, 0.11980143627101769, 0.13967516702413363, 0.14857202155479277, 0.14896163504164583, 0.1135629164134665, 0.1475082993124055, 0.11065463519052232, 0.14808633627912116, 0.10425969463021645, 0.16363927911824105, 0.14822949625657, 0.10932212723562584, 0.13166668851286745, 0.12517188898721776, 0.0967898734606415, 0.14877763239790642, 0.14558794317795742, 0.9155363941014735, 0.8987251751012777, 0.9023579941734843, 0.9030474478633265, 0.9215535509863698, 0.9204905268198583, 0.8740807009205143, 0.9102885002518128, 0.9021910358066677, 0.3441257926285316, 0.4335688088384262, 0.4401385212913693, 0.3450507333784564, 0.3574395811085159, 0.35195619688411106, 0.4234898649405344, 0.34026118323836585, 0.371171984001343, 0.22188698288407727, 0.2867987742744934, 0.2451867422238876, 0.26296007758806994, 0.34120712034735956, 0.31472729385699094, 0.24971538721082254, 0.1958764796668565, 0.21066791289476483, 0.3661719558725053, 0.22816847760092085, 0.18895130026786267, 0.2042279153667369, 0.13536013649003176, 0.16921425214561425, 0.16426331826453222, 0.17462241560324943, 0.12541858039599663, 0.12788797189400702, 0.15932552796218968, 0.12345889714557956, 0.17082344415164974, 0.1478827734479079, 0.13843867842314517, 0.32330454995858615, 0.14908269763280968, 0.1685960230582334, 9.999999999998899e-05, 0.00014894266055909267, 0.009882239048576102, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0077221583965125795, 9.999999999998899e-05, 9.999999999998899e-05, 0.09002633494441359, 0.11761538757345846, 0.036192514756723915, 0.05749310298180721, 0.05286361312312582, 0.021416771583737115, 0.12472530971296825, 0.09372562153076558, 0.058845376465045174, 0.23415490814045525, 9.999999999998899e-05, 0.008576413614271972, 0.0814955055440747, 0.044821417308051004, 0.10965969254481645, 0.04960205509128568, 0.06937275824679723, 0.08189507235664772, 0.14902100948230657, 0.243356067069878, 0.18618287173287806, 0.11273873309029947, 0.12628814050704207, 0.1544667231337633, 0.20896534999622574, 0.07766035759263268, 0.08624061030156083, 0.44994031869882867, 0.5780764504261796, 0.5224085216989611, 0.4705748990823355, 0.4995832728690236, 0.4555057133031325, 0.48905763473966757, 0.499770047787897, 0.4995649144793297, 0.1327526429774325, 0.10343801445826717, 0.149089102149772, 0.0815218917126116, 0.08872752357815494, 0.09494587239854713, 0.10018743173422007, 0.0818488292402102, 0.09829563222591697, 0.17490544422335752, 0.15192213916344122, 0.1432755013663376, 0.1738061176175033, 0.13127114641665416, 0.1394385638700536, 0.18359861992178106, 0.24438587564642233, 0.15728001791279278, 0.26752249149580654, 0.31847603986213746, 0.32117617151454336, 0.322475424751549, 0.3611424146570933, 0.2636581467749043, 0.3246497882247933, 0.39063117643391343, 0.39831281581844213, 0.2263771812064409, 0.23166575574450554, 0.21221735528670915, 0.25157171881196994, 0.21947923374635392, 0.16053295255654543, 0.20629183577422006, 0.2717695397631169, 0.21725358174548715, 0.19135369182807205, 0.21955488573733617, 0.19991526730380516, 0.18273216247637625, 0.20129222926331392, 0.1981882057997445, 0.19648151461667485, 0.18431967409355632, 0.21827953874903128, 0.1943351819154615, 0.6411321892803167, 0.19915276976286223, 0.2107442596428869, 0.21453256796345033, 0.19162562253242388, 0.20222534947088533, 0.1933399410919907, 0.2179157573099797, 0.16642192565988934, 0.1807932343468892, 0.7833735313014201, 0.8207928600305605, 0.1842113797996633, 0.1925017408074855, 0.16695234050447894, 0.17276796626188262, 0.14972768249751356, 0.23191304641707766, 0.2050120271460203, 0.20737165068246843, 0.2364313354094919, 0.1971060899355035, 0.4360438718189519, 0.16287116336100604, 0.2047097398211517, 0.19923290535496063, 0.18778415513658797, 0.1798411612704467, 0.18671565869979012, 0.1813583261093591, 0.1740830847160767, 0.17751043717846826, 0.17927401666461795, 0.1754690686161675, 0.18100975839480948, 0.09064786551650594, 0.07903234097386591, 0.06635462393802283, 0.08499624526344829, 0.0765235090614731, 0.08817455556156217, 0.09565821499392024, 0.07736403041323558, 0.07357080543114802]}, "mutation_prompt": null}
{"id": "08367cd6-f4cb-4934-a273-89dc0cca0a7f", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for improved balance between exploration and exploitation\n        self.CR = 0.8  # Adjusted CR for increased crossover opportunities\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.15  # Reduced global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.2 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for dynamic population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.05)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Enhanced Local Search using Dynamic Mutation and Crossover Rates.", "configspace": "", "generation": 89, "fitness": 0.27003307503436325, "feedback": "The algorithm AdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8556381009001287, 0.812441612749436, 0.8437357000148027, 0.8657990166429491, 0.8341669978701893, 0.8746454450627081, 0.8667751460608578, 0.854312905845566, 0.8486129138709632, 0.6482863081690206, 0.5314879305684715, 0.5610623598571455, 0.6718622434213389, 0.6558849052644777, 0.3764184653576005, 0.6704909629207234, 0.43058284712149797, 0.5921288509406688, 0.1776022251513517, 0.11058568351512132, 0.12397629542785105, 0.12552581701764354, 0.6743077728934439, 0.1113253971123902, 0.135762881771759, 0.14760048156516803, 0.13931484883226875, 0.09299634075104624, 0.1329913161902081, 0.10480730702009478, 0.13451276600836792, 0.11720308244431032, 0.14500527946902508, 0.11583075327085768, 0.12265017529720357, 0.13301643327137225, 0.9240564555080379, 0.9130076079860298, 0.9049495887320936, 0.9203178817243146, 0.9402987164336257, 0.9288197706600061, 0.9221806933465062, 0.8924288900826619, 0.9048829328130091, 0.3823131885686025, 0.3836473816645133, 0.3681342350389506, 0.3988634905254177, 0.39573117346294107, 0.44412976483561195, 0.431773145257215, 0.3820940119247096, 0.35516814786066275, 0.21980589967522335, 0.2245055273354527, 0.2121465712217152, 0.25792831213076806, 0.31248615401282, 0.2598086598579675, 0.20260987447291312, 0.2106180797866053, 0.23443161041495553, 0.12479036860897375, 0.16635707121214605, 0.14844237270041938, 0.1513695310061769, 0.13904785418764243, 0.13282109290954036, 0.14643458071303161, 0.2803360092387913, 0.15300218893857365, 0.2065623119690576, 0.12565233014509158, 0.10341715326906065, 0.145394265799773, 0.1559170189569653, 0.13898809771994314, 0.26805880453890063, 0.17471794007250174, 0.20020159508677005, 9.999999999998899e-05, 0.017147768317621215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019104377667014116, 0.005330001590315048, 0.038251040742318554, 9.999999999998899e-05, 0.08787664572231313, 0.051654380885470697, 0.08690828372297366, 0.0447366534472472, 0.10383556598703558, 0.027237174304186595, 0.12181557656358166, 0.1500074731424873, 0.0705185133951518, 0.03610726547287835, 0.03566965211484552, 0.08673482470937743, 0.0751851369332388, 0.22934073743525019, 0.12553192320157125, 0.08076764799092362, 0.3376895860574889, 0.1339880746207649, 0.06920632048985675, 0.05564331911068243, 0.09807254989094849, 0.15109279779428075, 0.08650311138142863, 0.24072213585428537, 0.21423179226348188, 0.16947068414563293, 0.1486584592730773, 0.4908640581508511, 0.443352253104366, 0.5220290247969396, 0.43262917321359495, 0.4970278765076408, 0.5146273280806394, 0.512595415410146, 0.4947183752526122, 0.49182736207992794, 0.11287395396186106, 0.09919940277898609, 0.09400327929918673, 0.10006062862731924, 0.11030077050239029, 0.09326845640238368, 0.1189294173899842, 0.1057192039369591, 0.12616628304682687, 0.1543072008260773, 0.13427497912551667, 0.21775706518443327, 0.176750347322163, 0.171030303732148, 0.1677841453985469, 0.1527123388822571, 0.14534074459446944, 0.13836256763011479, 0.25062620402266833, 0.333883615582118, 0.3499143755716565, 0.43323327956285107, 0.30187571948843983, 0.23726311665444733, 0.3092680318831593, 0.42930179411991276, 0.3592634501760412, 0.24052559421996356, 0.259792778006923, 0.2726667690234339, 0.27068469815041096, 0.20594272931922675, 0.22238878887115532, 0.19547904034375296, 0.25039275988168097, 0.12906044714044607, 0.1752165443157534, 0.2082076957466883, 0.16993403105360305, 0.2022869845420121, 0.20249053348440182, 0.18496088289777823, 0.20215575813536402, 0.21553932460302916, 0.2096902959490169, 0.20834627082707313, 0.17960563940779262, 0.20339831733169733, 0.23865970861889985, 0.23511591903410023, 0.22610509559271308, 0.22182617503799207, 0.19888271555532688, 0.20218370687975062, 0.15002891409168984, 0.7821806586326889, 0.19191624776958938, 0.19098358909370394, 0.19433029350405706, 0.390766162796948, 0.19860653026807218, 0.18310265819411276, 0.7354815720642376, 0.2021193610304547, 0.16335934665147156, 0.16343766959193762, 0.15932802013982983, 0.19512238361984624, 0.19997455620357762, 0.11193259900606212, 0.16113511142064452, 0.20697833947897804, 0.20089060795013414, 0.19235483115441643, 0.21730576134595803, 0.1947816547547866, 0.18211341980913398, 0.17346223695880703, 0.19194691805040565, 0.19551469236934882, 0.19090871256423803, 0.0771136785115294, 0.09356553083625874, 0.08315457295405582, 0.06497284608710774, 0.07956574165028307, 0.06502874524570212, 0.0776916892831252, 0.09527653031952599, 0.08849588146767107]}, "mutation_prompt": null}
{"id": "c4e9b1ae-d59b-4a57-ad1b-bfeadcc9024a", "solution": "import numpy as np\n\nclass AdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8  # Adjusted F for better exploration\n        self.CR = 0.9  # Adjusted CR for greater diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.4  # Probability for local search\n        self.global_perturbation_prob = 0.2  # Global perturbation probability\n        self.exchange_prob = 0.3  # Probability for stochastic exchange\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.6 + 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.95  # Slight adjustment for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.8, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def _stochastic_exchange(self, individual, other):\n        if np.random.rand() < self.exchange_prob:\n            exchange_mask = np.random.rand(self.dim) < 0.5\n            individual[exchange_mask] = other[exchange_mask]\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                # Stochastic exchange with a randomly selected individual\n                if np.random.rand() < self.exchange_prob:\n                    other_idx = np.random.randint(0, self.pop_size)\n                    trial = self._stochastic_exchange(trial, self.population[other_idx])\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumAssistedDE", "description": "Adaptive Quantum Assisted Differential Evolution with Stochastic Exchange, enhancing exploration-exploitation balance through stochastic selection and exchange of individuals.", "configspace": "", "generation": 90, "fitness": 0.2618347403648641, "feedback": "The algorithm AdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8356304753807796, 0.8337965133276222, 0.8499362209570317, 0.8128732108116512, 0.8306123396552018, 0.8432314589774662, 0.853886999283991, 0.8106332792639652, 0.8334092570307814, 0.6042526530283026, 0.2057995690401172, 0.5639734752788126, 0.3945460351450796, 0.5408509987223272, 0.39074582351796294, 0.5655349359120101, 0.5436443002410137, 0.2623246754542429, 0.1652826634198784, 0.17594237547847857, 0.10023643158675133, 0.1307403617895998, 0.12820853245021757, 0.1387391512106404, 0.1474051174451324, 0.1516670656304051, 0.10757943187249042, 0.10756514901993253, 0.12020170942752717, 0.10986451591742497, 0.1025177503096445, 0.1058607903140737, 0.1264863904446054, 0.1424543208260327, 0.13195478569046004, 0.17275988575279622, 0.9105950388895143, 0.9473422963657345, 0.9338294072332501, 0.8738942986232248, 0.8826757424100664, 0.918783339462067, 0.8806992375616358, 0.9194679550785246, 0.9082013937700231, 0.4451366435316798, 0.3694787479773368, 0.3939276390475356, 0.39681809676256985, 0.446617904762281, 0.38312441908874506, 0.3644614365279282, 0.40577633881081254, 0.40973013453240115, 0.18334042066646017, 0.30674579621636267, 0.19161250421886022, 0.33887328739758893, 0.7900564870103096, 0.26517897991215844, 0.1904694639650082, 0.22209600662148832, 0.20772637024614138, 0.1498294643607393, 0.11873058131632264, 0.23592906295585403, 0.15204386045973683, 0.12394862718172683, 0.1215417424468922, 0.15135523585817423, 0.16675480036702683, 0.16932813898492038, 0.14863179229910206, 0.23441306343043355, 0.1070521200202369, 0.16076148748179042, 0.14951655207337355, 0.13216103988535433, 0.1256611484139456, 0.15857061166177788, 0.18736616219220492, 0.06921383028636297, 0.015790862043915, 9.999999999998899e-05, 0.004370054025402026, 0.06599691842937083, 0.0032286106042657137, 9.999999999998899e-05, 0.07320875021895068, 0.007500636101769098, 0.09745009672185023, 0.0978869911703012, 0.11041800407119662, 0.12220016253861055, 0.07727950652755156, 0.09039345494001483, 0.14073258778618725, 0.14316103499607669, 0.0813138822474404, 0.05081800930189928, 0.3681321163328972, 0.24519472550103405, 0.2020024720686422, 0.12352443910430955, 0.08782008847251743, 0.11835707170645293, 0.18250962633882495, 0.19083216362632904, 0.11233935606482004, 0.1546815645364784, 0.20863229205709155, 0.13240252381826156, 0.24268415521897058, 0.2173980423972327, 0.11599362307052996, 0.11151636029826517, 0.1825454532902422, 0.4630889112928894, 0.5957812630335879, 0.4777728822418168, 0.46496972765018485, 0.5257590323034154, 0.4736337767176777, 0.5433816910121397, 0.507198484618319, 0.4630093378470157, 0.08756605240473403, 0.10834260287315045, 0.10263238171424605, 0.10309402547354862, 0.13492943724025985, 0.09052806196192109, 0.1313554588241792, 0.12948457143390046, 0.10808868338269517, 0.22967473858973986, 0.12835630840433454, 0.15854491194359233, 0.17760509221653065, 0.1911828258150149, 0.1872506177134865, 0.18314059026577123, 0.17420628199311328, 0.14995609352789674, 0.2755340247746656, 0.3042571805673582, 0.28011485185986507, 0.20636279634466903, 0.2939252803812473, 0.27420439531313356, 0.21159095873000122, 0.3391878993278812, 0.3975536183194831, 0.28314053297362907, 0.22445532684775382, 0.253000246995457, 0.21313307648265412, 0.20941101394403128, 0.1556468077404115, 0.23206814586154978, 0.27087817610054377, 0.23668425602372523, 0.20236617425167225, 0.22434913413980906, 0.1864561122846473, 0.2435783109812989, 0.1768028203913753, 0.23404997949330286, 0.20423556302695955, 0.18498556345914985, 0.21247944432855703, 0.18408162209032675, 0.18221836938936142, 0.18087751520014694, 0.18936997681089485, 0.18726006853774013, 0.18080488957492158, 0.1791714834562781, 0.1738660987161671, 0.19132370219730455, 0.1431923749536831, 0.20027447696555722, 0.17059001667351747, 0.16568381817896172, 0.19118755600747583, 0.167867128282697, 0.1645751861893181, 0.16361974178889216, 0.18467497965141177, 0.20395669712595232, 0.163540865912864, 0.08049375049405794, 0.162635159410344, 0.19678596940389603, 0.15854451818995963, 0.20221758762563136, 0.12303440919118092, 0.20266324399222801, 0.1822964254070586, 0.22405529692946669, 0.18744128016733597, 0.28109079378092483, 0.20921433305537807, 0.18118947332624147, 0.2221136177256472, 0.283332633747303, 0.2046427252084544, 0.0994118268125419, 0.08536660249405337, 0.09104491135725601, 0.0806008727277071, 0.08501803430879717, 0.08608760357464051, 0.10404105519876283, 0.08731084105949449, 0.07741585887098557]}, "mutation_prompt": null}
{"id": "c6bf024e-a1a6-4041-9c0d-d599b5d81fcb", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Adjusted probability for local search\n        self.global_perturbation_prob = 0.15  # Reduced probability for global perturbation\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Adjusted for a slightly faster decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "AdaptiveQuantumDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Search Strategy, incorporating evolving local search and perturbation tactics to enhance convergence.", "configspace": "", "generation": 91, "fitness": 0.2737966010404648, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8287540440009475, 0.8577915974615198, 0.8811445849045567, 0.8915822658447684, 0.8477562334750284, 0.8713529020980014, 0.8606526507382131, 0.8536796272892309, 0.8579425455579206, 0.6006568838532221, 0.4226192968149074, 0.5160764309840262, 0.32503860873303814, 0.5207576899557453, 0.5100073492388992, 0.44953290062565854, 0.27349743806569726, 0.379133949203746, 0.15387312454192548, 0.1794264622907411, 0.11499056764033799, 0.15712963383065293, 0.1537011040104107, 0.10847686540302726, 0.1381582365742019, 0.17849490158087788, 0.1302403175249074, 0.09373976477728119, 0.0875074646529771, 0.1423117642302968, 0.11197121917509012, 0.10388802496692329, 0.0897619889300384, 0.08880044166746848, 0.13704044855570008, 0.06032004357463194, 0.9220585133108218, 0.9342699236358243, 0.8791388578311081, 0.9166930460000644, 0.9160698362081425, 0.8998640261512335, 0.9424874232984002, 0.9058954769257088, 0.9321764566555313, 0.4610040211716926, 0.48101711651885404, 0.3868942923462527, 0.46170712030231376, 0.3934164981623397, 0.4113639266774498, 0.3359849988279592, 0.3248387248490542, 0.4845299770470215, 0.22766660746510148, 0.16738634981037537, 0.21694282874496618, 0.3061465927937391, 0.2154349362267438, 0.2122588859026866, 0.9087674200327017, 0.22680915226767662, 0.22476601349977654, 0.27807551626515536, 0.03872210142217847, 0.1610182163583559, 0.20219966174090398, 0.17211284420672113, 0.24321361474637615, 0.12888428544738273, 0.16669084157472625, 0.19345182976769548, 0.15706204947678049, 0.1489727124051291, 0.12269111172749958, 0.1267606548085083, 0.1399363307536391, 0.21777262209996606, 0.15862954292492537, 0.18839841491722398, 0.16600435845358674, 0.027683603885991448, 0.022773178616725676, 9.999999999998899e-05, 0.04461105073891647, 0.07538771525197285, 0.020096028482470163, 0.0552903662268589, 0.053799671299459284, 9.999999999998899e-05, 0.07944385107062102, 0.043393745489090696, 0.09645580629313277, 0.06416734005746327, 0.045609400214915885, 0.03675387812667452, 0.14692228444310163, 0.1462193805941988, 0.07186441330329452, 0.04066440348748479, 0.08575268634464572, 0.09598975618690508, 0.08973113648350806, 0.14233584980117853, 0.11645720106114965, 0.17028839671183538, 0.10450735977515924, 0.11630196455402908, 0.18286217018494122, 0.08039135112324858, 0.07053821982815589, 0.08267852372024076, 0.07658636822225162, 0.18132094407981103, 0.17754982061611968, 0.21470415688788758, 0.1357462097914568, 0.5340323855764026, 0.5049716802351059, 0.4791375332350115, 0.48141962917517056, 0.5250635995564519, 0.48018461661454603, 0.4870199475073532, 0.5012799330848736, 0.48445735694566683, 0.11338476985797319, 0.11936349865519369, 0.09488536660057945, 0.12561329671875332, 0.12841888072647256, 0.08187605649003349, 0.14830788978875442, 0.15622802043415795, 0.13115486166855295, 0.16549855227612842, 0.20934270825686707, 0.22186542214071925, 0.3041979434453782, 0.20523798626178247, 0.1778234462873215, 0.1531779707854204, 0.26858128232004264, 0.15541031500256663, 0.29872977650109467, 0.35798185038001096, 0.411523050113363, 0.33094316354104614, 0.2389414153062398, 0.35792860674087346, 0.2540401756315108, 0.4778923130837719, 0.23946101900526395, 0.30828778186679473, 0.29616854537469584, 0.23355485736537773, 0.22904001997507895, 0.2094491071926402, 0.2812652451479033, 0.2499347487580218, 0.22102318230755713, 0.28005735968459655, 0.18026598709563169, 0.19075907966229966, 0.16988145302216895, 0.22214620817074426, 0.18240836406053995, 0.1805502279824719, 0.2643356690997767, 0.22811700785748368, 0.18616168959558888, 0.17113662378406114, 0.18503315619806449, 0.17976928940107095, 0.171404020692548, 0.18717240719521155, 0.18028410833140063, 0.18399776046931127, 0.18736038193165483, 0.172475727398826, 0.15450893645556718, 0.18797700190186684, 0.18334045443418345, 0.8277880598480651, 0.19156668206406569, 0.174928187982346, 0.8167682061917683, 0.15901678233872973, 0.16972151369990296, 0.4779117490023521, 0.20671389841632026, 0.16621040277800836, 0.8040883708683929, 0.164980259193639, 0.3053212841379098, 0.1524122801088399, 0.39984799454552655, 0.11048752252962535, 0.17621920178011985, 0.17571191875624959, 0.20257181929889756, 0.18202775985139408, 0.18435628579573404, 0.1858022934070086, 0.1694416405283935, 0.19638918883599188, 0.18787871739928663, 0.07755196443702084, 0.09327423730853879, 0.10579306805527089, 0.1024996685435402, 0.08333344429181067, 0.09185936956818386, 0.0935199785688885, 0.08134136524494351, 0.08041464951223776]}, "mutation_prompt": null}
{"id": "56caa445-8239-4fee-81a2-2464ca487386", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 6 * dim  # Reduced initial population size\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Balanced F for exploration and exploitation\n        self.CR = 0.85  # Balanced CR for crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.35  # Balanced local search probability\n        self.global_perturbation_prob = 0.15  # Balanced global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Slower decay for more stable population size reduction\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)  # Adjusted variance for better stability\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Population-Size Adaptive Differential Evolution, combining adaptive scaling factors and reduced population size with quantum perturbations for robust exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.2613475345871184, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8818118172536157, 0.8892656066296838, 0.8479096038808158, 0.8529427341455512, 0.8890299175908101, 0.8695035070478649, 0.9048964410211945, 0.8456217335615797, 0.8538879925553623, 0.29565018983643676, 0.2574917781517765, 0.2673731470537988, 0.28226493354368176, 0.3143438576524852, 0.20440255981803856, 0.19541183097523684, 0.21153567228436154, 0.2636734223321854, 0.1185006251581523, 0.14470253982974302, 0.14186765429521653, 0.1732114888072689, 0.11825614571448828, 0.143393590888371, 0.1529024742642796, 0.1583370317845587, 0.14353569410647815, 0.11408442020886045, 0.1461269846307972, 0.09440504478757217, 0.09493365756753414, 0.13998050644413285, 0.13276987293669862, 0.09474996785239798, 0.09467884903113954, 0.11598515510087615, 0.9137221513902815, 0.923484015898944, 0.9228325721491348, 0.9192418105518675, 0.864070884965297, 0.9209762060778277, 0.875630398256431, 0.91726198162092, 0.9226819832891474, 0.4185267026483023, 0.5054688193237944, 0.28297057585040764, 0.4102074757856713, 0.47190046506462224, 0.439823650130887, 0.32932329846937614, 0.39755810548570036, 0.497136736923642, 0.2650079712674417, 0.23052381974005332, 0.2868743419165519, 0.2049841691695703, 0.2332856452846339, 0.266170079825367, 0.30976808315209836, 0.18559113572932096, 0.3300981582122161, 0.4772372229079409, 0.16366644901356775, 0.19863462540041377, 0.16576335963553845, 0.13004121376865352, 0.20063418737754557, 0.18549943627652732, 0.12927113907439658, 0.2069953939921183, 0.1528458787147987, 0.19377681072811415, 0.14368871195460853, 0.12862187485255017, 0.14568611559231937, 0.18791288664811068, 0.15191969967829588, 0.17419826626225643, 0.15688845676571395, 9.999999999998899e-05, 9.999999999998899e-05, 0.14836399009922274, 0.06366048448073325, 0.04635558013112551, 0.061444036613706676, 9.999999999998899e-05, 0.03441554747767439, 9.999999999998899e-05, 0.07440627347022177, 0.10022293309312014, 0.0961563759874472, 0.11978333562888943, 0.08363614444296896, 0.036386353688634854, 0.09243329468969808, 0.20831462070789097, 0.08151187374450597, 0.049403756470793425, 0.10508201457733435, 0.23503022816522023, 0.28226006919212243, 0.12220738075092286, 0.0830587355107466, 0.09432121616037203, 0.1632556988414845, 0.20778519104069149, 0.19265534478266544, 0.0531663013558995, 0.17293339196750113, 0.1619776774398881, 0.18036817344940304, 0.1045639086456609, 0.1271574359335058, 0.22173434899613398, 0.10398845406774637, 0.5004926349691794, 0.49836183686790814, 0.5077274011348175, 0.5198427144894116, 0.4788504969788505, 0.47948343514671254, 0.5013215146189097, 0.49955256211359844, 0.48096960631940766, 0.10913755320900365, 0.10220994137120598, 0.14075246848859146, 0.09972899117393375, 0.09514830628849036, 0.09938348203645475, 0.07751059125604864, 0.125443787191165, 0.11000483868016542, 0.153693776189613, 0.14522284573066102, 0.15249313718862667, 0.21065476617999435, 0.13942935492063935, 0.19906619888730603, 0.1488188332481417, 0.13340156674274717, 0.15137340480559347, 0.22219561676594934, 0.30658080998997717, 0.27446569800980314, 0.32007877049277234, 0.26110732904916045, 0.2750986020796551, 0.38494458039002155, 0.483066830304166, 0.3258460184026062, 0.1806028934971482, 0.31655237768829925, 0.194924953550497, 0.261888605069283, 0.22833526649262348, 0.16710242601445535, 0.20496150675762803, 0.28243515123696317, 0.18859748449697045, 0.18290815991299092, 0.18863656472215484, 0.18954069363469928, 0.22319946065201646, 0.1860682477403549, 0.20441570545943266, 0.1978898192199423, 0.20713671734501893, 0.23389570268012605, 0.1773276765759545, 0.19441288101712695, 0.22556389308655977, 0.20763958838277174, 0.2018445040040927, 0.1787447662680144, 0.18435197100452894, 0.19733869979199203, 0.2146862258938148, 0.9107004632605835, 0.1814436025163555, 0.16511051821082678, 0.1852849846967748, 0.1975349546222661, 0.16465236531067518, 0.16818471599791918, 0.1620013416632362, 0.16158546397778373, 0.3987539373566854, 0.20958476010007676, 0.21840874071618832, 0.19440804319792515, 0.1902504081061509, 0.16479458661066637, 0.20702152258069595, 0.373571750025837, 0.5056590189767888, 0.1818694765181451, 0.18857806921198594, 0.16915764084825036, 0.18942018770866675, 0.1874408890274163, 0.19260234173549606, 0.18552251329962643, 0.19574246102649318, 0.1853051035903842, 0.09573728051292796, 0.08279641908826885, 0.07837991112003506, 0.07980583907210914, 0.1034784358289278, 0.0893861132374617, 0.075895626257249, 0.09189922742449452, 0.08835492630549158]}, "mutation_prompt": null}
{"id": "5a4384e0-1777-4b0c-869e-4852cd79c10e", "solution": "import numpy as np\n\nclass ImprovedAdaptiveQuantumAssistedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly reduced F to control exploration\n        self.CR = 0.85  # Slightly reduced CR for more stability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Further adjustment for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Adjustment for smoother perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "ImprovedAdaptiveQuantumAssistedDE", "description": "Improved Adaptive Quantum Assisted Differential Evolution, introducing dynamic quantum search and adaptive global perturbations for enhanced exploration and convergence.", "configspace": "", "generation": 93, "fitness": 0.270696967573001, "feedback": "The algorithm ImprovedAdaptiveQuantumAssistedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8549787174629264, 0.8546904985576688, 0.8524793532628103, 0.8382910084324204, 0.8311701136143849, 0.8454145522762041, 0.8533205549729779, 0.878078887832508, 0.8560988715701133, 0.623622510315134, 0.2511808340771131, 0.40876389243555245, 0.3418166581280596, 0.4911788152956781, 0.3034614439784282, 0.11486494203467779, 0.34677370033628063, 0.44680482104007346, 0.08703587900304499, 0.1789474257804533, 0.12839480295333427, 0.09601382842704864, 0.12018795706757623, 0.12234057140597909, 0.09463585264473184, 0.09384547967285706, 0.13129287644783505, 0.12942294528858622, 0.09680530592349534, 0.1121483878489078, 0.10607929211841416, 0.13856221723554185, 0.11120986424504986, 0.0948854921639577, 0.15612815275488445, 0.17351439943679303, 0.9043413305160849, 0.9097954408922515, 0.937707786020043, 0.9276582634000848, 0.9216062708237144, 0.8956141265896476, 0.9033860992908627, 0.9371535288698973, 0.9195802760535442, 0.33778846160782205, 0.4731399714285853, 0.40355066593276734, 0.3952683947261413, 0.43076083550537114, 0.37348849553615215, 0.3642075401956081, 0.3852832232033718, 0.37794416912080864, 0.21833253686033272, 0.2182596558334916, 0.27469027906525845, 0.25162278849906583, 0.2252706774158224, 0.2644742660192029, 0.22743859740212247, 0.23683767874755146, 0.8501114564118705, 0.16356183908233268, 0.15802736223685065, 0.17631152674087003, 0.1656308747235733, 0.158441972068895, 0.11375989935808106, 0.12557634025038078, 0.12399195314802691, 0.15151147286192446, 0.14996593386223644, 0.15297420923261162, 0.12724684045933354, 0.17549910689014292, 0.14090659610197942, 0.12374025681865586, 0.16933828483325686, 0.2111785523124622, 0.17260886092515793, 0.07409570632431461, 0.03922803685409926, 0.02202652668894911, 0.02707927552246836, 0.001516203541362171, 9.999999999998899e-05, 0.01758569211836236, 9.999999999998899e-05, 9.999999999998899e-05, 0.2054385482382891, 0.16629361079857374, 0.12056204140614335, 0.08239180196019169, 0.016734902688770648, 0.05714536646102675, 0.21751500067811025, 0.10862262027181224, 0.14600621143982995, 0.08386383761864202, 0.12144772006025983, 0.058273100603858485, 0.10371519773177151, 0.16744543463765438, 0.10818588724974831, 0.10158326389808425, 0.11204047015884189, 0.10268152426455146, 0.2417104506129626, 0.17892775343668632, 0.09235734235041893, 0.31767955188768116, 0.18207898764360975, 0.08796842308871633, 0.20479932817554714, 0.1369484627141434, 0.08237810267737677, 0.5218173107301132, 0.5357421486873687, 0.5604045084038205, 0.5063904303663541, 0.6075301983048396, 0.513994308156922, 0.4969944994132073, 0.4864748478803014, 0.46945273883593264, 0.1590138845776975, 0.08850359425872845, 0.09800616541433194, 0.08510449052572044, 0.07173810045612372, 0.16298205551527845, 0.1803515342393175, 0.09588001941909097, 0.0849260387514007, 0.15242218386724615, 0.20889372550331786, 0.1484446139256177, 0.3653380340731963, 0.181634638417416, 0.16128145074755507, 0.15470980449277472, 0.22163536039088094, 0.17127461661088217, 0.33607511766768505, 0.3714353137057097, 0.2776024909979965, 0.2642710627904482, 0.27930862720927163, 0.309175966477799, 0.33779883376023256, 0.37609350943247877, 0.2679808838553456, 0.23916085839035028, 0.23285216769950723, 0.2676010470955771, 0.21735632768678537, 0.20271744511514, 0.2472494137752166, 0.22707683537494816, 0.28810824804252366, 0.19632764656500212, 0.1871490240309993, 0.18910629989142813, 0.19960504770779086, 0.20159041602941297, 0.16567797102483695, 0.20768568278594735, 0.2176729450287106, 0.18505017272739965, 0.20845048724977955, 0.17482615161401105, 0.1834527978253757, 0.18030894328998404, 0.20196879069238283, 0.20077390638979964, 0.19382995904220623, 0.3783255544442361, 0.2161479357417938, 0.24223886578541542, 0.874240582280104, 0.20358568969753688, 0.18234424487430845, 0.16933681412976698, 0.19664457995045903, 0.8330500235110172, 0.8087494892470712, 0.15543378796108498, 0.15967616304989551, 0.6524988983813859, 0.20768693081827483, 0.20232554884859433, 0.16577033637364746, 0.20586319619100035, 0.160489561607977, 0.12057329452338239, 0.20744983061005373, 0.2076943674202908, 0.1690011821758951, 0.16638083285950456, 0.1840365381940141, 0.18569198379211216, 0.1930068319576409, 0.18444371775306245, 0.18945682166183464, 0.19197480182395832, 0.17038132004216877, 0.0809186405634782, 0.06825875986549712, 0.08505415408524664, 0.07290264332374696, 0.08626312556441462, 0.08733535261216552, 0.08248647818963473, 0.05900239567722565, 0.06089003952318395]}, "mutation_prompt": null}
{"id": "a868a5bc-5faa-4988-bfb8-90f23f4e3e75", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly lower F for balanced exploration\n        self.CR = 0.85  # Slightly lower CR for more selective crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased local search probability\n        self.global_perturbation_prob = 0.3  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))  # More gradual adaption\n\n    def _adaptive_F(self, generation_count):\n        return 0.65 + 0.25 * (generation_count / (self.budget / self.pop_size_initial))  # More focused adaption\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Slower decay for sustained diversity\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.5, self.dim)  # Reduced variance for controlled perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum-inspired Adaptive Differential Evolution with enhanced local search and adaptive parameter tuning for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.28216812303075056, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.84235135739326, 0.8067732744119929, 0.8328742020202983, 0.8114751911036782, 0.8366196064436451, 0.8501100097476166, 0.8442357593478644, 0.8406592089991196, 0.8301933195824178, 0.5797683125425022, 0.47484712195752266, 0.5801879785401085, 0.6124554586773782, 0.5170663711422415, 0.6112547183432073, 0.6502020555246202, 0.30866502735815526, 0.5829977691299827, 0.12681396015447322, 0.14551302874496463, 0.13918061588634423, 0.11390232447224502, 0.1225779741385391, 0.11585389155024017, 0.1745933164122826, 0.16694393692874743, 0.1114089641264503, 0.14417724497503637, 0.07838110044469737, 0.09352530215691024, 0.11363240571762057, 0.14515213624521017, 0.1457126894184828, 0.09402939363704776, 0.1260746095543016, 0.14218074650915946, 0.9263797456087484, 0.9035475604295997, 0.9183125272602954, 0.9049255104772002, 0.9135940202771461, 0.8943799058620855, 0.9140201093451429, 0.9107172989065749, 0.885657975623446, 0.3764783789718975, 0.4357706145062976, 0.4828536065089034, 0.4579213819009269, 0.4225162102487223, 0.3762476198464062, 0.42885312917517515, 0.3723148781282727, 0.3649394718152572, 0.796968902343237, 0.21529063796752168, 0.20633286815949425, 0.20526806973836742, 0.3704284333061787, 0.35941896490305103, 0.7477280611102259, 0.37676941411024845, 0.6755247358997092, 0.14556388982152002, 0.13164638269411266, 0.1621135067147743, 0.18447898197619472, 0.10493246363975106, 0.15543824721329258, 0.15573098834442822, 0.14789665140466368, 0.15999591491679588, 0.1303697024619671, 0.33648484140302803, 0.22340590160407658, 0.15532888137068912, 0.14596095406896348, 0.23726515862650144, 0.18899355339696122, 0.12198888435638178, 0.31672517469667605, 9.999999999998899e-05, 0.04186347493292253, 9.999999999998899e-05, 0.013718933906946895, 9.999999999998899e-05, 0.000673289075497685, 9.999999999998899e-05, 9.999999999998899e-05, 0.01653962038756185, 0.11169553680716238, 0.07914428531847317, 0.0694341328159428, 0.07601202267670326, 0.047571498881537666, 0.04505456365980842, 0.06819939939186603, 0.11180076023178864, 0.09224367867288397, 0.015829090158491987, 0.09398918010789425, 0.10893836629530218, 0.10479385825859122, 0.12643213388940644, 0.1689048068378992, 0.13589139446111564, 0.195957422649631, 0.07902668495140242, 0.13829136348359294, 0.07605514584203177, 0.06768921379242787, 0.27715452265457674, 0.17028878516086665, 0.19478605418737394, 0.1061057346990163, 0.08367766071872551, 0.139502905839604, 0.46458516930917704, 0.4764295783438892, 0.5023184025997356, 0.48348594246209764, 0.49509044584493833, 0.4838163575656599, 0.5294417359191415, 0.4988305307489942, 0.5231868358609695, 0.11201775578396078, 0.10344802881847137, 0.11794602523368536, 0.10902874045599364, 0.11015446455188271, 0.08379909232316496, 0.13013480449005588, 0.12317912672627318, 0.11856943630682804, 0.15900557532262571, 0.14487217580708434, 0.14902393716165552, 0.32709676762641726, 0.17134803033293833, 0.18148222305487827, 0.2336609823125646, 0.16375049911657957, 0.19416673912395288, 0.33132508713944075, 0.32808692406901074, 0.33113808478678797, 0.3913552609124915, 0.3483975480169771, 0.32499060747796193, 0.40265956350660004, 0.254888320266641, 0.32894365595965835, 0.24129511830970263, 0.23180095397742628, 0.19696896986968682, 0.1708201555411999, 0.1878352392718443, 0.2068707688130318, 0.26705898427030006, 0.2511243661001378, 0.18467858421049754, 0.20517828117338666, 0.19913794368687066, 0.1962305617710477, 0.22872546661128135, 0.1883823843928586, 0.18895827903921825, 0.21069294968910968, 0.2205268230680688, 0.2023961264773193, 0.20209139669401588, 0.42777727779071817, 0.20421455121347687, 0.19404482224692188, 0.39347296168715906, 0.21498384287722272, 0.5335592646021039, 0.5346613405138425, 0.20810706321953698, 0.15510593581199716, 0.1790598029852074, 0.2059878767691684, 0.19341069523668342, 0.18337510299680648, 0.16295569936624976, 0.17179892215265058, 0.13473978976263767, 0.16773960604086313, 0.39868494099901575, 0.15239785878708623, 0.20324265421906362, 0.49778257136595017, 0.1923454710328284, 0.19391103673958665, 0.20316450060185376, 0.650666467338824, 0.6913192619684666, 0.19679494596043645, 0.1868586289122096, 0.1932963288724029, 0.18672980030394926, 0.21903710534599985, 0.19778585196286969, 0.19090902248330255, 0.18617718163619035, 0.17123173597000474, 0.08676745130991803, 0.06974727206619447, 0.09351848941131025, 0.0778786888123636, 0.07674058467177636, 0.07491244371223549, 0.08908616417363213, 0.061688922221911024, 0.11058081495699568]}, "mutation_prompt": null}
{"id": "ed66ed35-55f8-4fea-9c03-45e12d4fdc30", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim  # Increased initial population size for better diversity\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Tuned F for more balanced exploration and exploitation\n        self.CR = 0.85  # Tuned CR for adaptability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Higher local search probability\n        self.global_perturbation_prob = 0.15  # Lower global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), \n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.35 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.7 + 0.25 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Faster decay for population contraction\n        self.pop_size = int(max(4, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.25, 0.25, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Reduced variance for better stability\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive Differential Evolution with Dynamic Population and Perturbation Strategies for Enhanced Convergence.", "configspace": "", "generation": 95, "fitness": 0.26089828142287735, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.825189874108684, 0.8368095545107065, 0.8345808680235101, 0.8290571634834014, 0.8204648665695832, 0.8170818099571407, 0.8195841942017494, 0.8554912821077564, 0.8214575924693928, 0.32247094096156315, 0.4708312007892511, 0.384929821060087, 0.2519395181019818, 0.6098143363791475, 0.5305791266921669, 0.6077920712644729, 0.5458775938805972, 0.32788969087933106, 0.1327449063401004, 0.14899116147955616, 0.13284490948861172, 0.11787008169223168, 0.14528385761042517, 0.15021485548801305, 0.1522001595130994, 0.1762131568611317, 0.1423701338957991, 0.1038558992611468, 0.07331516629874257, 0.13859685985476555, 0.14621386793381075, 0.10478397885715063, 0.11371971060627928, 0.10879590958461338, 0.13449157677464496, 0.14188281977266648, 0.9074188351286251, 0.9109082315593695, 0.9087440224284032, 0.8973264876498823, 0.9083664943013331, 0.9132136236214208, 0.8883160038042164, 0.9090772096608156, 0.8874054891006323, 0.3339403864720115, 0.43960243893223194, 0.3443650797852954, 0.32227424336852295, 0.36917376525711443, 0.39288247454885905, 0.44477553738957576, 0.3721846149350755, 0.22643208897254796, 0.2051193568869869, 0.22566408381931635, 0.21582102985079332, 0.3168694116341242, 0.20635290507617876, 0.6682742195478372, 0.2938278178760936, 0.3134687783492375, 0.6156320209146273, 0.14661294273611547, 0.16475220186159678, 0.14390716046999974, 0.15356386432200764, 0.1548631571766318, 0.23842624404173807, 0.21217539876412594, 0.12358194534150224, 0.15689071823968903, 0.12722114295773101, 0.20491224547015796, 0.11494766687599622, 0.16653957046500822, 0.20483591825047665, 0.118939834793378, 0.18859275390545405, 0.1650311388892678, 0.20155397290881594, 0.02147024517714069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046815164663379094, 9.999999999998899e-05, 0.0318084251413806, 0.006581432374106799, 0.07410389773130466, 0.08719192152100952, 0.08879798975017927, 0.09845870778901156, 0.1291597756180758, 0.06607345088412497, 0.04644216878107765, 0.10727915678629418, 0.034914192931724375, 0.12825160394387436, 0.1362346432770266, 0.21385223108473694, 0.2551449140912996, 0.07619943232217008, 0.09131409283796221, 0.08381814028207524, 0.1335191027292656, 0.060107919344835836, 0.10026373058428506, 0.0915884512516757, 0.13462433376641691, 0.17015314707279516, 0.1789295619943323, 0.1709993824677991, 0.18297330112739496, 0.1535806819956691, 0.1657409587724411, 0.14102314723460063, 0.4954344855197189, 0.51731447499649, 0.4672405614019488, 0.47509251358159876, 0.4780465122219181, 0.47928759599931936, 0.5266439085830801, 0.4952754741595463, 0.4487339158290079, 0.1223653646824574, 0.08837409072040758, 0.08669514378748167, 0.11253664316797751, 0.11172076456631164, 0.13067198658830914, 0.1013946453919603, 0.10315477815008212, 0.0865768974202974, 0.15724988906828963, 0.14814377621914232, 0.14625957245247045, 0.2214404923567468, 0.16767000802951748, 0.15664136087661684, 0.16789040666106325, 0.1587812422921674, 0.1557176128738954, 0.21929900354621912, 0.24774575338650506, 0.2732355575248354, 0.29433169063787945, 0.2856814953586606, 0.2639860112612282, 0.2593042796917977, 0.23310664716814578, 0.38402532114265886, 0.2000925238381357, 0.3123821483937831, 0.1764115752731502, 0.17945361887146627, 0.18027382299193018, 0.1776140955554545, 0.15253430056596062, 0.1883633812896487, 0.218573390162342, 0.20530463579245528, 0.19959041113025044, 0.20305356638499095, 0.18278837428240136, 0.20454392334739224, 0.2010079698747752, 0.18352897734423246, 0.18944160451168468, 0.211379947285826, 0.24281842250519436, 0.18842162905024484, 0.18956774610460547, 0.18931694882182426, 0.20139987129149572, 0.17451249243951694, 0.2032812945988549, 0.20018548912199086, 0.21952286913137598, 0.15919251443664761, 0.5703907906970589, 0.14806652340654525, 0.5035621547418123, 0.5133318083819827, 0.17932143558775027, 0.14824371861382935, 0.28371564594949206, 0.13828203279574414, 0.20822093320027124, 0.2063554643107811, 0.2032669826981912, 0.15486796453868723, 0.15748310715987812, 0.3105166327357054, 0.1993013942471452, 0.14990302649045284, 0.19994281757693322, 0.1979876117549666, 0.19726582428289952, 0.21385348732722997, 0.19478306590621608, 0.20011780149819747, 0.2008733309765922, 0.19241848104796977, 0.18533917098734365, 0.1888623808746578, 0.07689033850030647, 0.09273153726487948, 0.07451843763988908, 0.07586398832445052, 0.06787754278593461, 0.0758143825989096, 0.07897095228625095, 0.08040110089802655, 0.07422914711753914]}, "mutation_prompt": null}
{"id": "7b8875ec-f7ef-4dce-9f06-be9db90660e2", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 6 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for balanced exploration-exploitation\n        self.CR = 0.85  # Adjusted CR for adequate mixing\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.25  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.85 - 0.5 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.92  # Adjusted for slower decay\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.9, self.dim)  # Adjusted variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategies, combining dynamic population sizing and quantum local search for enhanced global optimization.", "configspace": "", "generation": 96, "fitness": 0.25783992387123206, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8615330472607804, 0.819410738214962, 0.8607058229546342, 0.8435223797974195, 0.8256929267079128, 0.8479203109551539, 0.8194876609122344, 0.8895366146844471, 0.8650381696429321, 0.18545175278872372, 0.4051699537651323, 0.5977324081997677, 0.3529956597517401, 0.1406678521897431, 0.31043774248425593, 0.11702142077503541, 0.38152421720057994, 0.2085553207434082, 0.11937573847121052, 0.11563395412820121, 0.12866588658450528, 0.15495617715653276, 0.12928750881332618, 0.1480771616544747, 0.13008338758118498, 0.15233862443102952, 0.15715313657835017, 0.10591030231285825, 0.11513002898820035, 0.12596528105719496, 0.1109713731049613, 0.09152798304933607, 0.11523414859861192, 0.1287248629612352, 0.13972782778524273, 0.10763426789471398, 0.9352546645600058, 0.9330253009399395, 0.9265391043958235, 0.9236647279659185, 0.9568782472799634, 0.9460235176555433, 0.9030665391146677, 0.9367202894406275, 0.9437964615340156, 0.47113652781093984, 0.47752028688295367, 0.35491486168921604, 0.4246743840042475, 0.5571113457924451, 0.4513435263429264, 0.2913668821302623, 0.2898417219892446, 0.3428620371715362, 0.20664475700653173, 0.38147081341539857, 0.36896182014092826, 0.1689081468756467, 0.2371450518211483, 0.1863741011273098, 0.19405218721025408, 0.2947632270289924, 0.19706715385524087, 0.17333975624411213, 0.24551124563326843, 0.1592455830229541, 0.1229564350729474, 0.16181298877151096, 0.14772345763464179, 0.31660941407801635, 0.19846372706166127, 0.1799506234804532, 0.16321962427388426, 0.08655734889227373, 0.15847142433148698, 0.17868016820771504, 0.15518418497423625, 0.40782677277833823, 0.17173748995760885, 0.2990349946816122, 0.1710181385734244, 9.999999999998899e-05, 9.999999999998899e-05, 0.119522400278816, 0.011050433058208964, 9.999999999998899e-05, 9.999999999998899e-05, 0.031170058979320125, 9.999999999998899e-05, 0.08327283728260149, 0.06067578149780639, 0.0879186733463585, 0.09206741055157963, 0.08677353660052578, 0.1533399187393465, 0.031716725212885266, 0.09761708225937304, 0.16713554816446918, 0.10067335761088403, 0.1333444879665392, 0.049225418172871516, 0.07781732445856038, 0.07360161850563507, 0.14307002612112008, 0.08965609795819307, 0.13170542049333378, 0.15800931595629664, 0.2049867373973877, 0.0671036698174543, 0.22706867597730673, 0.04310847053226885, 0.124687962542395, 0.1475859652134357, 0.19670249167132903, 0.10719107799809513, 0.056774992090519616, 0.2372664416715483, 0.45168942455425265, 0.49713173858679016, 0.4534701583415931, 0.4799268264862201, 0.49417509792562475, 0.49937424314878043, 0.49709550745224373, 0.48577078565547527, 0.4998554406134097, 0.0797802883018961, 0.1134879433862257, 0.10259345874861425, 0.0831839088016102, 0.0972561763490234, 0.1131438385460053, 0.10894588349062817, 0.12583387780828603, 0.15311490437541875, 0.15939666458878932, 0.13312413730406047, 0.29652474031243037, 0.13886205313560562, 0.1630420799888712, 0.15004193992654913, 0.1510064577538338, 0.14504837893686595, 0.35191782710387587, 0.2733056952950734, 0.23153758693234694, 0.328124183577472, 0.23748088042149074, 0.2973466821793228, 0.3450692975187467, 0.44850974491569773, 0.22480393980592595, 0.2513123206022727, 0.23922614741673764, 0.22926806668339728, 0.22056932772816995, 0.17171060085892276, 0.33538972381508925, 0.31926200127826043, 0.16105677053599754, 0.26449158585387245, 0.19676295256567455, 0.21172588114816293, 0.19822915140271202, 0.19173884402059327, 0.20639815448851118, 0.21562171153951382, 0.22055908377329037, 0.20801362427528625, 0.19592970113137742, 0.22048707870127204, 0.18525158186600554, 0.1894233420274074, 0.23511775618089314, 0.22206060966261265, 0.20315426502734624, 0.1791071172457498, 0.17858739255197054, 0.2213825481967837, 0.1850682052798689, 0.18202659048922576, 0.1504620338960393, 0.17027117535349556, 0.1823115947225844, 0.19327493166730714, 0.162941879760377, 0.21080668901804533, 0.16701741295550454, 0.8363242503191638, 0.16493527433288857, 0.16863541077911381, 0.20553905584048926, 0.20403767711281484, 0.16273429261295036, 0.20699352890763, 0.1628777643747853, 0.2754532575447989, 0.15320499481927585, 0.17559133766982704, 0.18081495485342136, 0.17586708173133025, 0.18135692373850354, 0.23201365629396986, 0.2095945499655093, 0.18251671836785377, 0.176055493761887, 0.19517708786435461, 0.07783946209478854, 0.08626149832867336, 0.08846880920806433, 0.09877817487572993, 0.0909045835909712, 0.07498535669862083, 0.09413053264355875, 0.07060631821912133, 0.0751231924882646]}, "mutation_prompt": null}
{"id": "cadee8cc-4737-44c0-be27-2dcd062cb29e", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Adjusted F for better balance between exploration and exploitation\n        self.CR = 0.9  # High crossover rate for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5  # Increased probability for local search\n        self.global_perturbation_prob = 0.25  # Increased global perturbation probability\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.9 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay for population size\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.9, self.dim)  # Larger variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dual Search Strategy, integrating dynamic population reduction and quantum local search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.27484472054981607, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8714588075131301, 0.8678482895142685, 0.8505858751810087, 0.8353234362116395, 0.8382672468775075, 0.8592125233470861, 0.8784044441265836, 0.8507128813378237, 0.8453845242706599, 0.4348074518341275, 0.2692538533087231, 0.2712712992528957, 0.464941228319937, 0.37515835120059815, 0.38212987320136815, 0.6134623482617705, 0.25378299041305297, 0.47446153759240695, 0.08077941814465484, 0.12898611332329457, 0.15349324041341683, 0.11459639626177431, 0.14038266493184914, 0.13167852495034327, 0.7281353487787234, 0.13835347730669123, 0.15867347722287428, 0.11011641875169376, 0.11195949875631905, 0.11965532301882487, 0.14794491543869603, 0.10812579699281888, 0.15023004423143083, 0.1108778033187191, 0.10063595183373819, 0.11618906869507539, 0.9339619626956898, 0.9030101382334834, 0.8586793489136029, 0.9109055632123007, 0.9288189666589323, 0.911302954963809, 0.9184560060857334, 0.909415494392614, 0.8969189991026844, 0.34871429386261577, 0.539594226701966, 0.42319165401254233, 0.40391929027181006, 0.40753177471267854, 0.3958843976650349, 0.3196821741562772, 0.3717028452986404, 0.33609405889419086, 0.3570581652317657, 0.19942094315435965, 0.20191464678379878, 0.7786028322029273, 0.1693790281247377, 0.18903791083905253, 0.17581963036199755, 0.2257281665133647, 0.39646752363029725, 0.12789778789403194, 0.15349243767105858, 0.1728414583508846, 0.17900480620708437, 0.15819040748194002, 0.16007938229119212, 0.1498742909224191, 0.12716925805132373, 0.22173778711665926, 0.14605215601251054, 0.12494805099274275, 0.135455044524728, 0.14960143421747996, 0.16107889585965351, 0.12271741692828764, 0.17378747512769865, 0.1459547759411205, 0.1664850058368018, 0.01263656994119755, 0.10167880628666626, 0.06708667700685, 0.20973596939478656, 0.005302489521584741, 0.12150109535402898, 0.0003028778457501158, 0.07139288932107879, 0.003261628500078051, 0.09926424775847387, 0.06978696730958656, 0.09137929846438186, 0.03731209549047543, 0.040785184681804254, 0.19291631727584146, 0.09399188239165557, 0.07557939992757201, 0.10707320121072439, 0.03672053830996791, 0.18520055749184994, 0.09863606235667466, 0.07943204144059768, 0.20472526021488457, 0.12312965013373633, 0.1950097138506558, 0.22677084718128937, 0.13673780187078932, 0.09716660016382561, 0.20798372835444134, 0.0957965822727812, 0.18340306000201, 0.04727322531709777, 0.12581394235529864, 0.18526642010602068, 0.05964506647832479, 0.08861295642544142, 0.5860080137687272, 0.5129117330839221, 0.4754850945517751, 0.5052602095992196, 0.4923492358453003, 0.49934108738821337, 0.49693085177238017, 0.5007524337598767, 0.47384091420752994, 0.08065286803389138, 0.13877167342509367, 0.14679692004114497, 0.13648404881578102, 0.11350697175312308, 0.09260207009351795, 0.09938554083741657, 0.10979559629000091, 0.6155122326490212, 0.1374265060731834, 0.16185364983989037, 0.18021208937866995, 0.2725990503254536, 0.16506564308339944, 0.2086247548454414, 0.17069250315338325, 0.21838785465620425, 0.1673371131462985, 0.30126230115848307, 0.4095699905131803, 0.29066726596855674, 0.2827987116261145, 0.39696280382976235, 0.23606660573918226, 0.32944922827726153, 0.34639084871305637, 0.37338848170958894, 0.2381542256508299, 0.3286312669905168, 0.246087565569181, 0.2799964032022334, 0.2242888962131966, 0.24619380076543118, 0.14372021331181672, 0.20876864635683512, 0.26820107092513, 0.19291374529055105, 0.17439761014107102, 0.19070443549432248, 0.18305957185032162, 0.19954434048676617, 0.17411091811118007, 0.2207604005486069, 0.18614246704248705, 0.20460189906034065, 0.18053925450014363, 0.1939113662616151, 0.18371316795439918, 0.18352428347820993, 0.1772957581923874, 0.18306171385822623, 0.1775308646644933, 0.22290588357402308, 0.16721355600910115, 0.1505721208648556, 0.15543174962935646, 0.894118070018956, 0.7979463526388603, 0.18459182686627984, 0.1630724458235916, 0.15827125401894737, 0.12477396007783248, 0.8687774313564447, 0.2937484196194128, 0.16574267558993017, 0.15284179217341554, 0.830949970485448, 0.12234117291114543, 0.10472279378961924, 0.15292795826521888, 0.2072953958049466, 0.11920535773544538, 0.18141597586154845, 0.1941629031204678, 0.1661686237080443, 0.18282431049342818, 0.17885831628140336, 0.20290187023783024, 0.1726429075823107, 0.1901469248016443, 0.1710748016971545, 0.08051585736203248, 0.08576521576605789, 0.0918202282299393, 0.07338659407358405, 0.07403736065571243, 0.08288255914560083, 0.07922192231569392, 0.08209865790315307, 0.07091467415022867]}, "mutation_prompt": null}
{"id": "f1c8f3c6-f514-4a0c-9e90-1df693c5f7cc", "solution": "import numpy as np\n\nclass HybridQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 10 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.5\n        self.global_perturbation_prob = 0.15\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return 0.8 - 0.3 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adaptive_F(self, generation_count):\n        return 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.1)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.7, self.dim)\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "HybridQuantumEvolution", "description": "Hybrid Quantum Evolutionary Algorithm with Adaptive Parameters blends differential evolution dynamics with quantum-inspired perturbations and adaptive parameter adjustments for improved convergence.", "configspace": "", "generation": 98, "fitness": 0.2847582586315007, "feedback": "The algorithm HybridQuantumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8691264491916605, 0.8600351437498059, 0.8525341714748969, 0.8700749550298623, 0.8587279088523347, 0.859271055516571, 0.8803859364435761, 0.8527441895694767, 0.8412593978038407, 0.7476543031787649, 0.3825738767927189, 0.7183188466102486, 0.482117448867474, 0.5532750144518814, 0.5610335821491415, 0.47275893291198656, 0.5643789168640103, 0.5724144637679429, 0.1560013524642041, 0.15422688799108475, 0.12716528727228416, 0.7409917794311427, 0.15273987821257629, 0.1364488401667231, 0.1202869945108268, 0.15616856926920641, 0.13160830155901748, 0.15138056168966707, 0.13651697465387713, 0.08049018611948888, 0.0961194649147703, 0.08980480235975263, 0.12448668792151041, 0.1441491912735453, 0.17289052946958605, 0.11621965947371315, 0.9187888606880356, 0.9011051574665296, 0.8875472405818833, 0.9190743378534273, 0.9163432939147158, 0.9240971423506977, 0.9034869125225586, 0.9142982972497762, 0.9054922060961053, 0.4603846292086651, 0.46290111081043284, 0.4133448550905964, 0.4208812435730477, 0.32739770926032685, 0.41612011427502993, 0.38136888217252707, 0.4126597825576612, 0.3276234344576552, 0.22073151308653838, 0.1361823550878567, 0.6521977504557634, 0.2488688018761399, 0.6927380095003794, 0.33052242169027446, 0.16447063917779525, 0.21813320308410467, 0.2500105983828419, 0.10882012514657413, 0.12230650833757684, 0.1500946266582709, 0.14755030479868514, 0.14148522996448953, 0.12241187948069288, 0.1413652708652957, 0.15180258704626737, 0.1940684623564256, 0.1079645386462027, 0.1917533474650206, 0.15077770758911302, 0.24988137963536816, 0.27192175657018547, 0.15012837424926018, 0.16744006647979093, 0.1297051902310754, 0.17987626323545114, 0.03208681501279176, 9.999999999998899e-05, 0.07748159418655665, 0.18137851446470044, 0.037175819403604926, 0.029360297100390564, 0.017026864499232186, 0.005850713837956434, 0.038593899234071416, 0.046341151098488575, 0.056631637745202856, 0.041228779550858796, 0.08055741645963443, 0.0963439742893406, 0.019796876947353437, 0.22506080554202668, 0.11640425619367578, 0.13164328669277126, 0.22557050970722836, 0.03610101775348462, 0.1940437313419593, 0.10388876762222099, 0.08079071815584116, 0.1349119772439552, 0.11553295739624314, 0.1558143324743334, 0.19651655632876175, 0.10089829590803567, 0.07731347844615943, 0.02432935620399479, 0.1331441996462126, 0.20561763576623449, 0.20691649218667585, 0.1740997522892912, 0.16626270786774933, 0.14469612593448655, 0.5406649968103892, 0.4789500232501075, 0.500602947099531, 0.45972456238994863, 0.4554305378977993, 0.4724734165461294, 0.4969530520839568, 0.5013925377311509, 0.5082395350375417, 0.10582487771346782, 0.10116889029343967, 0.12038041842176739, 0.11407233638469427, 0.11380783948726436, 0.14564735958285713, 0.1349177987583049, 0.13196166800093145, 0.08891802541697891, 0.12011141291871263, 0.14313910118513717, 0.15914559374984127, 0.12558311751643392, 0.1354963708473137, 0.1685546136605135, 0.2852256503494678, 0.1741801633164809, 0.1534015895472225, 0.366791636047501, 0.39212857969357207, 0.2892350756305686, 0.31519902361996344, 0.2366285057887303, 0.25742469002392276, 0.2741547651467223, 0.32088293697767456, 0.30566081107044474, 0.23752844962906416, 0.30035622169268217, 0.22898627364574775, 0.18439402386169623, 0.24716848958520954, 0.23243587019931655, 0.2079006952381124, 0.19801788007273236, 0.2904004833115197, 0.19480250808438737, 0.17436447969210445, 0.17917845743158, 0.1746200083818641, 0.19889012566399644, 0.19692449284767577, 0.20365072819548136, 0.19709324945576345, 0.18654679274632324, 0.20824814573225126, 0.1781465276916384, 0.441372404705058, 0.20681203380793878, 0.17565774979242155, 0.18226833877583826, 0.2182457009325417, 0.19340958847387069, 0.21187574028771683, 0.15017724112573883, 0.18153822799975616, 0.18050844509028485, 0.8189860888952374, 0.7587493669127164, 0.16341134669915813, 0.18367254657723275, 0.15500720993615869, 0.8427189347517177, 0.3571589394673391, 0.47910994901313875, 0.34585660547554675, 0.1966282601154581, 0.6786514763100582, 0.15961571191138524, 0.14975559356741674, 0.5990936642278022, 0.09277822499861088, 0.1937378493587264, 0.18048311444213538, 0.17593616933502254, 0.18414552236580883, 0.18051449148749665, 0.188198827136705, 0.17141455937084193, 0.17608988119862168, 0.1783174712413591, 0.07284360815315771, 0.08184830813829302, 0.08703073768761183, 0.09128444719530215, 0.08434303646687746, 0.07245751220511498, 0.08451519717796108, 0.07759148024434104, 0.08822792045519878]}, "mutation_prompt": null}
{"id": "e4357a8a-ce4b-449d-b3d1-a57ccfd6f5af", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size_initial = 8 * dim\n        self.pop_size = self.pop_size_initial\n        self.F = 0.7  # Slightly reduced scaling factor for better balance\n        self.CR = 0.85  # Minor adjustment for crossover rate to maintain diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.pop_size_initial, dim))\n        self.local_search_prob = 0.45  # Increased local search probability for more refinement\n        self.global_perturbation_prob = 0.15  # Reduced probability to maintain individual integrity\n\n    def _mutate(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(self.population[a] + self.F * (self.population[b] - self.population[c]), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _adaptive_CR(self, generation_count):\n        return max(0.7, 0.85 - 0.3 * (generation_count / (self.budget / self.pop_size_initial)))\n\n    def _adaptive_F(self, generation_count):\n        return min(0.9, 0.5 + 0.4 * (generation_count / (self.budget / self.pop_size_initial)))\n\n    def _adjust_population_size(self, generation_count):\n        decay_factor = 0.9  # Faster decay to increase selection pressure over generations\n        self.pop_size = int(max(5, self.pop_size_initial * decay_factor ** generation_count))\n\n    def _quantum_local_search(self, individual):\n        perturbation = np.random.uniform(-0.2, 0.2, self.dim) * np.random.normal(0, 0.15)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def _global_perturbation(self, individual):\n        if np.random.rand() < self.global_perturbation_prob:\n            perturbation = np.random.normal(0, 0.6, self.dim)  # Reduced variance for perturbation\n            return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_sol = None\n        best_val = float('inf')\n        \n        generation_count = 0\n\n        while eval_count < self.budget:\n            self._adjust_population_size(generation_count)\n            new_population = np.copy(self.population[:self.pop_size])\n\n            for i in range(self.pop_size):\n                self.F = self._adaptive_F(generation_count)\n                self.CR = self._adaptive_CR(generation_count)\n\n                mutant = self._mutate(i)\n                trial = self._crossover(self.population[i], mutant)\n                \n                if np.random.rand() < self.local_search_prob:\n                    trial = self._quantum_local_search(trial)\n\n                trial = self._global_perturbation(trial)\n                \n                trial_val = func(trial)\n                eval_count += 1\n\n                if trial_val < func(self.population[i]):\n                    new_population[i] = trial\n                    if trial_val < best_val:\n                        best_val = trial_val\n                        best_sol = trial\n\n                if eval_count >= self.budget:\n                    break\n            \n            self.population[:self.pop_size] = new_population\n            generation_count += 1\n\n        return best_sol", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Perturbation and Dynamic Selection Pressure Adjustment for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 99, "fitness": 0.26812341009070134, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "84e177f1-1b3a-4e87-98e1-97c774d4caba", "metadata": {"aucs": [0.8688628858273824, 0.8861076681152252, 0.8847443335828638, 0.8596073107967992, 0.8505862543668649, 0.881509076862422, 0.8474583095997015, 0.8756410351270443, 0.8251212949180493, 0.0922910221053369, 0.28686225501841867, 0.6273273803697056, 0.4885446461515396, 0.24521337381473485, 0.09891058386490281, 0.3877595786378598, 0.25774219246676267, 0.08507464438223744, 0.10901536729967776, 0.10301671726385098, 0.1290617462966822, 0.11558972015303715, 0.1840432112053556, 0.10305980058090003, 0.12094194601779329, 0.09547512800970204, 0.1843531271629344, 0.10602703497911858, 0.10616045223218629, 0.09799806733218752, 0.08128237423955853, 0.09067656077933517, 0.09294447126728267, 0.07453109353222065, 0.08369218812672297, 0.15259579223153286, 0.9153276143578504, 0.9265213859445134, 0.9120787328153958, 0.8586255269475975, 0.9177409372578729, 0.8955658521763308, 0.9334233279199289, 0.899786237107808, 0.9192538896072159, 0.5269683408056314, 0.6139901796402669, 0.40487576145072934, 0.4930926065728817, 0.5753209648214503, 0.5470428220264059, 0.45698395426461724, 0.4638589921224969, 0.47473137165131996, 0.2991108420040717, 0.19114593297354632, 0.15933819462814813, 0.37417839512275375, 0.20866944726387615, 0.376255236455049, 0.23015283745992676, 0.2096795336309245, 0.19687502648445887, 0.2949419873007231, 0.22254531208602846, 0.23125460753460803, 0.17941653846908934, 0.1770146031334522, 0.12698103777859482, 0.18064939676535974, 0.26393790851492493, 0.12867775465827636, 0.19976766933644885, 0.16721124821151023, 0.1432020108464208, 0.12799719995049486, 0.13502680171146275, 0.20570877027130885, 0.20577372056592214, 0.1835572745204911, 0.18022188065579414, 0.027015972030599356, 0.11564391578342093, 9.999999999998899e-05, 0.0033103592776422275, 9.999999999998899e-05, 0.004335263164382708, 0.03348446460770682, 0.06866524200513102, 0.09807297608296517, 0.13529676603189056, 0.14106088877115286, 0.1186494742420473, 0.09274517934548054, 0.042628325724568095, 0.03718097382935226, 0.18048932074583768, 0.07761921056996712, 0.13881778372678433, 0.1642159906672176, 0.19345243532503642, 0.33463398726051674, 0.33509203951269273, 0.16997564962699452, 0.10290205997555113, 0.15675538323863347, 0.098160730239638, 0.1911076348825942, 0.17515933948577855, 0.12569452392359215, 0.16531764848716046, 0.2334486333718373, 0.06270244937218572, 0.10554082777808904, 0.07757747622912048, 0.19702750189466023, 0.08388113488059812, 0.5546407189449173, 0.5062154944590469, 0.5225908592928494, 0.5261314254408759, 0.5249590451995957, 0.5364202283410404, 0.5149622896652024, 0.5418092987226696, 0.4922597566545651, 0.13880206818695573, 0.08484288581981803, 0.1365435574310533, 0.14162524517969555, 0.09031147569216513, 0.07793700312532614, 0.1398947885948446, 0.12187283866044485, 0.12839476138477202, 0.2157236199397381, 0.23602559011728808, 0.1954061409420279, 0.16904027524950505, 0.14794715757681765, 0.16343115671352737, 0.3525837621579879, 0.20815619299872956, 0.14889179401999375, 0.2396219615964128, 0.24269964933608779, 0.31312593440741465, 0.2827041531726412, 0.24161344581565514, 0.27097162930034513, 0.2613488591217581, 0.3596640101598768, 0.3426213278892808, 0.24213486733343426, 0.17020427198468513, 0.3110812277478592, 0.20314256441630163, 0.2591853520009342, 0.20854486640280578, 0.14265747857310052, 0.30837559848395735, 0.19722444596487276, 0.19728414876541256, 0.21042874795506628, 0.17013499780058805, 0.20250053110577393, 0.18665375669596673, 0.23319620054326384, 0.18499449143442848, 0.20476796735872393, 0.17865953898010734, 0.1823896894585454, 0.20191751869961316, 0.17949114958634016, 0.1858810656088783, 0.1922605138749679, 0.17523695218286572, 0.1822544542702852, 0.1874555742136128, 0.17127712594383626, 0.1500473177294953, 0.16966640465520522, 0.19415190633158041, 0.16615295286127363, 0.18470795839907184, 0.8022129476608956, 0.1676407387142952, 0.14064051252366605, 0.16763585083415944, 0.7172863167290706, 0.1950880784667316, 0.2059000559882347, 0.5654573115990259, 0.11063209798281293, 0.14455439778930634, 0.6169463421396104, 0.1396603437924725, 0.10251181048608704, 0.1907555375145673, 0.17269340970716562, 0.1720758606726811, 0.17609743387120036, 0.17716946783016518, 0.1826698381060592, 0.19633098053329612, 0.19132900115521767, 0.1835741911729163, 0.071196474274281, 0.07798679086937066, 0.07521580083447821, 0.09105016591704718, 0.07716796709544793, 0.0640972324884187, 0.08215080163825728, 0.07021994747825433, 0.07868696241978668]}, "mutation_prompt": null}
