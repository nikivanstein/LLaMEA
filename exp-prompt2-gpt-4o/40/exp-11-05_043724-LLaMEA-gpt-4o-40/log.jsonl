{"id": "e1b0271c-b9fa-4efd-b62c-1e67b7f3aab7", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = self.global_best_position[:crossover_point]\n\n        return self.global_best_score", "name": "AdaptiveParticleSwarm", "description": "Adaptive Dual-Space Particle Swarm Optimization with Dynamic Inertia and Crossover for efficient exploration and exploitation in diverse problem landscapes.", "configspace": "", "generation": 0, "fitness": 0.19416424915254005, "feedback": "The algorithm AdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.5233014690855858, 0.5600224319035425, 0.5442330082383298, 0.496659970775448, 0.18239101121579837, 0.1860947988684043, 0.5487213926454697, 0.5793150559766809, 0.14908218572179266, 9.999999999998899e-05, 9.999999999998899e-05, 0.027509857370621504, 9.999999999998899e-05, 0.2905171397654349, 9.999999999998899e-05, 9.999999999998899e-05, 0.038196286794791035, 0.0327440959818498, 0.06205021602958427, 0.11940358208982749, 0.2218534513873267, 0.12120544320339321, 0.06597247004537654, 0.10509148527613055, 0.11462704043390426, 0.12203763817797775, 0.28796098413182225, 0.1060584385783151, 0.09976980140301972, 0.09580929996983123, 0.1333656284778021, 0.09048873208182218, 0.09223161670972202, 0.09462506176319097, 0.09825139268231087, 0.09257763087295334, 0.9942154866928717, 0.9908390381102207, 0.9942892776161362, 0.9928082789748238, 0.9931955050072623, 0.9913967496736169, 0.9944188878591407, 0.9938314782668671, 0.9936703294060389, 0.39679555227029073, 0.21439839745042322, 0.0590206539420306, 0.3130409025634596, 0.13318506407972286, 0.13999386508356804, 0.08165482316187922, 0.2998831750345433, 0.050103010067339304, 0.21027641413346287, 0.05982697130558556, 0.1666202840697728, 0.18835516894571858, 0.17191946828432214, 0.11038462244797598, 0.11835214277246109, 0.18673812211441088, 0.22894282138392164, 0.074918733469861, 0.14020828345915815, 0.07191951763228299, 0.12488745939692092, 0.11806386426462323, 9.999999999998899e-05, 0.1196722817493302, 0.13971365145358272, 0.12798375389900152, 0.11737396745237316, 0.022359710893012585, 0.01660963140650762, 0.18081035703510362, 0.09071192661280691, 0.09102334731805839, 0.1576121827791982, 0.031409762664576735, 0.06490574367382052, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018747510235039844, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04297833123830819, 0.016098278434293345, 0.014749757654736406, 0.0662611015278518, 0.005141458015646139, 0.0016455256546350494, 0.10231528164855608, 0.03190014468880675, 0.03242394217356448, 9.999999999998899e-05, 9.999999999998899e-05, 0.025658987824398682, 9.999999999998899e-05, 0.03804071783232321, 0.033198348370271025, 0.04983362366256372, 0.055268709935038296, 0.05026367840942181, 0.13744939625588815, 9.999999999998899e-05, 0.08311261758518429, 0.004063080049335088, 0.004393727739774644, 0.004017631199045191, 0.042403228600470855, 0.03975122252306884, 0.06283560610453132, 0.3825606265902727, 0.3906198746545254, 0.388614309390375, 0.1983953388244749, 0.4459512015050323, 0.20535128442273853, 0.4318313740125944, 0.41951945858815565, 0.43021171892627863, 0.0733851376472816, 0.07315663323360455, 0.05081469557097773, 0.07024059044212538, 0.08280042240711605, 0.19785675025965133, 0.14890131381453853, 0.07027878732179382, 0.09775923157393895, 0.1483949488802151, 0.12774302681100946, 0.1466205679096031, 0.34139356180744196, 0.29367993371476, 0.21160395765704565, 0.2001572677201361, 0.2683148979435618, 0.19645700607593286, 0.2731728851721379, 0.23215628658269505, 0.22813695025138236, 0.2200184116649806, 0.1847155868316448, 0.24324567667448604, 0.19428866438446968, 0.33269667077514775, 0.3428675619359769, 0.17416305167060853, 0.20596776786232918, 0.1282915106498429, 0.19423068135177957, 0.18768102313470636, 0.1759402008643185, 0.13104917078095768, 0.1734739206616721, 0.14405035308351577, 0.21656629651236703, 0.1432080249193719, 0.17523186553953674, 0.1672177056782328, 0.18700763344975013, 0.18151243414370077, 0.1846958497051453, 0.17387147961175575, 0.18077312959695224, 0.1900798938898952, 0.32834207470755694, 0.2728199756484201, 0.2074305934526708, 0.18073977009843367, 0.18429811057748202, 0.17412105187187532, 0.2032277233380878, 0.4415132670545162, 0.651397968345735, 0.1649349975207569, 0.15250444923645678, 0.6502998895641364, 0.6389234909772972, 0.1926120915691557, 0.09790757880831757, 0.1685918640910271, 0.14834220539554466, 0.3778019742812717, 0.1558412793247278, 0.16174663335907813, 0.3121113127049251, 0.20533441416834752, 0.20617773754336732, 0.19486639016896834, 0.20467627701411495, 0.18499229599749334, 0.19771159110319225, 0.1933321194842832, 0.20752329869046449, 0.17963340672310768, 0.2156142825378271, 0.19714087728616592, 0.2082279986814134, 0.19840334025932327, 0.17996409232116672, 0.07135821432026801, 0.0710441697128874, 0.07100139286309715, 0.08311320136857081, 0.0683646137741889, 0.07497414978411687, 0.07074154291008872, 0.062493259853113714, 0.08205508760486535]}, "mutation_prompt": null}
{"id": "09274cc8-9b93-482c-ae3b-815c0ea85474", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = self.global_best_position[:crossover_point]\n\n        return self.global_best_score", "name": "AdaptiveParticleSwarm", "description": "Adaptive Dual-Space Particle Swarm Optimization with Dynamic Inertia and Crossover for efficient exploration and exploitation in diverse problem landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e1b0271c-b9fa-4efd-b62c-1e67b7f3aab7", "metadata": {"aucs": [0.5233014690855858, 0.5600224319035425, 0.5442330082383298, 0.496659970775448, 0.18239101121579837, 0.1860947988684043, 0.5487213926454697, 0.5793150559766809, 0.14908218572179266, 9.999999999998899e-05, 9.999999999998899e-05, 0.027509857370621504, 9.999999999998899e-05, 0.2905171397654349, 9.999999999998899e-05, 9.999999999998899e-05, 0.038196286794791035, 0.0327440959818498, 0.06205021602958427, 0.11940358208982749, 0.2218534513873267, 0.12120544320339321, 0.06597247004537654, 0.10509148527613055, 0.11462704043390426, 0.12203763817797775, 0.28796098413182225, 0.1060584385783151, 0.09976980140301972, 0.09580929996983123, 0.1333656284778021, 0.09048873208182218, 0.09223161670972202, 0.09462506176319097, 0.09825139268231087, 0.09257763087295334, 0.9942154866928717, 0.9908390381102207, 0.9942892776161362, 0.9928082789748238, 0.9931955050072623, 0.9913967496736169, 0.9944188878591407, 0.9938314782668671, 0.9936703294060389, 0.39679555227029073, 0.21439839745042322, 0.0590206539420306, 0.3130409025634596, 0.13318506407972286, 0.13999386508356804, 0.08165482316187922, 0.2998831750345433, 0.050103010067339304, 0.21027641413346287, 0.05982697130558556, 0.1666202840697728, 0.18835516894571858, 0.17191946828432214, 0.11038462244797598, 0.11835214277246109, 0.18673812211441088, 0.22894282138392164, 0.074918733469861, 0.14020828345915815, 0.07191951763228299, 0.12488745939692092, 0.11806386426462323, 9.999999999998899e-05, 0.1196722817493302, 0.13971365145358272, 0.12798375389900152, 0.11737396745237316, 0.022359710893012585, 0.01660963140650762, 0.18081035703510362, 0.09071192661280691, 0.09102334731805839, 0.1576121827791982, 0.031409762664576735, 0.06490574367382052, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018747510235039844, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04297833123830819, 0.016098278434293345, 0.014749757654736406, 0.0662611015278518, 0.005141458015646139, 0.0016455256546350494, 0.10231528164855608, 0.03190014468880675, 0.03242394217356448, 9.999999999998899e-05, 9.999999999998899e-05, 0.025658987824398682, 9.999999999998899e-05, 0.03804071783232321, 0.033198348370271025, 0.04983362366256372, 0.055268709935038296, 0.05026367840942181, 0.13744939625588815, 9.999999999998899e-05, 0.08311261758518429, 0.004063080049335088, 0.004393727739774644, 0.004017631199045191, 0.042403228600470855, 0.03975122252306884, 0.06283560610453132, 0.3825606265902727, 0.3906198746545254, 0.388614309390375, 0.1983953388244749, 0.4459512015050323, 0.20535128442273853, 0.4318313740125944, 0.41951945858815565, 0.43021171892627863, 0.0733851376472816, 0.07315663323360455, 0.05081469557097773, 0.07024059044212538, 0.08280042240711605, 0.19785675025965133, 0.14890131381453853, 0.07027878732179382, 0.09775923157393895, 0.1483949488802151, 0.12774302681100946, 0.1466205679096031, 0.34139356180744196, 0.29367993371476, 0.21160395765704565, 0.2001572677201361, 0.2683148979435618, 0.19645700607593286, 0.2731728851721379, 0.23215628658269505, 0.22813695025138236, 0.2200184116649806, 0.1847155868316448, 0.24324567667448604, 0.19428866438446968, 0.33269667077514775, 0.3428675619359769, 0.17416305167060853, 0.20596776786232918, 0.1282915106498429, 0.19423068135177957, 0.18768102313470636, 0.1759402008643185, 0.13104917078095768, 0.1734739206616721, 0.14405035308351577, 0.21656629651236703, 0.1432080249193719, 0.17523186553953674, 0.1672177056782328, 0.18700763344975013, 0.18151243414370077, 0.1846958497051453, 0.17387147961175575, 0.18077312959695224, 0.1900798938898952, 0.32834207470755694, 0.2728199756484201, 0.2074305934526708, 0.18073977009843367, 0.18429811057748202, 0.17412105187187532, 0.2032277233380878, 0.4415132670545162, 0.651397968345735, 0.1649349975207569, 0.15250444923645678, 0.6502998895641364, 0.6389234909772972, 0.1926120915691557, 0.09790757880831757, 0.1685918640910271, 0.14834220539554466, 0.3778019742812717, 0.1558412793247278, 0.16174663335907813, 0.3121113127049251, 0.20533441416834752, 0.20617773754336732, 0.19486639016896834, 0.20467627701411495, 0.18499229599749334, 0.19771159110319225, 0.1933321194842832, 0.20752329869046449, 0.17963340672310768, 0.2156142825378271, 0.19714087728616592, 0.2082279986814134, 0.19840334025932327, 0.17996409232116672, 0.07135821432026801, 0.0710441697128874, 0.07100139286309715, 0.08311320136857081, 0.0683646137741889, 0.07497414978411687, 0.07074154291008872, 0.062493259853113714, 0.08205508760486535]}, "mutation_prompt": null}
{"id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 2, "fitness": 0.20832992230956646, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.23.", "error": "", "parent_id": "e1b0271c-b9fa-4efd-b62c-1e67b7f3aab7", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "f3576afc-34ce-4aee-aec7-38cfbe8ad916", "solution": "import numpy as np\n\nclass EnhancedLearningParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for better exploration\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.3\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 1.5  # Adjusted for better balance\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.cos(10 * np.pi * iteration / self.budget)  # Changed function for diversity\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget)) ** 2  # Non-linear scaling\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.6:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedLearningParticleSwarm", "description": "Enhanced Particle Swarm Optimization using an adaptive learning strategy with non-linear dynamic inertia and enhanced exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.147777118120878, "feedback": "The algorithm EnhancedLearningParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.25933316118629113, 0.3123041132819021, 0.31865633164602025, 0.17667601379309394, 0.35046573481464793, 0.1612740614553413, 0.27980729204700805, 0.25379926529294705, 0.34407961637669027, 0.003707122215915293, 9.999999999998899e-05, 0.027259883056452106, 9.999999999998899e-05, 0.0055203201411244684, 9.999999999998899e-05, 9.999999999998899e-05, 0.026525784823362875, 0.005744051554753216, 0.05405566242529947, 0.04435381238419411, 0.06854925645111765, 0.059270877340542705, 0.049930661951117505, 0.056164983937643576, 0.07638590368008868, 0.04376008876371884, 0.07676636459223496, 0.06739434371650055, 0.04237534407303212, 0.07064211747413263, 0.07318577421981298, 0.035505352762711495, 0.0642711500179377, 0.046484337123707364, 0.07305958891110653, 0.0781055105638434, 0.9926861534491807, 0.9945351520719253, 0.9940646040244875, 0.9678518121538101, 0.9911882732427899, 0.9886319869381751, 0.9916603475580096, 0.9913960495465992, 0.9915399738964359, 0.05321001834155015, 0.04800824100679457, 0.06725289900689024, 0.11170980267736308, 0.1217798958120635, 0.1354045387643752, 0.08087927774798975, 0.0846273131127171, 0.07993100762453631, 0.1700940690393672, 0.1336743434802905, 0.16715874086503557, 0.22715129983149873, 0.17137549271346275, 0.15762861241060366, 0.06275247482751223, 0.13011778496826587, 0.1181647223540655, 0.054639960831867396, 0.0721390214416926, 0.08510097405636696, 0.07361042656477568, 0.052751740966516136, 0.055823968491235054, 0.05752605548191769, 0.04638727866163572, 0.07544509089562212, 0.06491918609843361, 0.010014167428375353, 0.06974331810546341, 0.0945841146176577, 0.038288897920704, 0.06871556463087947, 0.06772495349761443, 9.999999999998899e-05, 0.0500156331022692, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002610311677467725, 0.00016973042594103926, 9.999999999998899e-05, 0.03367246465502394, 0.03663806688217042, 0.02191425223400023, 0.007459330415951593, 9.999999999998899e-05, 0.00024723110623925404, 0.0390049158970347, 0.039722065151048036, 0.041887743723470705, 0.0012557468352153434, 9.999999999998899e-05, 0.0012140896080607977, 0.007747491372624982, 9.999999999998899e-05, 0.019242193785951933, 0.0041458829966455335, 9.999999999998899e-05, 0.004613754029468731, 0.026839986726933107, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006607540957711544, 0.0018645103615834158, 0.034160967999278036, 0.07026537553348211, 0.03478855920358437, 0.28852967389177775, 0.2814345272825427, 0.31484836568196184, 0.20023055694117242, 0.2810054005335477, 0.1961398523450012, 0.31973265162690223, 0.31732128339699595, 0.2807300131009317, 0.04728930688309341, 0.04778694035876074, 0.05115148979113837, 0.06459623539012804, 0.06840286960726338, 0.06995981870952095, 0.043628387828664406, 0.0641052192666215, 0.05746959509372085, 0.15495236206114438, 0.20428233241859928, 0.150217043944473, 0.15337345703567717, 0.16416910905464155, 0.1427441960384953, 0.18701505500075333, 0.19674375018845203, 0.15228156911429647, 0.19552752938085438, 0.16528820585069692, 0.22960957409563132, 0.20038953737844944, 0.1659918200421625, 0.19307234234117765, 0.21400907499843513, 0.21246446602323144, 0.2009731440981476, 0.12472246680569987, 0.16809536843889983, 0.1607729065227772, 0.11931494536722786, 0.11216643956774075, 0.1563407014261109, 0.15881825178856124, 0.17453453536200236, 0.12561850275473319, 0.1547143330813724, 0.13006704966973792, 0.1728044300387519, 0.15568687554136817, 0.15750836222858344, 0.18092940333531327, 0.1769783141680178, 0.17035303368208765, 0.16882978599909748, 0.1775828107422459, 0.1597454354030533, 0.16090437731024432, 0.17035301585243834, 0.21783680496821445, 0.17408072540789343, 0.17151549179379622, 0.1280398347815842, 0.1805932885693261, 0.15848758496362247, 0.17936732485396134, 0.11284905434543746, 0.1589124276900291, 0.18487879694846687, 0.18923868505813612, 0.10426028009566402, 0.15616582012240887, 0.16390402391975878, 0.1609078002763914, 0.16743307051529355, 0.15041622644314068, 0.17219165155844696, 0.20435776388210403, 0.10814826167079206, 0.19203174446654825, 0.18713315110341866, 0.18934685444866262, 0.18439715713147775, 0.19684864934886304, 0.1967003105383034, 0.19288799103694432, 0.1787810368868662, 0.20515030607407048, 0.18982851463395478, 0.18256590496653935, 0.18721096402609605, 0.05318212519003407, 0.05498372610388591, 0.06888202459722781, 0.07009118175249407, 0.061524530166356284, 0.059740348667918775, 0.0792870693410831, 0.0652153869985348, 0.06683096983470527]}, "mutation_prompt": null}
{"id": "17c2f505-47b3-4f0a-9263-732cf2a5e074", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        F = 0.5  # Differential evolution mutation factor\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n\n                # Differential Evolution mutation\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = self.positions[a] + F * (self.positions[b] - self.positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < CR else self.positions[i][j] for j in range(self.dim)])\n                \n                self.velocities[i] = (inertia_weight * self.velocities[i] + \n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Apply crossover\n                self.positions[i] = crossover_vector\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "An improved adaptive particle swarm optimization incorporating chaotic maps and differential evolution mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.08176528455076372, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.08.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.13101826518704385, 0.13109703128492678, 0.13181411035834967, 0.17265297895101628, 0.16527571164552068, 0.1304206973727987, 0.16235434512342906, 0.12121633422605627, 0.13470307804345427, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02663625751579546, 0.036660598628439955, 0.029929369893682445, 0.026882937750653535, 0.020986598534872947, 0.04251850053738149, 0.03304273729612195, 0.035495328703016304, 0.02974047241698574, 0.014573187400192311, 0.02513647659496332, 0.01395349023137693, 0.021392314367498333, 0.0335685958773716, 0.02699401313636296, 0.014460740585415577, 0.01437476029304885, 0.02132728394340777, 0.10482727429474248, 0.1095688838706721, 0.10031252663088475, 0.11721644021198285, 0.4735910575354867, 0.572429255425712, 0.1970105149875645, 0.13498865262268522, 0.16088495932743463, 0.03285324981912685, 0.038751602485638026, 0.07404087470533671, 0.025130212056087342, 0.06720593763060168, 0.05108495284609105, 0.05969356672282644, 0.06503999244996028, 0.044733695149488995, 0.15026978346681896, 0.13071650206593077, 0.13698060095006437, 0.05316672947893697, 0.08474359631090189, 0.13009792985103108, 0.07800080283106037, 0.09748204063516519, 0.10791117019095087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025295346215301606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017243160534597513, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043023156854084976, 0.03215809356758459, 0.028356150799935143, 0.038485176453179504, 0.04509219750198468, 0.03575862357510051, 0.04761093761520496, 0.027130579454029413, 0.049803658193658173, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011417364386338003, 0.005673862477702962, 9.999999999998899e-05, 0.16243454113859024, 0.15429649640615517, 0.15821424757152436, 0.16800220292530643, 0.18381298847482475, 0.17495184078097703, 0.1626726297657729, 0.2156280259517126, 0.1905836052769485, 0.042758040206281156, 0.0329191876266417, 0.048853003468509404, 0.035370724105379114, 0.052458949206298566, 0.05830997579609176, 0.035956518347340705, 0.03449317506267602, 0.026875352977988598, 0.12693539601608805, 0.16744711925546285, 0.13145603918140747, 0.1393454325341289, 0.1303953336782946, 0.1394118731925752, 0.1340299978694306, 0.13276279371716082, 0.13562711122113158, 0.15451679524579065, 0.15642835640907438, 0.15166931410020557, 0.17699948229361107, 0.16030423553198214, 0.1448068052306013, 0.13987813221468004, 0.17377774300845283, 0.14067347848726508, 0.10176622541416058, 0.09961952962404175, 0.08532888194226673, 0.14056212950069125, 0.09694207827418289, 0.07609125945312079, 0.07773909741425633, 0.10613057203856047, 0.08693542486516614, 0.12647208227996543, 0.15217486258888824, 0.14378464447106032, 0.13763615494905657, 0.13666740787956844, 0.13324388919809094, 0.12794395214072596, 0.13873368278160725, 0.13465433390992299, 0.04556535668452766, 0.10061817580885657, 0.07666836288522938, 9.999999999998899e-05, 0.0573929316278432, 0.10765855212868813, 0.1559083210022152, 0.1073577152211459, 0.059980342651305585, 0.16071708924307115, 0.14160837839276486, 0.16963286303385916, 0.12502197368555934, 0.161850117087197, 0.13375586408401796, 0.13559934281761177, 0.15648467467623106, 0.19873471180040314, 0.13142478905623445, 0.0996906224343731, 0.11587316430137706, 0.12892799426428014, 0.20211969151372877, 0.09621409112087564, 0.13052258128311556, 0.20693849893641902, 0.1584669455311709, 0.17632887205035552, 0.20187845309640984, 0.18885292806456433, 0.18068484583523337, 0.1885580691340939, 0.19002574221941526, 0.18322226272308395, 0.21277931575719866, 0.1761069032182535, 0.04699090111923143, 0.036728507887688666, 0.03907526349601487, 0.035933699835652755, 0.04970652064786063, 0.04153956519015778, 0.048263514300145305, 0.05493184261953954, 0.04141206295667288]}, "mutation_prompt": null}
{"id": "41583f3f-da95-48f0-9454-9df05128814a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "b3ce9aa6-96f7-4b59-9bc9-fd86a30d10e9", "solution": "import numpy as np\n\nclass QuantumAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def quantum_rotation_gate(self, position, global_best, iteration):\n        rotation_factor = np.sin(iteration / self.budget * np.pi)\n        return position * np.cos(rotation_factor) + global_best * np.sin(rotation_factor)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n                \n                # Apply quantum-inspired rotation gate\n                self.positions[i] = self.quantum_rotation_gate(self.positions[i], self.global_best_position, self.evaluations)\n\n        return self.global_best_score", "name": "QuantumAdaptiveParticleSwarm", "description": "Quantum-inspired Adaptive Particle Swarm Optimization using quantum superposition and rotation gates for enhanced exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.11694075744312862, "feedback": "The algorithm QuantumAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.14259129527125347, 0.15514529269575705, 0.157721859894419, 0.20487142691570903, 0.16848305705155653, 0.17391497762463493, 0.20065481610429214, 0.18082230454881132, 0.16122909857817846, 0.00012327530522593388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001149065724912579, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044803266874566705, 0.058376348453486604, 0.03675060916003936, 0.038491468068045265, 0.03838523619380574, 0.029296353828711874, 0.03975153609517523, 0.03663114434601178, 0.04118620373340742, 0.05868857572831998, 0.025992216292291648, 0.023673209798564132, 0.0362878830257134, 0.041492892819222416, 0.02221799413649661, 0.02442160527520032, 0.023094867798423513, 0.028528525430021046, 0.990950685409357, 0.9897110987352359, 0.9944440040557022, 0.9935456622368599, 0.9929023647800547, 0.9908882398751614, 0.9958924714328697, 0.9942002083107868, 0.9943595541195183, 0.06937532713438355, 0.055663206820512845, 0.06176061917981901, 0.06878479546555083, 0.09035207304683612, 0.05167230020413138, 0.04640973090517131, 0.0878270554530638, 0.06618556951666688, 0.15881638063919834, 0.0593130891632232, 0.12240596126394487, 0.07511783860687193, 0.11690410300337828, 0.09155181674176294, 0.11768895876161845, 0.08674348850168867, 0.0909648238120282, 0.005907544808468224, 0.020942217088402493, 0.01430819149937268, 0.007804916959031849, 0.010575785681175343, 0.014256494516323603, 0.018804817280059116, 0.012189678480642563, 0.01823781351984599, 0.0017043868631815284, 0.05283145679943102, 0.01258648412901242, 0.01188800759762676, 0.018559939156442495, 0.043077523691797404, 0.015577635859065464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020551713856309495, 9.999999999998899e-05, 0.02227680292213241, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07543197895853815, 0.00022384860034219134, 0.019372017713131795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003560726980115225, 0.008784356086535494, 0.0015189979897283212, 0.0011410189983794838, 0.003176037093201023, 0.0026294360178995557, 0.00031132333942729407, 0.0006811222247171678, 0.0021081634248879544, 0.18219964731586147, 0.17098726574398682, 0.19200541853972264, 0.1885314196527922, 0.18056588534034468, 0.18089454774540759, 0.1752917010314794, 0.18289391341483685, 0.18208432561614207, 0.041494621034070756, 0.051614033667592985, 0.04400460436803044, 0.03197655079626116, 0.04280041275218305, 0.03473491959497188, 0.03419122434311961, 0.05823361045330733, 0.04260819631035051, 0.1394393813110557, 0.13928637896487073, 0.14302925250733967, 0.17581417296220514, 0.11515021444812301, 0.12284479543390758, 0.1035405603045052, 0.14252376839202785, 0.11890895186538442, 0.16123298225045968, 0.15213339419577265, 0.16485312460698698, 0.1567613041598741, 0.1509916871594018, 0.14920198038541188, 0.1522217877181682, 0.18079736601419794, 0.15545981927083974, 0.08982446686005419, 0.09291399134500355, 0.09479015994180118, 0.09980558005926154, 0.09175258032253841, 0.10851381103974767, 0.11019815047980408, 0.13494092040705075, 0.10901530082224853, 0.14335542021398473, 0.13270451427874064, 0.1438704576197104, 0.13515097423694222, 0.1340252363849055, 0.13743798853520728, 0.16244006982591108, 0.14694023003479417, 0.1388448151179904, 0.11498040701877654, 0.09660527453682022, 0.14763175441666299, 0.1534117757429665, 0.14124582309171096, 0.05694859273593689, 0.06020419770335539, 0.1354051301744521, 0.045747572178729046, 0.18032349186633567, 0.11625130118586535, 0.11812236486543648, 0.1289862871392774, 0.17649047766416193, 0.1428202187264771, 0.09741337782512505, 0.1414339922469222, 0.157638064251298, 0.11844944199004315, 0.11608004288737772, 0.13661805661864712, 0.11201013302217167, 0.12882223505083035, 0.14253838569978128, 0.15907993061612546, 0.15884736773771857, 0.12607124094030864, 0.1700550316214009, 0.16758820039694788, 0.16780962538424593, 0.17926046176737853, 0.16119121533331582, 0.16247274103834408, 0.16301397631612002, 0.18608942478497847, 0.162257151161058, 0.04340269574935829, 0.03430560795724136, 0.06816551848339913, 0.03856754186038147, 0.04633384019208753, 0.03540428290002451, 0.04166301765711811, 0.0441689324780864, 0.03932589970352163]}, "mutation_prompt": null}
{"id": "aedbb12f-12ef-4b88-bb10-03fc355c83a9", "solution": "import numpy as np\n\nclass EnhancedLevyParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, L):\n        sigma = (np.math.gamma(1 + L) * np.sin(np.pi * L / 2) / \n                 (np.math.gamma((1 + L) / 2) * L * 2 ** ((L - 1) / 2))) ** (1 / L)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / L)\n        return step\n\n    def chaotic_mutation(self, position, chaotic_factor):\n        return position + chaotic_factor * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                levy_step = self.levy_flight(1.5)\n                self.velocities[i] = (inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + levy_step)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform chaotic mutation for diversification\n            if np.random.rand() < 0.1:  # Mutation probability\n                for i in range(self.population_size):\n                    chaotic_factor = np.random.rand()\n                    self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor)\n\n        return self.global_best_score", "name": "EnhancedLevyParticleSwarm", "description": "A Particle Swarm Optimization variant with Lvy flight for enhanced exploration and chaotic mutation for diversification.", "configspace": "", "generation": 7, "fitness": 0.12143643593583732, "feedback": "The algorithm EnhancedLevyParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.20767053868235974, 0.159597427523821, 0.13834412894182968, 0.20414122702752713, 0.18724424375739035, 0.17640392205811095, 0.1614127771910847, 0.18435457967217317, 0.1761889582596965, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045376415921314917, 0.03251805357123683, 0.038468670534867355, 0.039900532044667814, 0.031627835053065434, 0.0473253414870487, 0.03790025008770259, 0.05290209837372606, 0.04340481768839688, 0.021863287677382326, 0.02292354742644398, 0.06332878470736891, 0.02334540161093923, 0.020941386078629165, 0.03569951918073, 0.019880819729675925, 0.01925209004826034, 0.028829597139038543, 0.994133681816129, 0.9941691851676169, 0.992748523425086, 0.9927682033456283, 0.99185449104822, 0.9909828210972146, 0.9951151392038626, 0.9924356067335438, 0.9923529005154652, 0.06052381028201448, 0.06776950925879699, 0.078249184463964, 0.0644854311864006, 0.08114700936745178, 0.09859729159122421, 0.09527974110319515, 0.08116315907494898, 0.07132096923838904, 0.15123738751098226, 0.1319484576766905, 0.11708750931733791, 0.13030583195021717, 0.10670243626874254, 0.11894341215871396, 0.11664605631779468, 0.11073602623570855, 0.12026822286672267, 9.999999999998899e-05, 0.0004419549176236659, 0.007486602684250054, 9.999999999998899e-05, 0.002198885446958232, 9.999999999998899e-05, 0.005398871150089524, 0.011335320520035719, 9.999999999998899e-05, 0.01925381325709763, 0.022306010067439597, 0.015470262364557286, 9.999999999998899e-05, 0.0026167683882364345, 0.0002816578159352545, 9.999999999998899e-05, 9.999999999998899e-05, 0.005929171241630282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0456398429278595, 0.016828519087050298, 0.01989489502812103, 0.0443709348086917, 0.00040468533909410187, 0.03384577226886143, 0.0659990384360637, 0.015689453159375755, 0.07595442692715748, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001118585066557376, 0.003650644062826891, 9.999999999998899e-05, 0.00069077782091298, 0.01328267327688859, 0.0025615936922745997, 0.1952343479429529, 0.17435017557597499, 0.1889066353605512, 0.1881188839768394, 0.17766149008439114, 0.20070202645443902, 0.20652589744201721, 0.18663634165745357, 0.17891930811558954, 0.053814199774748106, 0.050164539501723615, 0.046718410134724, 0.040062010397646564, 0.04242678741296346, 0.04496712502822464, 0.03423216843114041, 0.03999760353973436, 0.03517460340783396, 0.17074864140852952, 0.14161692162175676, 0.13594212659785665, 0.1663901132443829, 0.16803898763870473, 0.1328081710039607, 0.13871488354439265, 0.14818534484307821, 0.1593505147970753, 0.1586312275840588, 0.15650043131794633, 0.1621182482121276, 0.14609980287730673, 0.15929866919379487, 0.16083297778355865, 0.15647560881000777, 0.1747829196299857, 0.15524273761661367, 0.09423444168291517, 0.10147832232304876, 0.11227961970718026, 0.10664541725279064, 0.1001655053833117, 0.0876436927810943, 0.1120552400743603, 0.11498130788427474, 0.1106033375397687, 0.1451868647944521, 0.16013086970069113, 0.15154253780845905, 0.13785029280578964, 0.1351811380504978, 0.13189327128740946, 0.13953992237041835, 0.13930090225413372, 0.14039436778838865, 0.09032097971249042, 0.09614639889158139, 0.13826394377340367, 0.12640994404325723, 0.11852901417783146, 0.1264446379647497, 0.11115986880451889, 0.08802771675292698, 0.09531747231662868, 0.1311468081207824, 0.18287152672106377, 0.1284983168237932, 0.15705904834919715, 0.12842833179879798, 0.1894729049577364, 0.14264146045786896, 0.16602551183625314, 0.1458327223290118, 0.10809459457829018, 0.1292365007415488, 0.1361746912143299, 0.11992698773991173, 0.13786669625302927, 0.12904505287039214, 0.18276776639301107, 0.19056654224203318, 0.18949305738250866, 0.1747709406828135, 0.17330995869477994, 0.18153655801560287, 0.19972356888934428, 0.20313958067916604, 0.18606055705717017, 0.1847543901323767, 0.17143662259687575, 0.17546829424060617, 0.04175327213545221, 0.033560681696853, 0.04016966707637293, 0.038168258491173224, 0.04663234333519195, 0.053799784189872635, 0.0543800629798572, 0.04913787020649829, 0.04393863744859883]}, "mutation_prompt": null}
{"id": "78ba4da5-7275-4253-bd2b-c18bc7fe8fdf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "ceb1f3be-53b8-4e80-add9-c662884fb470", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "476f3a76-7c81-44eb-9154-e64050a285ab", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "ed148fb7-4eca-4e62-8b24-b28bc6f82192", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "a20abcbe-a612-48d7-8d26-60c4bcad0257", "solution": "import numpy as np\n\nclass HybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def differential_mutation(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        F = 0.8\n        mutant_vector = self.positions[r1] + F * (self.positions[r2] - self.positions[r3])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions with differential mutation\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Probability of applying differential mutation\n                    mutant_vector = self.differential_mutation(i)\n                    self.positions[i] = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_score", "name": "HybridParticleSwarm", "description": "Hybrid Particle Swarm Optimization integrates differential mutation strategies for enhanced exploration and exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.18459495709011725, "feedback": "The algorithm HybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.21.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.6076313680615214, 0.554388875170242, 0.6598706805057125, 0.4903023588733427, 0.18383963454062724, 0.5818910217633539, 0.52851923905164, 0.5908129393728692, 0.48316669229632303, 0.25349725901799314, 9.999999999998899e-05, 0.1803541077871691, 0.22740113923019334, 0.03979567890301183, 0.16878657628699434, 0.1492525698655952, 0.05286572549094104, 0.24399886459185172, 0.09973287106749229, 0.13719431059557397, 0.07571573602501591, 0.10435509385294517, 0.05315161819118852, 0.115740465801079, 0.1030375560077248, 0.05816892450595168, 0.06472193591442488, 0.1058651368851381, 0.06345336134692403, 0.08009571143187844, 0.10245861029145109, 0.06985148059939017, 0.09113379076254369, 0.07565163000331343, 0.07276008791209954, 0.08962469288322861, 0.9944979644471282, 0.9943877678044778, 0.9960549149899233, 0.9913238848809017, 0.9927826080758855, 0.9946090214681443, 0.9945312359828992, 0.9933131954666103, 0.9815828413188846, 0.05522357699170466, 0.050855619108749806, 0.055418192435399805, 0.03940077462012692, 0.23317588947696832, 0.2586649048380153, 0.08062762841285587, 0.05122075719926711, 0.04631021610365604, 0.2803078110051005, 0.20492538364777757, 0.20875471930907163, 0.19044117291570506, 0.16186242978559018, 0.18392413300061694, 0.1166104715787194, 0.1170701157503865, 0.13668968633014356, 0.15096612159032252, 0.14042491058079254, 0.13681718682684274, 0.09647706132344247, 0.1198047195876667, 9.999999999998899e-05, 0.24897232013227544, 0.12532698615889482, 0.2556195062129918, 0.05052293382761652, 0.010214250508432943, 0.10073265376031848, 0.11620117928094953, 0.1375261169913361, 0.11841199375031741, 0.11316113561628083, 9.999999999998899e-05, 0.1548382455247418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029244333291739144, 9.999999999998899e-05, 9.999999999998899e-05, 0.00889071253239948, 9.999999999998899e-05, 9.999999999998899e-05, 0.07367648200646237, 0.04739629223276587, 0.02435183869275137, 0.020035522630282188, 9.999999999998899e-05, 0.014779946251684883, 0.00878151561627638, 0.08675176626507686, 0.01755683449282297, 0.026188957856802197, 9.999999999998899e-05, 0.08586217994387679, 0.05701030853123279, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274901292771395, 0.06753476619869636, 0.05020750196848944, 9.999999999998899e-05, 0.06546370848314798, 0.20179151206971024, 0.004706028914896021, 0.1369710561616484, 0.0056176830335272765, 0.0743054931469862, 9.999999999998899e-05, 0.06982654544575251, 0.46588512423191886, 0.374215603473095, 0.43262217360302146, 0.42911461244619564, 0.42582960873118714, 0.4288477247067968, 0.4603339916599123, 0.13731765888773428, 0.4456680983893492, 0.07248145669579664, 0.06141663211893433, 0.07562715957967325, 0.0781133080517189, 0.041709257145529754, 0.09887311967398005, 0.08150573142473327, 0.06220578559854606, 0.08224401970082895, 0.141983170440675, 0.14106317314655792, 0.13773671516202646, 0.16418171715623298, 0.14525274469595517, 0.16929865059282534, 0.19593763809731002, 0.20493054080710948, 0.18454202984370027, 0.23476973133084633, 0.1797293802478398, 0.180823799063757, 0.16053560133818523, 0.18623918633585257, 0.15076853562098835, 0.2819030473931261, 0.316673019023601, 0.29618833821632107, 0.13768767012216698, 0.12616993874423865, 0.10618696103633096, 0.2010129450250373, 0.1532437907860783, 0.15846363827004573, 0.11793124057747095, 0.23982322808898526, 0.08563370013707283, 0.20364082053211896, 0.16625151516852077, 0.18413886359182619, 0.16873131029869515, 0.16331308266843048, 0.1770915455220231, 0.21500618455194853, 0.15062436232588317, 0.19646422058099355, 0.15907253500022311, 0.17255797388165373, 0.1885860081523031, 0.19008675084939675, 0.20576629137486502, 0.18084888101566854, 0.16043120345768802, 0.18365140635992472, 0.16492901699350038, 0.2549416917278011, 0.17626025468691675, 0.1051948172729924, 0.16567069703159032, 0.19085396174324143, 0.19054100295275744, 0.09808136053378802, 0.1628779387858751, 0.1509765448657443, 0.1209141503598461, 0.1551734310511349, 0.25452286223651743, 0.11099908056780972, 0.10914895626661769, 0.19658656608938374, 0.19749764243173162, 0.15739348484411442, 0.2061570883957795, 0.18787574001441498, 0.19396713911250418, 0.17903135019631156, 0.18113643030299187, 0.14994442780401174, 0.19384408269223052, 0.22368914023974584, 0.20426741406397142, 0.16968961981645603, 0.04994710135029179, 0.06656647171158914, 0.06231413556533627, 0.06804135602782446, 0.09565575890487366, 0.05197022469575363, 0.07771626136748233, 0.07141436483076535, 0.0767630289807536]}, "mutation_prompt": null}
{"id": "037148b1-4e80-4270-9a07-d8849377cb64", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "ffb18684-afd6-4377-9eef-e30a6456f181", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "05bd2fe8-5f5f-4c21-8e80-9bf8ef0768af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "32cb5a46-3f20-4363-b0b5-2142e2f26b0b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "4d00c49b-75f5-442f-99da-ee5953d3999d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "45eb692f-2283-4619-9212-7c1cab3bb3e6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "cc622149-6c3e-47bb-8730-5c14d90343f3", "solution": "import numpy as np\n\nclass ChaoticQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def quantum_operator(self, particle, global_best, chaotic_factor):\n        distance = np.linalg.norm(particle - global_best)\n        random_vector = np.random.uniform(-1, 1, self.dim)\n        return particle + chaotic_factor * distance * random_vector\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            # Update velocities and positions with quantum-inspired behavior\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                quantum_move = self.quantum_operator(self.positions[i], self.global_best_position, chaotic_factor)\n                self.positions[i] = np.clip(quantum_move, self.lower_bound, self.upper_bound)\n\n            # Perform adaptive chaotic crossover\n            if np.random.rand() < 0.2:  # Increased crossover probability\n                for i in range(self.population_size):\n                    crossover_point = np.random.randint(0, self.dim)\n                    self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                          (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "ChaoticQuantumPSO", "description": "Chaotic Quantum-Inspired Particle Swarm Optimization enhancing exploration-exploitation balance and convergence by integrating quantum behaviors and adaptive chaotic crossover.", "configspace": "", "generation": 19, "fitness": 0.10747770615258244, "feedback": "The algorithm ChaoticQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.20083770362336728, 0.24466096077341315, 0.20335968261365767, 0.22998785521465037, 0.2859821853425456, 0.24944324093808423, 0.21809490274560717, 0.233702527948088, 0.23343476808331787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05120583411005464, 0.0695212096953548, 0.060817907038026586, 0.05304615993053263, 0.04914629751607369, 0.05389959449038939, 0.05811578159036146, 0.07006691747195726, 0.05458455803625151, 0.04393407888889378, 0.0383326316070024, 0.034059899273847116, 0.052118677952733394, 0.04473191036308832, 0.04455579066035731, 0.04665114707359519, 0.049475010476115466, 0.04086726635265803, 0.14379932050344957, 0.12498337571625084, 0.12024545311702928, 0.13471433647898035, 0.10117204909868616, 0.15061935369417334, 0.19262954799245346, 0.14441772374872397, 0.1078944492234577, 0.11061548584233571, 0.08691472771149744, 0.09384954302121096, 0.10101482232713532, 0.10790261469603779, 0.08983822851567747, 0.09920333078298316, 0.11226811491471822, 0.12149640728651323, 0.1883283580433267, 0.12894654253637072, 0.16541125617267338, 0.1438360151063407, 0.1497418919568989, 0.1835680570963718, 0.11668200742851331, 0.17318361426809692, 0.1420232801303426, 0.07857889567003717, 0.013063989758380967, 0.05119124038838396, 0.027981348784530735, 0.029895564079809644, 0.08636968757177166, 0.03603251812582764, 0.05041690055851855, 0.03010769195123375, 0.01857083335977694, 9.999999999998899e-05, 0.017896684350285463, 0.03560583715123122, 0.052007017994806115, 0.03171322024360035, 0.07057090730416471, 0.07007291259933701, 0.0182985428859338, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05596895106797639, 0.08343451744738306, 0.10631684672564701, 0.044511597848654993, 0.044983015069784416, 0.055532300203708695, 0.041189793741326475, 0.06764492173544567, 0.06824780900492278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008148437021275101, 0.03042431039635507, 0.02580779552374568, 9.999999999998899e-05, 0.009925941365652724, 0.0011511774604497926, 0.024257759573950377, 0.009068394368574428, 0.002139843786861828, 0.2751094845061455, 0.2375252670384025, 0.21126242644072146, 0.2902377262671375, 0.22707539075954497, 0.23610892703634512, 0.21832951274204848, 0.23921934570497116, 0.22192463052096123, 0.06107951784853671, 0.06766388582064542, 0.06289843343051293, 0.043741674981113254, 0.07685690272475332, 0.08699030546593023, 0.05774236867444704, 0.08272889478865508, 0.051511458464984616, 0.14505006477050408, 0.18378451262096984, 0.13654266700316442, 0.14543720230657597, 0.1573334949814027, 0.1538588575243508, 0.1459250806641137, 0.15498285000578949, 0.13626891828346577, 0.17114690901228746, 0.18106914473686098, 0.17773372845404867, 0.1869278290453421, 0.19689920511316605, 0.17978833175847508, 0.18708652689596006, 0.22244467385325306, 0.17472817769832982, 0.12793118970290218, 0.12955417803103175, 0.1131104451167374, 0.143250927346097, 0.13595512934623077, 0.1228456780661622, 0.11593107553541415, 0.12785992704021332, 0.12282355010605261, 0.1957102461917708, 0.17295014951033505, 0.16542081016388388, 0.17501463612194834, 0.17770178183918028, 0.18987068393595596, 0.16333787765373398, 0.1585791941895277, 0.17157263002209255, 0.1522696497785433, 0.14652064500083728, 0.1570826294624762, 0.16903909334923906, 0.16033023728996199, 0.15858379942442913, 0.159528437371262, 0.1600657379235172, 0.14982908982061383, 0.16721806504672476, 0.15356396211762768, 0.16169769406263568, 0.19728418543281245, 0.16842674730531193, 0.1819635817960139, 0.17738213609398923, 0.15436694221326197, 0.21995967577548192, 0.19806619897708122, 0.1533557333029929, 0.2106988391807597, 0.17129077999226938, 0.16519074154966185, 0.14981913834275673, 0.1532388391830476, 0.23117613600983422, 0.16081131808568339, 0.18241378305354983, 0.1816394657881948, 0.18481552979682514, 0.17895786254577284, 0.17722478191107183, 0.18244045834654787, 0.1758760926300338, 0.21569494648494292, 0.18146862179570733, 0.05230322333106885, 0.06514453872893189, 0.052553084891836854, 0.07070646362310495, 0.05217664288138657, 0.07446232516328, 0.050802565386987575, 0.0529095515044995, 0.050438507002434796]}, "mutation_prompt": null}
{"id": "21370b47-5f3e-45f5-a605-40e306bb2d0e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "1b418366-81c7-41ee-a3d0-0a4760b370bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "33965e55-f198-410a-be1c-b2cad9551250", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "eb9c121b-7c96-4220-9b57-a1c25ddd9b69", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "18396195-a49f-4d32-871b-5879bd40844e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1/beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/beta)\n        return step\n\n    def opposition_based_learning(self):\n        opposition_positions = self.lower_bound + self.upper_bound - self.positions\n        return opposition_positions\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + self.levy_flight())\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Elite opposition-based learning step\n            if np.random.rand() < 0.1:\n                opposition_positions = self.opposition_based_learning()\n                opposition_fitness = np.array([func(pos) for pos in opposition_positions])\n                self.evaluations += self.population_size\n\n                for j in range(self.population_size):\n                    if opposition_fitness[j] < self.personal_best_scores[j]:\n                        self.personal_best_scores[j] = opposition_fitness[j]\n                        self.personal_best_positions[j] = opposition_positions[j]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "A novel Adaptive Particle Swarm Optimization utilizing Levy flight and elite opposition-based learning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.12036257877772699, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.20320408795831912, 0.1497205611174428, 0.17174608263176616, 0.19714964187365192, 0.18401163312245727, 0.19002636548235552, 0.17092755670825444, 0.18728632121146782, 0.16466873587599729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035420965218144196, 0.040748856305060865, 0.04643980779152257, 0.043822561873687715, 0.035586665854179245, 0.03847311129424613, 0.03877838084677765, 0.038416528092814595, 0.04949174616835095, 0.026185172496670406, 0.022076479899919677, 0.021256663988555524, 0.026606714436380408, 0.023208141732494747, 0.011684855152425233, 0.02726963244842262, 0.020183345464115376, 0.029657024016501943, 0.9927411690703987, 0.9930825629179192, 0.9936306784817118, 0.9910393323750855, 0.9904682931646377, 0.9920852690105786, 0.9951151392038626, 0.9909338477769873, 0.9925827842494732, 0.07731536602790057, 0.06541179850811729, 0.06515793423473037, 0.0834973400791934, 0.06575282038729313, 0.08227256920995829, 0.07349955289845511, 0.08549353223987688, 0.06901176172912438, 0.14670437389643698, 0.10957539313381326, 0.10005939637264072, 0.1347400285966811, 0.12683804559187173, 0.11673746717767375, 0.11525572470368461, 0.11073899562734169, 0.11520000138442299, 0.00795051627541088, 0.0004464372480390555, 0.015925345941199875, 0.0012583280387367113, 0.00010519645089479557, 0.0011846051833191984, 0.005162452844837073, 9.999999999998899e-05, 9.999999999998899e-05, 0.021660934560892242, 0.015829070143295265, 0.018020270058595078, 0.0005726431154072786, 0.0104823931084429, 9.999999999998899e-05, 9.999999999998899e-05, 0.006457643501313726, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03908674960825542, 0.021342660382871914, 0.03666133719343667, 0.028426088222466395, 0.02326221133257078, 0.045838634325879646, 0.0659990384360637, 0.04508167516888484, 0.019446810844874762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010901614527958348, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004945785438367989, 9.999999999998899e-05, 0.0053584628971864445, 0.18065829629836794, 0.19776021467765925, 0.1765349873954799, 0.18031172731712652, 0.1793781515279126, 0.18034097216377942, 0.1725746447490224, 0.17558861206372167, 0.17474478792206516, 0.06254617402565132, 0.0487178924570002, 0.05113163835183754, 0.035504539678127056, 0.04315258479228945, 0.050078543577256496, 0.03213902844328864, 0.042246860566048205, 0.05222961047368624, 0.13302958239062324, 0.1356222000654569, 0.1423144880479884, 0.14916207314130914, 0.17123126448272197, 0.14162085717926798, 0.14118333368189417, 0.13001930165862996, 0.14250030109345158, 0.16043454771980736, 0.16542736021082494, 0.16036483988425387, 0.15168558664493847, 0.1453449032998727, 0.1555035717919454, 0.15809707767682846, 0.17450678038413958, 0.16762798817644775, 0.08890947347346356, 0.10681541461543842, 0.09904084702012528, 0.10609134981777901, 0.10418368925432275, 0.09170515604002105, 0.1097569857261309, 0.12054874171223784, 0.11119792436601039, 0.1552568481457678, 0.1573511209527223, 0.15854100743714294, 0.15634109074844127, 0.14395749098899802, 0.15616993284723124, 0.1570540710793643, 0.14036487403656794, 0.14387056682657662, 0.11624086995146554, 0.10883936118621118, 0.09509410415999586, 0.12369340574341259, 0.07884407540882499, 0.14345812236633593, 0.10869834247480537, 0.10111842610954058, 0.14575369407669425, 0.13842795967608745, 0.1441331293128929, 0.1352478393665486, 0.11341808640436901, 0.15623467135987246, 0.17159608792526926, 0.15311342214331614, 0.1392145851814639, 0.11872902002936514, 0.16138697915840405, 0.1302064153279744, 0.13079192681097007, 0.09674036100435968, 0.11777017511181476, 0.10199036782904347, 0.17917190318436882, 0.18342126313171325, 0.18292665976361167, 0.19303367119539927, 0.18527269283106074, 0.19138970118234766, 0.18148630691744916, 0.18858789402542164, 0.18670464536260978, 0.17775653312333528, 0.18624365158210376, 0.18368505195793605, 0.03993628741237476, 0.04257424771327856, 0.044193800536997285, 0.0335699742075114, 0.04245196039449839, 0.04054806623288165, 0.05483727081526324, 0.03363256747945231, 0.03427640614294303]}, "mutation_prompt": null}
{"id": "c1896ae7-6923-498a-9fc7-9aa710c9e036", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "b2ccf0fe-d686-4a11-b8ef-f2ccf09a0ad7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "b5b4315a-8c2f-449d-b368-075a10af0357", "solution": "import numpy as np\n\nclass EnhancedGlobalTrajectoryPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_learning_rate = 0.01\n\n    def chaotic_trajectory(self, iteration):\n        return np.sin(2 * np.pi * iteration / self.budget) * np.cos(5 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic trajectory\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            trajectory_factor = self.chaotic_trajectory(self.evaluations)\n            inertia_weight *= (1 + trajectory_factor)\n\n            # Update velocities and positions with adaptive learning rate\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity * (1 + self.adaptive_learning_rate) + \n                                      social_velocity * (1 - self.adaptive_learning_rate))\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform mutation influenced by chaotic trajectory\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:\n                    mutation_point = np.random.randint(0, self.dim)\n                    self.positions[i][mutation_point] += trajectory_factor * np.random.normal()\n\n        return self.global_best_score", "name": "EnhancedGlobalTrajectoryPSO", "description": "Enhanced Global Trajectory Particle Swarm utilizing trajectory diversification and adaptive learning rates for robust optimization.", "configspace": "", "generation": 27, "fitness": 0.2019579087229188, "feedback": "The algorithm EnhancedGlobalTrajectoryPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.507974646223741, 0.4254676880978826, 0.5098135646760883, 0.5406490721630746, 0.48863309981637004, 0.5191016306959695, 0.5041808629038129, 0.45277449668411607, 0.5167693467679849, 0.2671412414858121, 0.20500068823069328, 0.25508815870841073, 0.17400229784830112, 0.1063941220062059, 0.19410833259849147, 0.18788635011161237, 0.12002393126632338, 0.2107511602006632, 0.13534527363142224, 0.14114032537563925, 0.10035699459438896, 0.12060969883413386, 0.12969910163437248, 0.10439414991367901, 0.13245941814338325, 0.10003166080101022, 0.08701382755222553, 0.13192670406401552, 0.09631888357972163, 0.10709825358167979, 0.12788870500373328, 0.09250456492294412, 0.10235979496837333, 0.1111818784794667, 0.11671651111273673, 0.08468101082476354, 0.9942586890815533, 0.9853683151610475, 0.9939805080341539, 0.9926012440297922, 0.9938902763597923, 0.9911109871580435, 0.9950144961710151, 0.9919517968466591, 0.9928639630278021, 0.2904638338318718, 0.21664565259754276, 0.20593421377297516, 0.2483336480876941, 0.24506778783116034, 0.25997043249751417, 0.2604243953788985, 0.23286811499028415, 0.2079208719264234, 0.2136841173115196, 0.1905560259709328, 0.16826054623957276, 0.19550573748917188, 0.18491390121930928, 0.19203091214510692, 0.12016251715955006, 0.20390125564431927, 0.13031299697720566, 0.11202862140339875, 0.13316988889935144, 0.1123185166224202, 0.12479824239366355, 0.13342043507450385, 0.10650256718846762, 0.12973990872838292, 0.12344834504262892, 0.14785173337423907, 0.12507047906636126, 0.08128596102785723, 0.10395177909210329, 0.16576515634019506, 0.031570724954304796, 0.13303579162314239, 0.13909999747896107, 0.07376799946705836, 0.0008157018975299968, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017126142129906263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03138800524605345, 0.02264108419430122, 0.05572036596964702, 0.042965175185376014, 0.008593677672320554, 0.012302711119959175, 0.04248263148280018, 0.02796291337400547, 0.028928602724197283, 0.008177467213412615, 0.010549138244059564, 0.005189308667831627, 0.02178210472613118, 0.033468452484835876, 0.020796892132786682, 0.025238713155403047, 0.0871815544784762, 0.03842029268243696, 0.06543356182282822, 0.061858825701698206, 0.07421702793477247, 0.010797361439657704, 0.05688785694133325, 0.04555979948063593, 0.05024027339359505, 0.04660081999576138, 0.07042457331968055, 0.3981381589616858, 0.39412465266356034, 0.3784999184258844, 0.36126348905915817, 0.37275437199306316, 0.4078043302635538, 0.41235651425152564, 0.3776541967418986, 0.4156571874484305, 0.10347101023112848, 0.06021300860833745, 0.07308724853947102, 0.0978142964046308, 0.09576462839172184, 0.10260990639362588, 0.0718540313115964, 0.08833959523802948, 0.09135736430832331, 0.12300045456835873, 0.17737426628450392, 0.15582212863176426, 0.23377983212087716, 0.157984938751894, 0.260181423271189, 0.15584266236670719, 0.13909015969236094, 0.1825375604126831, 0.27426880104052487, 0.18718988432577877, 0.2820795948120528, 0.2744795446399638, 0.19217314219603565, 0.2665335099642958, 0.26596343279600665, 0.33321391516683807, 0.2985266816524985, 0.16055055272381102, 0.13242071022359847, 0.20656224461900008, 0.16611203371917838, 0.1855018046769199, 0.2147800977994656, 0.1472691166280421, 0.2027728987603311, 0.23233072139114896, 0.2128028578440473, 0.20156949920934308, 0.18970587579705545, 0.20142468750589948, 0.19217860922817032, 0.17649600352474515, 0.16997613396562428, 0.19074551541250673, 0.1715633471718342, 0.17427014297586252, 0.17401561897813322, 0.17848605559839636, 0.19764702739975704, 0.2040951045246827, 0.21816169270364372, 0.18576006998708916, 0.18051744126700597, 0.17273245563052186, 0.7651742412480824, 0.1266398716695568, 0.15058284226498342, 0.18072623051078318, 0.19570737809623107, 0.15843227190478282, 0.2014207238238167, 0.16763669266331593, 0.1758030323562847, 0.2180383421386235, 0.16470529677101386, 0.1642613690724405, 0.195243673266012, 0.26483648771752744, 0.19562578177366508, 0.2047698491486044, 0.20218620877960491, 0.20135455172169825, 0.19755637080576183, 0.2080745711876636, 0.2015962686853512, 0.20356955118321451, 0.20249798794751428, 0.20499913528269942, 0.21970323363464728, 0.18837099811005953, 0.19701355026173129, 0.07955916317969225, 0.0714199316771097, 0.08398165969231519, 0.061171922869959094, 0.07243389131637945, 0.07270676291682177, 0.07527385418990473, 0.0681719591333726, 0.08696012683775278]}, "mutation_prompt": null}
{"id": "14d99f46-4329-4167-9173-ce6c339729b4", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def stochastic_ranking(self, scores, positions):\n        perm = np.random.permutation(self.population_size)\n        for i in perm:\n            for j in perm:\n                if np.random.rand() < 0.45 and scores[i] > scores[j]:\n                    positions[i], positions[j] = positions[j], positions[i]\n                    scores[i], scores[j] = scores[j], scores[i]\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Perform stochastic ranking\n            self.stochastic_ranking(self.personal_best_scores, self.personal_best_positions)\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Adaptive Particle Swarm Optimization using stochastic ranking for better exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.13598712073642286, "feedback": "The algorithm HybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.20.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.12133646908110951, 0.08943338415172675, 0.12557707399528195, 0.14047128833726696, 0.12106965443085826, 0.16038846930031925, 0.1485710311573445, 0.1416580195651037, 0.11640375277036397, 0.06668869472777494, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043868248332089244, 0.008838690701007179, 0.007054726052437954, 9.999999999998899e-05, 0.32667888519650634, 0.051691708858169316, 0.051140684238948464, 0.11196452149769143, 0.05712216934137182, 0.05283566534773476, 0.014308120801056035, 0.069386240055887, 0.024139685308730452, 0.3706191019912195, 0.11827266882462861, 0.008613870262153989, 0.11004320632935649, 0.11505998260233286, 0.04462737275043838, 0.007950606875248512, 0.021423550661201496, 9.999999999998899e-05, 0.032070478100359456, 0.9962546055583834, 0.9943976663125527, 0.996368502148769, 0.9939816382885626, 0.9964110781780811, 0.9945191699495319, 0.9963337216536498, 0.9960405085035391, 0.9959578281235806, 0.028268205323902507, 0.05441079132630078, 0.0318352123517569, 0.13824524114559866, 0.02213507827606298, 0.13904755965815607, 0.030272383860357466, 0.04994919053399571, 9.999999999998899e-05, 0.13293761790452996, 0.11492132465952565, 0.05297468041491815, 0.17922561176616114, 0.11594516469157357, 0.02707539294508532, 0.06410036168039912, 0.0887018452101962, 0.10359272447965251, 0.10513258513782531, 9.999999999998899e-05, 0.06577176056797618, 0.08794646153676344, 9.999999999998899e-05, 9.999999999998899e-05, 0.21389498727484824, 9.999999999998899e-05, 0.20139858017048906, 0.0168153995435798, 0.011736400959547644, 0.010058314332898055, 0.1648510623950621, 0.10286954981005036, 0.2144778209696412, 0.19598779556349188, 0.010086404239305735, 0.04274368744406509, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026199841093299092, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01569749248653718, 0.031798844273981386, 9.999999999998899e-05, 0.004825689282915269, 9.999999999998899e-05, 0.04648581232195281, 0.0064943703511646245, 0.07483347531843776, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06991664456720448, 0.0032246935970919877, 9.999999999998899e-05, 0.21641740562630607, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0060056749365896556, 9.999999999998899e-05, 0.0755688800166634, 0.49264264490681375, 0.5211003725552161, 0.44188018119021377, 0.13547272434834445, 0.17889655978239638, 0.13543249422915649, 0.49565989652611797, 0.12519785681559692, 0.5327424998902961, 0.019756607956068373, 0.01308477457000734, 0.004476030316538537, 0.06619518320469464, 0.07567894036114775, 0.08424745939397049, 0.040265841901075516, 0.04168146060009292, 0.09436441942407359, 0.10103474488032993, 0.10560488651477296, 0.09498158160054937, 0.18355826489170846, 0.1425831375978065, 0.15308367169353965, 0.1892504695411048, 0.06780300149538465, 0.17376725167044682, 0.10671465084305254, 0.15313065780063784, 0.16979303872798357, 0.17246691715190632, 0.1123321022341266, 0.11397886409415992, 0.1462385446381158, 0.31470073520271835, 0.0989436000650592, 0.14505341579724718, 0.05261093648025239, 0.11203097262778572, 0.09440120861851031, 0.07376077712363804, 0.0832788401920701, 0.0644787951472876, 0.14631148968790275, 0.058142176436456805, 0.14596837331320023, 0.12605257618846955, 0.2332641588249701, 0.18575822895485983, 0.16620389506745636, 0.1328496888440388, 0.21213630742953327, 0.15651561317590446, 0.16831493925618268, 9.999999999998899e-05, 0.16920974581491066, 0.15680653243601428, 0.15723794469629992, 0.17210690541675444, 0.1849685097041872, 0.17846185658750668, 0.16413929540925765, 0.18459390960865085, 0.1444895646922323, 0.12795360433013447, 0.10906026108528988, 0.16169259549259807, 0.19260587372124038, 0.08222109273683886, 0.09141015743498337, 0.16401552359850535, 0.12159159976633382, 0.06668552317638565, 0.10297953277776362, 0.07713339146552811, 0.10461168492845385, 0.09329830904653713, 0.04878922528913843, 0.15620472727239942, 0.11426362694710102, 0.13871367831519876, 0.17138077310990973, 0.20687491874259567, 0.21012688189591988, 0.16500026003569457, 0.19353944688539815, 0.15811812855608076, 0.19635078292132202, 0.1667343131810176, 0.35261325169114544, 0.012895064222680275, 0.042010918804537334, 0.0835515865367823, 0.08162923473875272, 0.03860446113740523, 0.029102130701310625, 0.040391886351681006, 0.022139104492289285, 0.0430850411233441]}, "mutation_prompt": null}
{"id": "17f4f3cb-5e6f-4abc-a5f4-9d0b69ac5b51", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 2.0\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.7 * (1 - (iteration / self.budget)) * np.sin(10 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Calculate adaptive inertia weight using chaotic map\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Perform crossover between population and global best with chaotic influence\n            if np.random.rand() < 0.1:  # Crossover probability\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.5:\n                        crossover_point = np.random.randint(0, self.dim)\n                        self.positions[i][:crossover_point] = chaotic_factor * self.global_best_position[:crossover_point] + \\\n                                                              (1 - chaotic_factor) * self.positions[i][:crossover_point]\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization incorporating chaotic maps for improved diversification and convergence stability.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7396480301051676, 0.7044137911015546, 0.8096023589257619, 0.7383900343509916, 0.1780692039660411, 0.1855632303111705, 0.7681344127643333, 0.1276392013282277, 0.7103011019886101, 0.5013308938647214, 0.027688208601028275, 9.999999999998899e-05, 9.999999999998899e-05, 0.04438414659822698, 0.5082998196112978, 0.4464587333583816, 0.4383161750816196, 0.012794877860792031, 0.10819879464506754, 0.13049790207547307, 0.09152821682068502, 0.10983299565100935, 0.11911463663120181, 0.07987174474104686, 0.08485406573825116, 0.10708844083934632, 0.044429684365158706, 0.10724442457605199, 0.12330788246333302, 0.1156728449244172, 0.09524810917385784, 0.10694790285164468, 0.1100451456407765, 0.1142351132126248, 0.09669866417811246, 0.07606191892855119, 0.9944730553028335, 0.9912763264823137, 0.9943921289560238, 0.9935091083495524, 0.9942446307355521, 0.9923422460487573, 0.9958926249609779, 0.9941977004682311, 0.9942900464729082, 0.44658860528368116, 0.0566207774104418, 0.057651076743675866, 0.4165583034829836, 0.14551915573672503, 0.14232695942051743, 0.07838259373201095, 0.050091799042081386, 9.999999999998899e-05, 0.16259511219287537, 0.10950606938370833, 0.13515642726652055, 0.16642019583848888, 0.11376662340983401, 0.10668045463740783, 0.11678868573697221, 0.177388491745049, 0.1052413562454092, 0.1148377963500763, 0.11730104236988503, 0.12150440163046183, 0.15614548944633766, 0.15638842635623584, 0.1171440801446344, 0.11090547404356166, 0.17142436220561452, 0.11896407521216246, 0.3115980597338419, 0.10909099401429523, 0.010044882776019004, 0.18825895140130489, 0.11108323462237424, 0.1692163496295931, 0.193848574814813, 0.032196317488878745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274308724607732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056276183077412, 0.05179242544433216, 0.013724853304430185, 0.09842938169715798, 9.999999999998899e-05, 9.999999999998899e-05, 0.08542969907358022, 0.06885671511286151, 0.05370659330075955, 0.027055577978285505, 0.0784994372144534, 0.04766979765627255, 0.07175894423621065, 0.09103513502985994, 0.10617457534807984, 9.999999999998899e-05, 0.13185063375287787, 0.06949303659772665, 0.054920438781348224, 0.03827487993116696, 0.29758865931595024, 9.999999999998899e-05, 0.004767980099057989, 0.004873260536809698, 0.2809266468365619, 0.040018623992793434, 0.07542066942014991, 0.42298133202134625, 0.4428994100300072, 0.5512412137674518, 0.47253607871758396, 0.4327157261098288, 0.2030606538054609, 0.5071371041246546, 0.42313364271720544, 0.4894097108961246, 0.0487716040981826, 0.04591889718945419, 0.04944916559987522, 0.10472264784610397, 0.043533717510354286, 0.10406020745015665, 0.07155426528003406, 0.08563992633075646, 0.081847352810685, 0.13695941370247489, 0.13904061539793533, 0.1420315820657979, 0.1551408790870924, 0.20298766790130152, 0.11610920122817092, 0.12281350752590592, 0.1929084400351998, 0.19868038886626804, 0.24108286620643182, 0.19889155919422496, 0.2116970853621869, 0.17844164141378427, 0.19613406756398022, 0.230129119632838, 0.1681511147675092, 0.23573333721202894, 0.2798913127361037, 0.13055461542885005, 0.17622600514404563, 0.15062080263762567, 0.1870494641280679, 0.16732551642441462, 0.19831994035009548, 0.13259215307907657, 0.26330352139000757, 0.1202110261659518, 0.1965737209619568, 0.1794648020631172, 0.19955955800700642, 0.20138397860729118, 0.19748082200634376, 0.24168451358908316, 0.21442783859968884, 0.19604998467280854, 0.21524325105134412, 0.18732187213316198, 0.19064961887631438, 0.21449311159355788, 0.18229488796827165, 0.30329464781265325, 0.1665008937447412, 0.18243731440233335, 0.18444191313112368, 0.6073133950590568, 0.8666097158237391, 0.14529757675724086, 0.1226392448397946, 0.7716148394107772, 0.17666926944619554, 0.19009955412723256, 0.09821101857337322, 0.1660313728894114, 0.14330595149663516, 0.13992229285015056, 0.15840356243231124, 0.11145290422859067, 0.5932248035595591, 0.15668189648238717, 0.1930349105647159, 0.1944813889558884, 0.18543961396466424, 0.18538771626661932, 0.18972676857414705, 0.1964638177682606, 0.19223868921795206, 0.19801504836503758, 0.20190807327205262, 0.19769366544895184, 0.1948559066071569, 0.1995563779194267, 0.19275840107914932, 0.060235641478769475, 0.08639312999996696, 0.07125875433267481, 0.0713068816210134, 0.08968611057491349, 0.04732435382328681, 0.07554787017338638, 0.07700805098559926, 0.06786941013846282]}, "mutation_prompt": null}
{"id": "86c10127-bc9e-4191-8af9-a1e060ec81e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for better diversity\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_component = 1.5  # Reduced cognitive component for balance\n        self.social_component = 2.5  # Increased social component for better convergence\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.8 * (1 - (iteration / self.budget)) * np.cos(10 * np.pi * iteration / self.budget)  # Changed to cosine for diversity\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Evaluate the fitness of the particle\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                # Update global best\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Adaptive inertia weight and chaotic factor\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n            chaotic_factor = self.chaotic_map(self.evaluations)\n            inertia_weight *= (1 + chaotic_factor)\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i] * (1 + chaotic_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Implement mutation for diversity enhancement\n            if np.random.rand() < 0.2:  # Mutation probability\n                mutation_index = np.random.randint(0, self.population_size)\n                self.positions[mutation_index] += chaotic_factor * np.random.uniform(-0.1, 0.1, self.dim)\n                self.positions[mutation_index] = np.clip(self.positions[mutation_index], self.lower_bound, self.upper_bound)\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Multi-Objective Enhanced Particle Swarm Optimization utilizing adaptive chaotic maps for dynamic exploration-exploitation balance and population diversity.", "configspace": "", "generation": 30, "fitness": 0.21364060888731562, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.23.", "error": "", "parent_id": "d279a647-293d-46ab-91f5-f39b76ce4ca1", "metadata": {"aucs": [0.7663652241052082, 0.6402113570870371, 0.7673302989032649, 0.7427246230902832, 0.5090515544303219, 0.5604000059218915, 0.6683683278184884, 0.636596367117007, 0.7806821317235578, 0.22921114753329863, 0.07680735378437364, 0.07410989998196038, 0.23782662719512015, 0.3573619591719487, 0.3236228328296129, 0.3780426110241839, 0.05342310885244228, 0.388930036307377, 0.10555059323500648, 0.09983567515368341, 0.10135822997828725, 0.11356799175486754, 0.06985382387516925, 0.06880232169647538, 0.07883321820138733, 0.032460011798982835, 0.06767667262872801, 0.07937676944038252, 0.0994950460314965, 0.09668561559130973, 0.09888921841756815, 0.07304104451000659, 0.0651541313577505, 0.05513790384674433, 0.05904520013832826, 0.0635856931281995, 0.9941953927762677, 0.9961886940826188, 0.9944020117771027, 0.9918161165891417, 0.9809213743134674, 0.9917878309052638, 0.9944172981376685, 0.9940346124566518, 0.9943471951338472, 0.10331057992199055, 0.3853461051307283, 0.33283345057312586, 0.38100350908233194, 0.17975679063822425, 0.2241998938872276, 0.09663896447937437, 0.2549680822407633, 0.10597147309309007, 0.2193463820123076, 0.24334380492031382, 0.22145396716950183, 0.2522154655929063, 0.11516552200979291, 0.11057525986272998, 0.11150367130434569, 0.08699206359291833, 0.10698265449489586, 0.1197277025788891, 0.09586896705132553, 0.09272716394983638, 0.1224847040376077, 0.12155726314404547, 0.10365815013562807, 0.18803033765072974, 0.11374434082305562, 0.15596450316896948, 0.09865720079857276, 0.10497778589713302, 0.09676145800352842, 0.12040552777312041, 0.07020159689500649, 0.20512985062974742, 0.09383758863539893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04557044759618056, 0.003027764415177825, 9.999999999998899e-05, 9.999999999998899e-05, 0.03280429011563246, 9.999999999998899e-05, 9.999999999998899e-05, 0.06488417236621791, 0.008281127371575492, 0.03902936390916312, 0.006240016477101706, 9.999999999998899e-05, 9.999999999998899e-05, 0.053230116345468925, 0.039050557765545446, 0.00784664530224366, 0.02005257952706685, 0.028771381554264175, 0.04128012270463555, 0.0780358519076555, 0.0757565575159268, 0.18482857936409147, 0.07996633197805836, 0.11626674158951211, 0.07049424155622219, 0.04265076629285136, 0.030388535513505843, 0.11821468762361276, 0.0345788046678992, 0.009132729856759059, 0.058209434278452266, 0.08674287941477488, 0.049756908453585824, 0.05469827140339656, 0.47569023365630214, 0.48967300521575374, 0.4713236132465415, 0.489076327069628, 0.4974341384175974, 0.5126234424763179, 0.517738978285687, 0.3747875396583308, 0.5007639629557761, 0.04785859192992192, 0.04174038038151051, 0.04992632171347544, 0.1023398479655323, 0.04887920151340863, 0.04183766781553244, 0.07314459323148892, 0.05772130758376992, 0.059611567224740925, 0.1555125192668202, 0.14734436090380842, 0.14733487158104164, 0.19996890906052334, 0.1560928316465997, 0.2106962371707658, 0.15454196569307355, 0.14418201170491174, 0.19120390848371094, 0.1633919097887645, 0.17463098745305228, 0.31783145778086086, 0.2252346610982785, 0.19287474467718058, 0.18264037909148823, 0.16051901308009542, 0.2732670865006869, 0.20212929327625495, 0.16452183183405467, 0.06364639945074302, 0.1724825170466785, 0.11746755102846107, 0.15010074011315389, 0.13605718254620291, 0.1753658594078613, 0.38756191002714746, 0.11543182517271611, 0.22329728941664906, 0.12190315603068735, 0.17509736648759333, 0.18292340870679646, 0.1569080534389501, 0.1585723553284032, 0.1822147770580469, 0.16498187706170087, 0.17666107060822434, 0.16794892376382609, 0.18761335433830872, 0.17946090018132965, 0.19132053905883106, 0.1873300416106396, 0.18488076122475416, 0.1720034833270262, 0.16783487914109296, 0.17100741545570786, 0.15745925198388755, 0.7957616205746496, 0.1482901102937343, 0.17916890694018806, 0.19670945435003628, 0.18170985635029135, 0.10503309203473399, 0.1652754489707079, 0.8015152835313175, 0.6960672388601112, 0.15295605912470978, 0.10969579791564754, 0.29544394994238543, 0.4667465770354857, 0.3627881801728038, 0.2087620121403837, 0.20351100369491637, 0.20731470381288175, 0.19260053529080368, 0.19068892463124376, 0.19087957902792418, 0.1735697618215314, 0.19711772660997673, 0.20720006760069132, 0.18763973158736436, 0.1924638867996823, 0.20747574814580927, 0.07913403514234763, 0.09513828287462567, 0.0633631357540464, 0.08000365137111676, 0.08470624131838034, 0.049154805864297435, 0.05790539248045201, 0.03977649868739297, 0.06952478757927316]}, "mutation_prompt": null}
{"id": "3946b608-e456-49d3-88e7-3b04d69a7cf5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.3  # Adjusted for better balance\n        self.inertia_weight_max = 0.8  # Adjusted for better balance\n        self.cognitive_component = 1.4  # Further reduced for exploration\n        self.social_component = 2.6  # Incremented to enhance convergence\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * \n                                                        (self.evaluations / self.budget))\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                levy = self.levy_flight(self.dim)\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + levy\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.15:  # Reduced mutation probability\n                mutation_index = np.random.randint(0, self.population_size)\n                self.positions[mutation_index] += self.levy_flight(self.dim)\n                self.positions[mutation_index] = np.clip(self.positions[mutation_index], self.lower_bound, self.upper_bound)\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "An enhanced PSO with adaptive velocity control using Levy flight perturbations for improved exploration and convergence.", "configspace": "", "generation": 31, "fitness": 0.1973916811256728, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "86c10127-bc9e-4191-8af9-a1e060ec81e2", "metadata": {"aucs": [0.4676544003185601, 0.45190680324900645, 0.4624333435180219, 0.4795841362431934, 0.4360020205057228, 0.4729335097484243, 0.4408810608732121, 0.4271476526241913, 0.4335368113774978, 0.03319206017305565, 0.05104231895976041, 0.03165882407224674, 0.023181856908070397, 0.039892919708069186, 0.04038412102775002, 0.018602513136322885, 0.014303059905361959, 0.024900218641920713, 0.13654405693556915, 0.11360789272309246, 0.11570466658482259, 0.11799175741003132, 0.1278206765905594, 0.12127727812802536, 0.11808260701128348, 0.06633258755002402, 0.10038473267418047, 0.11958784958926116, 0.105457339696857, 0.12363344253374275, 0.10538290400427996, 0.0949772256581567, 0.0945633301396197, 0.09313696099440405, 0.09789663907024637, 0.10440117409435401, 0.99371405050661, 0.9942958389698752, 0.9944375035542996, 0.9918296153756092, 0.9915094306132607, 0.9917398759540261, 0.9917824162125053, 0.9937046755655904, 0.9917329419736495, 0.19756764640428037, 0.223786102260209, 0.19208308904350768, 0.24743498552673704, 0.2783553851856746, 0.24213305671211804, 0.23184058282080933, 0.251706441979898, 0.22559315405161406, 0.20492271415354257, 0.14557579834512557, 0.15835675204007515, 0.20391707705083018, 0.1786542412322133, 0.26953049859203404, 0.20040577577731433, 0.1238533586737538, 0.22112543186668088, 0.14262320948813612, 0.1301573250179321, 0.131256220782084, 0.17061896368332818, 0.10711193559769794, 0.09585767025514347, 0.15655370475024633, 0.11349470797349348, 0.09552581872615284, 0.12649920311062357, 0.1020013272003022, 0.10708736674538011, 0.1530791495553372, 0.11502657609564793, 0.11119093604877894, 0.10143113507525359, 9.999999999998899e-05, 0.11597152719969239, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00037814954176207394, 0.00010728586587427369, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037256218445602785, 0.049817634046213755, 0.045028042667866086, 0.011223931743767346, 0.06412236608964139, 0.01428743392377163, 0.012710831359818653, 0.0557539885569025, 0.03312339914757789, 0.04594578923932058, 0.0003071677182550081, 0.0019865196521706707, 0.0031374573054783195, 0.0002844619819901695, 0.006874635011915209, 9.999999999998899e-05, 0.001014764392953671, 0.007402212078740034, 0.00277611766992214, 0.06842246611806879, 0.03069252227316288, 0.051740996092029534, 0.0679360775338097, 0.012670137824330907, 0.03357068808773089, 0.04945929723778186, 0.0709281728177984, 0.07777974067038684, 0.40197788098714327, 0.38508760643983686, 0.407014279960784, 0.35496287924698244, 0.3599157800063181, 0.38635305457386626, 0.3987205473301727, 0.3631418145605714, 0.4406015321700797, 0.08342817259843194, 0.06357782261659284, 0.05106029851622684, 0.09967602592272762, 0.09461653231292133, 0.09784441367125107, 0.07178497681642626, 0.06198281390564264, 0.10747596241647739, 0.19182510856749269, 0.21676636772668667, 0.16312482859070565, 0.21563552256301732, 0.27199565713444673, 0.21278492479540156, 0.30769510443044135, 0.17907277213191553, 0.2408886164152957, 0.11464593669108214, 0.19006717540856644, 0.26053515670802163, 0.2524482455173056, 0.28625435436048996, 0.1959442210466843, 0.27588991524270723, 0.24633467542988596, 0.25292347127253, 0.14178634302523863, 0.1904437309375866, 0.23233854636222517, 0.16855172448899336, 0.1734154943533085, 0.23216635432930643, 0.20389279181229336, 0.21773075996364488, 0.2045373441888252, 0.179211680406959, 0.14136157642258407, 0.1848104116178888, 0.19838327592985483, 0.15273309301527482, 0.18322664037312564, 0.20092232816263123, 0.20579559156457072, 0.19368907031522709, 0.1958430384172548, 0.19722292546705122, 0.29151992876829036, 0.21428367532654113, 0.22792390768091486, 0.18412531180163705, 0.19789608985962182, 0.20570217270846747, 0.19150947115051908, 0.16144659253954852, 0.16221004708126563, 0.14958253358401985, 0.5588090802140725, 0.19523826112705667, 0.14273116130361174, 0.10913312477679515, 0.16271140473503076, 0.693746195929542, 0.4916341032779432, 0.2416196139363732, 0.28639484637063795, 0.1971796397174983, 0.38196975148609436, 0.1977665302311662, 0.1486442339815196, 0.20857207415368662, 0.14835705253062592, 0.1844633931589128, 0.18446679566278756, 0.1832332233631705, 0.21840765052882993, 0.2069553364313117, 0.18789469647535728, 0.18361055568809004, 0.1911670247081656, 0.18852261805223314, 0.07097317194236097, 0.0888116858218575, 0.0717860977149809, 0.07432765046330769, 0.07549792313954418, 0.0765688166903461, 0.07328976249928276, 0.0768017905116598, 0.07636648156105241]}, "mutation_prompt": null}
{"id": "a04555fb-2bdc-4d85-a3b2-2e5599f7b16d", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    if func(mutant_vector) < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.evaluations += 1\n\n        return self.global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Particle Swarm with Dynamic Adaptive Inertia and Differential Evolution Mutation for enhanced convergence and diversity.", "configspace": "", "generation": 32, "fitness": 0.22940646599996378, "feedback": "The algorithm HybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "86c10127-bc9e-4191-8af9-a1e060ec81e2", "metadata": {"aucs": [0.7488319860304407, 0.12598404517271777, 0.7561162638065455, 0.1817052935923983, 0.18841908307833277, 0.1908093102386882, 0.748402003458846, 0.7541462029755855, 0.7554973815615196, 0.6251111243755721, 9.999999999998899e-05, 0.5673797774665207, 0.05343452245966307, 0.5551888744501523, 9.999999999998899e-05, 0.05249459759705677, 0.005673530171448005, 9.999999999998899e-05, 0.30498952513867095, 0.07320574513506584, 0.14744692656772151, 0.14324185310742865, 0.15269601107230701, 0.13660281325664603, 0.13079724245064195, 0.4194288017669815, 0.15109592258508275, 0.15966442813691484, 0.13429228016420713, 0.1645974216126247, 0.13150992768441971, 0.09584672061620092, 0.12747912753383717, 0.11798174142139273, 0.14924555207238321, 0.14066121288041944, 0.9940204925900432, 0.9945447052887141, 0.9940557602686825, 0.9749174841512889, 0.9905531089525624, 0.9885931597275027, 0.9916355204096264, 0.991008981808251, 0.9916541620743851, 0.05463691553292083, 0.4965529870123119, 0.11144664043384367, 0.15120332100387057, 0.14783442025981042, 0.14739971741702174, 0.08757073477631061, 0.47926318985094507, 0.12419698766701281, 0.36316618718627236, 0.16923979964039515, 0.20896187824281398, 0.21837152825200212, 0.21095916629497813, 0.18402995995930493, 0.11366552567863786, 0.13779370318512174, 0.6837620162541298, 0.16256540783206708, 0.11276061509067081, 0.10685588084645092, 0.17365228380723552, 0.1501299957201052, 0.09845145131876654, 0.22145743863366896, 0.15503752047621744, 0.18794963138167498, 0.2799778859520722, 0.009997714061267704, 0.1032080239893578, 0.3015641964742447, 0.12463023338374679, 0.16879824726811543, 0.03392000807001716, 0.033231635154686745, 0.16283723287173668, 9.999999999998899e-05, 9.999999999998899e-05, 0.030102651423578708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000492647703454141, 9.999999999998899e-05, 0.0001461500679613703, 0.021208169264507748, 0.023034864111587505, 0.07412578215131393, 0.09562968438183528, 9.999999999998899e-05, 0.008929117947246823, 0.042740718355281926, 0.04506799913898085, 0.024572834519160258, 0.3220551956783886, 9.999999999998899e-05, 0.03765618690921024, 0.07622812518883582, 0.07986527271444577, 0.1097181954926596, 0.2646492322489554, 0.08056530081450797, 0.061924352899519586, 0.06853380629522121, 0.03987313622819455, 0.04189517232669826, 0.005928157999663397, 9.999999999998899e-05, 0.006063240930831659, 0.07523345837350404, 0.07813237153402242, 0.07478123810252091, 0.5471416241696843, 0.591070423237181, 0.4730363233427354, 0.2094062734779748, 0.1807203383784819, 0.4899374613944598, 0.5716943951409843, 0.12390130131761978, 0.4969111613910764, 0.06974032625192195, 0.05781575968295061, 0.05050716881911321, 0.09098951868489624, 0.12238843393121701, 0.10173280101406579, 0.05502191893742492, 0.12815750122153424, 0.10157667729456976, 0.237119962566682, 0.4238996700195824, 0.18226847897297616, 0.15580239383864514, 0.3799477347179543, 0.17912166786456696, 0.18312089450925917, 0.30048376805759847, 0.2613868824721587, 0.35821460629443624, 0.19813638646262033, 0.31302336501419115, 0.4064601717163864, 0.42851608219260573, 0.29907927965189873, 0.2725522809071259, 0.3561459243235042, 0.4647954655395693, 0.2502854183184213, 0.16128076357501375, 0.1808895780250369, 0.18932552381281542, 0.1759578457632357, 0.2379033864743929, 0.26989838040056047, 0.28703178002814733, 0.14118689640922655, 0.22675971263841166, 0.1443336503899192, 0.20695741189257533, 0.23000794883015407, 0.18766446630317968, 0.1692735049783869, 0.21720268470015758, 0.1858826321641115, 0.2233761813043622, 0.6017886465286167, 0.2390352260024191, 0.1829083211018776, 0.2028098883839241, 0.20955141345817097, 0.21177187265902397, 0.23520915349157812, 0.2280282370819363, 0.2083220870153628, 0.2468064986876468, 0.17535838657550318, 0.1532967510769213, 0.8212853267477761, 0.1995625558234091, 0.19889069089999678, 0.10787710893490599, 0.16932412489929682, 0.1829920619085642, 0.44119150639039173, 0.3789175123536732, 0.11126149616277636, 0.1093033035922919, 0.3556082590870552, 0.2009123176950578, 0.19623187896583072, 0.19894523702354772, 0.19408919831398785, 0.2546049766355667, 0.19291201365476096, 0.19653999244381914, 0.21131362502163142, 0.19854657652382357, 0.19223189769828997, 0.2060841184974147, 0.196358205004328, 0.19613491233226077, 0.11579690822890476, 0.0877671959790266, 0.08890444862249136, 0.09908791049752219, 0.07971883906530952, 0.09244636608682544, 0.09463656100652063, 0.0756303044917106, 0.09636678583129088]}, "mutation_prompt": null}
{"id": "338cf392-6949-4bdf-9370-409bb2904463", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 33, "fitness": 0.2719375393413809, "feedback": "The algorithm EnhancedHybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "a04555fb-2bdc-4d85-a3b2-2e5599f7b16d", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "25c004dd-0cae-4331-9987-437b3caaaccc", "solution": "import numpy as np\n\nclass ModifiedHybridParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def sigmoid_warp(self, v):\n        return 1 / (1 + np.exp(-v))\n\n    def update_population_size(self):\n        # Adaptive population control with a more aggressive reduction\n        new_size = max(5, int(self.initial_population_size * np.sqrt(1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            indices = np.argsort(self.personal_best_scores)[:new_size]\n            self.positions = self.positions[indices]\n            self.velocities = self.velocities[indices]\n            self.personal_best_positions = self.personal_best_positions[indices]\n            self.personal_best_scores = self.personal_best_scores[indices]\n            self.population_size = new_size\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.velocities[i] = self.sigmoid_warp(self.velocities[i])  # Sigmoid warp\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Implement Opposition-Based Learning\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    opposite_position = self.opposition_based_learning(self.positions[i])\n                    opposite_fitness = func(opposite_position)\n                    self.evaluations += 1\n                    if opposite_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = opposite_position\n                        self.personal_best_scores[i] = opposite_fitness\n                        self.personal_best_positions[i] = opposite_position\n\n        return self.global_best_score", "name": "ModifiedHybridParticleSwarm", "description": "A modified Hybrid Particle Swarm with Opposition-Based Learning, Sigmoid-Warped Velocity Update, and Adaptive Population Control for enhanced convergence.", "configspace": "", "generation": 34, "fitness": 0.06223047190772714, "feedback": "The algorithm ModifiedHybridParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.1404542229402943, 0.1439827977322652, 0.10020119213990497, 0.08952233024927114, 0.06358751812920549, 0.07709668639236078, 0.19993533787650142, 0.11246722072444315, 0.13070065109310325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01124456578698041, 0.029361980381497732, 0.029490717113306864, 0.010643411704069683, 0.006811757008068353, 0.030464470890019024, 0.018248263482334326, 0.011726953946390895, 0.020502583324710888, 0.02386690803585334, 0.01798791109804665, 0.04072425692210779, 0.027335737120260828, 0.022004154692118583, 0.01767750218095987, 0.017979432366321824, 9.999999999998899e-05, 0.0187819575425614, 0.04538493112985775, 0.043185042583532285, 0.04467656147422272, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.039064723203418916, 0.05298503660033316, 9.999999999998899e-05, 0.041279575909880295, 0.04066717446879209, 0.017277982267767, 9.999999999998899e-05, 0.06256659917897811, 9.999999999998899e-05, 0.10027683525177622, 0.07382260615531289, 0.1374334677942034, 0.094309474922743, 0.05648381150117188, 0.05718224457320853, 0.07161730400646849, 0.061459193216479635, 0.09456784906121085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05633257766532984, 9.999999999998899e-05, 0.017596748495257275, 9.999999999998899e-05, 9.999999999998899e-05, 0.07037699617977711, 0.014185406075991724, 0.005398904359930956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22620323918437812, 0.13879659513922615, 0.1820160786619327, 0.14752826107873407, 0.1336067679717311, 0.14436399778918474, 0.18205526437188602, 0.1501238339265898, 0.15909543283528005, 0.021924742787885254, 0.025443450113095234, 0.013610891174740347, 0.04181715672195574, 0.04385821028786652, 0.041202127241795616, 0.02866512046727876, 0.030580594221767066, 0.027755949647328304, 0.11397115027406557, 0.13399167557868608, 0.09495693577655984, 0.11010254265524422, 0.11159266015686531, 0.09697270886961773, 0.10634241883457674, 0.09591603836390672, 0.10918612227363644, 0.13540662865347608, 0.12138748856840498, 0.1612949680969341, 0.16081273892448766, 0.12282097190614572, 0.14666123700579226, 0.14124588839561003, 0.17377774300845283, 0.12871478163253103, 0.10044800803429554, 0.0804205589271485, 0.08941244022451866, 0.09502971079493927, 0.07904404659911834, 0.06791775225898111, 0.08900461463541798, 0.0997711199450243, 0.08543330969980778, 0.11943364695601921, 0.10769782801327765, 0.13345086981233123, 0.13152035572244625, 0.12871633875960575, 0.11064424042784682, 0.12794180498901697, 0.1274876386223457, 0.1414562645388947, 9.999999999998899e-05, 9.999999999998899e-05, 0.001423781951673475, 0.15131158938113498, 0.020232681387609364, 0.1461548220260942, 0.017428053449203285, 0.1317491314077126, 0.1320021226923589, 0.16328635914949008, 0.12229787780313794, 0.09100426924613059, 0.1083532299683122, 0.14675513584396538, 0.1043286165705144, 0.1017566406986331, 0.09643604708838482, 0.09963492471994928, 0.11194172735860486, 0.15316331208694012, 0.15838707862648993, 0.06920118336561887, 0.06382616617572989, 0.06955049505595856, 0.12714735021597423, 0.10217559498462636, 0.11786408047175789, 0.18389418461699225, 0.1655411686583066, 0.21202307723539437, 0.16094604053264427, 0.20570511365756539, 0.17131145040325557, 0.1890317302510508, 0.15941046081479926, 0.15608939065498195, 0.039503600431687325, 0.020632629836385252, 0.03412832152907941, 0.03596629503749371, 0.03425093938292756, 0.03137984757326118, 0.04664608588946395, 0.0319929401111243, 0.030232736312932995]}, "mutation_prompt": null}
{"id": "901682e4-ef8a-4f41-9b9b-a84e3960a6ab", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "01d473dd-0fdb-47ce-9cd7-144dc78d7cee", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "5a3b4162-4400-4127-8c17-2eb859fd485b", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "a6228631-fc00-473f-ae95-738a3ff049c7", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "a34c68c3-499e-4784-821d-e01cac4736b2", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "3f6999d3-a7a8-467c-8f32-500401354d81", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "7edf81cb-13e2-41a5-84a7-07b6401e0eec", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "b7b315dc-fed5-43f6-bcbd-842eff7224a4", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "5b679669-5fae-4efb-a9c6-5a6427355446", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "6f0598d7-0bc5-4d5d-b04c-6824345c4108", "solution": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.8\n        self.cognitive_component = 1.7\n        self.social_component = 2.3\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.95 * (1 - (iteration / self.budget)) * np.sin(7 * np.pi * iteration / self.budget)\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return 0.1 * step\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.15:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Levy flight mutation for exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * self.levy_flight()\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "DynamicAdaptiveSwarm", "description": "Introducing Dynamic Adaptive Swarm with Chaotic Perturbation and Levy Flight Mutation for enhanced exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {}, "mutation_prompt": null}
{"id": "0705f18f-e890-4930-b7fa-813f75f18cc6", "solution": "import numpy as np\n\nclass MultiSwarmAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaos_influence(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.cos(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def differential_evolution_step(self):\n        for i in range(self.population_size):\n            if np.random.rand() < 0.1:\n                a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                mutant_vector = self.positions[a] + self.chaos_influence(self.evaluations) * (self.positions[b] - self.positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                if func(mutant_vector) < func(self.positions[i]):\n                    self.positions[i] = mutant_vector\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaos_influence(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                self.differential_evolution_step()\n\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "MultiSwarmAdaptiveDifferentialEvolution", "description": "Introduce a multi-swarm strategy with adaptive local search and differential evolution to improve convergence and diversity.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {}, "mutation_prompt": null}
{"id": "591aa5d0-4526-4081-8ca6-c636dc3162ce", "solution": "import numpy as np\n\nclass EnhancedLevyAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def dynamic_learning(self):\n        return 1.0 / (1 + np.exp(-(10 * self.evaluations / self.budget - 5)))\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                dynamic_factor = self.dynamic_learning()\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity) * dynamic_factor\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                L = self.levy_flight(self.dim)\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + L\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedLevyAdaptiveParticleSwarm", "description": "Enhanced Particle Swarm with Lvy Flights and Dynamic Learning strategy for adaptive exploration and exploitation.", "configspace": "", "generation": 46, "fitness": 0.1243693192374493, "feedback": "The algorithm EnhancedLevyAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.26444183180060676, 0.4062024399150279, 0.23152462862962497, 0.16299958573329276, 0.21988325809877163, 0.18238276076863358, 0.2505335618192436, 0.18659377613942674, 0.23140677310311275, 9.999999999998899e-05, 0.03548763981697811, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08031429026347359, 0.1213996575006997, 0.06191937842158224, 0.08749096583888472, 0.0638804363543195, 0.10082238393487974, 0.09383474606668607, 0.09565838745964794, 0.11117606943663305, 0.06988796628497507, 0.04707978206700569, 0.06656454062631834, 0.06368038737450532, 0.07195621902515137, 0.046034368373265355, 0.05977758588888049, 0.0800885587383513, 0.04550872270466533, 0.09995589089413026, 0.13935090898989055, 0.0797183345383542, 0.08079360376268341, 0.16596185633804272, 0.09913380076075973, 0.22720437108329494, 0.6328270779548413, 0.12029768661326856, 0.08958055030078171, 0.08682677058716015, 0.08465633136908257, 0.09518135077939494, 0.13037171338315434, 0.0910586425438481, 0.12388248490013543, 0.09616961125312151, 0.01581496820885897, 0.20117860965904444, 0.14146614261033896, 0.11128356167064735, 0.25902367962808237, 0.1732005124337771, 0.11618045287901935, 0.1508559361730034, 0.13045088098379842, 0.14487134981659233, 0.009062027452613752, 0.04836528034038734, 0.025802806040530757, 0.017710583053077378, 9.999999999998899e-05, 0.01723248391631982, 0.025246543790891196, 0.10612321230079247, 0.09058476370382718, 0.09632886170431243, 0.11093754912303011, 0.12128569590783977, 0.20326778534975498, 0.12110033710619195, 0.09088412583230454, 0.04165213508080501, 0.07930840928915128, 0.1512835594240216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037914007888099066, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1030954218100405, 0.07831764767236293, 0.08646305227027407, 0.13911106340929769, 0.04886393855815918, 0.026568911571340337, 0.17954368216153138, 0.094180262689323, 0.04209561541276252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04086813700226499, 0.029058243261257277, 9.999999999998899e-05, 0.0012618058581952418, 0.003591943207696513, 9.999999999998899e-05, 0.028634059221692265, 0.00023173764564266008, 0.0019310792691769052, 0.2963763984466137, 0.2497701133585406, 0.26537475735115745, 0.21484620749013394, 0.20695687271298735, 0.20598804942514493, 0.3002969641079156, 0.23908420221591542, 0.238757876967976, 0.059890588920704424, 0.1263462961896561, 0.018312305613255697, 0.05596164455525343, 0.08404893015329584, 0.08455116149316289, 0.0909507166705138, 0.11473798628734733, 0.0761116285730512, 0.227885958533511, 0.19823677151308738, 0.20514033699791756, 0.17142773448932036, 0.14780368514879316, 0.12850395050189456, 0.13014048922232435, 0.22400251243102443, 0.16913501204378079, 0.19914079486035197, 0.20977809849835205, 0.20363519288845222, 0.2139026293015529, 0.19286115500535594, 0.2806419661830275, 0.1823883248252769, 0.22779375418827608, 0.18090174234518064, 0.12014907191538327, 0.1298904725309571, 0.14658042368056956, 0.1840467266172623, 0.14275650888778468, 0.1789646655883349, 0.19971117620524814, 0.1690633452298762, 0.13145219902289396, 0.20475380772006213, 0.1944059928957801, 0.24015442012711885, 0.20949683495095517, 0.19712540166652093, 0.21324455429340228, 0.23411041761805884, 0.20998742528759273, 0.19280176037782926, 0.16253692594118985, 0.15062285282407561, 0.16608591877597623, 0.1637520780663715, 0.16966531920903383, 0.17117749651650338, 0.1597416727684684, 0.15619873951979102, 0.1651824934270688, 0.1627174563545244, 0.1575246398038056, 0.1576341260603098, 0.19439060743302794, 0.1756557044244017, 0.166092437330272, 0.12872439532037994, 0.1184809779337298, 0.38561563479314187, 0.3000076122999583, 0.12778071424490223, 0.1086529974098901, 0.1457993199558537, 0.3296774135455164, 0.3028880755278113, 0.2660052332324485, 0.09846704690982044, 0.14677342344868738, 0.23911011608897792, 0.1823011276841744, 0.18729258560617845, 0.18898235426511945, 0.1880932873934007, 0.20862409075878974, 0.20136747949999345, 0.18743715533155814, 0.1894902844117281, 0.07313824409297853, 0.08080370109496127, 0.08883483687207294, 0.07658547764420853, 0.08869464509228253, 0.07342368200311133, 0.09968246373616696, 0.07616381456081112, 0.08310633842440784]}, "mutation_prompt": null}
{"id": "9b7e075a-ee68-450d-a032-76a9938b4a30", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def chaotic_map(self, iteration):\n        return 0.9 * (1 - (iteration / self.budget)) * np.sin(8 * np.pi * iteration / self.budget)\n\n    def update_population_size(self):\n        # Adaptive reduction of the population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n            chaotic_factor = self.chaotic_map(self.evaluations)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.1:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + chaotic_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n            # Apply Gaussian mutation to enhance exploration\n            if np.random.rand() < 0.05:\n                for i in range(self.population_size):\n                    mutant = self.positions[i] + chaotic_factor * np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n        return self.global_best_score", "name": "EnhancedHybridAdaptiveParticleSwarm", "description": "Enhanced Hybrid Adaptive Particle Swarm with Gaussian Mutation and Adaptive Population Size for increased exploration and exploitation efficiency.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8020096592006042, 0.7516250934969835, 0.7900439150332305, 0.7263593995523048, 0.7701826873270614, 0.7705041102246161, 0.7822947843015289, 0.7774457297445707, 0.7769305569000019, 0.025279915999858016, 0.050699048855763484, 0.5589994217904066, 0.05863583537533901, 0.21497156621190305, 0.6268637863464525, 0.5864316965486528, 0.6363611597398104, 0.6230420153085501, 0.0687910766090647, 0.09086989988609717, 0.13902743322114786, 0.1315846680924453, 0.1559265146538824, 0.15521231371622213, 0.10735471352437054, 0.40501407360358377, 0.13955507869706796, 0.1557955156773978, 0.11304095052695629, 0.14515150469442684, 0.1302930376142858, 0.13209640310683868, 0.10742323335591775, 0.15737914131659403, 0.12255793931659953, 0.13964801248861625, 0.992106381913201, 0.9946280489502727, 0.9902751196463713, 0.9837900299206883, 0.990987977498868, 0.9887131818985774, 0.9896911553732447, 0.986696564158126, 0.9882139085058719, 0.5823749794142539, 0.5042531560424477, 0.4599003816742897, 0.5459680989618028, 0.45904938988859023, 0.4261713935009177, 0.5370976228038994, 0.5449132417285715, 0.5518687834464909, 0.763269383464041, 0.3425926995039287, 0.20631004395397867, 0.2666826506242891, 0.2692549470347101, 0.20081937181482812, 0.21555234230973275, 0.1252089116826215, 0.11933262397807864, 0.16468865059742088, 0.09299873080839227, 0.17623291224384907, 0.12239912059973779, 0.2222420814841074, 0.1739639852766166, 0.18171977612575518, 0.16339123022947966, 0.17089940245564994, 0.19159830512576814, 0.10789282808295897, 0.18871467957118804, 0.21463373007036857, 0.10533950461019181, 0.19437538091440987, 0.09036176402837959, 0.09258848688147703, 0.20160579168561976, 9.999999999998899e-05, 9.999999999998899e-05, 0.043955337064277455, 0.0006641718749670344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026540902636287278, 0.10006746636139363, 0.05656511669383235, 0.014774187779113213, 9.999999999998899e-05, 0.005980198370975076, 0.04579285964033242, 0.055260004341084135, 0.027868527224299, 0.04152049774352495, 0.029708891967983098, 0.043949721503942274, 0.06333117524580034, 0.07107780044997125, 0.07720361951150667, 0.08820452802039513, 0.06395769868455248, 0.06283701283463106, 0.010355981463016861, 0.03552616748681381, 0.011007382080527539, 0.16325305761345843, 0.12805597246319234, 0.009947542901449946, 0.07633566315930096, 0.05185553758026762, 0.0763127168572153, 0.4964269569588393, 0.5028144600873048, 0.5903706543093897, 0.4016600719919201, 0.4980840617929376, 0.57188805926712, 0.5563564801464611, 0.5041411529307573, 0.5372703928366789, 0.07676471297886622, 0.06547401069152803, 0.07005560990852644, 0.15248135506427185, 0.10665966346913391, 0.12817183769379403, 0.07256099976857822, 0.09022928899294147, 0.09218841535480371, 0.20266348406178192, 0.1629161010373278, 0.16825337629485349, 0.22202330802869918, 0.17700666914950702, 0.22040158384220354, 0.2567654411220873, 0.1603996069198964, 0.291570450733016, 0.21440021547170796, 0.19658635739408847, 0.3198945127352999, 0.2995330714993545, 0.3079675328992554, 0.37629860666803583, 0.36090416348700205, 0.29838102251924525, 0.2764923931429184, 0.268264880696074, 0.17673535685368114, 0.16928432697226214, 0.2091443423081195, 0.18575826224375802, 0.18639812638986308, 0.2578029878578253, 0.20146508243543604, 0.22648961332483108, 0.19964996849235106, 0.13978329490292984, 0.2130911977462756, 0.2040218029377595, 0.15221179864061374, 0.18125709566996195, 0.21786202477641758, 0.20544378327019108, 0.2109427828680247, 0.24301136755239083, 0.48060949181665624, 0.5855730669726406, 0.6448707003712755, 0.22447406999232966, 0.1835851978146379, 0.20252429502704183, 0.23383884841238178, 0.1989443694873223, 0.7745080424827622, 0.16589541138092678, 0.153587984423451, 0.8153505622572805, 0.1994731212071028, 0.8226662804714586, 0.12035205459201537, 0.16989780772402174, 0.20333703293493832, 0.46362020254544434, 0.3227312664660865, 0.1611680889544157, 0.19369134759116546, 0.46667011545187564, 0.20492156911331272, 0.20746747606062776, 0.10446305869766837, 0.6373368279354711, 0.2147348527613423, 0.19803512892657904, 0.1798622092062251, 0.20703823061595028, 0.19136746655135106, 0.1877776174091248, 0.2070144734763828, 0.19773142009117206, 0.21548984557871187, 0.1031395664651007, 0.08832810304057725, 0.07855290041480822, 0.09258106212947637, 0.07644281196378111, 0.08723588721541942, 0.08579492177634418, 0.12122813168319502, 0.10044101896219637]}, "mutation_prompt": null}
{"id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.28808836569543694, "feedback": "The algorithm EnhancedLevyDifferentialParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "338cf392-6949-4bdf-9370-409bb2904463", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "341d5dfc-a23b-4cb8-9bbf-fc55156e492a", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "db5290c7-9d6a-4bd3-aed1-bfe5ae108848", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "8880791b-f935-4364-bbca-1f61a8387ea5", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "3b7d1355-73a0-4d6d-be08-8975351faef1", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "727f9543-8536-4488-afd6-e79fc8a7f3f7", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "642d534c-7b73-4990-8772-d9e567b82abb", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "4d898408-a5fe-466e-8e2e-9cd24d13c18c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "c8ba47fd-c9cf-43f2-9c6f-9abbaef3c269", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "00ceaeb2-4eca-4cc7-915d-0d7839f1fb4b", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "3c59973b-7161-47b5-89cb-7218c398c32d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40  # Increased population size\n        self.population_size = self.initial_population_size\n        self.inertia_weight_initial = 0.9  # Updated for exponential decay\n        self.inertia_weight_final = 0.4\n        self.cognitive_component = 1.5\n        self.social_component = 2.5  # Adjusted for stronger social influence\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def exponential_decay_inertia(self):\n        return self.inertia_weight_final + (self.inertia_weight_initial - self.inertia_weight_final) * \\\n               np.exp(-3 * self.evaluations / self.budget)\n\n    def elite_guided_search(self):\n        elite_positions = self.positions[np.argsort(self.personal_best_scores)[:5]]\n        return elite_positions[np.random.randint(0, elite_positions.shape[0])]\n\n    def bidirectional_learning(self, index):\n        return (self.personal_best_positions[index] + self.global_best_position) * 0.5\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.exponential_decay_inertia()\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                elite_influence = 0.1 * (self.elite_guided_search() - self.positions[i])  # Elite-guided influence\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + elite_influence)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Bidirectional learning for enhanced exploration\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:\n                    bidirectional_step = self.bidirectional_learning(i)\n                    self.positions[i] = np.clip(bidirectional_step, self.lower_bound, self.upper_bound)\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Strategy: Hybrid of Exponential Decay Inertia, Elite-guided search, and Bidirectional Learning Mechanism for optimized global and local search.", "configspace": "", "generation": 58, "fitness": 0.23865287868360574, "feedback": "The algorithm EnhancedLevyDifferentialParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.5181387856438529, 0.47176599253569174, 0.6287354712320837, 0.6023943894237778, 0.5855545333772647, 0.5980874790402575, 0.5587397980626625, 0.5902097956385686, 0.5884194084591252, 0.11962305727689404, 0.3271596273140698, 0.08290527587013041, 0.09460855297535342, 0.13034564405266758, 0.2933576257851014, 0.2184583513212489, 0.19180782505410665, 0.15406312399880862, 0.116599952484843, 0.08971944721429481, 0.12002101526955411, 0.12407013747592388, 0.11623367816316654, 0.16424195877031744, 0.26705587892685867, 0.10611225507327982, 0.11001835320723874, 0.09337396521973729, 0.09706044191238983, 0.10936168186949813, 0.0979138387020293, 0.09783665810745001, 0.11603841335100473, 0.08680553655307288, 0.11354974938960116, 0.11330683798230512, 0.9903641242592874, 0.9925891362213816, 0.9920174212170053, 0.9879962121855398, 0.9870172277058822, 0.9884849805302864, 0.9921509027884131, 0.9875572209907622, 0.9906335752631005, 0.3674846058017607, 0.3745554916192253, 0.02197406905870669, 0.3907584266999631, 0.20642051356062885, 0.31361537434482123, 0.331102100750025, 0.21394796863387777, 0.4598002948406018, 0.21915085005743362, 0.21335514426084323, 0.21455196614949623, 0.20854737935673162, 0.3165682355613262, 0.21404723959383032, 0.4897048724919464, 0.21180782483363014, 0.35057356924876326, 0.19221068463652402, 0.16148886598975443, 0.14125743865383134, 0.14518514891316403, 0.11493520001164381, 0.17701556605237712, 0.11901864068806811, 0.1466145547364831, 0.16563098177192515, 0.14689669652670634, 0.11459418372141139, 0.11805471377215926, 0.2330682437211643, 0.10266460476743633, 0.15138188660248253, 0.26989797264315474, 0.133736787686059, 0.1605360982833216, 0.023325922717958747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007235173133891326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05907339569325143, 0.018595965822720828, 0.09277004276353473, 0.07461552661798665, 0.000201620402780045, 0.03762014152068094, 0.07138660537847497, 0.05341818443025581, 0.04971473661035619, 0.02582135635863414, 0.03125610511407917, 0.09586219762153925, 0.1169922014001602, 0.05854534447361859, 0.10031012082125002, 0.04431070147286287, 0.06814844845998291, 0.08738385817163219, 0.12282502345662871, 0.03343983505221326, 0.09808539355569668, 0.14696429783044718, 0.07642484879875178, 0.12539945580192857, 0.04337501199258298, 0.18912603301743425, 0.11001456998976178, 0.44394782817616163, 0.4373910915823075, 0.44969395538041546, 0.41014684272214885, 0.46077117058090566, 0.471084162594825, 0.42748275377012257, 0.4374363045853866, 0.44746935772718266, 0.13009225845484707, 0.0809118680753127, 0.08893490174957042, 0.09107628185705541, 0.14100080926421366, 0.1225452179974389, 0.10918981634023661, 0.10898559215521675, 0.12125222792367263, 0.18255628111354893, 0.34950740171745653, 0.19221520621140709, 0.2142072161993741, 0.30128370025122375, 0.17385608097982985, 0.12484933604443904, 0.18823061128543228, 0.21264517085087886, 0.3090358557342524, 0.32989309699268266, 0.3568703037982063, 0.2414027589120289, 0.28771283007432724, 0.2181115744491019, 0.3265613511016029, 0.3419417268538858, 0.3232838412388799, 0.191033136715263, 0.20038409679539526, 0.20866740032718212, 0.18415310204553903, 0.18195442378698146, 0.2127928153570755, 0.20737391549180972, 0.2517348196464372, 0.2722754751656845, 0.22005802322504486, 0.1527752409534907, 0.17877336413881695, 0.19030104264324044, 0.18835469459754328, 0.19725390039424795, 0.19302758803402076, 0.1935382940462521, 0.21521093619363252, 0.20199212926484356, 0.1870730561937749, 0.1809462933353314, 0.41440591613359734, 0.21475058862361573, 0.18480689414595886, 0.227280159141244, 0.3457177137154209, 0.20232043480104245, 0.7410001661550928, 0.16673982082906746, 0.15331415898785183, 0.6843383099790061, 0.19448470817392627, 0.1933326136512259, 0.13657132847268005, 0.16866405584933442, 0.6548591685765293, 0.5337383916658592, 0.20500035763129643, 0.6697493481059633, 0.20263139431385813, 0.16665425052574157, 0.3296148980044644, 0.2110932502512456, 0.2103376841492599, 0.20906989265776588, 0.1849423701723355, 0.19490611952933456, 0.18030280232723794, 0.19818555064944743, 0.18841753255663252, 0.22082852386267426, 0.19610079818226545, 0.18239687402897475, 0.1862558471998822, 0.08587678997880033, 0.08182332004073523, 0.09541508962368661, 0.06863831518767438, 0.0868081096060962, 0.08009383398438163, 0.08726992814454915, 0.08453074077655187, 0.08490155975108227]}, "mutation_prompt": null}
{"id": "011ae0a3-83b0-4096-91b1-69f7fbb24962", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "eb7bdb84-509e-4ddc-b27e-c1106e99e61d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "847df30e-262e-4d38-b2b7-dd816be19d11", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "0aee1f36-979f-47e2-a44c-03e9ffdcf98c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "8b9ba9d3-1098-421e-91d9-a091b8acc871", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "efbb7073-007d-4fed-a7d5-c3c62b4f8b52", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "b03569c3-17d7-4482-9613-53dbb368abfc", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "c3bd1ec6-8004-4ee4-b46c-09043dd060af", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "884f981b-db4b-4e62-8934-b841d310cfb9", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "164bd597-3df2-495d-a81a-35b7244749fd", "solution": "import numpy as np\n\nclass EnhancedDynamicElitistPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40\n        self.population_size = self.initial_population_size\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def adaptive_inertia_weight(self):\n        return self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.evaluations / self.budget)\n\n    def update_positions_and_velocities(self, func):\n        for i in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n\n            fitness = func(self.positions[i])\n            self.evaluations += 1\n\n            if fitness < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = fitness\n                self.personal_best_positions[i] = self.positions[i]\n\n            if fitness < self.global_best_score:\n                self.global_best_score = fitness\n                self.global_best_position = self.positions[i]\n\n        inertia_weight = self.adaptive_inertia_weight()\n\n        for i in range(self.population_size):\n            r1 = np.random.uniform(0, 1, self.dim)\n            r2 = np.random.uniform(0, 1, self.dim)\n            cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n            social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n            self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                  cognitive_velocity + social_velocity)\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n    def elitism_crossover(self, func):\n        elite_size = int(0.2 * self.population_size)\n        elite_indices = np.argsort(self.personal_best_scores)[:elite_size]\n        for i in range(elite_size):\n            for _ in range(2):\n                mate_index = np.random.choice(elite_indices)\n                crossover_vector = (self.personal_best_positions[elite_indices[i]] + \n                                    self.personal_best_positions[mate_index]) / 2\n                crossover_vector = np.clip(crossover_vector, self.lower_bound, self.upper_bound)\n                crossover_fitness = func(crossover_vector)\n                self.evaluations += 1\n                if crossover_fitness < self.personal_best_scores[elite_indices[i]]:\n                    self.personal_best_scores[elite_indices[i]] = crossover_fitness\n                    self.personal_best_positions[elite_indices[i]] = crossover_vector\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_positions_and_velocities(func)\n            if np.random.rand() < 0.2:\n                self.elitism_crossover(func)\n\n        return self.global_best_score", "name": "EnhancedDynamicElitistPSO", "description": "Enhanced Particle Swarm Optimization leveraging adaptive dynamic inertia, elitism preservation, and crossover-inspired exploration for improved convergence.", "configspace": "", "generation": 68, "fitness": 0.24029020584064611, "feedback": "The algorithm EnhancedDynamicElitistPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.5942997728915398, 0.5828850806904798, 0.5574364046080136, 0.581418119480098, 0.653692330028855, 0.5618483135952275, 0.5911409803656522, 0.6256574274990341, 0.6537235236289314, 0.3479190818458613, 0.2519855901821757, 0.3462790287642602, 0.3082546192927763, 0.03460089294436619, 0.27182841989408435, 0.27699037963165607, 0.20621532332661285, 0.34111453162903316, 0.11278214227865302, 0.1087544363805002, 0.2563714962477882, 0.10248018732994446, 0.11754217818797918, 0.12549204722577656, 0.12129876554783636, 0.12460193434742128, 0.1592696207228419, 0.2004840021729275, 0.08377598081721949, 0.09527272382737861, 0.12550598997774431, 0.11919548369149202, 0.11156105071941491, 0.11198651920614577, 0.09487687430012792, 0.13570316730872378, 0.9880498372206177, 0.9890600932078768, 0.9894431757395991, 0.9802762258522842, 0.9816129704314472, 0.9869999882955306, 0.983533381144736, 0.9819185434639954, 0.9883330770668712, 0.4467658641113439, 0.34834300472993474, 0.3321854760367535, 0.2933614938835555, 0.13956791471455077, 0.2753728472894128, 0.2748406658624616, 0.3388809969675496, 0.3134437692661257, 0.3393661020371096, 0.2368628532294973, 0.31973238295122997, 0.25471203247491025, 0.1994888331527942, 0.1927799997531474, 0.31264730227984705, 0.12634993876947498, 0.21665333500549344, 0.15334581542939485, 0.1006658377317734, 0.09168919953230092, 0.06405143809415859, 0.15359458527462233, 0.1393360445933951, 0.1724920824552162, 0.19629297052063144, 0.20025037994930595, 0.13457629207467525, 0.10541747317182237, 0.017031310271760747, 0.12409275110575313, 0.15896677822790772, 0.14091457521209905, 0.14283910177039305, 0.062015297145202375, 0.07216142513685864, 0.0027422954060061233, 9.999999999998899e-05, 0.004230786586679969, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029644902325451028, 0.05162805162979711, 0.08181248262726859, 0.10123139249922586, 0.0012816558694330737, 0.06834338505689885, 0.0790860351177245, 0.04405365083336232, 0.05891688662780814, 0.029087882912200103, 0.025348659766005976, 0.042418528313072024, 0.10543516147029985, 0.048877073313877695, 0.054025658193738835, 0.05692087197890483, 0.11694332918047168, 0.11581370878944308, 0.07033992019324853, 0.022629024010328846, 0.11427855329518355, 0.08099603025125945, 0.03502652581863297, 0.10135242005009126, 0.18411640330663515, 0.1646851911757945, 0.06137728507379547, 0.4605803312948449, 0.4044446574600571, 0.4695384806060642, 0.42031418151906585, 0.45859365536707986, 0.32279230476800214, 0.47880885307126364, 0.4178773048943396, 0.44332005653685724, 0.10565575211583367, 0.09207883496506819, 0.06898023567967171, 0.12110721031129301, 0.09475304931528294, 0.1022039034082991, 0.11169281217753602, 0.10955802530108938, 0.10395967983249665, 0.26392172742397335, 0.16782261749621197, 0.19375351489745385, 0.1635194845883099, 0.22856150976462375, 0.1715589793021265, 0.2510871423974722, 0.17660731349627024, 0.1813120477176815, 0.3155458677148708, 0.22698748790476853, 0.3680640853816156, 0.3176489642925805, 0.26100005159713113, 0.32442100085165193, 0.34499346220168825, 0.39250533122319886, 0.37782966016587116, 0.21232693890308396, 0.18167235117277292, 0.1556660971105268, 0.236623997737065, 0.22668064558566658, 0.21374014236321426, 0.1777171612515951, 0.3230783785041029, 0.2601592056442994, 0.1963082713890537, 0.19994669377423624, 0.189698913408046, 0.1890355656847601, 0.19126704155210006, 0.2056642152737299, 0.193971283085137, 0.20373547228898747, 0.1967557043793372, 0.19834734251844544, 0.17448934833863883, 0.21770038676824577, 0.22142428443850604, 0.19458409577330493, 0.18373441441887184, 0.19167944422205896, 0.16570169170259486, 0.1948819980546802, 0.6899473234411329, 0.1646613946718084, 0.15387272209272174, 0.7350627741944037, 0.19839315410981007, 0.19434291700213002, 0.72408945803066, 0.16789007808836687, 0.6380904112501128, 0.4500040048042695, 0.1985558007377065, 0.15034852602459048, 0.1971471481496706, 0.4430123948886928, 0.1500010918225122, 0.1997483366506757, 0.19476133202220713, 0.5356237016486493, 0.1900979927077675, 0.1913681645509605, 0.21144370100451193, 0.1973861752435978, 0.19997586806338696, 0.18840225552192835, 0.20067048547054933, 0.21537588561096743, 0.20754962853398706, 0.08084974148607038, 0.09283170119816353, 0.08728827856818222, 0.0930119202201376, 0.08947430616109009, 0.09296748945853883, 0.08768774726391637, 0.09063780136369792, 0.08221845224064839]}, "mutation_prompt": null}
{"id": "ed641de2-697b-4e1a-97d6-eb60cdc2634c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "21fd4a41-0a60-45e6-98cb-5174280dbd63", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "2890e532-0b19-4459-b4a7-b074bf441ddd", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "9fa2b3bc-fe4d-4dbc-b9df-34fad083cd16", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "d89199bf-2271-4f60-8871-3c18a73783d3", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "2c02d5c3-4d9a-4669-8cb7-0aeed2828d04", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0  # Adjusted for better balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # Adaptive reduction of population size as evaluations progress\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Introduce Levy flight for enhanced exploration\n            if np.random.rand() < 0.1:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.01 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential mutation inspired by DE\n            if np.random.rand() < 0.05:\n                for _ in range(int(self.population_size * 0.1)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedLevyDifferentialParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Adaptive Levy Flight, Differential Mutation, and Research-Inspired Dynamics for superior exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8190924500347935, 0.8215598597209004, 0.817007351965218, 0.8064834858511277, 0.8317210554768608, 0.7893572715719701, 0.8034540559629421, 0.8274770900916761, 0.8285375796400701, 0.6931719271909222, 0.6403293660047442, 0.35780519763714547, 0.6538911229335169, 0.6932056010886243, 0.05850905003988971, 0.5932697263714262, 0.6575962821503273, 0.6597315527774023, 0.07183170848499454, 0.14424680235223897, 0.1331152330976667, 0.7340274034357555, 0.07215005361679583, 0.16112932800353486, 0.11801814589467174, 0.10949270695151025, 0.14978235873222168, 0.10593141148822838, 0.11764799995723019, 0.1710689384558871, 0.13831530407518566, 0.16414947300686145, 0.1072867933370264, 0.11558848131949073, 0.144748900093565, 0.1298265171867481, 0.9919416878801299, 0.993649251651997, 0.9929934278522904, 0.9867282577487663, 0.9908274751090099, 0.9891323161861353, 0.9892026494275687, 0.9829352379943853, 0.9890077388694907, 0.6615564176804647, 0.6578269935826762, 0.4670389713832295, 0.6158814962724253, 0.4888369729023052, 0.6885993867235991, 0.6576202553971, 0.6810079192343654, 0.5269171615541567, 0.1707136981779802, 0.7769864556706287, 0.21517022872746094, 0.21211289893012353, 0.21106373152382651, 0.19340510885887263, 0.17388661608105815, 0.14566770635342507, 0.23588836489811316, 0.20510980327518047, 0.20907037993351185, 0.19261050062975205, 0.18956172831753515, 0.21213762393936042, 0.10257003090213457, 0.11943219932198046, 0.23287133586329423, 0.20174973038712996, 0.18719400185337176, 0.10865148659878576, 0.195415487868994, 0.30859284509063656, 0.18257767317086704, 0.22698269338893917, 0.2843759246954689, 0.08969531392711139, 0.15726378785990947, 0.05596772334255151, 0.006661659030818501, 9.999999999998899e-05, 0.007024714360845397, 9.999999999998899e-05, 9.999999999998899e-05, 0.04993517897349953, 9.999999999998899e-05, 9.999999999998899e-05, 0.04366414822112419, 0.03414742358587408, 0.020279425086734415, 0.13110451283837665, 0.010304568787029011, 0.015773531638624605, 0.008082560230773028, 0.05388962413124265, 0.021589033089481346, 0.04397653440005911, 0.03538485264087199, 0.05135250431039917, 0.07196406341914485, 0.08669016270600938, 0.07583739278383494, 0.09294500050089849, 0.06522218143436387, 0.0670009545614354, 0.09698615286390999, 0.03924525829426817, 0.03561453717420049, 0.27274042393618014, 0.008792936623396086, 0.00608687955164966, 0.07818675611887416, 0.07901930184605221, 0.055560403457043495, 0.4995869594963157, 0.5269429682882856, 0.513746042680006, 0.5482381579123246, 0.5152789860847, 0.5126330089692896, 0.5987547373566687, 0.564825032496252, 0.5797536751030306, 0.12967110226991685, 0.08019756342045692, 0.050290004247457, 0.133328930515363, 0.08972557874737519, 0.12163571528237771, 0.14108099747824732, 0.06636590476967308, 0.14460478958349487, 0.1807493922887019, 0.30242776167182517, 0.20936907519716463, 0.27541157569087005, 0.45588476168991576, 0.2326749666811616, 0.402297498515753, 0.19215395352787057, 0.24163260960035216, 0.31586503919076847, 0.18657777199816872, 0.22476283038495426, 0.2320746190789379, 0.3341666880909906, 0.36926043753619053, 0.42344614864735997, 0.44294413597838955, 0.279797841136325, 0.2948436213759691, 0.3445652694606164, 0.23943406042511928, 0.17173932241870082, 0.1831982998060253, 0.27044098045248544, 0.2542842202869582, 0.2415205720342254, 0.3382905948812396, 0.24137801240272472, 0.14547178960679197, 0.2699459948617481, 0.2591770497813449, 0.2006495859117663, 0.16785496407433953, 0.21143041681914776, 0.2041948058501133, 0.19368692569622303, 0.21623731656665013, 0.2122693495263671, 0.238331821404294, 0.21621743736216026, 0.1992650701879054, 0.20693443695525215, 0.1901878659297921, 0.24116889325340685, 0.23493674410780363, 0.7897743944676069, 0.1675521078785207, 0.15264863132360496, 0.8512263358921517, 0.19893802555283802, 0.1987491237892336, 0.09984173186344103, 0.17022622994536518, 0.2104919032065583, 0.69900532853769, 0.15401301679822987, 0.15040766613286793, 0.20706957613063515, 0.5368034169827731, 0.2080221607497933, 0.10499695803844644, 0.1048677055164462, 0.21113816822083875, 0.19589988249772938, 0.19743902716427553, 0.20421256059545967, 0.21852626935822217, 0.18383494040213055, 0.20664101800515378, 0.2155737551714616, 0.20368729182118916, 0.2120829243731599, 0.08210091605474334, 0.08296459457732475, 0.09701912405632962, 0.08839122265843269, 0.10255410891920036, 0.0820974647533631, 0.0878045611445285, 0.09329866724392433, 0.0968245377103154]}, "mutation_prompt": null}
{"id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 75, "fitness": 0.30797473048455853, "feedback": "The algorithm AdvancedDynamicParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "26fe2b30-dcce-4fda-9a7f-b0e417e34b73", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "9a68b59f-1a90-4dc9-b565-c96d54d42679", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "88163882-d415-4535-8dea-9c12aa8b9508", "solution": "import numpy as np\n\nclass EnhancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40  # Increased initial population size\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7  # Increased inertia for better exploration\n        self.cognitive_component = 1.5\n        self.social_component = 1.8  # Reduced social component to avoid premature convergence\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.2  # Increased adaptation factor\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def distributed_mutation(self, func):\n        for _ in range(int(self.population_size * 0.3)):  # Further increased mutation rate\n            indices = np.random.choice(self.population_size, 4, replace=False)\n            a, b, c, d = self.positions[indices]  # Using four points\n            mutant_vector = a + 0.5 * (b - c) + 0.3 * (d - a)  # Distributed mutation strategy\n            mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n            candidate_index = np.random.randint(0, self.population_size)\n            mutant_fitness = func(mutant_vector)\n            self.evaluations += 1\n            if mutant_fitness < self.personal_best_scores[candidate_index]:\n                self.positions[candidate_index] = mutant_vector\n                self.personal_best_scores[candidate_index] = mutant_fitness\n                self.personal_best_positions[candidate_index] = mutant_vector\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with adaptive Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.05 * levy_step  # Adjusted step size\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Use newly defined distributed mutation strategy\n            if np.random.rand() < self.adaptive_factor:\n                self.distributed_mutation(func)\n\n        return self.global_best_score", "name": "EnhancedDynamicParticleSwarm", "description": "Enhanced Dynamic Particle Swarm Optimization with Adaptive Lvy Flights and Distributed Differential Evolution Mutations for Improved Global Exploration and Exploitation Balance.", "configspace": "", "generation": 77, "fitness": 0.28546459914047184, "feedback": "The algorithm EnhancedDynamicParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7980225188655582, 0.786540305268475, 0.7621724762343708, 0.7590431443715127, 0.7681093209458223, 0.7637941452257925, 0.7901685963801351, 0.7801510244622226, 0.7555183041504091, 0.5444909350001883, 0.032623018666855796, 0.5952365927476463, 0.5922402418810271, 0.5897930717254553, 0.6572894911702842, 0.5882136471379265, 0.015203442094769204, 0.617106873220734, 0.13671276351783312, 0.11127954573177046, 0.14655566719559043, 0.16187552870596467, 0.10893394600762041, 0.13542123662256111, 0.140366659729681, 0.14145752032817527, 0.1458156010008299, 0.10109326731262713, 0.10531618612265725, 0.12527841995714295, 0.11682632628444478, 0.09506883081694761, 0.09229588587916293, 0.13951777120333808, 0.12599381332635717, 0.1292818500055668, 0.9864020287054716, 0.9805022283060377, 0.9897526048611056, 0.980311174982839, 0.9759737885983307, 0.9886505852198424, 0.9840088446122316, 0.9799926115780893, 0.985657591572296, 0.6920778578872209, 0.6242485036104066, 0.6030529969777221, 0.5100313516186072, 0.6200717944011189, 0.6305902697716084, 0.6411063466996135, 0.5453816224765484, 0.3846914676584152, 0.22510940156122916, 0.7676072143686187, 0.17191826863319803, 0.7016487226236032, 0.20832955913898188, 0.2132339155492321, 0.12909141356385057, 0.34687554087966566, 0.21507584240157707, 0.2293002132695816, 0.11511278347552711, 0.1903334485965278, 0.17512875737410727, 0.11815722455612343, 0.17472772682627236, 0.18428674405839962, 0.17469779613067882, 0.20948528191747173, 0.25480697919789264, 0.17946582199892291, 0.17908194560054547, 0.17091505555415676, 0.1384240738836059, 0.12489268479001459, 0.1278219145553794, 0.12870724890364904, 0.20104616375339424, 9.999999999998899e-05, 0.006143561223173277, 9.999999999998899e-05, 0.027007169200843784, 9.999999999998899e-05, 9.999999999998899e-05, 0.03937251325270441, 9.999999999998899e-05, 9.999999999998899e-05, 0.04554619046367847, 0.06684600870474444, 0.07600131383013575, 0.03920990033829874, 0.00015424425215937454, 0.052894949719747286, 0.020129739213147646, 0.07270632711292346, 0.08108164626281322, 0.04257261255108624, 0.040480667860924635, 0.2664542756086702, 0.06973294977056044, 0.14978741276837737, 0.07188270919050244, 0.09923210065720944, 0.11827199547105538, 0.20625452430300883, 0.08559204987121449, 0.11006287973076634, 0.0550547508069934, 0.13630788961990004, 0.11428032224558504, 0.10729030709712584, 0.05661252199724054, 0.33762490340338824, 0.0750644238576097, 0.5758896000003011, 0.4760967357332875, 0.48967368834146474, 0.573004614936488, 0.48974571935245237, 0.479523714027531, 0.5679648010402936, 0.5343814485713618, 0.5276557884837391, 0.09429996374629113, 0.09693791227611759, 0.1152749025935329, 0.11481993627136178, 0.10730546611445357, 0.13367575479352922, 0.06135693516331797, 0.09373268075576757, 0.08839055468099466, 0.22542039810893755, 0.18305903163528603, 0.1979994975411591, 0.1932058604005188, 0.29770106845917155, 0.24235573316889736, 0.19004488373417905, 0.1628757364226605, 0.22082204406496542, 0.359171512102755, 0.243304600716289, 0.32347988307368614, 0.2468835176091021, 0.216667581913651, 0.3710752429387659, 0.3650567285500027, 0.4127015073400774, 0.3464731214098088, 0.27134171550599295, 0.21840355029334468, 0.20983275761168363, 0.20313899595719298, 0.24862108984371956, 0.33495818595018223, 0.2556037123492929, 0.25347672918015474, 0.19903743604314872, 0.21008894447863835, 0.13747639409260481, 0.19579321454218923, 0.20902765771297005, 0.18889617874925235, 0.23187876639760596, 0.2260007336745199, 0.1947770133330311, 0.23814340982204507, 0.20425748171482538, 0.21708543087227217, 0.2062630396212075, 0.20220929161587797, 0.18714602007438375, 0.19004492670337336, 0.2048411542736892, 0.6794263142558372, 0.2409937164692112, 0.8313696125359815, 0.16594889338523422, 0.15270997159622313, 0.8524084744542773, 0.19957168501939582, 0.19806030073780634, 0.14164497868101167, 0.1687686091127263, 0.20995508269207896, 0.6859168029781547, 0.20883739634262644, 0.3889641597495681, 0.5349433485253055, 0.16569194300465429, 0.14629540312408718, 0.10444770982754237, 0.10477018306111896, 0.6788256033028057, 0.21398660758875476, 0.18947276674555835, 0.20193017217040043, 0.20652370720687097, 0.21890358426708323, 0.19486016616206814, 0.23062606700351762, 0.1971035035287817, 0.18629262404997848, 0.08791424458493402, 0.09785014899046873, 0.08013848379715927, 0.09486370981440317, 0.08967993582374378, 0.0920060889637887, 0.08946391696287814, 0.0946942971744551, 0.09527496178326911]}, "mutation_prompt": null}
{"id": "d4826fe2-8376-4f2c-9414-79ac0c3b72cd", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n        self.fitness_landscape_factor = 0.05\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def fitness_landscape_analysis(self, func):\n        sample_points = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n        sample_values = np.array([func(point) for point in sample_points])\n        diversity_measure = np.std(sample_values) / np.mean(sample_values)\n        return diversity_measure\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            diversity_measure = self.fitness_landscape_analysis(func)\n            adaptive_mutation_factor = self.adaptive_factor * (1 + self.fitness_landscape_factor / (1 + diversity_measure))\n\n            for i in range(self.initial_population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = 0.7 * (self.budget - self.evaluations) / self.budget\n            for i in range(self.initial_population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = 1.5 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = 2.0 * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < adaptive_mutation_factor:\n                for i in range(self.initial_population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Adaptive differential evolution inspired strategic mutation\n            if np.random.rand() < adaptive_mutation_factor:\n                for _ in range(int(self.initial_population_size * 0.2)):\n                    a, b, c = np.random.choice(self.initial_population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.initial_population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm Optimization with Dynamic Fitness Landscape Analysis and Adaptive Mutation Strategies for Improved Convergence.", "configspace": "", "generation": 78, "fitness": 0.2560079425221588, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.695403300242198, 0.7021764806796127, 0.7285884853017208, 0.6873075207729552, 0.7123320122241998, 0.7088299134059185, 0.7266823573878012, 0.6714336841931614, 0.6480011120637497, 0.4776405951031112, 0.46128243519190615, 0.3976039705077984, 0.4764433941292888, 0.03899884920836305, 0.47004929290563247, 0.46741067148223103, 0.5200175457071435, 0.4307105395855255, 0.07095242757450282, 0.14283899519610388, 0.3768587885025978, 0.1258533131153079, 0.07012992266923868, 0.11763576679415055, 0.3898784814835943, 0.11291758831534171, 0.12416303017313368, 0.12055383107619322, 0.11934228221854215, 0.09450550924800194, 0.15121780502315108, 0.11083379193535325, 0.44295850802638403, 0.05984056865114451, 0.12381568607552396, 0.1177764747668214, 0.9841068030347259, 0.9896717562183783, 0.9871236098055716, 0.9797737155914598, 0.9805286634614642, 0.9811616572098147, 0.98125132973553, 0.9851022505335002, 0.9853042751950317, 0.4243608541166154, 0.39900301244487624, 0.4181783088123562, 0.402048807038346, 0.3938667677182984, 0.3322777215604047, 0.4098110129893836, 0.4276104420784008, 0.40784806711223454, 0.20673157528282815, 0.1640549973718709, 0.21884524390157134, 0.20852554498951004, 0.20173818206868022, 0.19059349008304138, 0.19217596179898333, 0.14466362483210737, 0.20554466479812084, 0.16107966421607745, 0.18777503686436658, 0.15614705395948603, 0.1641586629539754, 0.10212651302942466, 0.1141043938783578, 0.15264496118156912, 0.12318926771900696, 0.14966235661421323, 0.10275227001953446, 0.11805518477058796, 0.15793905893572757, 0.16139587883320605, 0.17272935914547738, 0.19607258415604678, 0.11130502775832463, 9.999999999998899e-05, 0.17882064368856643, 9.999999999998899e-05, 9.999999999998899e-05, 0.04943242627887379, 0.0064135075879862, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006407153484626615, 9.999999999998899e-05, 0.032542418040074184, 0.06451076626398988, 0.02993753379958397, 0.06490817742548771, 0.08252265730009489, 0.042377458805529344, 0.010862582960257217, 0.048762289278014626, 0.056275334433165014, 0.028942801690639675, 0.041135039539613394, 0.06821318107303231, 0.03860468760805014, 0.05990816760688544, 0.06958348318499741, 0.05525390074780079, 0.06506466179697512, 0.05327062536119376, 0.0728884606958542, 0.048846483667096985, 0.0797340247532855, 0.127535122686931, 0.16003144982066475, 0.07620184650204542, 0.17782072513904734, 0.052947684334016976, 0.046343882909522294, 0.16619268478894533, 0.4979525887196442, 0.46612318777586126, 0.5085996892951383, 0.4729561309705751, 0.47039835663594354, 0.49000411578801284, 0.5393861292150168, 0.4615320292664301, 0.4792730496677131, 0.0966382612169211, 0.06461114644151844, 0.06144800950470852, 0.12679122865549997, 0.12653872261766352, 0.11471748537550652, 0.0649770933516629, 0.11185073008259938, 0.09395120458642559, 0.2512909527188951, 0.28335723253432954, 0.20777271795903562, 0.19282457468896386, 0.25500727807302637, 0.15814820741154112, 0.16957546711906868, 0.1538991054869734, 0.18195506486606294, 0.2626426570149176, 0.35444519557486154, 0.22467891321925448, 0.2828801970948923, 0.348057704725529, 0.35160329794518375, 0.36378117554919054, 0.4042007228892548, 0.40275394111862073, 0.1791690682582483, 0.1699426882584063, 0.21498902104162476, 0.254970990037825, 0.18276846318176543, 0.2209268209273515, 0.3140319082833325, 0.2988767408713736, 0.39999498187860927, 0.2156350451302902, 0.17023083911683712, 0.18420489738215706, 0.1930144397862109, 0.18882712562434179, 0.21565792694752528, 0.1977786365726435, 0.1868331264678872, 0.18352473448261253, 0.18603563652968746, 0.19278235963122747, 0.2126653708359748, 0.1894389713863035, 0.22293460754141792, 0.22057178252184784, 0.19505109459810788, 0.2055227336407328, 0.1979360384053277, 0.16408452333982093, 0.16676310459624388, 0.15278503904005647, 0.17638152335292911, 0.695522839354563, 0.16661642878755722, 0.1402752390541807, 0.21169346381816023, 0.7552708487719799, 0.5804377527630749, 0.2087920857724036, 0.15579356328539307, 0.20023947638844175, 0.16416492735628485, 0.21313061400045086, 0.20595108115716143, 0.20604584887436084, 0.6751018123598963, 0.22333812363565264, 0.18209459648787418, 0.21111905971339073, 0.19791588626968415, 0.19352216077954987, 0.2366839675580843, 0.19944056274096322, 0.2007451813212554, 0.19655648625079836, 0.07541189935672077, 0.09233433020318627, 0.07943277899442269, 0.09604143926216602, 0.08238970957428193, 0.07179608814304739, 0.08760662033897404, 0.08309983239096652, 0.07504710532362857]}, "mutation_prompt": null}
{"id": "5841d0cb-4056-48b7-b0e9-7f799cc4e5ec", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "7b23393b-c171-4662-822e-715496a0540b", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40  # Increased population\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7  # Adjusted inertia weight for better balance\n        self.cognitive_component = 1.5\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.15  # Adjusted adaptive factor\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        # More aggressive reduction strategy\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                mutation_term = np.random.normal(0, 0.1, self.dim)  # Gaussian mutation for fine-tuning\n                self.positions[i] += self.velocities[i] + mutation_term\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.3)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])  # Modified scaling factor\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "HybridAdaptiveParticleSwarm", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution and Dynamic Learning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 80, "fitness": 0.19879075194244336, "feedback": "The algorithm HybridAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.40961887928957086, 0.35953656367180997, 0.40621408117688007, 0.3946552304835198, 0.38708404809957464, 0.38241822998577324, 0.403070917695842, 0.4486637640544131, 0.3748295602433869, 0.011117828420226017, 0.006206905844718502, 0.002525810701834441, 0.03492073737552692, 0.0070349512270849734, 9.999999999998899e-05, 9.999999999998899e-05, 0.012569309904993498, 9.999999999998899e-05, 0.08589517407745006, 0.1108942788884073, 0.0901230661091369, 0.07457867626228509, 0.066311418109535, 0.09868033155308076, 0.07623267217513963, 0.09607936439238729, 0.10692595432930718, 0.09729153375284239, 0.09934976892583747, 0.0844030621915366, 0.0949659014240184, 0.11006351563254524, 0.09821182234853854, 0.0950090996542049, 0.0851416062824899, 0.08888110448599496, 0.981563374656585, 0.9902947868441904, 0.9878573466478586, 0.9704642455255804, 0.982659239683017, 0.9818406101093274, 0.9845683807509436, 0.9856915744405697, 0.9855945876159876, 0.25627800414466806, 0.251548694075002, 0.23708113570255696, 0.2515828281050627, 0.24352922969907198, 0.2570009631076613, 0.2310558077623922, 0.2583801756411209, 0.27149409406027003, 0.2201361863290654, 0.27794618716476094, 0.21765617926731196, 0.26219181162650085, 0.19664824458608965, 0.2450893510673039, 0.19371976527547685, 0.2665564652448922, 0.3370176728293268, 0.1336243587419994, 0.13586892476010892, 0.10322948560278566, 0.11545758149476548, 0.14941291317836747, 0.11016642426312062, 0.13127043921851034, 0.08112540933542367, 0.15297143307599548, 0.13918394253744104, 0.13305520659300873, 0.14848020097642622, 0.15268272120946136, 0.11963015254320375, 0.16347024248433206, 0.13018047034512614, 0.07820896835940416, 0.08061959120829965, 9.999999999998899e-05, 0.00833615877474636, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030342053426088977, 9.999999999998899e-05, 0.0011793885869360032, 9.999999999998899e-05, 9.999999999998899e-05, 0.048886925706852935, 0.06717050013342196, 0.07324741592421358, 0.03214993750349804, 0.0034726933433674168, 0.018346452173617966, 0.10737819461650155, 0.04332877843266125, 0.02918503496214453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010888810602240895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09403100173589896, 0.03862785658610646, 0.08493173624509565, 0.06569512100356079, 0.07225599496045865, 0.072467181440664, 0.07691532014611058, 0.044177264979597064, 0.08752852719831539, 0.3811757491443948, 0.37720072848723873, 0.3852668685845495, 0.3718563685597257, 0.36361869073411157, 0.35667419011820534, 0.3917080829003319, 0.3683340252817817, 0.3658149373537495, 0.07746583050800926, 0.08693343253191343, 0.10936397382525154, 0.10944312765245345, 0.10577994129639012, 0.10092121293320055, 0.09313381847711877, 0.08947709912238389, 0.09238607524859543, 0.174019550291449, 0.23468497319778803, 0.15988837179509574, 0.25480180188415646, 0.21564260933472323, 0.1665453551963435, 0.19854273932195876, 0.2337831212597854, 0.1930035954082182, 0.25392216576142324, 0.2668348159257049, 0.2662229321789049, 0.2823179869163813, 0.2616914625647553, 0.2592576142079943, 0.26599840889737936, 0.27886252918109267, 0.24077822283886108, 0.17343883864010057, 0.1699513836258606, 0.1524597488437328, 0.15191191802868287, 0.18615256783969958, 0.21532519642862302, 0.1743861522828225, 0.2049739804597791, 0.1932006312867739, 0.1989448467992474, 0.1501456332833091, 0.19090343636647367, 0.19784178971502608, 0.18435463037730793, 0.22560954695143454, 0.19192347101818774, 0.18119175155141054, 0.20612833320485546, 0.18433386147089836, 0.20397771736738846, 0.18554784180948802, 0.18579726229577975, 0.18821775315361733, 0.19743968114943578, 0.1924161991624571, 0.19583456594238702, 0.20115639408159025, 0.1782538042913797, 0.13903111366530152, 0.15177377732142505, 0.5447046109602693, 0.5430887088172277, 0.19334155973629952, 0.1416388031401662, 0.16744738518760682, 0.20764533928686046, 0.4267879359649087, 0.20729541087875325, 0.42289728244558134, 0.49197109129481953, 0.42294690927629797, 0.14648210482964263, 0.20949255636586928, 0.10495078142881542, 0.3182497202774017, 0.20689981190355433, 0.1869412540795935, 0.1826198609510039, 0.19628931950043949, 0.17758169488064945, 0.1762304745107689, 0.1717672741542443, 0.18639145605409235, 0.21898156460303175, 0.10700680767881399, 0.08405000561875897, 0.07889873164683903, 0.07913211549791599, 0.08291168787572367, 0.07443148205540095, 0.07901255058764056, 0.07330264386817731, 0.08271209935782631]}, "mutation_prompt": null}
{"id": "86ca842c-8ef2-497d-8cf0-901037203eb7", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7  # Increased inertia weight for better exploration\n        self.cognitive_component = 1.6  # Slightly increased cognitive component\n        self.social_component = 1.9  # Reduced social component\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.2  # Increased adaptive factor for more frequent adaptation\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with adaptive strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.03 * levy_step  # Increased levy step size\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Modified strategic mutation with differential evolution\n            if np.random.rand() < self.adaptive_factor / 2:  # Reduced mutation occurrence\n                for _ in range(int(self.population_size * 0.3)):  # Further increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.4 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedParticleSwarmOptimization", "description": "Enhanced Particle Swarm Optimization with Adaptive Techniques for Improved Global Exploration and Convergence.", "configspace": "", "generation": 81, "fitness": 0.28712136095761176, "feedback": "The algorithm EnhancedParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7921532566555498, 0.8016034106475489, 0.8152089312303685, 0.7692266438854358, 0.8037281051697522, 0.8197269055433837, 0.8461594594106483, 0.7818780118491315, 0.8035530347885915, 0.6677434669705031, 0.6068224709891228, 0.03863406007315695, 0.5911815481521703, 0.04307350071982852, 0.6734690118710999, 0.4751447646620872, 0.7039307773292586, 0.7094646902021255, 0.15150691357521995, 0.12945614036545772, 0.19995701199046367, 0.15055612547913666, 0.10420639616310023, 0.16550558910003965, 0.174053864276985, 0.17357952390714126, 0.1683642232066761, 0.135276137875751, 0.14134038212823674, 0.1411651234525121, 0.1379809671828892, 0.1197496168637866, 0.12786315544179883, 0.09400248838595981, 0.13998173430049887, 0.1053791377381702, 0.9890071168637605, 0.9935980752467108, 0.9924829463607804, 0.9775351436965801, 0.9907751535795474, 0.9882496105483682, 0.9839851475426294, 0.9826140682065949, 0.9885739545950073, 0.5661832670653351, 0.5339802576216506, 0.6932159949744131, 0.40452303922026345, 0.66334415958655, 0.47011257379686056, 0.6367578316355279, 0.6530628921417299, 0.45515272366171056, 0.16971347846067586, 0.7294896146334765, 0.2187862888498362, 0.24873897711638948, 0.18548999231089647, 0.19072168547314228, 0.11966714073344376, 0.5495372160045356, 0.1415869156049714, 0.21489055350986996, 0.2095736005439811, 0.18168308306724057, 0.12344905976868426, 0.1861316780993041, 0.11963747173605588, 0.12367637255644492, 0.12225633729258645, 0.1831891372130019, 0.18963519984061938, 0.11390751458697779, 0.18206587186529066, 0.21746077830053623, 0.17526209536897808, 0.20817289631134916, 0.21819273002051454, 0.009700362042774358, 0.21936119233213902, 9.999999999998899e-05, 0.06662862773515066, 0.002660407809515708, 0.016085091427071374, 0.006248575688650115, 0.014904350210165451, 9.999999999998899e-05, 9.999999999998899e-05, 0.007472956685843246, 0.0676689272633616, 0.03387373741458655, 0.08301785793902705, 0.05097286053700245, 0.013173828425046885, 0.028765607677709193, 0.08483997175170266, 0.053474376588506844, 0.04131763750315853, 0.04613028517214568, 0.04622041319915893, 0.1605105071376447, 0.06874059115290387, 0.08820969319992367, 0.07377842591982531, 0.09047071173325294, 0.06413475620381615, 0.07016871497422095, 0.15034502400920846, 0.04027938882948123, 0.03475659650180185, 0.05649239012392737, 0.08265187636653559, 0.10849161756335035, 0.09084128223085575, 0.084789265420535, 0.07700585852892072, 0.5183432846175839, 0.48026866769529575, 0.4925051422650575, 0.6525388160283105, 0.5809739983893614, 0.5559876830133308, 0.5232884674547857, 0.5029925818943461, 0.5118515981837053, 0.06078112100838784, 0.11486641177424206, 0.09645919287339189, 0.12976048262267592, 0.16411563523281492, 0.10902121498000328, 0.061066261326833904, 0.08494322903817697, 0.14782507839360426, 0.24410308524417068, 0.22971806486691349, 0.26377196068700226, 0.2843411599895165, 0.47450278670814194, 0.2154453254707429, 0.5049891456273898, 0.20508683562168528, 0.20152265906371802, 0.15510121451778525, 0.24824201843068794, 0.3343241709262542, 0.328091820189791, 0.32502698617727954, 0.3138544320714397, 0.47221719906953963, 0.38446036058793, 0.2964377347564744, 0.2589420063451596, 0.20537151624267747, 0.27820314834921356, 0.4117869598059376, 0.19419704860860265, 0.2138467517917838, 0.29116107845492323, 0.3233973201269902, 0.2887008684083331, 0.24541383452680376, 0.14071942421108075, 0.2104940180302316, 0.21838455407414548, 0.24434317654850213, 0.19136752144281677, 0.23397383271580563, 0.22618403484338867, 0.16790544667028096, 0.19708976401186773, 0.23277263245187962, 0.22178683609963668, 0.21762202872525105, 0.2144292420688888, 0.22757622687501422, 0.20004464521211118, 0.18140537762357467, 0.1766782715173948, 0.8554565609896763, 0.16723777867132816, 0.15303343273260872, 0.8392857203040651, 0.19769371185928897, 0.19777800014417257, 0.14703054256865522, 0.16941259432717581, 0.21001127126913344, 0.8095757469900637, 0.15313309889767168, 0.11216574148719316, 0.2019606681607622, 0.4952145789025939, 0.6742648607579436, 0.21145744978049308, 0.20889188685991789, 0.1954288362708667, 0.21424047244815425, 0.2132695872750141, 0.19759975011017417, 0.19302297390394885, 0.22265877140776102, 0.2316287321881867, 0.206192621789545, 0.18904288185739326, 0.2357881147749069, 0.08888337779719935, 0.08679091713712717, 0.08747200199595173, 0.08644306109565492, 0.09421555300949491, 0.09260205841264746, 0.09113346617973017, 0.092979194763261, 0.08941456264838199]}, "mutation_prompt": null}
{"id": "c1d1eaa2-dc12-428e-8233-ff9c6a0ad774", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "72c1a664-a71d-4db2-99fc-0c6595010510", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "99780e3d-c99d-4c64-8607-c452564266af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 40\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.dynamic_mutation_factor = 0.05\n\n    def gaussian_mutation(self, size):\n        return np.random.normal(0, 1, size)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic mutation with Gaussian perturbation\n            if np.random.rand() < self.dynamic_mutation_factor:\n                for i in range(self.population_size):\n                    mutation_step = self.gaussian_mutation(self.dim)\n                    mutant = self.positions[i] + 0.1 * mutation_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Local search strategy\n            if np.random.rand() < self.dynamic_mutation_factor:\n                for i in range(self.population_size):\n                    local_best = np.copy(self.positions[i])\n                    local_best_score = func(local_best)\n                    self.evaluations += 1\n                    for _ in range(5):  # Fixed number of local iterations\n                        if self.evaluations >= self.budget:\n                            break\n                        candidate = local_best + np.random.uniform(-0.1, 0.1, self.dim)\n                        candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate)\n                        self.evaluations += 1\n                        if candidate_score < local_best_score:\n                            local_best, local_best_score = candidate, candidate_score\n\n                    if local_best_score < self.personal_best_scores[i]:\n                        self.positions[i] = local_best\n                        self.personal_best_scores[i] = local_best_score\n                        self.personal_best_positions[i] = local_best\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Adaptive Particle Swarm Optimization with Enhanced Convergence through Dynamic Mutation and Local Search.", "configspace": "", "generation": 84, "fitness": 0.2908802981217254, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7912630482880495, 0.8239856113947939, 0.8195538995561399, 0.7793124290279919, 0.825518716309751, 0.7888434635265373, 0.7968605115934989, 0.8058663634951508, 0.8004717020085205, 0.6593492677369963, 0.6300146577200456, 0.5657436768331523, 0.6199716916040852, 0.0428585014645414, 0.037812470877968685, 0.004786685491299791, 0.7154920391656322, 0.6670532951738466, 0.09370850831079136, 0.12757078736445493, 0.13423355133045212, 0.14146709898755072, 0.10848627303296632, 0.11098694145833887, 0.5610106343728204, 0.1552487800413508, 0.15366531396925331, 0.14303765755717956, 0.10304580166861599, 0.13492147884330297, 0.11008875759595116, 0.10884369532605032, 0.16074146924060295, 0.05776353035577064, 0.10854600240247614, 0.11190473004940471, 0.9855645098522138, 0.9893498057955917, 0.989560857934936, 0.9758598403390746, 0.9786126219302129, 0.987497796908974, 0.9817389584850524, 0.9877406618332132, 0.9854015484057006, 0.678091489549945, 0.6937548267305889, 0.5641695613493158, 0.6325016607109593, 0.5054750364427514, 0.5614789113760653, 0.5588643374080655, 0.5364248152413259, 0.600511757809212, 0.2268944681243117, 0.3526564242284741, 0.7517348901775958, 0.26601612813885256, 0.20497527335782684, 0.2763147942249129, 0.5174147569552616, 0.1233422433333099, 0.21330380920994063, 0.18130566993266417, 0.18302628165755042, 0.19089279731174214, 0.18699530350723104, 0.16796270161644533, 0.12805772715397012, 0.1829347857215976, 0.17384211093846058, 0.1807525701152124, 0.19076413997976083, 0.2033850317002811, 0.10928960022688172, 0.12766117954261536, 0.10699241370365231, 0.2091387542613674, 0.1878549568262733, 0.23713290293072065, 0.12785692820814532, 0.0062689122162659094, 0.006623962485186929, 9.999999999998899e-05, 0.0018155490557999476, 0.005606297586904674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046508186237836924, 0.02950782023412979, 0.12438948956050644, 0.07449119644034685, 0.012707662595553115, 0.05115050857837666, 0.04463076188211801, 0.21354724373743617, 0.03804234430031406, 0.07367524261860203, 0.03279916621473711, 0.054393987410067846, 0.1922155470111524, 0.09057779756145823, 0.15241175002322793, 0.08495193543895097, 0.09049890763033452, 0.08632139430900554, 0.13233077023005846, 0.050428303278498565, 0.09420112204205111, 0.1524215540454772, 0.10228295754150984, 0.13169521604088208, 0.08213652099266489, 0.08502459401138163, 0.08650524450648622, 0.5295557896982531, 0.5407301899288028, 0.48538751557446713, 0.5518679759730816, 0.49519327818574177, 0.5074101905430151, 0.5138207515090373, 0.5214363477642645, 0.5082859242639086, 0.13631433616652888, 0.13848589671911393, 0.14765004696492945, 0.1119634052186862, 0.13147476271574854, 0.11343260541086397, 0.1717045363621581, 0.1438298059774763, 0.14647602811737692, 0.19197697967382732, 0.2428502164347428, 0.18238782175684465, 0.26881289379558215, 0.17806487792259773, 0.23187806117071008, 0.26442495386029363, 0.19471992072762123, 0.16516029560202639, 0.3010306557070531, 0.3660220971614263, 0.31384050675298825, 0.22707420851730487, 0.34393769352541526, 0.2782950328593694, 0.449326738165428, 0.4575070192266696, 0.31256862133065966, 0.3025663562472859, 0.2968140466578497, 0.2978015800972046, 0.20166688435450697, 0.18440633502748438, 0.20562011399326297, 0.25310002343387494, 0.21249652131787844, 0.30001417389769836, 0.22311994815359826, 0.15675578544135438, 0.20838153608452248, 0.20238175498759214, 0.2170456846685136, 0.2014920594050913, 0.21423203767163657, 0.1898147375413739, 0.19974454880570536, 0.20033039344192116, 0.20452384426605452, 0.21530227768976629, 0.6679107876206642, 0.22393947206393727, 0.19360778258740252, 0.21701917616220368, 0.215489352051206, 0.20810066513786718, 0.8402818479345571, 0.12649735884495406, 0.15361825797260442, 0.8719255640935228, 0.19867220863692847, 0.19937753479197062, 0.14226612406304373, 0.1700483229649684, 0.8313413456972832, 0.638044095967014, 0.20828843978659284, 0.5386060772186148, 0.2048536447005942, 0.4538230514926881, 0.1546146607982919, 0.105118537793924, 0.10452024051156772, 0.5023119956046168, 0.20642776894586556, 0.1836880839299807, 0.20298299700519118, 0.2070830834210856, 0.20535248825837105, 0.23591499353187606, 0.2160238147597202, 0.1861181528866176, 0.18731538948691506, 0.11633967065184514, 0.08246237915025578, 0.08670298228607187, 0.08496027444337473, 0.09565968982016981, 0.076411233104685, 0.11402766783760365, 0.10304666930225903, 0.08505325632467753]}, "mutation_prompt": null}
{"id": "4b927518-5a29-4047-b120-7baf4ae8772d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.2\n\n    def levy_flight(self, size):\n        beta = 1.7\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(8, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (0.5 + 0.5 * (self.budget - self.evaluations) / self.budget)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.03 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Enhanced Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.3)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.7 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedAdaptiveParticleSwarm", "description": "Enhanced Adaptive Particle Swarm Optimization with Dual Mutation Strategy and Dynamic Inertia for Superior Convergence.", "configspace": "", "generation": 85, "fitness": 0.2776607942766955, "feedback": "The algorithm EnhancedAdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7793395778343478, 0.762073960956087, 0.7764359771148328, 0.7264656020004381, 0.812347417176967, 0.7841504940825215, 0.7553688191693453, 0.7569999121616466, 0.7628984358650156, 0.5949736049427019, 0.5738091121755595, 0.07823162756879831, 0.49914009518504454, 0.5788288768154584, 0.534284043218451, 0.5696680501750016, 0.5420874058383551, 0.5926461158320095, 0.10341186052697737, 0.5376204182070738, 0.1267172117122356, 0.15752853822118595, 0.06048457058732348, 0.11213092016024961, 0.15811668400568724, 0.10165659825979778, 0.1362816349564615, 0.1366684321971361, 0.10805653580420926, 0.12835497622727088, 0.13314766634716357, 0.11003165085930089, 0.10076596304657015, 0.12357453950981656, 0.11784160079657535, 0.11884895241810645, 0.9891174179346492, 0.9936502434941508, 0.9904700303377842, 0.975334254293011, 0.9908475635947479, 0.9869929600046331, 0.983941278284996, 0.9827587953185817, 0.9886850310580874, 0.47626170501321774, 0.5498668547298056, 0.5885062641274201, 0.5878694254439596, 0.5189325838193617, 0.5942776641045739, 0.5689400721386059, 0.59788062436046, 0.5756698996355278, 0.20927498900925479, 0.6534977610882028, 0.5693084122515468, 0.7569002866122899, 0.18255014218285315, 0.1862349804844614, 0.11611928073700983, 0.20533795077310701, 0.3300614783382836, 0.18515316806929505, 0.1884122468514715, 0.16775108747308165, 0.18560651014085228, 0.1264710486148859, 0.17070198687542526, 0.11502144279265791, 0.19736628390490119, 0.1639986507934622, 0.2056556978632238, 0.10659493238203177, 0.20066982431196234, 0.19146669514526382, 0.21248994819275802, 0.19530992559164762, 0.0856532419573881, 0.02093730421113138, 0.10419591017086949, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01973784839006365, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041213126107040754, 0.05696268789518544, 0.0957770684257474, 0.07372145042620182, 0.03533107438758909, 0.027112943423238223, 0.12261178060072886, 0.05528842424702074, 0.026959921931018482, 0.04052338798363597, 0.030230006557595668, 0.1338981009983783, 0.058326802613862805, 0.08316434030800335, 0.07664548628947288, 0.2919848682157864, 0.06998419200995143, 0.07969017079472307, 0.03824029258613171, 0.03997933752792138, 0.11802979967816829, 0.007258507355763277, 0.02721324174399742, 0.02999962366931308, 0.08013700967652881, 0.08100353413911143, 0.09349428293791284, 0.5271689927047922, 0.5142074428929803, 0.4797979922484986, 0.507976680382108, 0.5356536147251653, 0.4881116059815578, 0.5161877979087954, 0.5249726743966794, 0.5072695159021936, 0.1425525464813472, 0.08212764479672063, 0.09687405542437533, 0.092077650517976, 0.08825276282944339, 0.12947118221995424, 0.07971196453478446, 0.06608992556227056, 0.10443457521978095, 0.21398718341236367, 0.3879792672576027, 0.15797177526471784, 0.23953218274244248, 0.34743651684284127, 0.1509484092676736, 0.3757540199189001, 0.2677004878013455, 0.18620819433160285, 0.22887989083685312, 0.1879927026787921, 0.421459144285935, 0.22027380181779943, 0.3142125466083977, 0.30878129004604793, 0.2829481641140985, 0.4691791975055597, 0.4553078497607327, 0.20502709590558554, 0.22583843457442687, 0.17791934423556954, 0.20542906320554044, 0.1481866252245403, 0.25767593722151816, 0.3493935543251966, 0.2517800723579634, 0.24752458154177115, 0.20063620388020997, 0.15188984259979277, 0.19884594700037517, 0.19094846151293376, 0.21647687437112628, 0.2100681167457814, 0.1972242076090449, 0.1800545110041989, 0.2088274520582959, 0.18094616587374968, 0.2178645701020624, 0.19812735365301637, 0.6251861110120172, 0.22631280654860841, 0.19605663499576165, 0.2020564416906473, 0.2175769861805218, 0.21740540092847827, 0.16341416119572072, 0.1678815601622553, 0.15330591922649184, 0.8594766475804858, 0.19931395044934974, 0.19792970197149773, 0.09921878724471789, 0.17013258994876346, 0.20926061618804093, 0.5455940706494471, 0.1535660632082798, 0.11258103059412639, 0.20215425383522456, 0.5200708726436035, 0.2056729724150621, 0.2092272088010424, 0.2035398720652002, 0.21108619433792786, 0.23061548765385265, 0.18213401412430774, 0.19723642659177232, 0.20345823047043043, 0.19532466438911023, 0.20493646941914556, 0.18995842098610172, 0.19485765605654404, 0.19480740717369271, 0.11141178216844705, 0.09425322627277744, 0.06277941546465737, 0.0851432001414314, 0.10537052637319388, 0.09938417177991832, 0.09842706324526951, 0.08812074689772453, 0.0892650890700386]}, "mutation_prompt": null}
{"id": "afe56447-def5-4e21-ac11-207674e954d9", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "ace4b6d4-dbac-4d0f-a3c8-9c2477c533d5", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "f17abae9-b1ac-49dd-8304-baa2fb3ac04f", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "78a2188e-d976-449a-80a6-eabba8232156", "solution": "import numpy as np\n\nclass AdaptiveEliteParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.elite_fraction = 0.2  # Elite preservation fraction\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_component = 1.5\n        self.social_component = 2.2\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return 0.01 * u / np.abs(v) ** (1 / beta)  # Adjusted step size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            # Linear inertia weight decay\n            inertia_weight = self.inertia_weight_initial - (\n                (self.inertia_weight_initial - self.inertia_weight_final) * (self.evaluations / self.budget))\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Elite preservation mechanism\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(self.personal_best_scores)[:elite_size]\n\n            # Enhanced exploration with dynamic Levy flights for non-elite particles\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    levy_step = self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                    self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_score", "name": "AdaptiveEliteParticleSwarm", "description": "Adaptive Particle Swarm Optimization with Elite Preservation and Dynamic Levy-Driven Exploration.", "configspace": "", "generation": 89, "fitness": 0.20725394684013107, "feedback": "The algorithm AdaptiveEliteParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.48049990618617655, 0.528779573711581, 0.5290882720685706, 0.5364027018443549, 0.5252846077328875, 0.5076897232294042, 0.4985247219744917, 0.5523020760667268, 0.5470833160424748, 0.1914821845945488, 0.0361471481900999, 0.18160610721898407, 0.01973155663868087, 0.26786016660305423, 0.21806183941896895, 0.030765491642960496, 0.06256363209458782, 0.026796119344470237, 0.06787346073429634, 0.0931181795535555, 0.06602173377341891, 0.13699883316901973, 0.11670121052663762, 0.08031509986668695, 0.11370054919293615, 0.12723034904176656, 0.12545264161525171, 0.09794039594395176, 0.09283322534857541, 0.10129761723456054, 0.10725648790458331, 0.10715627499739244, 0.07959811575018794, 0.08081631228755903, 0.0813805452278501, 0.0830729117870731, 0.993391057449957, 0.9936935213206625, 0.9920453739363758, 0.9860502647776485, 0.9903206454694157, 0.9802949806747188, 0.9912458554480027, 0.9893163575085783, 0.989609124622471, 0.2737744168416346, 0.24351505862933265, 0.2693589159051515, 0.2427027276378807, 0.2224786181256705, 0.3071758663323011, 0.17792472761112454, 0.26666902681716875, 0.20616689511098385, 0.29784110617520987, 0.19576965883062347, 0.1939514159597664, 0.24605277522878688, 0.21599178634953375, 0.18303003913121463, 0.24038359053866176, 0.19564594843878347, 0.10519327267108913, 0.14354851835078775, 0.11916907445663161, 0.13139041111222027, 0.102679532934284, 0.09041582609318188, 0.09064747680378771, 0.12719274302100914, 0.11954488191456114, 0.13472290716690882, 0.13021753643487333, 0.09286484345381474, 0.12307604885607382, 0.26643856643177577, 0.27364536682262475, 0.14769566065819384, 0.06195602138593226, 9.999999999998899e-05, 0.08370913613141306, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000573764976611546, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028209098621439055, 0.006408132252918808, 0.023267407014799346, 0.026668786905743036, 0.008603259507505179, 0.015919425520624864, 0.07238009603326301, 0.04375602265927814, 0.08744917633077132, 0.041794355367287594, 0.02899316575464328, 0.024953286778421346, 0.039594039222264454, 0.08886039183467531, 0.053376631919224704, 0.05437716902736667, 0.07083810004071833, 0.03492505540485635, 0.01744242659236206, 0.02353913272820085, 0.027825559903501884, 0.015070693849656314, 0.022592393933597132, 0.006520315366348783, 0.056084817975118884, 0.057219375301669206, 0.06215114415564582, 0.3744525700559216, 0.4228662364272818, 0.3816178932682034, 0.39218202642107447, 0.45694379383272776, 0.39136086617967936, 0.4389501102035879, 0.36530081416395344, 0.42652958863162005, 0.07094463091223957, 0.06658658142209806, 0.05929833432815723, 0.10363841880904712, 0.12260137649630176, 0.1195980554195909, 0.08896881507185228, 0.0728042753372321, 0.09952320194259101, 0.14425437129035512, 0.18539307315461906, 0.2398269646649095, 0.20389949323094803, 0.1762771929023027, 0.1694424146826392, 0.2541025524636693, 0.15863285734148125, 0.18333720108894558, 0.2594034137478628, 0.20188642305348425, 0.24710744051976963, 0.2934696843429361, 0.29050715428853346, 0.27743745365092753, 0.25918965393570836, 0.28861550506495637, 0.26389344674065585, 0.15513203168219647, 0.18893785928487872, 0.21242039980045424, 0.14042135911819298, 0.1670717262675384, 0.17407587103102906, 0.13674526585894187, 0.24562482334080715, 0.23343031098397227, 0.20337304313008364, 0.14809790535294465, 0.18858529340208663, 0.19842776359378334, 0.15774494232650327, 0.1785357185468529, 0.17907221068581436, 0.1840176006821833, 0.212019771154777, 0.3058115558983039, 0.2702515197236013, 0.18991799592618852, 0.21110766098306444, 0.19782765451823825, 0.41331151523566767, 0.1921945895273638, 0.19779057207574768, 0.18217524820224085, 0.5290596486556564, 0.16225508691421653, 0.14652645639373518, 0.6559384983226609, 0.18976532026111304, 0.18706446171619118, 0.10618212692034779, 0.19232501646002953, 0.19611990397797285, 0.44891515020849715, 0.36099016675470974, 0.18983498821382472, 0.18502197404587473, 0.26613578003973215, 0.1936583929629474, 0.20707296333425718, 0.1204226331113254, 0.20197722018942676, 0.22546565131198404, 0.18654342059923557, 0.18467662559289322, 0.19182978099222714, 0.19984693598033032, 0.2068768967286928, 0.20721585114577667, 0.20931574566157563, 0.18188857782717782, 0.06788872627783982, 0.05593018102765146, 0.07133084063537698, 0.07071300001159564, 0.08024803264441271, 0.06908126654268598, 0.08607875545871335, 0.08089512755654193, 0.06856132646209812]}, "mutation_prompt": null}
{"id": "c1d5cbef-39e3-473e-82e4-dfbc98b2e463", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "dd0acc74-7603-4fe6-83cf-a92de46a4a8a", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "1f03d416-1eb6-4f2d-b369-1f7378ce0688", "solution": "import numpy as np\n\nclass EnhancedParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7  # Adjusted for more exploration\n        self.cognitive_component = 1.5  # Slightly increased\n        self.social_component = 2.0  # Slightly decreased for balance\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.15  # Increased to enhance exploratory actions\n        self.disturbance_factor = 0.1  # New factor for hybrid exploration\n\n    def hybrid_exploration(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Hybrid exploration with reinforced disturbances\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    disturbance = self.hybrid_exploration()\n                    mutant = self.positions[i] + self.disturbance_factor * disturbance\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.3)):  # Further increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.8 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "EnhancedParticleSwarm", "description": "Enhanced Particle Swarm with Adaptive Learning and Hybrid Exploration using Reinforced Disturbances for Robust Optimization.", "configspace": "", "generation": 92, "fitness": 0.26813691955284463, "feedback": "The algorithm EnhancedParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7939514575539951, 0.7759167118451566, 0.7364373244801177, 0.7472482461569661, 0.7975326693985834, 0.7701631326654947, 0.7536782833890359, 0.7531807959599476, 0.7629900271677269, 0.6422815698296724, 9.999999999998899e-05, 0.5850855352956652, 0.6157414197019946, 0.4549555434206364, 0.5881396751474708, 0.5844145213874661, 0.5995098944669304, 0.0467781809266673, 0.07833272844607075, 0.10298554177537733, 0.14689538199069907, 0.17449136385717734, 0.07349262201485185, 0.5316727758071228, 0.1600446074884485, 0.10923960692193391, 0.11656467469483955, 0.15142789430153603, 0.10334397778211768, 0.10038047244860393, 0.0985630745139281, 0.10328618922620703, 0.10069004362616474, 0.14488983575373315, 0.12310242119537196, 0.10411213757835014, 0.9919433928301629, 0.9936512355068291, 0.9914506538410238, 0.9863323729480619, 0.9908946971015837, 0.9856909989610848, 0.9891136781753401, 0.9824390357221545, 0.985764501353312, 0.5489695904441818, 0.43302265136216356, 0.5466078042800278, 0.5601704205687144, 0.5535127999459885, 0.31153985413196006, 0.5927141597518459, 0.43696668405208794, 0.6206449087321053, 0.17073098306388523, 0.2052169712498113, 0.21892853921823074, 0.3514857952259012, 0.2052428335020784, 0.2036673335570265, 0.2080697515372354, 0.20052144029457986, 0.1743905160851258, 0.12938300590654583, 0.16912256049255725, 0.07394136471589063, 0.12317048994332758, 0.11309279788277182, 0.12272010198129013, 0.21964085524492183, 0.18646879137299432, 0.17596492840573807, 0.17809285909148242, 0.11432324624164836, 0.11061921917768358, 0.13132570331281535, 0.22727248469197692, 0.19104798841698067, 0.276900561541052, 0.09212012204034203, 0.1374919061783536, 9.999999999998899e-05, 0.012186800234918138, 9.999999999998899e-05, 0.023732069590219895, 0.00020214028058129774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04187799916703949, 0.028673017447925497, 0.09210089188657533, 0.0516607445411853, 0.0327850867704943, 0.004647920811319817, 0.03300949116140672, 0.045744776877334026, 0.03302977382759231, 0.042307629865516394, 0.03149045214464807, 0.08361975527367782, 0.07958414195881891, 0.07718065225620319, 0.07535786425352886, 0.16667022081258565, 0.06791246599093737, 0.061603359236368616, 0.03776002894846575, 0.03908839642076056, 0.05220068309361081, 0.158731730623485, 0.01978418370143553, 0.030221555219783425, 0.07741768366761503, 0.07834398997046865, 0.07615266038782231, 0.4929192377531395, 0.5039732875789604, 0.5003671631629132, 0.5229820875236499, 0.5375384564132939, 0.4826972277727749, 0.513452779997653, 0.5589900609812457, 0.5123584347395977, 0.10058702927352603, 0.10285572663337117, 0.10854814832369253, 0.08430633378918095, 0.10786493982946577, 0.10908285547257368, 0.06676396075186763, 0.07091987150767742, 0.1255827360777002, 0.24607836283063333, 0.2541813669635079, 0.18019330022309044, 0.2564483802788998, 0.24583641807228618, 0.15396700112792916, 0.2465708894115407, 0.2046891579029113, 0.17671022203735232, 0.3200256926686712, 0.20730040661739912, 0.3238766708688178, 0.2946637315648193, 0.30176804930091383, 0.32453158996605014, 0.3823470244364622, 0.31863522020241986, 0.44990506714480094, 0.2504517552137506, 0.16777401451831897, 0.24006101597138763, 0.17297475374775584, 0.1559831891653134, 0.24413053848125565, 0.2677138222859923, 0.21733433550172543, 0.2978525691444365, 0.22668171862782693, 0.16221081740027998, 0.2139590054528966, 0.2015323505307749, 0.1946675400017519, 0.16516851431466617, 0.2137402063751288, 0.20520133711497734, 0.2086173964642286, 0.23181644357681852, 0.20403612629824797, 0.6815562246163653, 0.20083852942538716, 0.23450890749137898, 0.18528615564999462, 0.1841429906874581, 0.6625764639232636, 0.22376310663521481, 0.8361007551694929, 0.1653056446386867, 0.15323128499517646, 0.8215678626697566, 0.19900252038488786, 0.1987769289826964, 0.09929943550781006, 0.17012073496283697, 0.20893574688583538, 0.5097370979351967, 0.15249121089879447, 0.11142916947449344, 0.20453958257780502, 0.4559699501292793, 0.20658057790945872, 0.10499195737401346, 0.10507489233967426, 0.2114098844868143, 0.19361860249219376, 0.1924655854913344, 0.21240932250930789, 0.17214158544166747, 0.20750495163307325, 0.1980523179999536, 0.2178523466287794, 0.21991955439737887, 0.194406713907618, 0.11396625088489476, 0.08379264381958673, 0.0778884374711466, 0.09192110166514633, 0.09095218495634416, 0.0914869714250719, 0.08322577367406825, 0.06649205175523276, 0.09113317740228521]}, "mutation_prompt": null}
{"id": "21e7ca5a-a18b-49a9-b419-0f7d78e7f506", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "342adf8c-0e7f-4cac-9743-e46ed5756b06", "solution": "import numpy as np\n\nclass MultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7\n        self.cognitive_component = 1.5\n        self.social_component = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.exploration_factor = 0.15\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (0.5 + 0.5 * (self.budget - self.evaluations) / self.budget)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.exploration_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.05 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            if np.random.rand() < 0.2:\n                for _ in range(int(self.population_size * 0.25)):\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.8 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "MultiStrategyAdaptivePSO", "description": "Multi-Strategy Adaptive Particle Swarm Optimization with Dynamic Population Control and Hybrid Exploration.", "configspace": "", "generation": 94, "fitness": 0.29378004288102355, "feedback": "The algorithm MultiStrategyAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.7781397887256505, 0.7485790516565407, 0.8142053545011467, 0.8049457648505983, 0.7775026431319068, 0.7726427750170393, 0.7326071461505258, 0.7899762450487352, 0.750310185611462, 0.6305820009041173, 0.5147822390431092, 0.5674864746353072, 0.6110140655108739, 0.562846857423736, 0.4933774455767197, 0.3551726794057378, 0.6411795493656856, 0.6124329316613949, 0.06937565702542237, 0.1451482597737006, 0.15883320743581064, 0.1549869100620741, 0.13572989039774352, 0.10545838361435966, 0.1340065164279255, 0.16278800355961354, 0.5522213058880769, 0.128594845841289, 0.14304642845564353, 0.10542180108653354, 0.14219439347285756, 0.14694131643260155, 0.14304693579228445, 0.1107604773938099, 0.11701562340886762, 0.13026601551287653, 0.991942548442265, 0.9936502434941508, 0.99171461676648, 0.9862575799554921, 0.9908475635947479, 0.9843962149755957, 0.9891131166047843, 0.9825874194490043, 0.9895925700548607, 0.5396471096974188, 0.604982910784789, 0.6007529583360818, 0.5522424815866259, 0.4676630667306042, 0.5684090100034049, 0.6202542141518437, 0.5636192575783803, 0.5620576881209571, 0.1725193169583581, 0.3678635883177269, 0.34533220852038016, 0.22146422733936577, 0.1386984804777096, 0.19037300868968177, 0.12459798315446335, 0.752167616929259, 0.2032679770235003, 0.17125855183878325, 0.17111492917805904, 0.17571155209286948, 0.1268656035357526, 0.18825298119935951, 0.18091896797621299, 0.11378022003292898, 0.1951536950619185, 0.17706401157735485, 0.12595313548794673, 0.1133742991832225, 0.21637929044070947, 0.1293829464021352, 0.22826785439405084, 0.21427623083418157, 0.23898968269818643, 0.08420875244814763, 0.26484405997201543, 9.999999999998899e-05, 9.999999999998899e-05, 0.07597762472780356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029402505546971214, 9.999999999998899e-05, 9.999999999998899e-05, 0.04132439280051858, 0.042719202523600286, 0.07339691459819953, 0.010796036810900689, 0.008155913666176295, 0.010962831393034111, 0.07421913398968283, 0.05311505296665853, 0.05084858341016241, 0.0444922820364585, 0.028552408683113595, 0.15444847411268925, 0.06388319920894758, 0.0842860159677572, 0.09352181741003096, 0.1341592826870146, 0.11234354146391323, 0.0678749762491887, 0.22371426130395644, 0.03888690911206072, 0.09735212074816713, 0.1471038300878148, 0.015122653941270436, 0.03743315078563303, 0.07964349359661305, 0.09468035287866405, 0.07667516968243016, 0.508225788378598, 0.5331407313173833, 0.5747864878237605, 0.5231443023740512, 0.5036491811744721, 0.5038865110150379, 0.5287247771355601, 0.49119451036111306, 0.5378252458497894, 0.14408570121645348, 0.13613812112932866, 0.11173341012700189, 0.6262346426793624, 0.14101107829923787, 0.11753936794601338, 0.06557588247572166, 0.06969138540063846, 0.15652048839067179, 0.2815298239472811, 0.29153027856157876, 0.3253282557799856, 0.27046505688607503, 0.19969843221604067, 0.2804320292093282, 0.20235347582013175, 0.24835774742777728, 0.17876185321722604, 0.2049879559494434, 0.18404189027616435, 0.300350761368249, 0.3026101619665086, 0.4102763310233899, 0.3267917503862433, 0.4144959500766545, 0.4686709254018595, 0.3189623578815818, 0.29851375405730673, 0.16617742847538908, 0.21197397577472965, 0.1582305779229295, 0.15860133591208292, 0.24258222182897649, 0.24990362762995577, 0.24087227385395638, 0.3129172709546916, 0.27714673506782284, 0.14698223177498881, 0.21680876778476066, 0.22096625808983061, 0.1916041363499349, 0.18592985409383855, 0.25102832484958204, 0.21896462324710653, 0.20008241700842389, 0.6967085517368132, 0.23943974186062245, 0.24282218133828282, 0.6745726166681261, 0.17482364190048538, 0.1808823312418535, 0.18441364001047944, 0.24126521723332883, 0.22088288092689967, 0.83146581665054, 0.16842173535632088, 0.18313973850421084, 0.8442980512950239, 0.19950892149451338, 0.19959939684322459, 0.09959705445818634, 0.17019041915799538, 0.21194342624161444, 0.6391980984046741, 0.15351628729883193, 0.1120378336357577, 0.2067249422904902, 0.5534951160583002, 0.6393904239105723, 0.10517347072771921, 0.10511441634176899, 0.6432000528602864, 0.20667465476562252, 0.19573599682953602, 0.20550302674246224, 0.21602170460494186, 0.21024862577730408, 0.19514372696794813, 0.1959516665600679, 0.22240545173864745, 0.2002987185702656, 0.08580389478222317, 0.09198695276765789, 0.0788150503713465, 0.09697271782362171, 0.0954318825110042, 0.10927818277109214, 0.08623497776934741, 0.07685563819536978, 0.11203887885671415]}, "mutation_prompt": null}
{"id": "27633eeb-1347-4231-8003-3fb1726cdbb3", "solution": "import numpy as np\n\nclass AdaptiveQuantumParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.7  # Adjusted for better exploration\n        self.cognitive_component = 1.5  # Slight adjustment\n        self.social_component = 2.0  # Slight adjustment\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_rate = 0.2  # Modified adaptive factor for more adaptation\n\n    def quantum_behaviour(self, size):\n        return np.random.normal(0, 1, size)  # Simplified quantum behavior for exploration\n\n    def update_population_size(self):\n        shrink_factor = np.log(1 + self.evaluations / self.budget)\n        new_size = max(5, int(self.initial_population_size * (1 - shrink_factor)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return self.global_best_score\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * np.exp(-0.5 * self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Quantum-inspired exploration\n            if np.random.rand() < self.adaptive_rate:\n                for i in range(self.population_size):\n                    quantum_step = self.quantum_behaviour(self.dim)\n                    quantum_mutant = self.positions[i] + 0.01 * quantum_step\n                    quantum_mutant = np.clip(quantum_mutant, self.lower_bound, self.upper_bound)\n                    quantum_fitness = func(quantum_mutant)\n                    self.evaluations += 1\n                    if quantum_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = quantum_mutant\n                        self.personal_best_scores[i] = quantum_fitness\n                        self.personal_best_positions[i] = quantum_mutant\n\n            # Enhanced mutation with dynamic contraction\n            if np.random.rand() < self.adaptive_rate:\n                for _ in range(int(self.population_size * 0.3)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    contraction_factor = 0.5 * (1 - self.evaluations / self.budget)\n                    mutant_vector = self.positions[a] + contraction_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdaptiveQuantumParticleSwarm", "description": "Adaptive Quantum-Inspired Particle Swarm Optimization with Enhanced Mutation Strategies and Dynamic Contraction for Efficient Global Search.", "configspace": "", "generation": 95, "fitness": 0.27376432635843173, "feedback": "The algorithm AdaptiveQuantumParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.767841458103367, 0.7476862018508604, 0.7858047594803825, 0.7395498027699687, 0.736022638325986, 0.7265573927869291, 0.7525826720293353, 0.7925717407925155, 0.7589955560501034, 0.583981759340196, 0.5819604032706538, 0.43851529811653467, 0.5330653177801131, 0.5702830474550569, 0.5502232151124963, 0.5295809598936623, 0.5803729426769072, 0.07500834722169769, 0.1621280904719955, 0.14445568766738048, 0.12972374805705966, 0.1159618780480971, 0.06195248823939781, 0.1206384412704018, 0.13147164944846246, 0.1088974400051338, 0.1616495527241214, 0.12947973972458882, 0.10651482924154076, 0.11075299275102102, 0.10903251122679192, 0.10745266020344135, 0.10212743487187914, 0.10161826402408447, 0.12062693631601418, 0.15724768500504327, 0.9892646744554782, 0.9936502447332937, 0.9904762682547318, 0.9803981983173299, 0.9908476175862648, 0.9871986228470803, 0.9886078968498279, 0.9828134534673502, 0.9886707302944961, 0.4201365717796225, 0.5290523278401664, 0.5538638232819036, 0.5509253641801717, 0.5476995021011357, 0.5113187767680676, 0.4106878951811206, 0.478410525077399, 0.5701333849728081, 0.8051308757346096, 0.21134368700123873, 0.33316185280170907, 0.21956041235131207, 0.19975655800114933, 0.7118081456736595, 0.2194674051868739, 0.12935665095829718, 0.11287501906997077, 0.29454228815520267, 0.18223267810623434, 0.10641536022709275, 0.12377752432644251, 0.17746631592458906, 0.10252416486739946, 0.20006645908074638, 0.19434875753507042, 0.17786776797732795, 0.2155057381947182, 0.11047333015236904, 0.1183575662446843, 0.21026694126029866, 0.09497664791045868, 0.19149645606001653, 0.09559558793870149, 0.08604705874538032, 0.20845613521436612, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011641525429602062, 0.013304434971682322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048925557280217746, 0.02517829862193799, 0.06617266772461827, 0.02931052981397675, 0.014295361601357581, 0.02322513064166909, 0.06508175429957919, 0.06443698878232862, 0.020408510359143817, 0.029399182422926384, 0.02878019949988031, 0.12127237238757738, 0.058680249392801254, 0.0733945112556077, 0.07492469716090455, 0.10601668714075074, 0.060444992835765654, 0.06131395781264459, 0.07430286165723698, 0.039426580040765824, 0.09303889256148923, 0.24497284737643155, 0.1047186687711299, 0.01328439503885348, 0.07680072832454021, 0.07011253147567054, 0.07864434445192969, 0.48417808228609904, 0.5155404451675423, 0.48132706260386404, 0.504945035603932, 0.46408268085152016, 0.5116441274707534, 0.5385741301282538, 0.524281526981272, 0.5764515074537111, 0.0855345699374026, 0.0730861213943037, 0.1244312074877102, 0.10539222269902171, 0.08077770435553033, 0.11435697875840656, 0.07338375212355808, 0.1026975791186816, 0.06954325901752623, 0.14427576911557882, 0.27123517339223113, 0.19309004768668614, 0.2707143512973914, 0.26530080019035096, 0.17635494101326388, 0.19374506564868865, 0.19355491363018862, 0.22356517290936073, 0.25654617795688495, 0.1836159361471017, 0.40373546772619695, 0.37095779947855534, 0.4332967941593109, 0.25090681980898755, 0.3950481165705342, 0.3872284609785833, 0.36550850533973545, 0.2835071503039388, 0.18583402134993487, 0.16962063598020616, 0.16873720089673427, 0.14630204774994615, 0.22336647044042013, 0.1423408487566581, 0.26207743366662595, 0.22793372411339696, 0.24277217025461395, 0.15428594939226437, 0.20597419985219412, 0.1961359630302294, 0.2089574040432982, 0.18623475883819118, 0.2272023715316498, 0.21359035542518479, 0.21372126520467316, 0.19507273284176885, 0.19553048772945258, 0.21954723171110258, 0.24547974275226492, 0.2402831214531872, 0.20675309441426248, 0.19002272233574102, 0.18261076452723823, 0.21259022383643522, 0.7285643306351997, 0.16927693992115544, 0.15154627402208076, 0.863634537232224, 0.19888421714147986, 0.19788258131519698, 0.14144100843719243, 0.17026761122696388, 0.21083582582246652, 0.6611500348705217, 0.1529235871077006, 0.3816428086306063, 0.20626414730049258, 0.5244891243254695, 0.20259064990605435, 0.20620209345195717, 0.2094585352302294, 0.7084979500983419, 0.21087893452990736, 0.21318540999851254, 0.19521984023501715, 0.20244791088579417, 0.21233829789462677, 0.20034469697066792, 0.1986495047358512, 0.21934956847983944, 0.20287181426948975, 0.05238222147954419, 0.09425440024932208, 0.08108565217902308, 0.09067141983636706, 0.09436289738125392, 0.08813918911275409, 0.08745619396676318, 0.05027783064118796, 0.0871331636919025]}, "mutation_prompt": null}
{"id": "84419efc-4526-4cba-b6ce-e8e1485ace33", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "2bd6370a-7f0f-4f00-b947-fc05273986ba", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "87a7f8c0-e3f1-436a-a8dd-1d413663c3ba", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
{"id": "d955e281-4cca-44da-a004-fbef40530e80", "solution": "import numpy as np\n\nclass AdvancedDynamicParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.4\n        self.social_component = 2.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_factor = 0.1\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def update_population_size(self):\n        new_size = max(5, int(self.initial_population_size * (1 - self.evaluations / self.budget)))\n        if new_size < self.population_size:\n            self.positions = self.positions[:new_size]\n            self.velocities = self.velocities[:new_size]\n            self.personal_best_positions = self.personal_best_positions[:new_size]\n            self.personal_best_scores = self.personal_best_scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                fitness = func(self.positions[i])\n                self.evaluations += 1\n\n                if fitness < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = fitness\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if fitness < self.global_best_score:\n                    self.global_best_score = fitness\n                    self.global_best_position = self.positions[i]\n\n            inertia_weight = self.inertia_weight * (self.budget - self.evaluations) / self.budget\n\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_velocity = self.social_component * r2 * (self.global_best_position - self.positions[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            # Enhanced exploration with strategic Levy flights\n            if np.random.rand() < self.adaptive_factor:\n                for i in range(self.population_size):\n                    levy_step = self.levy_flight(self.dim)\n                    mutant = self.positions[i] + 0.02 * levy_step\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    mutant_fitness = func(mutant)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[i]:\n                        self.positions[i] = mutant\n                        self.personal_best_scores[i] = mutant_fitness\n                        self.personal_best_positions[i] = mutant\n\n            # Differential evolution inspired strategic mutation\n            if np.random.rand() < self.adaptive_factor:\n                for _ in range(int(self.population_size * 0.2)):  # Increased mutation rate\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    candidate_index = np.random.randint(0, self.population_size)\n                    mutant_fitness = func(mutant_vector)\n                    self.evaluations += 1\n                    if mutant_fitness < self.personal_best_scores[candidate_index]:\n                        self.positions[candidate_index] = mutant_vector\n                        self.personal_best_scores[candidate_index] = mutant_fitness\n                        self.personal_best_positions[candidate_index] = mutant_vector\n\n        return self.global_best_score", "name": "AdvancedDynamicParticleSwarm", "description": "Advanced Dynamic Particle Swarm Optimization with Adaptive Population and Strategic Mutations for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29061883-b836-4b55-9dbe-8259dbb73ad7", "metadata": {"aucs": [0.8744484486449439, 0.8987984836188737, 0.8845447745630597, 0.8762725921571553, 0.870153374962246, 0.8732835511403704, 0.9148931040787918, 0.8889187107673509, 0.8980881258698545, 0.04072342598830714, 0.5724912999068323, 0.5034898190534776, 0.7656871034642679, 0.766510438978383, 0.8057948952150241, 0.7838014912189907, 0.7880523254058407, 0.7980017252528105, 0.15546925440351733, 0.18280372957826652, 0.10101060828676656, 0.14760329424131247, 0.07159074425964662, 0.1585468866098947, 0.1088018359765951, 0.1406789777979065, 0.14397030619757367, 0.13194467417706113, 0.1040134882554965, 0.14986865865054444, 0.12390128287286539, 0.15408858259452918, 0.13991414667000013, 0.10827884170173219, 0.15199533841278712, 0.11706460635922977, 0.9916705543760246, 0.9936314881814935, 0.9927472779771929, 0.9867375571025138, 0.9906816329688101, 0.989560048579392, 0.9892439691117939, 0.9828916269171405, 0.9861925851793878, 0.6639403978005116, 0.5709033689259275, 0.7564673608355887, 0.7681840223116504, 0.4094350358697242, 0.7675452883682714, 0.7571471657495625, 0.7493267573188722, 0.5210445482441833, 0.22335021772252273, 0.8431725946364352, 0.22809902235145518, 0.2821933967191803, 0.2124492426627136, 0.20762256522473577, 0.12467768351659525, 0.2326155926875756, 0.17016160461837426, 0.2287776283000007, 0.20903961728719556, 0.1659177365382395, 0.1306877667761348, 0.22094131693210406, 0.22168876489375666, 0.21385486264004316, 0.19891564779826942, 0.19878697413140756, 0.13440731538082906, 0.11827113405323086, 0.2361623578594233, 0.22100312629205088, 0.20121009133969914, 0.22918845990550107, 0.2646194396234379, 0.08455936506799322, 0.23842460299624568, 9.999999999998899e-05, 9.999999999998899e-05, 0.06304447201466157, 0.01912907521929741, 9.999999999998899e-05, 0.008159801395228206, 0.08412408639270708, 9.999999999998899e-05, 0.041725100934745574, 0.05017212123417192, 0.042259649780596376, 0.07065387004766399, 0.07341472431639162, 9.999999999998899e-05, 0.013758659880983903, 0.21778830938528548, 0.10132361073277918, 0.07395169223319065, 0.10568445559059347, 0.03479484510323472, 0.05455483436399866, 0.10700118137717762, 0.12002453979260719, 0.16784400826800616, 0.23843865706348566, 0.07181316286427064, 0.07191065497863924, 0.150722358340314, 0.04396871705455485, 0.15761718033664052, 0.07895599664427122, 0.03911145868223809, 0.26486088521049056, 0.08478918162560489, 0.08259147079147933, 0.30787484151707345, 0.527114373362374, 0.5723524437277528, 0.530849853168633, 0.5422576015539673, 0.5232419699420306, 0.5186722528979464, 0.569080209059681, 0.579363528751879, 0.5535710358468011, 0.08128898451369782, 0.09090921687746945, 0.04476604233051984, 0.11161510081971426, 0.07071164038856059, 0.12492825220881909, 0.07827533778760776, 0.10781814258271338, 0.13408970435123302, 0.22594767265278015, 0.265821066586427, 0.1751098166244528, 0.28713210738831985, 0.277849446119377, 0.1757148778512574, 0.18913634394997947, 0.1937527456662379, 0.21947131938402642, 0.41486745118715596, 0.35003981433811837, 0.35533677951220466, 0.3333370037697917, 0.38410244351348777, 0.28459052287607634, 0.48493724482714096, 0.3510649443509577, 0.2831609560870324, 0.2438129100519948, 0.18544254213028633, 0.225511561513147, 0.3104523343469745, 0.17875293045371077, 0.30277070808805173, 0.24475811975476858, 0.3352484438181714, 0.231282648574489, 0.2973046100564628, 0.14099830465383456, 0.22817946753868412, 0.18119210069723657, 0.21598075202554, 0.1986306145657638, 0.22092319586421805, 0.22104575601025278, 0.2603387590587447, 0.79621901819581, 0.1978313006974306, 0.20097006579070242, 0.19506519263225897, 0.1999742505347275, 0.25058736210626786, 0.1940382874354667, 0.24604965569669746, 0.19441643879112025, 0.1864766046645856, 0.12705763316245544, 0.15442709368693464, 0.9204398414132133, 0.8862136059314331, 0.20062367789372404, 0.09947874393875478, 0.17037946158060369, 0.2135824652375109, 0.6307895086448924, 0.15594903999041287, 0.11098365929379306, 0.21107876055893338, 0.6218410055343966, 0.21151346751400601, 0.1053319997861123, 0.10469348706035253, 0.8052227332743156, 0.1993189831787563, 0.19449088519821356, 0.20648071676077961, 0.2079788917345824, 0.17373429997012302, 0.20001344298545043, 0.23048408291788758, 0.2663131650046011, 0.21785243951064714, 0.08673987032672503, 0.0853499964220531, 0.10400796364256548, 0.08963547003538619, 0.09435508306081009, 0.09459552087460232, 0.13496213412533054, 0.06632341606962322, 0.09755569146315646]}, "mutation_prompt": null}
