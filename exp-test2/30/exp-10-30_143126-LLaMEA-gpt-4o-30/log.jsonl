{"id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation Rates for Efficient Exploration and Exploitation in BBOB Problems.", "configspace": "", "generation": 0, "fitness": 0.27765212420272234, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6283866687471074, 0.5599684724820415, 0.6044007915522476, 0.6602282946178315, 0.6494265622771446, 0.6456279113633787, 0.6649615823336175, 0.6362821027844461, 0.6454158958995131, 0.3846371067390836, 0.3838604673772348, 0.39208984810044556, 0.4008673971312565, 0.4110641503372885, 0.4019986547347061, 0.35287662679272536, 0.39417897433082427, 0.37162764931755987, 0.09295139357267945, 0.0953126168778925, 0.0923258940264079, 0.09070185626403215, 0.09757051557505891, 0.09482829866628273, 0.08943381811114282, 0.08762006819721935, 0.1055144815648249, 0.08373182489498499, 0.09191980667088717, 0.0879736865572952, 0.09377417777398855, 0.08056614116304683, 0.08376844680567797, 0.08680992338009985, 0.09030078605844916, 0.08625727650751946, 0.9712773195163967, 0.9419552275288863, 0.9179649922749318, 0.9657982780716878, 0.9390472919958578, 0.9411195823186964, 0.9379607857561556, 0.9434222608726626, 0.9654217723758547, 0.3085192607131504, 0.2759913759268954, 0.2678411559527023, 0.28345547004427385, 0.30236808138103066, 0.27359442273072876, 0.3120182845548195, 0.3044310540823648, 0.29620970943759717, 0.5197949720278778, 0.5570996245988636, 0.4866538334630576, 0.5439278373157537, 0.5068141561533498, 0.5850788282831583, 0.5879271773683848, 0.4904049248918594, 0.5539734392350915, 0.19539852153107662, 0.21992266973908747, 0.2234861643771472, 0.22545248241441185, 0.2617897459721965, 0.20494291762885453, 0.19877610874114393, 0.21227422567322463, 0.2105390313954697, 0.24370784983351268, 0.2523537489569442, 0.28111711668235206, 0.20957618286530155, 0.23195954856991918, 0.18671872902164588, 0.19095546754883763, 0.17216381992540408, 0.2056263093205204, 0.1586344579380229, 0.1447642058006826, 0.166095858573321, 0.13870702813624014, 0.16222730057039603, 0.17773875142543694, 0.17229427558880706, 0.12974448508523362, 0.17182479951498575, 0.2588627862051476, 0.26445952056672406, 0.3037842714177863, 0.28938900311092375, 0.28602188194079325, 0.26240456758105724, 0.30304634281696397, 0.32423383913090786, 0.3393409242404838, 0.031650157651942235, 0.04083373638514365, 0.03545542359365006, 0.06532375075531105, 0.033912758674800925, 0.04556855313117181, 0.042661318134265325, 0.04248039702418249, 0.04476871497942614, 0.16061584494201053, 0.15802951432579648, 0.16315954402544974, 0.1698108263456437, 0.1729447322844777, 0.179739707151354, 0.17267103966327613, 0.18801818574132478, 0.1693216831960339, 0.46347182755234895, 0.507067093411833, 0.48559611814190917, 0.5025363996088619, 0.5038446604014317, 0.5069612204006999, 0.46583279717577664, 0.4783076971769995, 0.5113961559822865, 0.08020229122036848, 0.0774919205385931, 0.08158559962859147, 0.0855543532037204, 0.08273835965208831, 0.08294219909620881, 0.08000672102271877, 0.07190690304714376, 0.07955259906228129, 0.1662658861700569, 0.1616419137081606, 0.2001072303311605, 0.13147814930220103, 0.15067372413125035, 0.1894399566857986, 0.17964615795714745, 0.15230950753249528, 0.14470445561802137, 0.26021471020326814, 0.2691867906662603, 0.2784729642795877, 0.254399783528944, 0.26294890757650236, 0.27368906753354383, 0.29939869859666624, 0.28480422252317517, 0.27657536933143323, 0.21184531675555385, 0.2252969182004937, 0.20733168714535133, 0.22994414526248153, 0.22342749575157705, 0.2072172924151372, 0.21369797325787698, 0.2076571792870744, 0.22072227527654864, 0.1755056477680229, 0.1769302049140522, 0.18199078817532066, 0.19456686260403144, 0.16826606330767557, 0.1964284256687323, 0.18513059311722357, 0.1746061066119542, 0.20521640746148728, 0.168189182160836, 0.1830021063134829, 0.17802869230898777, 0.17478980941064814, 0.18011321287363058, 0.175636674856679, 0.17785617847458957, 0.18239747856472932, 0.17637986137177109, 0.7136050362167431, 0.18090093804996088, 0.4212359090272899, 0.6266866421194233, 0.5046750025324845, 0.4990881740865133, 0.16423534045704713, 0.17779518334715372, 0.23533345360548963, 0.5741172653494913, 0.503039386741382, 0.4128287511512587, 0.20482535685491865, 0.1782286466749431, 0.31367481388621, 0.19837192519081714, 0.6248679086813376, 0.20364154410750235, 0.17668710375370267, 0.1850257869094044, 0.17546759919062516, 0.1925679697804834, 0.18252563173558034, 0.17689718736062965, 0.18710803456204483, 0.1908583810023352, 0.18309524712107395, 0.07083593438291225, 0.06487221205513305, 0.06575283731098969, 0.06836251224922052, 0.06634150291604979, 0.06518089363313195, 0.06683255469441851, 0.06816078281316673, 0.06737627061742169]}, "mutation_prompt": null}
{"id": "739f1682-f245-48b5-8a64-7a7e2b339cac", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation Rates for Efficient Exploration and Exploitation in BBOB Problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {"aucs": [0.6283866687471074, 0.5599684724820415, 0.6044007915522476, 0.6602282946178315, 0.6494265622771446, 0.6456279113633787, 0.6649615823336175, 0.6362821027844461, 0.6454158958995131, 0.3846371067390836, 0.3838604673772348, 0.39208984810044556, 0.4008673971312565, 0.4110641503372885, 0.4019986547347061, 0.35287662679272536, 0.39417897433082427, 0.37162764931755987, 0.09295139357267945, 0.0953126168778925, 0.0923258940264079, 0.09070185626403215, 0.09757051557505891, 0.09482829866628273, 0.08943381811114282, 0.08762006819721935, 0.1055144815648249, 0.08373182489498499, 0.09191980667088717, 0.0879736865572952, 0.09377417777398855, 0.08056614116304683, 0.08376844680567797, 0.08680992338009985, 0.09030078605844916, 0.08625727650751946, 0.9712773195163967, 0.9419552275288863, 0.9179649922749318, 0.9657982780716878, 0.9390472919958578, 0.9411195823186964, 0.9379607857561556, 0.9434222608726626, 0.9654217723758547, 0.3085192607131504, 0.2759913759268954, 0.2678411559527023, 0.28345547004427385, 0.30236808138103066, 0.27359442273072876, 0.3120182845548195, 0.3044310540823648, 0.29620970943759717, 0.5197949720278778, 0.5570996245988636, 0.4866538334630576, 0.5439278373157537, 0.5068141561533498, 0.5850788282831583, 0.5879271773683848, 0.4904049248918594, 0.5539734392350915, 0.19539852153107662, 0.21992266973908747, 0.2234861643771472, 0.22545248241441185, 0.2617897459721965, 0.20494291762885453, 0.19877610874114393, 0.21227422567322463, 0.2105390313954697, 0.24370784983351268, 0.2523537489569442, 0.28111711668235206, 0.20957618286530155, 0.23195954856991918, 0.18671872902164588, 0.19095546754883763, 0.17216381992540408, 0.2056263093205204, 0.1586344579380229, 0.1447642058006826, 0.166095858573321, 0.13870702813624014, 0.16222730057039603, 0.17773875142543694, 0.17229427558880706, 0.12974448508523362, 0.17182479951498575, 0.2588627862051476, 0.26445952056672406, 0.3037842714177863, 0.28938900311092375, 0.28602188194079325, 0.26240456758105724, 0.30304634281696397, 0.32423383913090786, 0.3393409242404838, 0.031650157651942235, 0.04083373638514365, 0.03545542359365006, 0.06532375075531105, 0.033912758674800925, 0.04556855313117181, 0.042661318134265325, 0.04248039702418249, 0.04476871497942614, 0.16061584494201053, 0.15802951432579648, 0.16315954402544974, 0.1698108263456437, 0.1729447322844777, 0.179739707151354, 0.17267103966327613, 0.18801818574132478, 0.1693216831960339, 0.46347182755234895, 0.507067093411833, 0.48559611814190917, 0.5025363996088619, 0.5038446604014317, 0.5069612204006999, 0.46583279717577664, 0.4783076971769995, 0.5113961559822865, 0.08020229122036848, 0.0774919205385931, 0.08158559962859147, 0.0855543532037204, 0.08273835965208831, 0.08294219909620881, 0.08000672102271877, 0.07190690304714376, 0.07955259906228129, 0.1662658861700569, 0.1616419137081606, 0.2001072303311605, 0.13147814930220103, 0.15067372413125035, 0.1894399566857986, 0.17964615795714745, 0.15230950753249528, 0.14470445561802137, 0.26021471020326814, 0.2691867906662603, 0.2784729642795877, 0.254399783528944, 0.26294890757650236, 0.27368906753354383, 0.29939869859666624, 0.28480422252317517, 0.27657536933143323, 0.21184531675555385, 0.2252969182004937, 0.20733168714535133, 0.22994414526248153, 0.22342749575157705, 0.2072172924151372, 0.21369797325787698, 0.2076571792870744, 0.22072227527654864, 0.1755056477680229, 0.1769302049140522, 0.18199078817532066, 0.19456686260403144, 0.16826606330767557, 0.1964284256687323, 0.18513059311722357, 0.1746061066119542, 0.20521640746148728, 0.168189182160836, 0.1830021063134829, 0.17802869230898777, 0.17478980941064814, 0.18011321287363058, 0.175636674856679, 0.17785617847458957, 0.18239747856472932, 0.17637986137177109, 0.7136050362167431, 0.18090093804996088, 0.4212359090272899, 0.6266866421194233, 0.5046750025324845, 0.4990881740865133, 0.16423534045704713, 0.17779518334715372, 0.23533345360548963, 0.5741172653494913, 0.503039386741382, 0.4128287511512587, 0.20482535685491865, 0.1782286466749431, 0.31367481388621, 0.19837192519081714, 0.6248679086813376, 0.20364154410750235, 0.17668710375370267, 0.1850257869094044, 0.17546759919062516, 0.1925679697804834, 0.18252563173558034, 0.17689718736062965, 0.18710803456204483, 0.1908583810023352, 0.18309524712107395, 0.07083593438291225, 0.06487221205513305, 0.06575283731098969, 0.06836251224922052, 0.06634150291604979, 0.06518089363313195, 0.06683255469441851, 0.06816078281316673, 0.06737627061742169]}, "mutation_prompt": null}
{"id": "63eaf693-ac62-4e30-9ae9-0e6605094cb6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.archive = []  # New archive to store successful trials\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def archive_update(self, trial, trial_fitness, idx):\n        if trial_fitness < self.fitness[idx]:\n            self.archive.append((trial, trial_fitness))\n            self.archive = sorted(self.archive, key=lambda x: x[1])[:self.pop_size//2]  # Limit archive size\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    self.archive_update(trial, trial_fitness, i)\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n            \n            # Incorporate archive members for diversity\n            if self.archive:\n                self.population.extend([ind[0] for ind in self.archive[:self.pop_size//10]])\n                self.fitness = np.append(self.fitness, [ind[1] for ind in self.archive[:self.pop_size//10]])\n                self.archive = []\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Archiving for Better Diversity and Convergence in BBOB Problems.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'numpy.ndarray' object has no attribute 'extend'\").", "error": "AttributeError(\"'numpy.ndarray' object has no attribute 'extend'\")", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {}, "mutation_prompt": null}
{"id": "83eaf2dc-8e55-4af1-84e8-04924ebd541f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation Rates for Efficient Exploration and Exploitation in BBOB Problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {"aucs": [0.6283866687471074, 0.5599684724820415, 0.6044007915522476, 0.6602282946178315, 0.6494265622771446, 0.6456279113633787, 0.6649615823336175, 0.6362821027844461, 0.6454158958995131, 0.3846371067390836, 0.3838604673772348, 0.39208984810044556, 0.4008673971312565, 0.4110641503372885, 0.4019986547347061, 0.35287662679272536, 0.39417897433082427, 0.37162764931755987, 0.09295139357267945, 0.0953126168778925, 0.0923258940264079, 0.09070185626403215, 0.09757051557505891, 0.09482829866628273, 0.08943381811114282, 0.08762006819721935, 0.1055144815648249, 0.08373182489498499, 0.09191980667088717, 0.0879736865572952, 0.09377417777398855, 0.08056614116304683, 0.08376844680567797, 0.08680992338009985, 0.09030078605844916, 0.08625727650751946, 0.9712773195163967, 0.9419552275288863, 0.9179649922749318, 0.9657982780716878, 0.9390472919958578, 0.9411195823186964, 0.9379607857561556, 0.9434222608726626, 0.9654217723758547, 0.3085192607131504, 0.2759913759268954, 0.2678411559527023, 0.28345547004427385, 0.30236808138103066, 0.27359442273072876, 0.3120182845548195, 0.3044310540823648, 0.29620970943759717, 0.5197949720278778, 0.5570996245988636, 0.4866538334630576, 0.5439278373157537, 0.5068141561533498, 0.5850788282831583, 0.5879271773683848, 0.4904049248918594, 0.5539734392350915, 0.19539852153107662, 0.21992266973908747, 0.2234861643771472, 0.22545248241441185, 0.2617897459721965, 0.20494291762885453, 0.19877610874114393, 0.21227422567322463, 0.2105390313954697, 0.24370784983351268, 0.2523537489569442, 0.28111711668235206, 0.20957618286530155, 0.23195954856991918, 0.18671872902164588, 0.19095546754883763, 0.17216381992540408, 0.2056263093205204, 0.1586344579380229, 0.1447642058006826, 0.166095858573321, 0.13870702813624014, 0.16222730057039603, 0.17773875142543694, 0.17229427558880706, 0.12974448508523362, 0.17182479951498575, 0.2588627862051476, 0.26445952056672406, 0.3037842714177863, 0.28938900311092375, 0.28602188194079325, 0.26240456758105724, 0.30304634281696397, 0.32423383913090786, 0.3393409242404838, 0.031650157651942235, 0.04083373638514365, 0.03545542359365006, 0.06532375075531105, 0.033912758674800925, 0.04556855313117181, 0.042661318134265325, 0.04248039702418249, 0.04476871497942614, 0.16061584494201053, 0.15802951432579648, 0.16315954402544974, 0.1698108263456437, 0.1729447322844777, 0.179739707151354, 0.17267103966327613, 0.18801818574132478, 0.1693216831960339, 0.46347182755234895, 0.507067093411833, 0.48559611814190917, 0.5025363996088619, 0.5038446604014317, 0.5069612204006999, 0.46583279717577664, 0.4783076971769995, 0.5113961559822865, 0.08020229122036848, 0.0774919205385931, 0.08158559962859147, 0.0855543532037204, 0.08273835965208831, 0.08294219909620881, 0.08000672102271877, 0.07190690304714376, 0.07955259906228129, 0.1662658861700569, 0.1616419137081606, 0.2001072303311605, 0.13147814930220103, 0.15067372413125035, 0.1894399566857986, 0.17964615795714745, 0.15230950753249528, 0.14470445561802137, 0.26021471020326814, 0.2691867906662603, 0.2784729642795877, 0.254399783528944, 0.26294890757650236, 0.27368906753354383, 0.29939869859666624, 0.28480422252317517, 0.27657536933143323, 0.21184531675555385, 0.2252969182004937, 0.20733168714535133, 0.22994414526248153, 0.22342749575157705, 0.2072172924151372, 0.21369797325787698, 0.2076571792870744, 0.22072227527654864, 0.1755056477680229, 0.1769302049140522, 0.18199078817532066, 0.19456686260403144, 0.16826606330767557, 0.1964284256687323, 0.18513059311722357, 0.1746061066119542, 0.20521640746148728, 0.168189182160836, 0.1830021063134829, 0.17802869230898777, 0.17478980941064814, 0.18011321287363058, 0.175636674856679, 0.17785617847458957, 0.18239747856472932, 0.17637986137177109, 0.7136050362167431, 0.18090093804996088, 0.4212359090272899, 0.6266866421194233, 0.5046750025324845, 0.4990881740865133, 0.16423534045704713, 0.17779518334715372, 0.23533345360548963, 0.5741172653494913, 0.503039386741382, 0.4128287511512587, 0.20482535685491865, 0.1782286466749431, 0.31367481388621, 0.19837192519081714, 0.6248679086813376, 0.20364154410750235, 0.17668710375370267, 0.1850257869094044, 0.17546759919062516, 0.1925679697804834, 0.18252563173558034, 0.17689718736062965, 0.18710803456204483, 0.1908583810023352, 0.18309524712107395, 0.07083593438291225, 0.06487221205513305, 0.06575283731098969, 0.06836251224922052, 0.06634150291604979, 0.06518089363313195, 0.06683255469441851, 0.06816078281316673, 0.06737627061742169]}, "mutation_prompt": null}
{"id": "dd3c5528-80ad-4c8b-87b6-ed90ec11a453", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.dynamic_pop_size = int(np.ceil(self.pop_size * 0.5))  # Dynamic population size\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        if self.evaluations > self.budget * 0.5:  # Adaptive mutation factor\n            self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.dynamic_pop_size):  # Use dynamic population size\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Population Size and Adaptive Mutation Strategy for Improved Convergence in BBOB Problems.", "configspace": "", "generation": 4, "fitness": 0.15481990452619737, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {"aucs": [0.2779316292142231, 0.2853748694194316, 0.2880295545196512, 0.30778889900574113, 0.27759117800223676, 0.3411989361647906, 0.32442968016934215, 0.31645480669609916, 0.2610316704247655, 0.03524933262115004, 0.05340523225369653, 0.04485474525609534, 0.030676299379023275, 0.03776631862321023, 0.05634154500166022, 0.03139566461344223, 0.04161370782308915, 0.04174244219789491, 0.06327280457558848, 0.0625807631351667, 0.0691305146751312, 0.06660858714678253, 0.05708707594462903, 0.06696143841639624, 0.06748847833240057, 0.05724382909478953, 0.06325462879325483, 0.05401573500852552, 0.057958432367879675, 0.06872799645762129, 0.06759119806565772, 0.07279837289099833, 0.05357619530229529, 0.07312286214346697, 0.05562219860712736, 0.05757375098009965, 0.9698676137474082, 0.9507110001792557, 0.9608423033570157, 0.9687280233646895, 0.9647562221111724, 0.95318018464764, 0.9544900016773469, 0.9758512601385102, 0.9797351580936009, 0.14305426014192402, 0.11499985350875663, 0.1242630241670184, 0.11930179578775424, 0.10462342944857961, 0.13369105737764098, 0.13103243308500567, 0.11107218789614726, 0.12776765926562517, 0.17471226514093974, 0.18407526278723663, 0.20158280073965595, 0.18477716725004079, 0.16512871044669342, 0.17939323324113488, 0.18351943835601858, 0.1941351955593721, 0.22246442325527316, 0.05066533180486532, 0.06819049284373668, 0.07316939823375923, 0.07641237256797684, 0.034882103027348066, 0.0460803561249008, 0.04819191392194477, 0.07412466313933186, 0.04667098656215407, 0.014959562480308719, 0.019572367788386114, 0.06134153371750162, 0.04923924889232878, 0.08869803738893456, 0.09842026024144379, 0.09259875984169685, 0.06743832042960496, 0.036578749776757125, 0.011211605969149274, 9.999999999998899e-05, 9.999999999998899e-05, 0.023269265556762897, 0.001340224606299345, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010867542355985638, 0.00618732705082492, 0.07243612698976976, 0.07401281373327417, 0.08531849780993506, 0.06500782809813044, 0.100011931549158, 0.06385327608897895, 0.06555104412519797, 0.09434313757501, 0.11356220729604338, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04238022861647428, 0.03241963450457985, 0.035509822276811986, 0.03677107006284108, 0.040131303543575414, 0.05620237550462248, 0.03380473894580427, 0.05032819221245499, 0.02927006956580025, 0.2416847079345854, 0.30171888721459594, 0.2963315237587709, 0.283940107459124, 0.27454903746392745, 0.29114363585839254, 0.28332515674670755, 0.2595991015051774, 0.26531113093757863, 0.07452490608509654, 0.05775650283957856, 0.06986725990759568, 0.05981939131418079, 0.0539637028774107, 0.05959247110407706, 0.059876026567201146, 0.04761126989070963, 0.05763829558308953, 0.14620053160338886, 0.13712416040831066, 0.13246677346619729, 0.1442574363065936, 0.12903342446009958, 0.1575663519727919, 0.1551872753927841, 0.15183989290176103, 0.1411753741674322, 0.18559140065085966, 0.17428167702696662, 0.20528250238336454, 0.18843058936884005, 0.1941428796385667, 0.19144517807504013, 0.19595409055849766, 0.2089552080179352, 0.19764301147967767, 0.1298818537898, 0.11833716489530377, 0.12285957364863476, 0.13559054963814365, 0.13130315094856082, 0.13911311167718998, 0.1270906049113968, 0.15013533349789177, 0.14347891980544014, 0.15751453669660131, 0.1563467026469929, 0.15254386073941573, 0.168513726884441, 0.1729458131044883, 0.17037981312310235, 0.16845666221051436, 0.1636736395192664, 0.17973458235603834, 0.15349300194697368, 0.15507922268350904, 0.15798350535165795, 0.16162374223332043, 0.14337334166877624, 0.16361388375140573, 0.16212240094372787, 0.16615584227403546, 0.157331080314981, 0.20567211046950384, 0.19372850098988115, 0.13766348072570767, 0.17697669826682194, 0.24517280335299418, 0.17038109753161812, 0.18344238845276473, 0.1441735678366749, 0.18039514464153095, 0.15018803420256122, 0.19146640410662996, 0.16171566407857263, 0.21167735443575797, 0.14312008468876725, 0.14613897301825274, 0.19073515337609392, 0.1923603330981366, 0.19163919811096453, 0.1933361696904613, 0.1906691150079287, 0.17859617070846656, 0.20500307879059132, 0.17464314003484882, 0.17990838456142189, 0.17146041402725154, 0.18436075321028145, 0.1867380818105948, 0.051585217216620016, 0.05466528095359713, 0.06158984214202223, 0.05580701929940057, 0.06653508539987796, 0.05120560899577353, 0.06650278964449097, 0.06177327105003949, 0.05975327556036447]}, "mutation_prompt": null}
{"id": "765eb3f4-1b19-47c5-a288-2b72cd31de81", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation Rates for Efficient Exploration and Exploitation in BBOB Problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {"aucs": [0.6283866687471074, 0.5599684724820415, 0.6044007915522476, 0.6602282946178315, 0.6494265622771446, 0.6456279113633787, 0.6649615823336175, 0.6362821027844461, 0.6454158958995131, 0.3846371067390836, 0.3838604673772348, 0.39208984810044556, 0.4008673971312565, 0.4110641503372885, 0.4019986547347061, 0.35287662679272536, 0.39417897433082427, 0.37162764931755987, 0.09295139357267945, 0.0953126168778925, 0.0923258940264079, 0.09070185626403215, 0.09757051557505891, 0.09482829866628273, 0.08943381811114282, 0.08762006819721935, 0.1055144815648249, 0.08373182489498499, 0.09191980667088717, 0.0879736865572952, 0.09377417777398855, 0.08056614116304683, 0.08376844680567797, 0.08680992338009985, 0.09030078605844916, 0.08625727650751946, 0.9712773195163967, 0.9419552275288863, 0.9179649922749318, 0.9657982780716878, 0.9390472919958578, 0.9411195823186964, 0.9379607857561556, 0.9434222608726626, 0.9654217723758547, 0.3085192607131504, 0.2759913759268954, 0.2678411559527023, 0.28345547004427385, 0.30236808138103066, 0.27359442273072876, 0.3120182845548195, 0.3044310540823648, 0.29620970943759717, 0.5197949720278778, 0.5570996245988636, 0.4866538334630576, 0.5439278373157537, 0.5068141561533498, 0.5850788282831583, 0.5879271773683848, 0.4904049248918594, 0.5539734392350915, 0.19539852153107662, 0.21992266973908747, 0.2234861643771472, 0.22545248241441185, 0.2617897459721965, 0.20494291762885453, 0.19877610874114393, 0.21227422567322463, 0.2105390313954697, 0.24370784983351268, 0.2523537489569442, 0.28111711668235206, 0.20957618286530155, 0.23195954856991918, 0.18671872902164588, 0.19095546754883763, 0.17216381992540408, 0.2056263093205204, 0.1586344579380229, 0.1447642058006826, 0.166095858573321, 0.13870702813624014, 0.16222730057039603, 0.17773875142543694, 0.17229427558880706, 0.12974448508523362, 0.17182479951498575, 0.2588627862051476, 0.26445952056672406, 0.3037842714177863, 0.28938900311092375, 0.28602188194079325, 0.26240456758105724, 0.30304634281696397, 0.32423383913090786, 0.3393409242404838, 0.031650157651942235, 0.04083373638514365, 0.03545542359365006, 0.06532375075531105, 0.033912758674800925, 0.04556855313117181, 0.042661318134265325, 0.04248039702418249, 0.04476871497942614, 0.16061584494201053, 0.15802951432579648, 0.16315954402544974, 0.1698108263456437, 0.1729447322844777, 0.179739707151354, 0.17267103966327613, 0.18801818574132478, 0.1693216831960339, 0.46347182755234895, 0.507067093411833, 0.48559611814190917, 0.5025363996088619, 0.5038446604014317, 0.5069612204006999, 0.46583279717577664, 0.4783076971769995, 0.5113961559822865, 0.08020229122036848, 0.0774919205385931, 0.08158559962859147, 0.0855543532037204, 0.08273835965208831, 0.08294219909620881, 0.08000672102271877, 0.07190690304714376, 0.07955259906228129, 0.1662658861700569, 0.1616419137081606, 0.2001072303311605, 0.13147814930220103, 0.15067372413125035, 0.1894399566857986, 0.17964615795714745, 0.15230950753249528, 0.14470445561802137, 0.26021471020326814, 0.2691867906662603, 0.2784729642795877, 0.254399783528944, 0.26294890757650236, 0.27368906753354383, 0.29939869859666624, 0.28480422252317517, 0.27657536933143323, 0.21184531675555385, 0.2252969182004937, 0.20733168714535133, 0.22994414526248153, 0.22342749575157705, 0.2072172924151372, 0.21369797325787698, 0.2076571792870744, 0.22072227527654864, 0.1755056477680229, 0.1769302049140522, 0.18199078817532066, 0.19456686260403144, 0.16826606330767557, 0.1964284256687323, 0.18513059311722357, 0.1746061066119542, 0.20521640746148728, 0.168189182160836, 0.1830021063134829, 0.17802869230898777, 0.17478980941064814, 0.18011321287363058, 0.175636674856679, 0.17785617847458957, 0.18239747856472932, 0.17637986137177109, 0.7136050362167431, 0.18090093804996088, 0.4212359090272899, 0.6266866421194233, 0.5046750025324845, 0.4990881740865133, 0.16423534045704713, 0.17779518334715372, 0.23533345360548963, 0.5741172653494913, 0.503039386741382, 0.4128287511512587, 0.20482535685491865, 0.1782286466749431, 0.31367481388621, 0.19837192519081714, 0.6248679086813376, 0.20364154410750235, 0.17668710375370267, 0.1850257869094044, 0.17546759919062516, 0.1925679697804834, 0.18252563173558034, 0.17689718736062965, 0.18710803456204483, 0.1908583810023352, 0.18309524712107395, 0.07083593438291225, 0.06487221205513305, 0.06575283731098969, 0.06836251224922052, 0.06634150291604979, 0.06518089363313195, 0.06683255469441851, 0.06816078281316673, 0.06737627061742169]}, "mutation_prompt": null}
{"id": "c6577c32-be13-4bdc-9095-210cbd3891fc", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, dim))\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.evaluations = 0\n        self.dynamic_pop_size = self.initial_pop_size\n        \n    def adjust_parameters(self):\n        # Gradually reduce mutation factor and dynamic population size\n        self.mutation_factor = 0.5 + 0.3 * (1 - self.evaluations / self.budget)\n        self.dynamic_pop_size = int(self.initial_pop_size * (1 - self.evaluations / self.budget) + 4)\n        \n    def evaluate_population(self, func):\n        for i in range(self.dynamic_pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        \n    def select_parents(self, idx):\n        indices = list(range(self.dynamic_pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutant = self.population[r1] + self.mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_parameters()\n            for i in range(self.dynamic_pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness[:self.dynamic_pop_size])\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Dynamic Population Size and Adaptive Parameters for Enhanced Convergence in BBOB Problems.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 52 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 52 is out of bounds for axis 0 with size 50')", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {}, "mutation_prompt": null}
{"id": "846d4925-d854-44ce-9966-7e72fea0858f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 7, "fitness": 0.3537035111906692, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "eb6cd154-fb13-4f06-af49-c7db9385a80b", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "37decc21-718c-497d-8d88-b309592c1ae3", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "508524fa-1fff-42bd-b61e-9bcbb09e7bea", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "d63b63b1-20a4-43ea-b50a-2c43b98270e5", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "4540b148-b6ad-4cef-a80b-07aac901151f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "ae608b02-4332-40d0-96f3-dfb56db5af26", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "5d39919a-67dd-48a8-91ed-03e9b0cbfbf9", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.dynamic_crossover_rate = 0.7\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  \n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            crossover_chance = self.crossover_rate if self.evaluations < self.budget / 2 else self.dynamic_crossover_rate\n            if np.random.rand() <= crossover_chance or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def strategy_selection(self, idx):\n        r1, r2, r3 = self.select_parents(idx)\n        mutant = self.mutate(idx, r1, r2, r3)\n        trial = self.crossover(idx, mutant)\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                trial = self.strategy_selection(i)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Strategy Selection and Dynamic Crossover for Improved Convergence.", "configspace": "", "generation": 13, "fitness": 0.3433267538854526, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7340488434973462, 0.731102841525682, 0.7332645482144515, 0.7702001126223323, 0.7503511928291109, 0.7484951266185469, 0.7639036188625983, 0.7419688728977212, 0.7591595572923922, 0.6350385484032846, 0.5864574763748127, 0.6111064452993797, 0.5938039224783243, 0.5936951532095073, 0.6208810337591875, 0.6003867019857544, 0.6132659965220173, 0.6033742841269625, 0.12511897401741623, 0.13763906055853126, 0.13361178718605038, 0.127563684270669, 0.1311654189876792, 0.1319367784012898, 0.13353586098270276, 0.1371260746882883, 0.13423495117746587, 0.14962226316501914, 0.11283672024158009, 0.12196057492728452, 0.11516681084968439, 0.1390618511416094, 0.10728113939543404, 0.12304871320341082, 0.12180701074300049, 0.10881532306328112, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.4131787435889983, 0.3492573409375006, 0.3568318620970419, 0.4202906683215364, 0.3891723866257294, 0.29108786024265765, 0.39816789539096775, 0.41583097695986704, 0.36772890487829857, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15602585925873258, 0.1851268476287019, 0.1667618096655591, 0.2130983063845462, 0.16075958335429497, 0.17495147953166856, 0.19070315616552858, 0.17142868859964688, 0.17882716603203574, 0.1989781904141601, 0.26170653178304604, 0.1475962772265359, 0.17318945300740762, 0.22470249574304357, 0.16372223536180586, 0.2136823290451123, 0.1889785028982296, 0.19383164231673056, 0.26296304401087167, 0.35692778205569875, 0.2959402594255768, 0.3134065516764687, 0.2798458308961106, 0.24864016070190065, 0.3050521330583803, 0.356151217149866, 0.24029833547761337, 0.46934051851286274, 0.45723757821961897, 0.45193282202350493, 0.4122112065721646, 0.4768372970712016, 0.4322106233121573, 0.48672378968326424, 0.47285281156385794, 0.4757368201703317, 0.11944389907811004, 0.1513877790502749, 0.13924632468544984, 0.1901837179523136, 0.14002499726518258, 0.22854185585744824, 0.07364668772409422, 0.1406718568227221, 0.11671705634863194, 0.24768506820448866, 0.275210288095064, 0.2630571319916184, 0.25894231386926436, 0.3020579900850451, 0.3025481897797223, 0.2543901136637299, 0.23802502641981216, 0.2717329220333994, 0.6159137609957916, 0.6266527496809899, 0.6234625516070742, 0.6479432579584916, 0.6079545245754818, 0.6747509146807871, 0.6438811760733526, 0.5812339516188776, 0.6377025603170713, 0.09797594316055258, 0.09909628244708779, 0.1023035301528753, 0.10677151666580609, 0.0953759388340093, 0.09529339462931041, 0.09747364264288916, 0.0937958885755319, 0.10144767542989752, 0.1767934881217239, 0.15404202702408343, 0.15974412365745827, 0.1626613111089371, 0.14296141232210413, 0.18059450273638034, 0.1389109914014296, 0.14195982843985733, 0.16337817935626686, 0.3875152525529433, 0.3713156387190002, 0.3896783079350641, 0.3717917837106205, 0.3752580361286003, 0.37824022556623227, 0.43918408081563076, 0.41941076892523876, 0.41142309065861404, 0.2870635596001787, 0.28445374759749487, 0.28462993466899333, 0.2734324376663342, 0.26984315910785195, 0.29719469290312106, 0.327707764303632, 0.33549727187952827, 0.311599754887498, 0.21105550694283115, 0.18764481620472429, 0.200603950795467, 0.17757904180769823, 0.1792374452699238, 0.18622005757308102, 0.17817013388602632, 0.1859899615175723, 0.18850146910161747, 0.2805372295519175, 0.20205905390349044, 0.25262224818752843, 0.2134265332176335, 0.18966830841802484, 0.22904418909148294, 0.19230690652335003, 0.2155670280869756, 0.19032111665856888, 0.7736138196241596, 0.17650409433780845, 0.18406427024433947, 0.6374181236519847, 0.6620849997622258, 0.17247781004013374, 0.48636641703973305, 0.1784428414837672, 0.6097918097646093, 0.6839713429413881, 0.6404355978960155, 0.3933320087055805, 0.1933691009246924, 0.25137748393228476, 0.2854303636256522, 0.5780377745804426, 0.2088923613931416, 0.20388869483678707, 0.1890584166261281, 0.17741636832731256, 0.17995535499451398, 0.16974704279296815, 0.17636347025669596, 0.20321312480961262, 0.20837937822444597, 0.17893327448540752, 0.20937259150329568, 0.06738657750263788, 0.0849744779775421, 0.07531103953743545, 0.07949765548411492, 0.07683268802569454, 0.07935480127422578, 0.08325864043108233, 0.08037365168979216, 0.07439529713929749]}, "mutation_prompt": null}
{"id": "5874da0e-977e-4709-96b8-43845ca75100", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(15 * dim, max(25, budget // 40))  # Adjusted adaptive pop size\n        self.mutation_factor = 0.5  # Initial mutation factor reduced for exploration\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        exploration_factor = 1.0 if self.evaluations / self.budget < 0.5 else 0.8  # Dynamic exploration strategy\n        mutant = self.population[r1] + self.mutation_factor * exploration_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Strategies and Adaptive Learning for Efficient Global Exploration and Exploitation.", "configspace": "", "generation": 14, "fitness": 0.3415160460713618, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7403648724275476, 0.7325152722414081, 0.730037822193799, 0.7366427743553641, 0.7398148791053136, 0.7355542155331061, 0.7285758044481696, 0.7408857054538287, 0.7102626178009073, 0.5277158770140045, 0.5430755637028462, 0.5378846307274945, 0.5379504900203125, 0.5274687503396729, 0.5136628002114403, 0.549501571885874, 0.5078892790622961, 0.5413102223921096, 0.09308588456352573, 0.11033586245517979, 0.10729336255845379, 0.10480223291742108, 0.09953456308470099, 0.0945050134026687, 0.13270303751820123, 0.11346835930609755, 0.13044831880852492, 0.09433685570709349, 0.09120161141388361, 0.09400449751473028, 0.11322577592571725, 0.11064814353676433, 0.09788002474119895, 0.10317896928670456, 0.0918216451070677, 0.09087928874613604, 0.874968310958431, 0.7975830227967651, 0.7221653578413891, 0.7022463014540585, 0.8738455439786212, 0.8674074078785918, 0.8889455884168779, 0.9362131692666203, 0.9043249183871584, 0.37483595495477584, 0.3695820080260258, 0.3403725068353376, 0.37896414623140506, 0.3591151710897035, 0.34057180530226516, 0.3955787474679302, 0.34845176743034856, 0.3731328192449127, 0.7348852540173001, 0.719716578121572, 0.7080045640443462, 0.7315276898384553, 0.7104616566703299, 0.7048881069319055, 0.7020040173058514, 0.6934979995267453, 0.6868348471291714, 0.154199230643702, 0.24435466126013894, 0.31930966212830736, 0.15881318971657676, 0.25688290178370965, 0.16230636521137654, 0.20666519288942453, 0.3214177181361413, 0.18890128006038664, 0.12159991271958226, 0.17674629278412435, 0.3468010520754291, 0.21459737232748333, 0.1899509670219761, 0.24704859164099946, 0.1998060153945822, 0.3671403573103952, 0.35604235760902325, 0.3064857990296149, 0.28239480693102226, 0.2936427979739896, 0.29845093858215344, 0.32485348933011315, 0.28514247238907575, 0.2696358568397237, 0.3373509120042759, 0.3057585889949711, 0.4678231891088852, 0.43984019633308213, 0.4273469385995069, 0.48431357266665087, 0.45529684039960316, 0.40645070904360636, 0.4624633274742199, 0.46963576488367065, 0.44352738067029573, 0.10585143742290348, 0.11316328825125854, 0.08564840302098076, 0.17736381322923478, 0.14362749721950696, 0.11190000561104985, 0.11677354855969191, 0.11731082212994093, 0.1521808445602485, 0.2473854915220256, 0.24275800338142473, 0.283300847234485, 0.2576355862463341, 0.2710210472466723, 0.27214241905378733, 0.25896872171051466, 0.2594355112251584, 0.25322602286834606, 0.6184281080062649, 0.6465949354682242, 0.6419677951219553, 0.6224900681371182, 0.6470095423958317, 0.6187791751876497, 0.6200188689619692, 0.6285973345685252, 0.6027603546099305, 0.09500230575365642, 0.1036323664414065, 0.10951390958078555, 0.10905801591360964, 0.0957688362661262, 0.10087841902034, 0.09897410063108403, 0.09570861645683093, 0.10276248621682005, 0.18865173140472102, 0.16320041492686777, 0.1386887205576821, 0.15573006156471092, 0.12531007821314322, 0.1655161909836248, 0.15249320789818155, 0.156051758264114, 0.13126891343683056, 0.3608399535658956, 0.35519607226479566, 0.3838039230232114, 0.36396487071260386, 0.3738258524478295, 0.3794610125752481, 0.3879359287751788, 0.39001721356003505, 0.3752396924193555, 0.27223077853374544, 0.2633106608657354, 0.2927483608259558, 0.2913164276052439, 0.2892494053521679, 0.26280407830073893, 0.3115426934349995, 0.2878062954499363, 0.28912351731563835, 0.202188264842746, 0.20428222414384867, 0.19495243948017027, 0.20479719923179263, 0.18773433676495466, 0.1830966596115522, 0.19880277944262037, 0.19343883044826005, 0.1902428440611429, 0.18183583730093056, 0.18149477465015984, 0.18882427586692652, 0.2076577135686244, 0.20150390835325493, 0.18051406897814704, 0.18007653164989623, 0.2050186337737646, 0.22558949346985324, 0.49206940121757026, 0.625962037358367, 0.600502910042142, 0.6649932176001041, 0.5765649009073994, 0.5333156986115851, 0.5151217774001942, 0.4743415100593814, 0.5427426640482609, 0.4625791762635375, 0.28281183975281887, 0.4369229547885183, 0.566564913390153, 0.19797683155963108, 0.6725015554309188, 0.19978421020622938, 0.647381137975972, 0.5533291391545831, 0.18123951612031897, 0.19014315445141494, 0.1861514929751622, 0.18807553643647346, 0.20379074491153593, 0.1832712146072879, 0.18180574575037056, 0.1863061844980327, 0.1913871653659116, 0.08420194771752865, 0.06981066737553188, 0.08621042787028455, 0.0826459714404687, 0.07707860628328822, 0.07861187271990533, 0.07297236569374255, 0.06709384265342344, 0.07659788100329334]}, "mutation_prompt": null}
{"id": "7332e74f-6ca9-4060-8def-b07155f321e4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "da478fa1-1171-4ca3-b0e8-aa665fd70aa5", "solution": "import numpy as np\n\nclass ImprovedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.local_search_prob = 0.1  # New parameter for local search probability\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = np.random.rand() * 0.8 + 0.2  # Self-adaptive mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def local_search(self, solution, func):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        perturbed_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n        if func(perturbed_solution) < func(solution):\n            return perturbed_solution\n        return solution\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n\n                if np.random.rand() < self.local_search_prob:\n                    self.population[i] = self.local_search(self.population[i], func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "ImprovedHybridDifferentialEvolution", "description": "Improved Hybrid Differential Evolution integrating Self-Adaptive Learning and Local Search for Enhanced Convergence.", "configspace": "", "generation": 16, "fitness": 0.3525358971281768, "feedback": "The algorithm ImprovedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7378029285092391, 0.74061889856, 0.7592464734037305, 0.7577046393069724, 0.7381640925630226, 0.7597932375366598, 0.740208283143634, 0.7628383144731076, 0.7316161034181279, 0.5388469178569842, 0.571001191188705, 0.5296724410417735, 0.5669472662403849, 0.5343807920089387, 0.5449123499288822, 0.5683498530392117, 0.5817813421869833, 0.5561794826585209, 0.12103023527421175, 0.1366040731887237, 0.12716691419439263, 0.11513775170798835, 0.11135860649557894, 0.12081474288056504, 0.11305564755672948, 0.10227442438740453, 0.10661817403805984, 0.12262892717023255, 0.10474770106378095, 0.10244349637358352, 0.10239949631392031, 0.09937715366002542, 0.11440255525652354, 0.11252424415416884, 0.09738190735817809, 0.10677576510760789, 0.9726014438695038, 0.8835672076127717, 0.8677682638355131, 0.9206028833741102, 0.8698762573373744, 0.9163946401624924, 0.8598797184651161, 0.8406704593073281, 0.8721681913939974, 0.4254290895126849, 0.40899760243507777, 0.40585471004794904, 0.37198178208300436, 0.3591536110970057, 0.4055615003923366, 0.39904718285892227, 0.37184175318331714, 0.40982375224352374, 0.7270483691403591, 0.6704953959986494, 0.7505877328324293, 0.7343544123677777, 0.7626333921321717, 0.7752877373860453, 0.7152227018326162, 0.7270310140260343, 0.7391497603830885, 0.30854247619502406, 0.3087177848567698, 0.208870864765896, 0.4138267464043681, 0.16859789118939772, 0.21659520237492036, 0.26932320025468015, 0.3499433882451375, 0.30608610290557803, 0.24216483326685434, 0.1874568336439698, 0.3933093127660372, 0.23795553274959624, 0.25569228324785076, 0.3201537407920605, 0.2654507134437789, 0.2584688794837141, 0.3834912675857308, 0.2919377519880385, 0.34326256044589043, 0.308249270537974, 0.35546855091159035, 0.32386354536197126, 0.3035524803861449, 0.3419189397539599, 0.2951858183688224, 0.36744636176058265, 0.4762805726565935, 0.4964091267034447, 0.4754290931074674, 0.4611920213924249, 0.40293292186484264, 0.45985777391272176, 0.4702482528429357, 0.4962369777988903, 0.43036402410599583, 0.18596134957938093, 0.12476329524255148, 0.10882321006859552, 0.14276204919037316, 0.22311421943936083, 0.15406782521744566, 0.10483452442613106, 0.12969318296581145, 0.14132061949749564, 0.27506058510980125, 0.2885246725374142, 0.2698135383213659, 0.264986676812745, 0.25421144701128284, 0.28323665312805124, 0.27826762568654717, 0.2643261509521234, 0.29417716983062614, 0.6119778099329958, 0.6338104115398222, 0.6989049115057322, 0.6686059196405957, 0.6633862982920523, 0.6559461106906934, 0.6441647451465371, 0.6433602198031999, 0.6155365594291858, 0.10788112615861778, 0.10394281667935434, 0.09226230298354143, 0.10209343834848783, 0.09650790888045269, 0.09605845583235262, 0.0986447723418713, 0.09577170899166942, 0.0856069277656979, 0.1374329830037052, 0.16301294969816282, 0.22880738065395112, 0.17307514651222278, 0.1847603532157751, 0.2055989817838707, 0.21250619262351178, 0.18460203788448304, 0.18461559055975474, 0.3440209882831584, 0.38819186640637304, 0.3645248887702115, 0.3680208633868277, 0.3992611984202701, 0.35891781678573, 0.388662460375773, 0.4047942982427749, 0.3877474192703748, 0.28393228353666955, 0.28333173621875385, 0.29183513690951646, 0.28031321876866755, 0.276094511980311, 0.2841126928164083, 0.30452851429119276, 0.3301890037879981, 0.3101284907263573, 0.19652293991144643, 0.17467966883770425, 0.18282132332705192, 0.19682420677146606, 0.18611794317130181, 0.19412645732407696, 0.21299691076321792, 0.18138044701021716, 0.20642810859746785, 0.19640423904652426, 0.19986256748230213, 0.3084926710331971, 0.1823519654849589, 0.22617254256872688, 0.18341243871765145, 0.1967687521244087, 0.190364819643565, 0.19061802039963727, 0.7150888107005686, 0.6629522200177314, 0.16814993599558747, 0.6661794029158822, 0.17737171905777793, 0.7474488762701381, 0.18023164717670914, 0.593172517248808, 0.6841729603972184, 0.6480445445644767, 0.5410763796669558, 0.1653151484380212, 0.5042987259836409, 0.1592087974439912, 0.15695826054457507, 0.20735257094093695, 0.20160898968321872, 0.6973519139247601, 0.1825043286502146, 0.21691992592892895, 0.20081628035848675, 0.18045667998657677, 0.1855725556499459, 0.18395648455896463, 0.17964071373070034, 0.17629537498372816, 0.1702586279265912, 0.07236128153227273, 0.08525979573830866, 0.06779985873222416, 0.07521531516535229, 0.07020154001851775, 0.07492236924282714, 0.07160157796047206, 0.06977916815656793, 0.08211612765740794]}, "mutation_prompt": null}
{"id": "9b4ee46a-371a-4306-a400-63ade4143355", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.learning_rate = 0.1  # Adaptive learning rate\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        if np.random.rand() < 0.5:\n            mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        else:\n            mutation_factor = self.initial_mutation_factor * (self.fitness[r1] - self.fitness[r3]) / (self.fitness[r2] - self.fitness[r3] + 1e-8)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                    elif np.random.rand() < self.learning_rate:\n                        self.population[i] += np.random.normal(0, self.learning_rate, self.dim)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Learning Rate and Adaptive Mutation Strategy for Improved Robustness and Faster Convergence.", "configspace": "", "generation": 17, "fitness": 0.2303576989488602, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.4690121774673838, 0.44843193439312723, 0.48911794893514615, 0.4623862336747908, 0.4764898031670115, 0.4772091732097622, 0.44423763645585235, 0.45179928286561977, 0.44644112953202864, 0.05644508622108657, 0.058461673950035986, 0.04256279174844224, 0.09970065012415907, 0.04562716229622166, 0.0720579441737822, 0.07562478703885722, 0.09478285950900789, 0.06433015822810817, 0.10521380381906986, 0.1008313603044999, 0.1017656933520269, 0.09374850513312816, 0.10600313085938928, 0.0998454389534309, 0.1133832383228377, 0.10851242633514502, 0.09740662288963808, 0.08995525878711574, 0.09559629561707661, 0.10378350322221008, 0.09794383122269279, 0.09927977131973709, 0.08667102655794046, 0.10274741573831925, 0.09359432319164185, 0.09269601466623678, 0.9504163690042949, 0.9749225498859024, 0.9544877203769007, 0.9852054549992619, 0.9651796794810206, 0.9446186169957492, 0.9205720285813351, 0.9518033659224143, 0.9613925421917, 0.2749716577732233, 0.27314137045398224, 0.2501739539079989, 0.2719133221449592, 0.2647252828359852, 0.2744142938143572, 0.26132762309680546, 0.28811406645230553, 0.26382571625739126, 0.6954886967499809, 0.3337546399249657, 0.6307585028252317, 0.32161527590552774, 0.34328935356518464, 0.7002936849675825, 0.35850259189931144, 0.3239083596339064, 0.3225918151297438, 0.16733975121941802, 0.16467654596341763, 0.14873496651592744, 0.13916570428582764, 0.1607273140066645, 0.1566908850812193, 0.16672989499868396, 0.19428011318367988, 0.194880334510938, 0.11193828495494706, 0.11251863990530708, 0.18800527663590771, 0.16371556185690084, 0.16744019853107073, 0.15332554141185029, 0.15255332508979336, 0.140499332419585, 0.16960537399154585, 0.05132485330757808, 0.032859517022269524, 0.03294779946820203, 0.03666701124152527, 0.053096772694008365, 0.043073376056211754, 0.007233797171594447, 0.028775488229617063, 0.016551360120916292, 0.07917955997115966, 0.11063489803427351, 0.11481118364382348, 0.1630178204681244, 0.08771231110712174, 0.0248276799277648, 0.10394730589623813, 0.1256719180355239, 0.10139729942598574, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008690212682050946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10398957832606137, 0.10970061466612369, 0.10151655180460761, 0.1119547583062529, 0.09441126957977664, 0.11650469269375974, 0.11192643822980264, 0.11416818941232432, 0.11920163925949234, 0.4323360953792603, 0.3768174626931521, 0.3974508819240643, 0.4114112820174277, 0.3962095446182483, 0.4268460615391022, 0.37539808110302453, 0.4065552707193454, 0.4081794873893946, 0.09599443565916477, 0.1087576848889048, 0.09503750864941596, 0.0895233219061412, 0.09440137801981696, 0.09630500263308173, 0.09148908772582276, 0.1007762861002135, 0.09697928091049157, 0.15398803673917505, 0.23564930910477877, 0.16041479768075806, 0.19529823290459436, 0.18000154045633154, 0.16101734991362793, 0.15083769058039875, 0.1512768546995763, 0.17468547542383206, 0.2781499314111021, 0.2700808475882883, 0.2834595103679236, 0.27149287086555274, 0.269828751344409, 0.27979204556707105, 0.29076350909842064, 0.2879260488706191, 0.2958063521617662, 0.21502460876149143, 0.21158959777817632, 0.2184347855778639, 0.22043491703110019, 0.21681637263649944, 0.21190136888999456, 0.22151034906687495, 0.22594748365869466, 0.21220162956505084, 0.18987920814255443, 0.1755656704163332, 0.21175274154645796, 0.189769295567775, 0.21335784054861429, 0.20084801268770702, 0.18430382556158398, 0.22142513197704494, 0.18545314367331756, 0.18367898013751505, 0.18400927824208524, 0.21345858908900395, 0.18841753945127937, 0.19757397826374368, 0.1739974830976162, 0.18425303052059605, 0.17852486727512407, 0.1878122033765498, 0.5512871015572788, 0.6056770021521592, 0.15012505027597922, 0.17988892080397878, 0.6802978019732977, 0.18089321346240783, 0.48043042165077643, 0.1794522275530146, 0.6142255355132527, 0.577134992507158, 0.19640551228503378, 0.5411990705841607, 0.20349643733346345, 0.4166490854158005, 0.1883793724812537, 0.20949750902904485, 0.5452740923397501, 0.21092570724384363, 0.18629380679879837, 0.1892267188486879, 0.18017566590868517, 0.20249278424044714, 0.1893908144396581, 0.1921005873362155, 0.18332770909118856, 0.1842483747059267, 0.17683801072231764, 0.08549331436886642, 0.07094433958885915, 0.08384345474088062, 0.07213270521805859, 0.07039090202689824, 0.07356766194923836, 0.08168890434451737, 0.06885832451470253, 0.0694262207626467]}, "mutation_prompt": null}
{"id": "3a071dd9-c7a0-4292-a1b3-e9674983c129", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "6c815582-1ae2-484d-90a2-61a434c4fdc4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "98a1a537-208b-4c15-9800-2026a2c5bdec", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "2a9bb6bb-2d02-4f63-a287-26cad8b47610", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.mutation_factors = np.linspace(0.5, 0.9, self.pop_size)  # Adaptive mutation factors\n        self.crossover_rates = np.linspace(0.7, 0.95, self.pop_size)  # Adaptive crossover rates\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.mutation_factors[idx] * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        crossover_rate = self.crossover_rates[idx]\n        for j in range(self.dim):\n            if np.random.rand() <= crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Improved Hybrid Differential Evolution with Adaptive Strategy Control for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 21, "fitness": 0.3490273201329394, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7772379136552467, 0.7825696043378743, 0.7760580463436756, 0.796118855136801, 0.7870989664725101, 0.7858270281083104, 0.7800585162233767, 0.7864275533340576, 0.7860629308772564, 0.6358630870846855, 0.6370778256882168, 0.6297088283965421, 0.6210400668962242, 0.6527223750275097, 0.6445956185135341, 0.6399297242257033, 0.6357358049546763, 0.6545165683222998, 0.13447731523621242, 0.1900978337835202, 0.13464021313439667, 0.18443288679606684, 0.14605963830099222, 0.12785043664771367, 0.16760519961384512, 0.16956788213175022, 0.1256779048124117, 0.11520651739566168, 0.1138078610939689, 0.12186135427078493, 0.15536747799879047, 0.13138887544337818, 0.11873072969363607, 0.14291294464769322, 0.15266525268518794, 0.12431722691444558, 0.968443835130255, 0.9621768198221123, 0.8821521679829188, 0.911088500202632, 0.9068703690485242, 0.9221833071163259, 0.9363402359748808, 0.9752417836675521, 0.9338648402290142, 0.3686396141401638, 0.38797249184798854, 0.3740053533140214, 0.32703089017426357, 0.4148673725813914, 0.4083815486495894, 0.35820977176011115, 0.3276523269917627, 0.31326155207481543, 0.7148899000013897, 0.7210469855548041, 0.7176689768208142, 0.7165232338233439, 0.7337881291944888, 0.7458727953416615, 0.678349328118161, 0.7118277066297811, 0.6811399567854559, 0.15888986617893897, 0.14030534628024816, 0.18561435830845707, 0.16547014289751716, 0.18827462600691003, 0.17728281699318504, 0.16065323733436832, 0.20667866384373523, 0.24501223987899234, 0.1765719910796033, 0.1856672050045367, 0.15304751070895817, 0.17007090299356753, 0.1840010479344797, 0.1797922029193615, 0.15089018838808965, 0.1969357286850062, 0.17299998264153782, 0.33934533354794616, 0.24485623965842718, 0.2233003745652049, 0.29424832582097815, 0.3359921881012874, 0.2551920037768628, 0.3277318274217318, 0.19202683843170576, 0.24645346788844325, 0.33218548491489563, 0.407514337758202, 0.3607529802452828, 0.3971505484910841, 0.3819939955833275, 0.38791412851174445, 0.5059441770220707, 0.4911914413381876, 0.42413519734070804, 0.1366041729797064, 0.09737609734351538, 0.05986391245191702, 0.19214853354885086, 0.1257579138949182, 0.1740150183557011, 0.1354284479611101, 0.13609701492069903, 0.11777418082420632, 0.2586671064920305, 0.30384821966001496, 0.25489959345776303, 0.29018798179702643, 0.28359974813698496, 0.30401409119503764, 0.28478807587740385, 0.2549427801119639, 0.22848064574907279, 0.6660156306272197, 0.6616549640919713, 0.6792974296820994, 0.6179648562711735, 0.6585948478675736, 0.6726257479300009, 0.6304893661415217, 0.6113714779169527, 0.6838229670157532, 0.17001052158231866, 0.12150708356888795, 0.11237499439174792, 0.11545858304314738, 0.12487380039583218, 0.10645652031388964, 0.12251418857534646, 0.09553651436929689, 0.10111155705123287, 0.16857073660809185, 0.15662397467293032, 0.14535869208511998, 0.16939141052250417, 0.15981530530522925, 0.15733102316025938, 0.21130337954983835, 0.14439033180376282, 0.20209705786931342, 0.4291010705167547, 0.42446304103964816, 0.452065540508517, 0.4430177120610448, 0.39786978841001786, 0.4279235121430496, 0.43149392375328566, 0.46788067307742665, 0.4663238426743105, 0.31405306374526776, 0.3648730012441872, 0.3069857415097026, 0.33070019372236414, 0.33492295076514633, 0.3325125149744995, 0.346533627652976, 0.32663068567299947, 0.34324505829860996, 0.2092239536590612, 0.2133181950811871, 0.19769205306640092, 0.21419223152706846, 0.1853926035957163, 0.19647496982371526, 0.18778143699441274, 0.20464335224353103, 0.2148229914768569, 0.22400833983734691, 0.41549646370946114, 0.22723522258538953, 0.2624326296319871, 0.35604394083136925, 0.26009333636882304, 0.2820827975896604, 0.1929967010083402, 0.2011238681148636, 0.17898572154008274, 0.7471081512276485, 0.1821240421924204, 0.5774560924884731, 0.684328352142056, 0.1782599075148864, 0.5709001550787254, 0.17917451874785073, 0.4126236058269851, 0.19370621746866523, 0.19844187765999777, 0.683913528771281, 0.6585161501140033, 0.19632845413496403, 0.6753993405719865, 0.2040961676936991, 0.2051159467619713, 0.20402130558421927, 0.18770178131849358, 0.17959451227248024, 0.19078256049039055, 0.1789534091018946, 0.1681095017407408, 0.17962619744067687, 0.17374765875881948, 0.18417507696443758, 0.18623621869902918, 0.08672394740552114, 0.0763204804331783, 0.08394404900508157, 0.09185633997629139, 0.07212556212194754, 0.0822497751516772, 0.07698323585992528, 0.07901105536061137, 0.07965911933510428]}, "mutation_prompt": null}
{"id": "b6b5f604-072d-4e1f-a309-123a7bd9f9a6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "9b78e326-2c09-4074-88cf-af0359e687f5", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "dd088f8d-6fcc-4494-a7e1-2be9a24ccf2b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.elite_individual = None\n        self.elite_fitness = np.inf\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.elite_fitness:\n                    self.elite_fitness = self.fitness[i]\n                    self.elite_individual = np.copy(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = 0.5 + (self.initial_mutation_factor - 0.5) * (1 - self.evaluations / self.budget)  # Adjusted mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() > 0.75:  # Local search probability\n                    trial = self.local_search(self.population[i])\n                else:\n                    r1, r2, r3 = self.select_parents(i)\n                    mutant = self.mutate(i, r1, r2, r3)\n                    trial = self.crossover(i, mutant)\n\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                    if trial_fitness < self.elite_fitness:\n                        self.elite_individual = trial\n                        self.elite_fitness = trial_fitness\n        \n        return self.elite_individual\n    \n    def local_search(self, individual):\n        # Simple local perturbation\n        return np.clip(individual + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Local Search and Elitism for Robust Global Optimization.", "configspace": "", "generation": 24, "fitness": 0.2926115197465366, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.6414776687735737, 0.6150615584920542, 0.6245534877058484, 0.641035196486313, 0.6158406501568991, 0.6476559183106028, 0.6436364284088419, 0.6403806919349946, 0.6386565650926364, 0.3937163812428729, 0.3736528194532479, 0.3827740283643445, 0.4176847983704073, 0.3989114097883689, 0.4047605012494522, 0.3901771341786858, 0.3935112958615904, 0.38821851776349836, 0.10357806218547938, 0.10708395236262336, 0.09872005902180059, 0.11484725015819752, 0.10423159260337056, 0.10680575300380679, 0.1040877295030268, 0.10124118404846161, 0.10299808987417813, 0.09349441331801189, 0.09598048106789014, 0.08398436039834101, 0.08820866778182501, 0.08849592509323279, 0.0919138607483343, 0.08356154009489258, 0.0853051084335733, 0.09048560172033193, 0.9009951163459001, 0.9059855735871153, 0.9335862988779807, 0.9217413714197418, 0.9425747714761636, 0.9062864757167761, 0.9314187717283988, 0.9124597494925017, 0.8966326953384224, 0.30769655976863775, 0.27778912117419907, 0.2782864973774376, 0.3147443531925569, 0.3072854973818975, 0.29474355756950565, 0.2940873338893504, 0.31665011770937257, 0.3254075040201444, 0.5695752270528917, 0.6060555375708141, 0.6021653490832195, 0.5506081798422422, 0.6427699639537108, 0.5324872132945925, 0.6199340846462007, 0.5672300365183933, 0.5917704714127752, 0.21484544964861074, 0.2104758324275282, 0.21245106061960883, 0.219218707507415, 0.18162356907314514, 0.17004257808921253, 0.2812604019971018, 0.17776861543913525, 0.286483487592182, 0.18892920392575763, 0.2053632616595611, 0.15865858534824384, 0.19482136180082676, 0.17093384065350126, 0.2406126975665065, 0.16579921572452583, 0.1758047471857408, 0.15823132889971947, 0.19778237437766333, 0.17684379783039095, 0.1864350699715851, 0.199001164048754, 0.1732343463825693, 0.16836863147376913, 0.16890955648049089, 0.2190568910365076, 0.16414162820474976, 0.32880563170369836, 0.3306043992069001, 0.2995214679973356, 0.3167960561443933, 0.3009002749642482, 0.3244221800626267, 0.3360063497399207, 0.3202502153233845, 0.32995579360649285, 0.04749121521766608, 0.06905395471417142, 0.0519777216598073, 0.07423853194757446, 0.07216475086101914, 0.048786762639217884, 0.06904902970757343, 0.07591625724029016, 0.08268930636138017, 0.20407049858860615, 0.17914923799889326, 0.205040104212461, 0.2018139435932803, 0.18269015221608853, 0.19790636740323408, 0.2125550025611468, 0.19623900846629605, 0.18273610161158316, 0.5055697157026937, 0.515093507374307, 0.5190058852004739, 0.4972157596263983, 0.5113357096452047, 0.5240219786019082, 0.5048944565198898, 0.504552467962283, 0.5128968781793302, 0.0981861809363781, 0.1009475144725187, 0.10572651747594997, 0.10065153501881174, 0.09545140388443452, 0.11038118079618087, 0.08682303791205159, 0.09573323309730675, 0.0948191425760091, 0.17614987046540687, 0.3101147436216999, 0.15144169284074527, 0.23547982472649787, 0.2173050730719729, 0.17825592555522796, 0.2003634181638777, 0.19958869599494788, 0.1561533225453693, 0.29921749203720105, 0.28334717110447305, 0.2935014097654458, 0.2961207605547105, 0.2460168709542595, 0.28477340460901424, 0.29108335440588007, 0.3194294643421258, 0.28351007055222066, 0.21019017201079748, 0.22755575448984755, 0.22477323379725977, 0.21734194036753463, 0.19478995004178223, 0.21458139795053022, 0.24739291088218585, 0.23734343325637597, 0.22974998784140688, 0.18220847060474654, 0.19847664489751227, 0.18124607056489328, 0.20420401461065196, 0.18632778253629845, 0.1836039392040828, 0.19241119191412703, 0.19140603248976007, 0.18795742240503677, 0.19301855408952984, 0.1879635835461646, 0.182367165188839, 0.18107601982794264, 0.20028385201804688, 0.18765278063143853, 0.18758871313360015, 0.1801082834378943, 0.18760244606905419, 0.19583044659843385, 0.378393477190327, 0.5976406810246144, 0.6515302591420647, 0.57125525367665, 0.6211627132822988, 0.6596498929753688, 0.6447560464801768, 0.4871705739804615, 0.5625563968942421, 0.1956501432923824, 0.5620883114187836, 0.25986742066991964, 0.4417709568529433, 0.4161055405949523, 0.20179875046295037, 0.19969901863466766, 0.20503404144222337, 0.169878101630223, 0.18828832027382725, 0.17878255252753983, 0.18904049433910575, 0.19507597319107883, 0.18189164014065695, 0.1859828072160422, 0.18616984367823786, 0.18549657363635308, 0.06836163913093929, 0.06757064174419591, 0.06898942714536083, 0.07640778521586056, 0.06738910299285161, 0.07041596968193187, 0.07292435882564219, 0.07166250934427876, 0.06779634861712092]}, "mutation_prompt": null}
{"id": "b77f89a5-ff41-43e5-a628-b50bdae213c8", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "8ab1d2c7-6e42-496f-bd99-0795488acf77", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "fec48838-6ccd-40f4-b0bd-645671f4d9d4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "56f83b75-fa83-4ea5-92d2-8365223d2e9d", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "513d16c9-a383-4585-8d66-9611cf41bca3", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "8fe01ba5-9b69-4ad0-94b0-9d05110c0814", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.7  # Adjusted initial crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n    \n    def levy_flight(self, step_size=0.1):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step_size * step\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        mutant += self.levy_flight()  # Lvy flight step added\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        current_crossover_rate = self.crossover_rate + 0.1 * (self.evaluations / self.budget)  # Adaptive crossover rate\n        for j in range(self.dim):\n            if np.random.rand() <= current_crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Lvy Flights for Exploration and Adaptive Crossover Rate for Improved Convergence.", "configspace": "", "generation": 30, "fitness": 0.21340114802859522, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.4622279693794519, 0.4326196282247817, 0.42747380429000015, 0.44416757677830543, 0.43161982621919737, 0.4390131563739903, 0.43851407143695265, 0.4482189152338414, 0.4642372486004087, 0.12273373746616723, 0.12105043833935214, 0.09643335736532588, 0.08685665030957912, 0.09327865025296322, 0.09326024223795115, 0.09184098013168573, 0.09316405486207713, 0.09945308394186447, 0.13116588711166732, 0.1241481158241079, 0.11161488551950882, 0.12772746880518027, 0.12248128037777684, 0.12325929306973227, 0.10846024258929265, 0.11097731510267417, 0.11700004281903531, 0.1098381080205405, 0.1086148751748437, 0.09864499340155886, 0.10335472280963331, 0.10602260449756618, 0.10886553139594557, 0.1023105085924706, 0.1034514753429372, 0.09769217463555402, 0.9532537695280006, 0.9731602623767837, 0.9435265759939361, 0.9145838705955455, 0.9142154622934432, 0.9474491488531445, 0.9471501045776061, 0.9459282456521545, 0.9266416586157261, 0.2510936246492479, 0.23986610240585327, 0.240574169804606, 0.24379012157245716, 0.2308257546505883, 0.24622757809257378, 0.25791198593518216, 0.24770384274222468, 0.23677137700152073, 0.3067603020225912, 0.28952538266288297, 0.2997221703144689, 0.2898884021493445, 0.3411307099219205, 0.3564162029003948, 0.3039369456693758, 0.2926706641287117, 0.3042786330696068, 0.14115094974815767, 0.13313537005953602, 0.14941760902705514, 0.15304173406491195, 0.13350021013234015, 0.143764368354945, 0.14651366458537318, 0.13216817791414492, 0.1365341829170026, 0.12959608312453363, 0.10825455718066701, 0.10343139265445611, 0.1295995281674044, 0.14385484570908214, 0.13011510326187636, 0.13250393110817626, 0.13432114368603632, 0.13988768020301146, 0.0038266179416225343, 0.0046455041933740615, 0.0038232304256671235, 0.03207444425997508, 0.008486978746610085, 9.999999999998899e-05, 0.016166023354344028, 0.020712367718813907, 0.033977101194517134, 0.08519942225492283, 0.10018075620678879, 0.07989640192740421, 0.053581036541942906, 0.09354888695608665, 0.09116062095122401, 0.08334113220448125, 0.08744076605470696, 0.08651460693935187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08008278570320149, 0.10335815859412523, 0.09862314605372358, 0.0972533697526462, 0.08667194350633745, 0.08615155380843209, 0.08382133074873599, 0.08513804908042821, 0.08163964890514508, 0.3830831670408783, 0.3824468958257422, 0.3904937463953303, 0.4137389988149257, 0.38777535424222354, 0.4013859743800945, 0.4239122549880573, 0.3975423688826455, 0.40391073853912607, 0.10334067319646822, 0.08246792250864787, 0.11122288456106266, 0.0983842408088259, 0.10091953793674946, 0.09447193380920438, 0.08412324813637584, 0.09896417058295937, 0.0979515432967899, 0.15762113481405216, 0.15411261745073057, 0.14202081858785243, 0.1479366484161999, 0.17634237584028212, 0.15830363956746618, 0.15398316120987443, 0.13681967170284992, 0.1495379421321339, 0.27308140863178065, 0.2706231790537965, 0.2733452684707428, 0.2648635947453698, 0.25972069062764025, 0.2620834488394709, 0.2792288657144245, 0.2782964654281054, 0.27602003552122056, 0.20943696798769884, 0.19458464693398636, 0.19774767433376905, 0.18407293313124173, 0.19694388276296182, 0.19911505950683384, 0.21562526385503322, 0.21983488050995914, 0.1993731256579283, 0.18753293851586683, 0.18963340670441742, 0.20268933290456703, 0.18828785646502288, 0.20555318600216543, 0.19046715924641344, 0.1894124842915449, 0.19567513531298464, 0.18142048154073187, 0.21879595969080834, 0.19640552369853548, 0.19887516617529855, 0.1817940483778746, 0.18487134860077303, 0.21521695967865695, 0.1898376775302283, 0.20458004936715535, 0.19751335387442737, 0.36429726685273034, 0.18292400016573418, 0.34739419936411564, 0.34027986828998724, 0.4199717354732435, 0.16795200436156155, 0.3516726924082938, 0.3312909616333407, 0.4224858341305082, 0.39926715041625527, 0.19596301667418348, 0.21086623745250743, 0.3883342108464841, 0.18899197259499723, 0.2752821037160148, 0.44905004133744664, 0.20290600891254262, 0.4287456587426517, 0.18167776313689532, 0.1949428718335655, 0.19134839880657195, 0.17565132419443585, 0.19530296491345867, 0.17425702970312396, 0.19397752531914347, 0.1866087201127813, 0.18537138702100842, 0.06705895643835302, 0.09204524761358368, 0.08643298538167943, 0.07278965591030773, 0.07240199094814814, 0.07619107098562705, 0.07374173373734905, 0.0714048681852828, 0.0744929925685317]}, "mutation_prompt": null}
{"id": "c9ee0b44-046c-411e-a925-169a83b063c2", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "57f247a8-3ef6-4f93-a05b-208d756bc024", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.learning_rate = 0.1  # Learning rate for mutation factor adjustment\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.mutation_factor * (1 - self.evaluations / self.budget)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.mutation_factor += self.learning_rate * (trial_fitness - self.fitness[i])\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Strategy and Learning-based Parameter Tuning for Better Exploration and Exploitation.", "configspace": "", "generation": 32, "fitness": 0.3537035111906692, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "5755409b-97aa-4acc-bcb3-8962ff3254b4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        adaptive_cr = self.crossover_rate * (1 - self.evaluations / (2 * self.budget))\n        for j in range(self.dim):\n            if np.random.rand() <= adaptive_cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        return np.clip(opposite_population, self.lower_bound, self.upper_bound)\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        opposite_population = self.opposition_based_learning()\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n            \n            # Evaluate opposite population after main loop\n            if self.evaluations < self.budget:\n                for i in range(self.pop_size):\n                    if self.evaluations < self.budget:\n                        opposite_fitness = func(opposite_population[i])\n                        self.evaluations += 1\n                        if opposite_fitness < self.fitness[i]:\n                            self.population[i] = opposite_population[i]\n                            self.fitness[i] = opposite_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Improved Hybrid Differential Evolution with Opposition-Based Learning and Adaptive Crossover Rate to Enhance Exploration and Exploitation Balance.", "configspace": "", "generation": 33, "fitness": 0.21701063372999105, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.6013360039357409, 0.5788531551260092, 0.6175643023445647, 0.6466445661933964, 0.5785945166266946, 0.6373365914766256, 0.595434335647202, 0.5991501516343831, 0.5866290891642857, 0.35245257133575747, 0.3657694749872116, 0.34777059728240856, 0.3399542384705846, 0.3249635661168576, 0.3845035890065105, 0.3159816507928004, 0.34632947207306697, 0.3486979383483073, 0.12422540910702207, 0.09997324816247821, 0.11456397433727217, 0.10862096242578811, 0.11395838119130897, 0.10671467794621348, 0.11183558327099796, 0.10372254144079285, 0.10787994784824984, 0.10005286082522835, 0.09509150487352003, 0.09855967789591502, 0.09685154274373275, 0.0930667508644305, 0.09826884884717291, 0.09162993589776758, 0.10307925107598603, 0.08526332201782405, 0.8793127650883138, 0.8962673422357716, 0.8532918954062798, 0.9175559525974382, 0.9044307519893547, 0.839440414459676, 0.9584663981942797, 0.8739079952976522, 0.850756896338311, 0.19170833537663057, 0.19603521601686813, 0.19733885047644117, 0.19967243775951315, 0.22017799274742633, 0.22444287492720305, 0.20288429602015834, 0.20809092037714494, 0.2162567154264211, 0.27858446169713, 0.32980641081991535, 0.2658154975360767, 0.3446704254903894, 0.4167020783552412, 0.335010353908627, 0.2729620114180974, 0.3647305765881349, 0.3340495474016051, 0.1253174202526416, 0.1324081205828741, 0.11570268051350918, 0.1386049058996237, 0.11351910331704207, 0.10457497014566941, 0.12174621026313648, 0.11577017062818573, 0.11860941691719618, 0.10714030778531192, 0.11772218717738392, 0.07756351185328025, 0.11779103272807445, 0.10939058241797706, 0.1573820749438275, 0.11571404811615993, 0.09130408312096772, 0.10757951808650545, 0.023735105927285116, 0.016657538242383252, 0.0335005699676727, 0.013298754271841795, 0.0102176625242133, 0.009420961727940824, 0.0036773796388490654, 0.020837474601284156, 0.005125371708111337, 0.1542981042174042, 0.14110037769973183, 0.1311195710867027, 0.14042704197050315, 0.12470483934965015, 0.09868392473481213, 0.1532693999071273, 0.106984252071194, 0.1868161120461237, 0.0013807427804054528, 0.00013554683205729834, 9.999999999998899e-05, 0.001826694391120709, 0.00030257598692118304, 9.999999999998899e-05, 0.007639304101706879, 0.008795347355962768, 9.999999999998899e-05, 0.09381819873961272, 0.09018546135325867, 0.09641888373020702, 0.11552908308326137, 0.11013118648782438, 0.11605273817816397, 0.09451022132353626, 0.09262005893027325, 0.09313850165098025, 0.4208532316875838, 0.4132284570134812, 0.42241124603391267, 0.4235092333890974, 0.4100000695193189, 0.4090498114862322, 0.3984875874335113, 0.40772538075833276, 0.4282916487130394, 0.08093482543801167, 0.08243426434806167, 0.08500453677801145, 0.08340594445968441, 0.07646562305853855, 0.07814762256185426, 0.07080777650358272, 0.0819449593939604, 0.07844330815929912, 0.15491492006696772, 0.1568188899729427, 0.1412780490328851, 0.1453817779349451, 0.12233845113471675, 0.14369532522179085, 0.13617999914046974, 0.12392494180013125, 0.12438055879182086, 0.2648429275695853, 0.27696280300782694, 0.26924015092261877, 0.2543606360819508, 0.2618336472788111, 0.2751517109285343, 0.2839106855838768, 0.2713185433406847, 0.30136516828640103, 0.19014942809780044, 0.18280546628349725, 0.21281666789960152, 0.19055706533040195, 0.1867669774227687, 0.1743880759938098, 0.20612616774268, 0.2018734216860717, 0.20263462882003103, 0.19371132940293945, 0.18375259889266615, 0.1875719175816961, 0.18355437371442918, 0.18707371630902647, 0.1802272097308938, 0.176525043455099, 0.18609234653661566, 0.15933929122302593, 0.17653629695160167, 0.18371333689020153, 0.1767803708820166, 0.17905841808186773, 0.1715390999646874, 0.18741872275426785, 0.17312162585317636, 0.19052914446378677, 0.1745070601620513, 0.2004244956209913, 0.16998587106593754, 0.16417390032961865, 0.4379321495873225, 0.19635110833327318, 0.24359725775579177, 0.1769077626905995, 0.193227085025499, 0.2865841901134143, 0.2644794489409512, 0.17684499767909423, 0.13947554343971624, 0.17393842571833118, 0.1842448332329072, 0.1352775799930005, 0.2182863715271015, 0.2784788610862995, 0.20232205802365144, 0.18527435453014796, 0.1668317004326758, 0.18746316432284593, 0.17960551283186965, 0.1977299867431077, 0.2032125695080068, 0.1759536467656384, 0.17553911028659064, 0.1805821388289396, 0.06912065198786277, 0.072167998457487, 0.0696878461418945, 0.07775783590601204, 0.06769451457859554, 0.08445954041411274, 0.07183673944511026, 0.0667928122931628, 0.06364733042961213]}, "mutation_prompt": null}
{"id": "d5b22a72-76b5-4a49-ac9a-fa208328e6a1", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "aad23162-d419-4b25-bc5c-3c3a91850fe6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "65d16240-f8a8-4bc6-98c2-6e4f77bc3021", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "638ef9fe-f7dd-4d68-8019-a6b65e2b2909", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "a5fdbe4a-63fe-42b4-99b4-b8b71c3df0e0", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "02a0e64f-145f-4555-8e1d-8cc79c86753e", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))  # Adaptive pop size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)  # Dynamic mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Dynamic Mutation Factor for Improved Convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.7349489443964317, 0.7312214287997205, 0.7335174779536477, 0.7702001126223323, 0.7503004709558531, 0.748671227090434, 0.7639036188625983, 0.741896874751081, 0.7591595572923922, 0.6354785861758434, 0.5891405688895763, 0.605482763172992, 0.5964639388779446, 0.598399048551429, 0.6239626822035652, 0.6002343350049604, 0.6164481576224945, 0.6047194200212053, 0.1102301471678171, 0.11825756150900757, 0.1382624003060522, 0.103429570612671, 0.117264607848508, 0.1078286826966307, 0.1274210551319207, 0.12926819659133648, 0.13909380688596173, 0.13040256607260214, 0.10272142537776818, 0.1121831510621436, 0.1176952384880029, 0.12034379542401452, 0.10103349916988369, 0.10277872428908919, 0.11504482354237222, 0.103163301049367, 0.9712108350741211, 0.9524312108578546, 0.9149226759657616, 0.9687111734275069, 0.9534152350458027, 0.9269311779231953, 0.8960347339301096, 0.9386655581210954, 0.9654231585782912, 0.406551078530491, 0.40390008581397263, 0.34132785830572654, 0.4290113235417602, 0.40108900997672503, 0.2889303964226473, 0.4057067149145299, 0.38588691713412626, 0.37026719850348355, 0.6731890602806527, 0.7286919743589872, 0.7072415915813364, 0.7184907243644822, 0.677946802892258, 0.7006377735513165, 0.7094523342246435, 0.7171839331811074, 0.7233300239666554, 0.15484799493717472, 0.18529308477108863, 0.167599827826722, 0.2111194952980291, 0.16027618731611726, 0.17501842708043536, 0.1890196415738059, 0.16986565403044585, 0.18135179814027091, 0.19951456306141913, 0.2765202061612654, 0.14630662720061338, 0.17436261330736502, 0.22410983914015514, 0.1640789883302134, 0.21385887571654327, 0.1924347805736365, 0.19413214161315817, 0.3201061193360558, 0.4296140386009901, 0.35171528805210495, 0.3777136752068776, 0.4115780876702533, 0.2693191698666828, 0.36416276302433415, 0.3237544345360698, 0.33639516110687495, 0.5503170797361293, 0.5099945732484488, 0.5499357136647383, 0.4882697738679026, 0.5090275226350143, 0.49030122556406686, 0.5115535461226991, 0.5400348950779938, 0.5501308440143575, 0.08287630145844482, 0.1717556095289967, 0.1563106858611456, 0.20226727944930212, 0.15593046720280312, 0.25108137926559115, 0.10786754503340035, 0.14815508331313498, 0.12718762705137598, 0.2875987663592383, 0.3220528418966949, 0.3367359960609557, 0.31393090285672576, 0.34195311886691115, 0.3267423384216278, 0.26662081524194936, 0.28410393572511716, 0.3260120054291116, 0.6461578658175073, 0.654600253573812, 0.6675614932998994, 0.6550284135118933, 0.6759466918726866, 0.6803413313789018, 0.6728073588729153, 0.6161490981520302, 0.6697722794593768, 0.10388507687767601, 0.1301677799796075, 0.10282881514376296, 0.10651671953752262, 0.10594201453719776, 0.09602982132348115, 0.10003076733727179, 0.10175834815274498, 0.10427798324979887, 0.1767974157320148, 0.16240590394947974, 0.15586269415617204, 0.21358012878182941, 0.14491087858662666, 0.18204541589084278, 0.15912716651281933, 0.13771128016391998, 0.15817287515945222, 0.4028228158293258, 0.40007016932510164, 0.3920702095461327, 0.3914802788877173, 0.40847875715193227, 0.385422703520638, 0.41238694568595, 0.4444144524301168, 0.4120457144559976, 0.28557647542585374, 0.3256182845096538, 0.321588253113795, 0.29943736584391656, 0.3093837922885023, 0.34920658027884155, 0.3215821849192535, 0.34730590945098894, 0.3426449292330561, 0.21105550694283115, 0.1888352735765354, 0.21004069432568873, 0.19555444955116685, 0.18567046689745315, 0.18289137579994064, 0.18200890285586235, 0.19040272383480328, 0.18003509053867417, 0.26037378662633104, 0.20603910874739306, 0.19552502251419235, 0.189577730898138, 0.1878532122475559, 0.19587944779019206, 0.19383471502383376, 0.2041922830828894, 0.22691285124892735, 0.7736138196241596, 0.17650409432873315, 0.18406427163446093, 0.6384020614011088, 0.6620709793890618, 0.17248164362382545, 0.5278486038456784, 0.17844284143919975, 0.612544673178613, 0.6848411114013347, 0.6410790466598268, 0.40359625444495517, 0.19336908873043235, 0.2481833992546948, 0.28271003788119153, 0.6481299275575048, 0.20889236139579426, 0.20388869483648708, 0.17926090057377553, 0.1871636672345155, 0.1786950229165788, 0.16974704279296815, 0.17919763486911355, 0.2032125695080068, 0.20837937822444597, 0.18095985840109108, 0.21087859103239903, 0.06825422613928289, 0.08412648506842246, 0.0742337384910634, 0.08112274271749442, 0.07581316874686161, 0.07679136345473014, 0.0819675625713846, 0.07843184413904869, 0.07245569089498782]}, "mutation_prompt": null}
{"id": "9d07d742-8e75-40bd-bbbd-774d8bf7d0ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(12 * dim, max(22, budget // 45))  # Slightly increased pop size\n        self.initial_mutation_factor = 0.85  # Adjusted initial factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        chaos_factor = 0.5 * np.sin(self.evaluations / self.budget * np.pi)  # Chaotic variation\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) + chaos_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Exploration using Chaotic Maps for Improved Convergence.", "configspace": "", "generation": 40, "fitness": 0.21729350145522677, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.506227902200725, 0.5046918407535741, 0.5077581637153482, 0.5322053945430805, 0.5398226543694516, 0.5247974348739324, 0.5497397692703517, 0.5066460435409783, 0.504140363406033, 0.26465741834385403, 0.27949908077214036, 0.26007867839055454, 0.27025696979189184, 0.27399322180114627, 0.27488142497883483, 0.28627500722131427, 0.2783799606563685, 0.2859592261454049, 0.09364007521506901, 0.0901178978730448, 0.12413600652228851, 0.1105503114582056, 0.10004651832762523, 0.09447426694788263, 0.09946795304514322, 0.08883500988218784, 0.09497643127135491, 0.08149220661123036, 0.09071044007494278, 0.08156981043640321, 0.08447920801879549, 0.08613523268953871, 0.08978156019369066, 0.08499191882626944, 0.10359300145723205, 0.07699551631758239, 0.9551797589592984, 0.9366853797794454, 0.9505424655060831, 0.9560530086717238, 0.9548935314929651, 0.9609928202216778, 0.9717116056010112, 0.9295935311059318, 0.9509980807642867, 0.1934780268660754, 0.18886807398980676, 0.21244034746830853, 0.20317693013148896, 0.2126597555039248, 0.21054780744987223, 0.22148991608669433, 0.23048916527695307, 0.20848728904421132, 0.3281021678990864, 0.3458896625096122, 0.32082152001335273, 0.3334784900600627, 0.38590072985453083, 0.33479117932104774, 0.3195247142869526, 0.35915136598824116, 0.33954231027002846, 0.12632092615539858, 0.11069022251381466, 0.12550550487878376, 0.100226321639725, 0.13478689505586716, 0.1089203226486205, 0.12528115138136187, 0.13213755350427547, 0.15268876662661335, 0.13467656146533757, 0.16762887277832672, 0.15399549397543522, 0.12007583265580746, 0.10376819799474246, 0.130988721518576, 0.10821185401311628, 0.11652626576193303, 0.09404609762405003, 0.036408807572906654, 0.044109761640910405, 0.042306348531509275, 0.037566015871727365, 0.040277820542148235, 0.05045712623308829, 0.04205774698703113, 0.03384331578404198, 0.04741727425332265, 0.12919287014377046, 0.12950606894769734, 0.14368225064363327, 0.1410936127729221, 0.1491188305000224, 0.14866358988350825, 0.16044534674837363, 0.17538969380601976, 0.16694743314409788, 0.014041399228634455, 0.015057720007226827, 0.010296420871657719, 0.007338260555186049, 0.007735770220733684, 0.013767417856146547, 0.0224918276961249, 0.009631047213281452, 0.013146999970580886, 0.09606973272547348, 0.07780684828549456, 0.0986994578135485, 0.10735707663684901, 0.11061989815986106, 0.10604175844160746, 0.10054122756719885, 0.0963762218790698, 0.10519024778867259, 0.4088153147561444, 0.41188093551176685, 0.3908800949379808, 0.3932763376587952, 0.40736879120416924, 0.4082541223841005, 0.39968627041714966, 0.3903852596250629, 0.392160518091067, 0.08202840868434069, 0.08341270795137223, 0.08040432999437619, 0.07133319321236153, 0.0747511403319635, 0.07999752466836196, 0.08752479241478772, 0.07727748483682806, 0.07092896532959625, 0.13833803438866688, 0.18725368338338033, 0.16885921345083754, 0.1551003234412226, 0.13950835151842034, 0.1346777915424744, 0.13359736906945652, 0.15884031004066967, 0.13824222593724111, 0.2536050617322767, 0.2124897162101841, 0.2576626888940198, 0.22892487831574937, 0.21566898316402316, 0.23642986834587953, 0.2622343887799047, 0.26145777075662247, 0.25648528678574567, 0.17871224009139064, 0.1651545204797792, 0.18943634433490775, 0.16564268989021314, 0.16285787596495482, 0.16514917473417612, 0.1870256751371293, 0.19230504366170198, 0.17969619710246754, 0.19860391127666177, 0.17049873304822338, 0.17514847205198059, 0.1737423759248482, 0.19075763577861327, 0.15858198108814325, 0.17157177025657422, 0.16777928852770752, 0.17698405509009008, 0.1757714882625141, 0.18679446023251034, 0.16902205272572135, 0.1781227474354875, 0.17472172345793258, 0.1719822382041346, 0.1818711367071465, 0.16233068128542927, 0.17869199738427866, 0.16192713347338028, 0.16129883218796204, 0.5006739084020988, 0.3099212380956694, 0.23740332832648048, 0.17070242441215755, 0.14886781485907663, 0.3303104229797589, 0.18571438574702337, 0.1647285991784223, 0.3854648601040116, 0.19631483158512442, 0.2934025954294138, 0.15333011530940732, 0.21134175251611453, 0.20601889565191567, 0.3873707702571585, 0.49227295184814435, 0.21425512929312696, 0.1840263239313077, 0.19507177245342355, 0.1955169972512173, 0.18071692103675818, 0.1756853525263541, 0.1861453302750654, 0.21198875182767363, 0.1785451144747463, 0.06791929116806517, 0.06533615298997197, 0.07250006946855214, 0.0721043780552938, 0.05984580051577648, 0.06339744061917973, 0.0703349829886829, 0.06986220498031526, 0.05771842902643298]}, "mutation_prompt": null}
{"id": "b27866fe-434d-4755-990f-106ea7a75984", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.best_solution = None\n        self.best_fitness = np.inf\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        memory_factor = (self.best_solution is not None)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j] if not memory_factor else (0.5 * (mutant[j] + self.best_solution[j]))\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n            if not self.evaluations % (self.budget // 5):  # Restart strategy\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n                self.evaluate_population(func)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Adaptive Population Dynamics with Memory-enhanced Crossover and Restart Strategy for Diverse Exploration.", "configspace": "", "generation": 41, "fitness": 0.29161635609539877, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.9541788970612132, 0.9538468270952303, 0.9496173802885505, 0.9516850609069539, 0.9511342138985381, 0.9522150933599673, 0.9535694796152082, 0.9539322066256747, 0.9510795385357784, 0.10733337454860159, 0.052811053407523234, 0.1853809943903525, 0.016933401479069854, 0.03530611084069313, 0.2312966877220035, 9.999999999998899e-05, 0.5582353912630102, 0.12946210069808117, 0.17774138014438956, 0.12359936383813475, 0.14752369004596, 0.1897546735497877, 0.13013985701586495, 0.13381992272654786, 0.1319874636925813, 0.16215419424285615, 0.1607957687420163, 0.0983994856052739, 0.11166953478526065, 0.06384920848246856, 0.09801256585516127, 0.13006943207134103, 0.10490919844250235, 0.18543513227936848, 0.10071082761018701, 0.069680415575056, 0.23671448624071167, 0.5940130052340653, 0.3625256399415274, 0.5146883511178628, 0.44228494849206, 0.1357633905995066, 0.42162302259239604, 0.22753125470200808, 0.3624091922752334, 0.37129693371957484, 0.41354985238972675, 0.3743625455952694, 0.7026404877152228, 0.3425825927142705, 0.4639644715140664, 0.6037892404029028, 0.35393563744717493, 0.44112589282629666, 0.40284973745008634, 0.9550342872996184, 0.1717594840488531, 0.38946338264313185, 0.21506661947786765, 0.228331345413485, 0.2372258104555326, 0.2140781613346735, 0.23485387165578298, 0.17155051533865995, 0.13342186141834678, 0.14744670234541568, 0.13052920458662898, 0.14292142968742683, 0.3709181533663144, 0.15424244389719843, 0.21493415474657662, 0.13642892354655234, 0.17503026160479274, 0.19577561556602874, 0.14204635687049283, 0.14224816809688035, 0.13337485195330223, 0.1331913128946004, 0.17625834681910268, 0.17563105924963152, 0.17489610437626635, 0.14692416468517044, 0.07443252406712941, 0.06231835734949831, 0.17462947550007724, 9.999999999998899e-05, 0.09239661306714786, 0.10325643146759778, 0.1484946776702062, 0.10624170460134519, 0.2903365810323828, 0.4281737855980642, 0.3171042555301259, 0.16184528312007462, 0.13428750499573738, 0.2244916886682493, 0.43668415632508906, 0.2964319363787127, 0.31294186331229845, 0.09054263405532725, 0.17526971937817382, 0.15710202004927543, 0.14414908952229055, 0.09236684988882937, 0.17191205175233348, 0.20403348748171857, 0.16542255966730557, 0.22478733307236476, 0.2623143005102172, 0.13446279859529509, 0.2373775651237109, 0.07986298870759123, 0.1584617021105682, 0.2572114451318964, 0.18756827192630032, 0.14779626009728197, 0.13214720956163528, 0.6396558056918624, 0.6753421990702921, 0.6770064720145006, 0.6528038220840697, 0.6208355879307181, 0.7034891173525651, 0.667795360464079, 0.7344101117649502, 0.7126882851795159, 0.07286122229488956, 0.16325898817396012, 0.0831978711949719, 0.11592193752224389, 0.11412733330043956, 0.123492773823342, 0.16242105716153732, 0.1452545545557914, 0.1052780496399659, 0.6776985244867855, 0.34124150110541296, 0.23163686244425752, 0.22196946187794475, 0.385283622412117, 0.3593371114071614, 0.436216381239796, 0.7855921492130788, 0.5039897013631832, 0.32685365776444164, 0.1899829033468261, 0.3465257169764605, 0.3868787237617043, 0.3237628787881016, 0.3429705560029571, 0.23999943079109387, 0.45283319881363526, 0.2835397647271243, 0.3002005310907644, 0.41118078022299365, 0.243665855262865, 0.24857128244526805, 0.2809342122060612, 0.23545857921414715, 0.1942255954649661, 0.28131570411914686, 0.23437277523371092, 0.22531210916009992, 0.26687207564465576, 0.21199561612080164, 0.25561006309629, 0.2647927605467312, 0.24330001478918184, 0.2515960650785434, 0.2483671766882587, 0.23979267344456856, 0.2107165109937832, 0.19236217199300687, 0.18727407907835625, 0.18298584205280044, 0.19777039821799158, 0.2215668483584624, 0.1865682655267663, 0.18958455529642493, 0.21364579225205793, 0.9640110989488503, 0.18849029223606428, 0.18774746628903582, 0.9646481260057359, 0.9605424998063303, 0.21116398719333018, 0.16552502820909265, 0.5490093717706422, 0.16275036233736917, 0.4621312977606109, 0.21363537677251732, 0.9461010437506969, 0.21368714180719384, 0.1262420193103484, 0.21169629023645453, 0.10546538225180335, 0.8746678433274662, 0.2399976070608716, 0.18311370711014618, 0.18251474318052274, 0.18695189069390017, 0.1735862985717822, 0.19965655178211705, 0.1759287082728721, 0.20028088950672596, 0.18686093282224225, 0.17981647890215335, 0.09196062721793874, 0.09830031200321687, 0.13434598827525768, 0.10524951091951373, 0.09482613036524168, 0.12553702148767587, 0.0932717355319499, 0.09210840511250373, 0.10456139233013129]}, "mutation_prompt": null}
{"id": "7c16ae92-bc5b-4dd6-8685-c19c4bdd8df6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []  # Track successful trial solutions\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() <= self.crossover_rate or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                    else:\n                        self.success_mem.append(0)\n                    self.success_mem = self.success_mem[-10:]  # Keep last 10 values\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "An Enhanced Hybrid Differential Evolution with Adaptive Population Size, Dynamic Mutation, and Success-Based Strategy Adaptation for Improved Convergence.", "configspace": "", "generation": 42, "fitness": 0.37234048537239034, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "846d4925-d854-44ce-9966-7e72fea0858f", "metadata": {"aucs": [0.8357551968955359, 0.8440318805291063, 0.8342202693080674, 0.8259229044336445, 0.8450912809276254, 0.8447059519855409, 0.8408215121918354, 0.8290490750524406, 0.8214996309077884, 0.7135607525005454, 0.7179594299283436, 0.7116463633184833, 0.6935835192912116, 0.7314996666823453, 0.7176424693512302, 0.7260694605896634, 0.711292585715833, 0.700782944824692, 0.15034062683146654, 0.1587379134775425, 0.17817056377327156, 0.15301241122985354, 0.19590651142134974, 0.15201212395541064, 0.20610626892670147, 0.18612856824450885, 0.15745939700510803, 0.1039508136915176, 0.1300450426589177, 0.15419439939161061, 0.1279573376361688, 0.13190750300234033, 0.15149256304837766, 0.1303130793682944, 0.12895060585730445, 0.13403288462564178, 0.8957086267693963, 0.8436337407759981, 0.7803658295582088, 0.7986488249982048, 0.7864810341531968, 0.8707577074274561, 0.8663225352061673, 0.9120517698113799, 0.957949914033352, 0.2994935663863746, 0.3347899786347721, 0.27918468331223434, 0.24564336378152662, 0.3194557254338718, 0.22673041994636334, 0.314964336340926, 0.28787280877885035, 0.17380931101309838, 0.8632626960259345, 0.8070479643373302, 0.8260946687670889, 0.8451337579452922, 0.8268113030876397, 0.846532281884276, 0.8443841074049183, 0.8424309829665838, 0.8036092049454218, 0.17454417706237457, 0.24784868102883661, 0.16295664745287108, 0.12890407379738866, 0.1287677797685205, 0.13384371785097593, 0.1700446325469671, 0.1482875294990268, 0.15749066029696768, 0.15593769593173767, 0.13392189068346938, 0.17109671240493807, 0.26288547891605796, 0.2867317309549974, 0.1900729210685328, 0.17386596193573245, 0.1776342878133399, 0.18542182234157256, 0.539521577384455, 0.4795143286148069, 0.4409263174269734, 0.14052350432900707, 0.33505169506485366, 0.30792969115976343, 0.3695817656500686, 0.06931580635495571, 0.228534432652429, 0.4719200223399773, 0.22501372094920014, 0.31714606054037653, 0.6187354929741176, 0.5019950632604706, 0.0826086027607491, 0.6669396051723286, 0.6435275431341791, 0.6444680022575053, 0.16456033950144444, 0.10582390139245201, 0.07189501434326462, 0.10914757249266227, 0.19822317028590997, 0.22240489599093516, 0.11259277172308935, 0.18893957412496032, 0.14597469606766877, 0.3261808314063649, 0.3833736492569826, 0.3737763302818514, 0.4057438418178966, 0.2986706932288049, 0.4303090173628977, 0.21834949900988598, 0.24402974692266344, 0.2867092468980731, 0.5952652986260532, 0.6580594682891907, 0.6950749560216251, 0.6275628652673564, 0.62828199419051, 0.6495258100404853, 0.6850121090192194, 0.7706743666608873, 0.7956025539994145, 0.16473669283412873, 0.14823914417665873, 0.1170613647035792, 0.11159674562080568, 0.14590556901235996, 0.15127523670804366, 0.14388042641567245, 0.1327851551047683, 0.1275296259551798, 0.18941226429724933, 0.17684690494074695, 0.1710969086290679, 0.19928050416919563, 0.1730058405401127, 0.17959474718770507, 0.17283850867054174, 0.15356891526926975, 0.2283925204208952, 0.4977664768966279, 0.44206352658880577, 0.4688739037541093, 0.5334927407302461, 0.4718175835414903, 0.592490201510425, 0.6077576353977293, 0.430057374673839, 0.5286007991998579, 0.3459132543168727, 0.3516481066026944, 0.40617586576798204, 0.4607150696346842, 0.4137871299620208, 0.3544163537007323, 0.45503644155580425, 0.43166050747966456, 0.4220721073191862, 0.24106367349546498, 0.20240069397475557, 0.22005396148709877, 0.2034774610412895, 0.2306562623907361, 0.22379486633755752, 0.1929680151120271, 0.19800133676659126, 0.2225503442209581, 0.3305941619957724, 0.4987237274848094, 0.28744276112030653, 0.27593594867672533, 0.23106242094658125, 0.2504842080592852, 0.20744867367096453, 0.19209883773962, 0.22555984349868086, 0.17129145753577324, 0.7262435837092993, 0.20321645283223477, 0.17352968917779177, 0.2947956984254839, 0.19486209770455987, 0.7217340560077667, 0.7042576339012314, 0.7630092595252143, 0.7995889057618102, 0.2043210166078624, 0.19947994012849235, 0.626249238141855, 0.20101207077030392, 0.8022938622392198, 0.20327974905000767, 0.15413434801209847, 0.208003679815969, 0.18783599545508667, 0.18915772145631315, 0.20755688761311053, 0.1846668733458079, 0.18913393500232833, 0.1818651666774166, 0.178176192831759, 0.18612241809472418, 0.19348708330944686, 0.08242751142423999, 0.08771532148406624, 0.08169347701694041, 0.09119251214852886, 0.09745355873663686, 0.08713129875172598, 0.08558311615620673, 0.08614283634726638, 0.10089234402149228]}, "mutation_prompt": null}
{"id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)  # Success memory for the population\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "An Enhanced Hybrid Differential Evolution with Adaptive Memory and Dynamic Crossover Strategy for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 43, "fitness": 0.3753916450086116, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "7c16ae92-bc5b-4dd6-8685-c19c4bdd8df6", "metadata": {"aucs": [0.8284745695740005, 0.8361443008961171, 0.8401114022053776, 0.8297956680524514, 0.8370801297275048, 0.8301672904582592, 0.8499573244334298, 0.8293506250143982, 0.8381200806100132, 0.7175938497472089, 0.7209669663451164, 0.5160243045916513, 0.6984785507847241, 0.7048595019119083, 0.7094474393701253, 0.6955776053372135, 0.7265789922197262, 0.7236830210160983, 0.14629413456804619, 0.15058401150170453, 0.14452963759393045, 0.247120065323705, 0.16525600738353374, 0.1664653080545342, 0.13787260379669986, 0.17681249047176262, 0.13341876721463508, 0.12021522081626024, 0.13022552617472305, 0.1336066384811938, 0.15220296449735815, 0.13418703282123856, 0.12930715954571848, 0.12391188893314153, 0.13167910569841024, 0.13916211713162951, 0.8422845685153633, 0.849134365740644, 0.8860854693159702, 0.8498838144622953, 0.846927794250032, 0.9030221220365832, 0.8756881512523278, 0.8202861767816639, 0.957949914033352, 0.42751493556004183, 0.2475856062509243, 0.1979109297023991, 0.2924056697404055, 0.31796022345335606, 0.3166854285719243, 0.33173176142633143, 0.31696483077935167, 0.2066923581772152, 0.8553179370132458, 0.836326025660016, 0.850498718575419, 0.8419173906754244, 0.8235001490297449, 0.8055251036584657, 0.8322220769134674, 0.8430097046373484, 0.8278640088304265, 0.1810125424551411, 0.4619243992869496, 0.180959192242515, 0.13432748528053684, 0.1450209162870617, 0.13448319181030943, 0.17982396414491253, 0.15934684872878702, 0.17191541200570204, 0.1908503301576263, 0.13502091975935182, 0.17192114102047706, 0.1453733060883291, 0.20614793235037976, 0.2573405733713475, 0.15849159054800455, 0.27468298313899486, 0.13548582401233367, 0.5759755373181767, 0.32231484799599486, 0.40234896101253326, 0.10887714746538235, 0.3509977546510903, 0.2387416102129708, 0.46535583434440864, 0.29671403092073434, 0.4608633582374667, 0.6571944904681594, 0.31963553755623786, 0.5131582158797987, 0.44612338087250425, 0.4048201241204038, 0.08786766807798796, 0.5921682263921277, 0.24660969771413133, 0.4013863597283507, 0.1825697180425444, 0.15437178964332232, 0.0919351800721504, 0.07778819463816522, 0.2563216199217758, 0.1760243291312933, 0.22983872056311294, 0.1503300886523613, 0.16685261087980874, 0.28487764752049594, 0.4511767704007815, 0.32392681450308414, 0.4143741622599473, 0.31600991215597807, 0.38338115924759564, 0.35285652131367595, 0.34679446923559454, 0.3195028631599035, 0.684241172476358, 0.542324448809912, 0.8000930763472839, 0.7652578991139503, 0.6831039803342588, 0.7307250260577351, 0.7184882784672617, 0.5939406338174962, 0.7194644964377912, 0.13605326938796203, 0.11340193975344626, 0.11981507634373101, 0.1317816871450006, 0.12519714280308458, 0.12601731733371957, 0.1237402279049733, 0.1379287932788662, 0.13376358198046234, 0.18201466967352087, 0.1812113634799608, 0.1758730311823743, 0.1716967425720184, 0.1837935631397869, 0.1472321787578228, 0.18501408582164924, 0.19720796024027187, 0.20718763337758772, 0.4908664091974101, 0.52935700271793, 0.5146639871645526, 0.5163213525700046, 0.48003069321950087, 0.47922373614831726, 0.47600643494452954, 0.5478654809585384, 0.5651782557132852, 0.34431490454122304, 0.4034590570460538, 0.38183174074552795, 0.40029515885465794, 0.402063747407323, 0.3558799920523221, 0.3841399370140335, 0.51592835060205, 0.3206888016230127, 0.21394455527320566, 0.2239209183711609, 0.2196451208973006, 0.2116168940862997, 0.27830753754813675, 0.20838171297755093, 0.21668882098468079, 0.22569125602462514, 0.19831848863528323, 0.6436259115953425, 0.21812199073507765, 0.4797914179976114, 0.3334880450793256, 0.22745057388627477, 0.1896534031753334, 0.21728330120956463, 0.2246606620107623, 0.20963918656000335, 0.3612658697468927, 0.17956592656675985, 0.20392169298279794, 0.7707571056660718, 0.41691191098304703, 0.19487580423691275, 0.7031585224602226, 0.7077454629098853, 0.7979502495841385, 0.7876817011507777, 0.20540823929886542, 0.1996954307055221, 0.20410478916901753, 0.20345816881187961, 0.8013008342053717, 0.22429264154902306, 0.1542439395801537, 0.20757786007513324, 0.18783599545508667, 0.1746428875166186, 0.17915669337450602, 0.1932822125949475, 0.18913393500232833, 0.18473435387617188, 0.1757473800038526, 0.18263145125429914, 0.1763436216076294, 0.10449311610689183, 0.10122157956785416, 0.09141456308934415, 0.08777902416484795, 0.09354223298230158, 0.09131896794619898, 0.09344839573887254, 0.09044816076254014, 0.10621904118114711]}, "mutation_prompt": null}
{"id": "42dd0df5-04ae-4b1e-a89f-6a8d06ffd563", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        return indices[:3]\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        shrink_factor = np.random.rand(self.dim) * 0.5  # Introduced shrink factor for fine-grained exploration\n        mutant = mutant * shrink_factor + self.population[idx] * (1 - shrink_factor)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "A refined hybrid differential evolution with adaptive memory, dynamic crossover, and enhanced selection pressure for improved convergence speed.", "configspace": "", "generation": 44, "fitness": 0.1204281887146587, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.2547693060728746, 0.1957069184370569, 0.22347190740872536, 0.1111350390410909, 0.125393712855284, 0.19941601570990963, 0.14463794725562307, 0.18557290965577522, 0.10472179403091797, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00311842035222909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0551467169277603, 0.09480314371412601, 0.06527014021765076, 0.07589815211574336, 0.059030133745515356, 0.08911181084198871, 0.08003310587002743, 0.06762389811984815, 0.07438318712808889, 0.05369537951619385, 0.072796910443512, 0.05605785126566587, 0.06700201157786323, 0.07143619716403937, 0.04432236688156521, 0.05436680223526946, 0.05782827670855328, 0.045712269827586915, 0.05317958589055449, 0.054015381422908626, 0.04637589328168601, 0.06345149095247926, 0.052207454918403506, 0.05108780710146765, 0.06593082035881759, 0.05374172319755466, 0.05232341738391055, 0.0629489397374906, 0.08763892681688956, 0.037728898134932964, 0.11017243481656169, 0.05747849459256327, 0.0547554728547508, 0.05827941130759973, 0.076051986486114, 9.999999999998899e-05, 0.20982002693626334, 0.2597216067020798, 0.20283849224730421, 0.1637415818536383, 0.14693384482580296, 0.08631864161108771, 0.10250147077088567, 0.1243556775370458, 0.21807205443639266, 0.12168173550624739, 0.094923643782304, 0.02737729424301938, 9.999999999998899e-05, 0.0421142560439699, 9.999999999998899e-05, 0.038167919433376496, 0.056913729478445974, 0.019271829196406354, 0.13772331215303435, 0.15645533419245206, 0.11831786798325594, 0.14152999796929, 0.14589414612312068, 0.12510635944615456, 0.1264630803022272, 0.1584293252754605, 0.12842339151470605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034023541918602684, 9.999999999998899e-05, 0.00014915769797185785, 9.999999999998899e-05, 0.004186951534563943, 0.11288835870662495, 0.13316839288939297, 0.11292629722689684, 0.05005364006487378, 0.07045700433163715, 0.08094620105549677, 0.09061085796455026, 0.12194557993879529, 0.11417375942017682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22384076314940726, 0.28033668209690465, 0.25691113063694815, 0.19068412577790161, 0.15351580763649675, 0.19463409711895374, 0.23537085506506428, 0.23320409760531824, 0.29532958467672665, 0.024950531306322965, 0.03804718784000638, 0.030640287470676375, 0.059958514847991085, 0.048071861156483875, 0.07072779971294696, 0.07233154868552083, 0.09427870088270429, 0.06803745814082418, 0.16251704252081778, 0.18231347378937302, 0.18654136446694924, 0.16211105867575715, 0.2126897766951965, 0.2117533250799557, 0.14350863535845615, 0.16473968119690485, 0.1554384919552686, 0.16839586920088423, 0.16261606861578348, 0.1873863395398937, 0.2257682964683505, 0.2327497676915583, 0.2572247538283218, 0.1421407508082715, 0.21057515029378315, 0.16594806233240056, 0.11789533808658725, 0.09188733743427546, 0.19036384394575712, 0.16682970869186975, 0.1790552536392923, 0.1973147277364785, 0.1325454464193263, 0.1946340591557688, 0.11485506784606403, 0.22521167221089777, 0.21334821393604164, 0.21886845628788587, 0.2385853455769339, 0.23146094606980783, 0.24807835015252444, 0.2172584151255228, 0.24959507437836825, 0.22538825249029437, 0.17524538814568025, 0.17097031965595144, 0.1715794744449739, 0.1787283399522387, 0.17158005076913907, 0.17845204545121374, 0.1767946539652525, 0.16262576815667018, 0.1779858318870292, 0.18193181493951127, 0.18558259994451132, 0.17599788548535067, 0.40630581968507395, 0.16428964705258042, 0.3686649499070911, 0.39876705867151463, 0.414112764982992, 0.32139428258877156, 0.25213832626410004, 0.30186275168026255, 0.22899225651047717, 0.32427416218121685, 0.20907250084098383, 0.37872641018247355, 0.21842369265434625, 0.19060672617506424, 0.1963474016538984, 0.17315035202214224, 0.17920207643070485, 0.17921129412942005, 0.19085931538078493, 0.17874538733783196, 0.17601110518632523, 0.19052151103076953, 0.18831704862439325, 0.17153332781379826, 0.07629687995681889, 0.0761271487131735, 0.06535189296535915, 0.07633094043375444, 0.07179677401527895, 0.08128014635497638, 0.08137893481268454, 0.09256118503688227, 0.07193924009526653]}, "mutation_prompt": null}
{"id": "6ee0777f-d349-4d24-ad45-422d1ac74006", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)  # Success memory for the population\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "An Enhanced Hybrid Differential Evolution with Adaptive Memory and Dynamic Crossover Strategy for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.8284745695740005, 0.8361443008961171, 0.8401114022053776, 0.8297956680524514, 0.8370801297275048, 0.8301672904582592, 0.8499573244334298, 0.8293506250143982, 0.8381200806100132, 0.7175938497472089, 0.7209669663451164, 0.5160243045916513, 0.6984785507847241, 0.7048595019119083, 0.7094474393701253, 0.6955776053372135, 0.7265789922197262, 0.7236830210160983, 0.14629413456804619, 0.15058401150170453, 0.14452963759393045, 0.247120065323705, 0.16525600738353374, 0.1664653080545342, 0.13787260379669986, 0.17681249047176262, 0.13341876721463508, 0.12021522081626024, 0.13022552617472305, 0.1336066384811938, 0.15220296449735815, 0.13418703282123856, 0.12930715954571848, 0.12391188893314153, 0.13167910569841024, 0.13916211713162951, 0.8422845685153633, 0.849134365740644, 0.8860854693159702, 0.8498838144622953, 0.846927794250032, 0.9030221220365832, 0.8756881512523278, 0.8202861767816639, 0.957949914033352, 0.42751493556004183, 0.2475856062509243, 0.1979109297023991, 0.2924056697404055, 0.31796022345335606, 0.3166854285719243, 0.33173176142633143, 0.31696483077935167, 0.2066923581772152, 0.8553179370132458, 0.836326025660016, 0.850498718575419, 0.8419173906754244, 0.8235001490297449, 0.8055251036584657, 0.8322220769134674, 0.8430097046373484, 0.8278640088304265, 0.1810125424551411, 0.4619243992869496, 0.180959192242515, 0.13432748528053684, 0.1450209162870617, 0.13448319181030943, 0.17982396414491253, 0.15934684872878702, 0.17191541200570204, 0.1908503301576263, 0.13502091975935182, 0.17192114102047706, 0.1453733060883291, 0.20614793235037976, 0.2573405733713475, 0.15849159054800455, 0.27468298313899486, 0.13548582401233367, 0.5759755373181767, 0.32231484799599486, 0.40234896101253326, 0.10887714746538235, 0.3509977546510903, 0.2387416102129708, 0.46535583434440864, 0.29671403092073434, 0.4608633582374667, 0.6571944904681594, 0.31963553755623786, 0.5131582158797987, 0.44612338087250425, 0.4048201241204038, 0.08786766807798796, 0.5921682263921277, 0.24660969771413133, 0.4013863597283507, 0.1825697180425444, 0.15437178964332232, 0.0919351800721504, 0.07778819463816522, 0.2563216199217758, 0.1760243291312933, 0.22983872056311294, 0.1503300886523613, 0.16685261087980874, 0.28487764752049594, 0.4511767704007815, 0.32392681450308414, 0.4143741622599473, 0.31600991215597807, 0.38338115924759564, 0.35285652131367595, 0.34679446923559454, 0.3195028631599035, 0.684241172476358, 0.542324448809912, 0.8000930763472839, 0.7652578991139503, 0.6831039803342588, 0.7307250260577351, 0.7184882784672617, 0.5939406338174962, 0.7194644964377912, 0.13605326938796203, 0.11340193975344626, 0.11981507634373101, 0.1317816871450006, 0.12519714280308458, 0.12601731733371957, 0.1237402279049733, 0.1379287932788662, 0.13376358198046234, 0.18201466967352087, 0.1812113634799608, 0.1758730311823743, 0.1716967425720184, 0.1837935631397869, 0.1472321787578228, 0.18501408582164924, 0.19720796024027187, 0.20718763337758772, 0.4908664091974101, 0.52935700271793, 0.5146639871645526, 0.5163213525700046, 0.48003069321950087, 0.47922373614831726, 0.47600643494452954, 0.5478654809585384, 0.5651782557132852, 0.34431490454122304, 0.4034590570460538, 0.38183174074552795, 0.40029515885465794, 0.402063747407323, 0.3558799920523221, 0.3841399370140335, 0.51592835060205, 0.3206888016230127, 0.21394455527320566, 0.2239209183711609, 0.2196451208973006, 0.2116168940862997, 0.27830753754813675, 0.20838171297755093, 0.21668882098468079, 0.22569125602462514, 0.19831848863528323, 0.6436259115953425, 0.21812199073507765, 0.4797914179976114, 0.3334880450793256, 0.22745057388627477, 0.1896534031753334, 0.21728330120956463, 0.2246606620107623, 0.20963918656000335, 0.3612658697468927, 0.17956592656675985, 0.20392169298279794, 0.7707571056660718, 0.41691191098304703, 0.19487580423691275, 0.7031585224602226, 0.7077454629098853, 0.7979502495841385, 0.7876817011507777, 0.20540823929886542, 0.1996954307055221, 0.20410478916901753, 0.20345816881187961, 0.8013008342053717, 0.22429264154902306, 0.1542439395801537, 0.20757786007513324, 0.18783599545508667, 0.1746428875166186, 0.17915669337450602, 0.1932822125949475, 0.18913393500232833, 0.18473435387617188, 0.1757473800038526, 0.18263145125429914, 0.1763436216076294, 0.10449311610689183, 0.10122157956785416, 0.09141456308934415, 0.08777902416484795, 0.09354223298230158, 0.09131896794619898, 0.09344839573887254, 0.09044816076254014, 0.10621904118114711]}, "mutation_prompt": null}
{"id": "896a8644-cab1-4582-9316-2664e527e3d9", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        success_ratio = np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * success_ratio\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == np.random.randint(self.dim):\n                trial[j] = mutant[j]\n        return trial\n    \n    def resize_population(self):\n        if self.evaluations > self.budget // 2 and self.pop_size > 10:\n            self.pop_size = max(10, self.pop_size // 2)\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n            \n            self.resize_population()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "An Adaptive Hybrid Differential Evolution with Dynamic Population Resizing and Adaptive Crossover Strategy for Enhanced Convergence.", "configspace": "", "generation": 46, "fitness": 0.3130489003114192, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.8404383523880999, 0.8539479728677082, 0.8361802495040772, 0.8296351295234439, 0.8696072794664802, 0.8534576061525666, 0.8642892451741773, 0.8531515496572895, 0.8588444995031843, 0.6280953440919577, 0.7518381754527481, 0.7329964163768137, 0.1413777775064904, 0.7391425573749468, 0.762189589582486, 0.7385750392641728, 0.74781027464542, 0.7540862384783514, 0.17492371441214472, 0.13887061141246326, 0.1766065406748607, 0.16562141864172752, 0.18009770028930905, 0.136197142766598, 0.09726295661018847, 0.18038361684910253, 0.17531799103991397, 0.23896470965813255, 0.12607531311300046, 0.1486375008653742, 0.14992036889575688, 0.13434487516220706, 0.12419502664045978, 0.2027600309135108, 0.11886641689702737, 0.10588370026028437, 0.9560180690560598, 0.8329786867574303, 0.7788076546228291, 0.8529466257921552, 0.8120565855355553, 0.7554593222332345, 0.8079060714073454, 0.8655747283317166, 0.9382306028495988, 0.22216106812654957, 0.26957536487200784, 0.24634578388195683, 0.16176408273806375, 0.264630794391399, 0.22568046600460379, 0.16921021276561043, 0.21314722915713225, 0.18339687717604736, 0.27506754784215426, 0.23624210999285133, 0.3402679826450019, 0.2688789632248243, 0.8865965057822379, 0.3468260537456309, 0.8646137465881848, 0.8684470053566632, 0.8810960288425118, 0.2324709815101521, 0.14092221057307364, 0.43474308528947325, 0.15307055695420402, 0.1278687412656354, 0.16238383116025157, 0.1314343928426306, 0.30563533189126424, 0.12931130256860723, 0.14995825840754629, 0.17848072093098122, 0.19228727826508796, 0.2591363686100875, 0.17753439209083022, 0.13267490297772944, 0.14011354094092, 0.17314602206191954, 0.134370353869382, 0.18360202923248536, 0.04995316781348447, 0.013851554435528102, 0.1870812651271787, 0.25999402872631183, 9.999999999998899e-05, 9.999999999998899e-05, 0.09553422810350731, 0.014061753127978749, 0.1888277714155826, 0.17391788277692322, 0.2411065004200642, 0.08532108593959908, 0.22931244180371868, 0.12018801641233035, 0.18745953320408615, 0.2758924749488225, 0.06780417342446199, 0.13963835581306194, 0.23744480490356257, 0.17624849571484558, 0.18318103073018888, 0.2860879901600172, 0.17656575415165587, 0.29975941562674924, 0.21982265237753928, 0.135648292600965, 0.28763654979855857, 0.1782959714372071, 0.2721344333713409, 0.23368070749304715, 0.30981334908559144, 0.23352024558204565, 0.20062281282006644, 0.18043670181614657, 0.253866953442736, 0.5955126856741162, 0.5016543386549599, 0.5165715122303474, 0.6067951757488639, 0.6248463625388929, 0.646542970360604, 0.6022523971008806, 0.73691596405954, 0.6192162590620631, 0.13431759322072157, 0.13796090114245285, 0.1309677087765858, 0.10963050678505137, 0.14464762212462956, 0.12814845870975422, 0.1245868646021856, 0.08762694373187718, 0.15518870021655462, 0.23647258399816973, 0.16996551132332383, 0.2767505419898445, 0.15980010194819383, 0.1426723487682784, 0.12559293620954304, 0.19019511212780504, 0.13626380445569397, 0.24759118841871608, 0.22521367888302857, 0.43596442619310727, 0.3520209856607558, 0.4896366037514297, 0.3052650211719773, 0.4601137766951825, 0.40069227732298707, 0.4717380629073602, 0.5335704705664921, 0.261130686887708, 0.38842454708988794, 0.3952363831722472, 0.3071894140341793, 0.2588423585852846, 0.28354823710723487, 0.3216955525696613, 0.44830919405973346, 0.3291331117932017, 0.19686929512090423, 0.2012888142903726, 0.2231446217036287, 0.22558042034006387, 0.17517744252119938, 0.16616667194014445, 0.16948647153080443, 0.1571235883815556, 0.20703596565438664, 0.18904801157087447, 0.20965973653263004, 0.18306546447652372, 0.24869713454038167, 0.32701268313849285, 0.19474098050626887, 0.20559996386704005, 0.6988850792543293, 0.3089091989718421, 0.1871984984707873, 0.17017028650964616, 0.9009716712933213, 0.17706659028695426, 0.1992382643586167, 0.18596056882604273, 0.2030783953489348, 0.17020164746838595, 0.32006238181140145, 0.6643896827583231, 0.20938635319392174, 0.29090578762966646, 0.2394353164066988, 0.12649329165291912, 0.16980539842165454, 0.1574943597726457, 0.12656256010196199, 0.8339880243579556, 0.1837825999667606, 0.1801195147308413, 0.17760993114059798, 0.18732126853704212, 0.20497914347253077, 0.21292249348472359, 0.18196665530088552, 0.16669430649712558, 0.17606459562390553, 0.07058791162749023, 0.07971677289022461, 0.07857107725212586, 0.08715099878700816, 0.06951942200923733, 0.07843889950523264, 0.059904699102867776, 0.06080661355612338, 0.09751926046044479]}, "mutation_prompt": null}
{"id": "c8066282-ed71-4a15-b547-674acead9d8c", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)  # Success memory for the population\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "An Enhanced Hybrid Differential Evolution with Adaptive Memory and Dynamic Crossover Strategy for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.8284745695740005, 0.8361443008961171, 0.8401114022053776, 0.8297956680524514, 0.8370801297275048, 0.8301672904582592, 0.8499573244334298, 0.8293506250143982, 0.8381200806100132, 0.7175938497472089, 0.7209669663451164, 0.5160243045916513, 0.6984785507847241, 0.7048595019119083, 0.7094474393701253, 0.6955776053372135, 0.7265789922197262, 0.7236830210160983, 0.14629413456804619, 0.15058401150170453, 0.14452963759393045, 0.247120065323705, 0.16525600738353374, 0.1664653080545342, 0.13787260379669986, 0.17681249047176262, 0.13341876721463508, 0.12021522081626024, 0.13022552617472305, 0.1336066384811938, 0.15220296449735815, 0.13418703282123856, 0.12930715954571848, 0.12391188893314153, 0.13167910569841024, 0.13916211713162951, 0.8422845685153633, 0.849134365740644, 0.8860854693159702, 0.8498838144622953, 0.846927794250032, 0.9030221220365832, 0.8756881512523278, 0.8202861767816639, 0.957949914033352, 0.42751493556004183, 0.2475856062509243, 0.1979109297023991, 0.2924056697404055, 0.31796022345335606, 0.3166854285719243, 0.33173176142633143, 0.31696483077935167, 0.2066923581772152, 0.8553179370132458, 0.836326025660016, 0.850498718575419, 0.8419173906754244, 0.8235001490297449, 0.8055251036584657, 0.8322220769134674, 0.8430097046373484, 0.8278640088304265, 0.1810125424551411, 0.4619243992869496, 0.180959192242515, 0.13432748528053684, 0.1450209162870617, 0.13448319181030943, 0.17982396414491253, 0.15934684872878702, 0.17191541200570204, 0.1908503301576263, 0.13502091975935182, 0.17192114102047706, 0.1453733060883291, 0.20614793235037976, 0.2573405733713475, 0.15849159054800455, 0.27468298313899486, 0.13548582401233367, 0.5759755373181767, 0.32231484799599486, 0.40234896101253326, 0.10887714746538235, 0.3509977546510903, 0.2387416102129708, 0.46535583434440864, 0.29671403092073434, 0.4608633582374667, 0.6571944904681594, 0.31963553755623786, 0.5131582158797987, 0.44612338087250425, 0.4048201241204038, 0.08786766807798796, 0.5921682263921277, 0.24660969771413133, 0.4013863597283507, 0.1825697180425444, 0.15437178964332232, 0.0919351800721504, 0.07778819463816522, 0.2563216199217758, 0.1760243291312933, 0.22983872056311294, 0.1503300886523613, 0.16685261087980874, 0.28487764752049594, 0.4511767704007815, 0.32392681450308414, 0.4143741622599473, 0.31600991215597807, 0.38338115924759564, 0.35285652131367595, 0.34679446923559454, 0.3195028631599035, 0.684241172476358, 0.542324448809912, 0.8000930763472839, 0.7652578991139503, 0.6831039803342588, 0.7307250260577351, 0.7184882784672617, 0.5939406338174962, 0.7194644964377912, 0.13605326938796203, 0.11340193975344626, 0.11981507634373101, 0.1317816871450006, 0.12519714280308458, 0.12601731733371957, 0.1237402279049733, 0.1379287932788662, 0.13376358198046234, 0.18201466967352087, 0.1812113634799608, 0.1758730311823743, 0.1716967425720184, 0.1837935631397869, 0.1472321787578228, 0.18501408582164924, 0.19720796024027187, 0.20718763337758772, 0.4908664091974101, 0.52935700271793, 0.5146639871645526, 0.5163213525700046, 0.48003069321950087, 0.47922373614831726, 0.47600643494452954, 0.5478654809585384, 0.5651782557132852, 0.34431490454122304, 0.4034590570460538, 0.38183174074552795, 0.40029515885465794, 0.402063747407323, 0.3558799920523221, 0.3841399370140335, 0.51592835060205, 0.3206888016230127, 0.21394455527320566, 0.2239209183711609, 0.2196451208973006, 0.2116168940862997, 0.27830753754813675, 0.20838171297755093, 0.21668882098468079, 0.22569125602462514, 0.19831848863528323, 0.6436259115953425, 0.21812199073507765, 0.4797914179976114, 0.3334880450793256, 0.22745057388627477, 0.1896534031753334, 0.21728330120956463, 0.2246606620107623, 0.20963918656000335, 0.3612658697468927, 0.17956592656675985, 0.20392169298279794, 0.7707571056660718, 0.41691191098304703, 0.19487580423691275, 0.7031585224602226, 0.7077454629098853, 0.7979502495841385, 0.7876817011507777, 0.20540823929886542, 0.1996954307055221, 0.20410478916901753, 0.20345816881187961, 0.8013008342053717, 0.22429264154902306, 0.1542439395801537, 0.20757786007513324, 0.18783599545508667, 0.1746428875166186, 0.17915669337450602, 0.1932822125949475, 0.18913393500232833, 0.18473435387617188, 0.1757473800038526, 0.18263145125429914, 0.1763436216076294, 0.10449311610689183, 0.10122157956785416, 0.09141456308934415, 0.08777902416484795, 0.09354223298230158, 0.09131896794619898, 0.09344839573887254, 0.09044816076254014, 0.10621904118114711]}, "mutation_prompt": null}
{"id": "b42dfbec-1c49-43ec-b916-7514e48a0dc3", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.stagnation_count = 0  # Track stagnation\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def adapt_strategy(self):\n        if len(self.success_mem) >= 10 and sum(self.success_mem[-10:]) < 2:\n            self.stagnation_count += 1\n            if self.stagnation_count > 3:\n                self.initial_mutation_factor = np.random.uniform(0.5, 1.0)\n                self.crossover_rate = np.random.uniform(0.8, 1.0)\n                self.stagnation_count = 0\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n            \n            self.adapt_strategy()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Success-based Adaptation and Stochastic Learning for Improved Optimization Performance.", "configspace": "", "generation": 48, "fitness": 0.36099359175346557, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.8284745695740005, 0.8352128136753536, 0.8401114022053776, 0.8297956680524514, 0.8370801297275048, 0.8301672904582592, 0.8499573244334298, 0.8293506250143982, 0.8381200806100132, 0.7175938497472089, 0.7209669663451164, 0.5160243045916513, 0.6984785507847241, 0.7048595019119083, 0.7094474393701253, 0.6955776053372135, 0.7265789922197262, 0.7236830210160983, 0.19545634625680064, 0.18332455021585214, 0.2580276626810508, 0.1471702998845147, 0.2749071844096893, 0.16265028712935892, 0.14276792134503635, 0.22662816782650175, 0.14771007209809228, 0.10419251236281324, 0.14386807400930413, 0.12412442862250861, 0.1497672457263981, 0.15892470294977357, 0.1024546650271344, 0.13496347672927567, 0.12880041714081003, 0.1515138110259051, 0.8422845685153633, 0.849134365740644, 0.8860854693159702, 0.8498838144622953, 0.846927794250032, 0.9030221220365832, 0.8756881512523278, 0.8202861767816639, 0.957949914033352, 0.20053271790691818, 0.2475856062509243, 0.1979109297023991, 0.29240566028295734, 0.31796022345335606, 0.3166854285719243, 0.17577025161086546, 0.31696483077935167, 0.2066923581772152, 0.8459447422166033, 0.3771069878454547, 0.850498718575419, 0.8678927621543424, 0.8453666413108791, 0.8029626584415611, 0.8590776793923417, 0.8430097046373484, 0.8477105898152608, 0.19509454025351447, 0.3578330788279025, 0.17341409372758831, 0.13335457468016043, 0.1450209162870617, 0.13843924635759708, 0.18279287277960365, 0.16803507331497625, 0.17191541200570204, 0.1598805112848819, 0.12814744782010878, 0.17188431464937037, 0.14537365484905862, 0.20614793235037976, 0.2986110894757492, 0.15849159054800455, 0.277829030592609, 0.13548582401233367, 0.32241205708646903, 0.33511517918340383, 0.35775831823243187, 0.10397575505193402, 0.2427177908161463, 0.29512546703442566, 0.4123935665244677, 0.5171933998498952, 0.1932639474918848, 0.5348363327166086, 0.5425992749388235, 0.26413579119731745, 0.27925999130495205, 0.7561256849015792, 0.13723971504013643, 0.7443006292869128, 0.18713243198664686, 0.34562170251448454, 0.20541071257147692, 0.1551358391885418, 0.07512127229810706, 0.07608029087746926, 0.1881705401260262, 0.1298773235354025, 0.2794177810921825, 0.12728920852308134, 0.15496289989246848, 0.27291112090563896, 0.25447234632907867, 0.2935501359024738, 0.3451541407196551, 0.36560200894454753, 0.37983117237461617, 0.2766339573237273, 0.3855121972801421, 0.28629372336906134, 0.6767827232712589, 0.5471665659055038, 0.7614882474366778, 0.7650828369962321, 0.7575829338152104, 0.7034707852406203, 0.727006235612236, 0.5962769902603765, 0.7195530499237393, 0.14356013553705693, 0.11142791048845935, 0.13466175234959665, 0.10625548006185559, 0.14239322699623713, 0.1270971986391105, 0.162587556043018, 0.11909379906452866, 0.1273663364455082, 0.1960409565128387, 0.18867632327453343, 0.206550480366969, 0.21714945533680974, 0.2301711400798505, 0.195521357356229, 0.2381079833632178, 0.22081844362126068, 0.18708187032885792, 0.44614733301946363, 0.4597560642003903, 0.5023363590584393, 0.6201802489269939, 0.5128051322922471, 0.47881997337604554, 0.44349720479356347, 0.5066050753505265, 0.5406009043783662, 0.2834891499853919, 0.3396280036206466, 0.3300580323845873, 0.31172055062740534, 0.3453251877806458, 0.28738131301667935, 0.3167153703303808, 0.46766122642027375, 0.42041429409937014, 0.21474321063461266, 0.2197117599820112, 0.20365788496212067, 0.20490194059150546, 0.24948423049958568, 0.2130503471232239, 0.20770879692335598, 0.22919447893823586, 0.20759609599350748, 0.2366067922575299, 0.19711529357041901, 0.31227299023829613, 0.23058280457807956, 0.3017291690378736, 0.2753127559797137, 0.3717814394934248, 0.35287885866327084, 0.20898681418755327, 0.36646120127985393, 0.1778593964910946, 0.19899094011737029, 0.16814425616130702, 0.7760152278477077, 0.19493332880861258, 0.7358588340998906, 0.20739062182479584, 0.47237036993556913, 0.7552302640860555, 0.2045255802718824, 0.20108037966461945, 0.23688604192371943, 0.2047753740892564, 0.5370150494757288, 0.2133834974856188, 0.1542439395801537, 0.20757786007513324, 0.18098000301498762, 0.20053431023144486, 0.191472154987946, 0.20051359565322824, 0.19707671306948737, 0.18433985649302687, 0.1788057370366699, 0.1877442375966839, 0.1810868001872934, 0.09603358986539057, 0.09612503383059845, 0.0930869492460018, 0.09256442188482272, 0.08436517168966096, 0.08832982759853181, 0.09094425253235783, 0.090609329598479, 0.08537507111249254]}, "mutation_prompt": null}
{"id": "0348f626-719b-49e9-b2df-963b0c28497f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * dynamic_factor\n        noise = np.random.normal(0, 0.1, self.dim)  # Gaussian noise for diversity\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) + noise\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n                    \n            # Stochastic Population Reduction\n            if self.pop_size > 20 and np.random.rand() < 0.1:\n                worst_idx = np.argmax(self.fitness)\n                self.population = np.delete(self.population, worst_idx, axis=0)\n                self.fitness = np.delete(self.fitness, worst_idx)\n                self.trial_successes = np.delete(self.trial_successes, worst_idx)\n                self.pop_size -= 1\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "A Refined Hybrid Differential Evolution with Adaptive Mutation and Stochastic Population Reduction for Efficient Budget Utilization.", "configspace": "", "generation": 49, "fitness": 0.2432322310807694, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.4779749354585012, 0.45238554544191334, 0.4481143139677537, 0.46011868098238384, 0.48440326187489813, 0.46787770367629633, 0.47581891637542195, 0.4603273627290978, 0.45861910361866864, 0.0839805390545918, 0.07649633627699282, 0.08017354043968794, 0.06791081791630971, 0.1070967236820306, 0.07661541383743276, 0.0737786549566839, 0.0944389282433189, 0.09603250456991175, 0.1292567830489454, 0.11868048181683155, 0.12140042598517264, 0.13819859294390624, 0.12370299734968249, 0.11487269821028845, 0.13573544927272374, 0.11913607246715874, 0.12945695991179762, 0.1269617959104653, 0.1125746125261925, 0.11216112741766171, 0.10614103936199903, 0.11872932617950338, 0.11693470928791572, 0.11533868077149256, 0.1096326494694535, 0.10838742927162526, 0.8762703015108997, 0.8958967897585961, 0.9366039312891844, 0.9208855419956704, 0.9258763271799781, 0.9088839567802405, 0.9211638471511111, 0.9309944042933336, 0.9211084881940819, 0.30118112324304624, 0.31432242781489284, 0.29846861953987325, 0.2925238730452363, 0.3142574248577684, 0.31364148383761203, 0.2866460917495621, 0.2878802362414614, 0.29154865402178143, 0.44795865815862257, 0.7978713000334339, 0.5376021638384272, 0.36555938360765794, 0.49350716620519874, 0.5003793183980134, 0.4626577431788993, 0.4480398730065327, 0.46473972569851596, 0.1553177016276619, 0.17012540821432376, 0.18721527975234542, 0.2004124381587019, 0.14620244168655572, 0.18117311543153813, 0.1752774403151045, 0.16285570405880867, 0.18458195470044736, 0.1689114722620828, 0.16223930219527594, 0.1744717537942343, 0.18136425266764555, 0.18716451508349574, 0.1589691142565458, 0.16546800870187905, 0.16891805789321168, 0.1784653692197875, 0.043703266651720196, 0.09197544110874645, 0.06823180288580966, 0.05406717315593357, 0.01942602501601398, 0.03753544234265338, 0.06419380397142371, 0.05784031868385686, 0.023053334876895315, 0.13907154613960504, 0.06475115896392925, 0.12754555294086345, 0.07199165913737138, 0.11775768612070858, 0.08046280852243126, 0.11326653252825103, 0.10102394593674635, 0.16926544050443704, 9.999999999998899e-05, 0.0035560045478423286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1068424384917902, 0.12425387627517726, 0.12824123556547307, 0.12219495748541498, 0.11153315111226458, 0.12076678327704216, 0.10739372541340708, 0.1093165430809151, 0.11677111062370749, 0.4271577159837644, 0.41942816241607095, 0.4186159179941412, 0.43092713994355647, 0.41126496888502784, 0.4116532839737752, 0.41914647296104024, 0.41317529560238053, 0.4341751102222067, 0.10179083469253869, 0.1425916918636605, 0.11782422176743679, 0.13513817930255645, 0.11029001703509733, 0.11449927322235476, 0.1182318433961036, 0.1222330727567652, 0.12211350215919081, 0.1857539102895489, 0.24051565548953346, 0.19954618820124614, 0.15005364769671792, 0.22124307519500885, 0.16724919027745055, 0.19895145200066655, 0.24847938307983874, 0.19066482627562853, 0.2954986187831018, 0.29723713637290794, 0.2974977225873495, 0.2976161232664858, 0.29203908772214016, 0.2968327331365578, 0.29994028808463113, 0.30856216381609824, 0.29505909183158396, 0.23232551520993994, 0.2449241712113328, 0.2299531155043214, 0.24395545128866825, 0.23384103569429993, 0.2345605240556814, 0.24977039922712907, 0.24648655389218477, 0.24695032846573972, 0.21805235919956922, 0.22991537427055264, 0.20482524294635163, 0.203023813813902, 0.19785222207876718, 0.22893661358104966, 0.2281164117817126, 0.20663649967730002, 0.1963178278029677, 0.1930352388254185, 0.21641940312283825, 0.20806069884560563, 0.23837500089835062, 0.2000851981573618, 0.2632654331576332, 0.24810256456859636, 0.23983384893505733, 0.21620264227903485, 0.5829065055089162, 0.17938360680313725, 0.18211585879112147, 0.5144239916310279, 0.1940460764323837, 0.6181875526731855, 0.5658083877397935, 0.1635922187897384, 0.5803002278665828, 0.581681795508243, 0.20634881838677255, 0.5752843442079579, 0.6172214955123925, 0.20058706517311842, 0.16551685858986875, 0.15215746806751063, 0.20691514804175826, 0.20432587269412272, 0.1855593990118093, 0.19653767909860675, 0.1898616289096735, 0.18207402601200862, 0.1698484182913944, 0.1850123756329043, 0.18284974050053737, 0.18415799040553416, 0.20361020784258677, 0.08505745947504018, 0.07775437904198756, 0.09029814592431318, 0.08340456618677294, 0.08385925312618259, 0.08168402970529931, 0.08401260635253005, 0.0889397066316211, 0.0781164577898158]}, "mutation_prompt": null}
{"id": "e9da2ffa-10ba-4483-8ae2-ced17a1e95b7", "solution": "import numpy as np\n\nclass SelfAdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.self_adaptive_params = np.random.uniform(0.1, 0.9, (self.pop_size, 2))  # Added self-adaptive parameters\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.self_adaptive_params[idx, 0] * dynamic_factor  # Use self-adaptive mutation factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.self_adaptive_params[idx, 1]  # Use self-adaptive crossover rate\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def adapt_parameters(self):\n        for i in range(self.pop_size):\n            if np.random.rand() < 0.1:\n                self.self_adaptive_params[i] = np.random.uniform(0.1, 0.9, 2)  # Randomly adapt parameters\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adapt_parameters()  # Adapt parameters at each generation\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "SelfAdaptiveHybridDE", "description": "A novel Self-Adaptive Hybrid Differential Evolution that autonomously adjusts mutation and crossover strategies for enhanced optimization.", "configspace": "", "generation": 50, "fitness": 0.357893704283099, "feedback": "The algorithm SelfAdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.8351090383394979, 0.8318114109293078, 0.8294528340060218, 0.8242093206815146, 0.845477593461609, 0.821845518858414, 0.8206413545024364, 0.8311619904347372, 0.824860395416849, 0.6828671839396876, 0.6829581305232006, 0.6947930782930274, 0.704987749959882, 0.7060391288647931, 0.6977526112312138, 0.7148585596984178, 0.7075374344107979, 0.7054423223536552, 0.5773585298688227, 0.507530588044153, 0.5882060439863495, 0.5530898962963335, 0.5277452847290349, 0.5042675418448452, 0.41949405643593507, 0.5499154192175295, 0.5569907081203166, 0.4252886962853717, 0.1788839587576988, 0.14904968682971553, 0.45011177586098905, 0.5438640003617496, 0.5200297072316907, 0.16493975015044926, 0.49887350734662084, 0.16974225931621223, 0.8891940025914071, 0.9556287225970155, 0.9082030276807869, 0.9328932804003369, 0.9185577768756418, 0.9126691867995859, 0.8960925693907366, 0.9331928659515951, 0.9392311857141978, 0.3494571460433563, 0.30548912781895277, 0.2958620996349407, 0.40889379137002, 0.31921335773760606, 0.37217562912361113, 0.2179099713716065, 0.24810752310784878, 0.33294916498373295, 0.5791114798122607, 0.6994982832392959, 0.5908854445699642, 0.6350099539289993, 0.692736238075349, 0.5485092852939326, 0.6280022331475459, 0.7169725177046189, 0.6983708268564092, 0.16581077914090203, 0.1525190372358306, 0.1827751691057099, 0.19946082806838383, 0.1593342138625845, 0.3607947627961863, 0.3038159507246123, 0.1504221319835478, 0.1939283039901567, 0.17862935616712095, 0.13353865709731816, 0.16478482323066346, 0.15787941557352914, 0.16854649611950268, 0.1600678582028544, 0.15493516325039547, 0.15517540345627645, 0.1626955578028172, 0.03615082366542888, 0.08493286688323354, 0.09427586439718161, 0.04173533226093984, 0.04706530206333359, 0.04011046351366421, 0.03328861494015278, 0.07726972410122723, 0.12006034298227097, 0.18779570601397932, 0.20410796162409828, 0.2080913446432806, 0.16414828022375838, 0.2585344210526753, 0.10475739051157507, 0.19186799031489066, 0.2374992278907705, 0.19163063167510674, 0.09752102491486969, 0.10005608759065199, 0.049400759145640016, 0.06326060859393512, 0.06992956798005612, 0.08465135859648965, 0.0862044574253612, 0.09484785716388089, 0.052749798925231905, 0.12178251399643358, 0.20703256486743926, 0.16610578740405313, 0.17859270623710877, 0.2124380678208604, 0.20048001199922105, 0.14881686038240516, 0.17359575744972566, 0.15221852909388311, 0.5478426482876706, 0.5625039145840378, 0.5302199759542173, 0.5737047535612421, 0.5719645547901304, 0.5344522269306343, 0.5666890653510462, 0.6026201606724053, 0.5983025658225563, 0.1225154767758837, 0.12892101009132617, 0.1010452025288634, 0.11503608242938645, 0.12433915963243125, 0.12039076959199368, 0.1266629754963744, 0.10365710102020387, 0.11111587009909185, 0.1465324078371386, 0.15673255311694156, 0.1812130678136471, 0.166956928680686, 0.1417955005261592, 0.14390429246869585, 0.1483783925483474, 0.1757644679339282, 0.13518526170835232, 0.40435767337050765, 0.3917763536173787, 0.38898699187978436, 0.3963247190227446, 0.4221005011543526, 0.3961326669372077, 0.4515158088440119, 0.490002707409117, 0.432389559851319, 0.2892202154182244, 0.23021215289081898, 0.28840819291680875, 0.2946178358660413, 0.2603214604806099, 0.2767144961974001, 0.3161097584207969, 0.3234635061464499, 0.26856015481550666, 0.18737473663193227, 0.20207088491967296, 0.2299941214557285, 0.19583360615693624, 0.20123291089509998, 0.21317205047795185, 0.22000237765474995, 0.2260180778264732, 0.20249571124744448, 0.545924490372111, 0.5141201623374531, 0.4382985127816932, 0.23549201669056774, 0.5372981596508479, 0.24061588680446777, 0.3613500332655577, 0.4853923940576207, 0.4974285226863563, 0.5762893787613508, 0.7992029715485999, 0.19716230093520337, 0.7213510335028464, 0.7550866379212857, 0.7428712632551848, 0.7095656610966596, 0.43474628917462044, 0.4314300731987223, 0.38701161359216707, 0.4156027133679081, 0.24123462746125146, 0.18807851342801118, 0.40096603097551087, 0.56572377422783, 0.4331941334016398, 0.5793114469905778, 0.23761424644666507, 0.17955111805205037, 0.20284019169196932, 0.18786964590540456, 0.1867513589011336, 0.19280190236138606, 0.19509799559642427, 0.18613129962489872, 0.17988630839590714, 0.18378644118447995, 0.07800798363250427, 0.08485172978116029, 0.08343917492589992, 0.08340759137283604, 0.08368858651958455, 0.08745029818801853, 0.07220826969389815, 0.08135939250722168, 0.08556805556000291]}, "mutation_prompt": null}
{"id": "c66f4fc5-ff1f-40c0-afc9-b8ddc3ff54e4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n                \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        diversity = np.std(self.population, axis=0).mean()\n        mutation_factor = self.initial_mutation_factor * (1 - self.evaluations / self.budget) * (0.5 + 0.5 * diversity)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                if self.evaluations >= self.budget: break\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Population Size and Adaptive Mutation Strategy for Improved Convergence Efficiency.", "configspace": "", "generation": 51, "fitness": 0.27158889480726683, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.7868804079205515, 0.7382996903151576, 0.7176764080372156, 0.8122756314487963, 0.8322766024714883, 0.8174366429533916, 0.725179202195284, 0.7854053627739495, 0.6549116465502638, 0.5957154344736626, 0.3655325702897967, 0.42292082886664084, 0.4682752785468991, 0.22552378093218572, 0.4325830586556345, 0.5497493362960619, 0.5965045595320049, 0.4785808593621572, 0.10641753470323834, 0.11253988831520123, 0.10934298390390373, 0.11032256853653721, 0.14215449151008686, 0.11797309890413632, 0.11578905337203871, 0.14361696222635767, 0.12553028999071136, 0.13239646540528083, 0.10531374784153291, 0.10434863474049638, 0.12290433046555604, 0.10127666584318107, 0.1259054138058402, 0.10863466864400528, 0.113081257822228, 0.1287589542403038, 0.9825124896689377, 0.9761604045595552, 0.974423312360052, 0.9603254456054093, 0.9781066258768777, 0.983023128621603, 0.9557146496651758, 0.9863504984081017, 0.9821379332396176, 0.29617750275719934, 0.21111674815637782, 0.23185052389453753, 0.21984750719703483, 0.20271624319062198, 0.25210233991386, 0.21414545899220383, 0.08506429365448098, 0.16098876042216492, 0.29699070067696653, 0.6198468280555343, 0.6288287429125938, 0.7232552071666918, 0.6313746777571025, 0.6255881503168976, 0.7113531051111304, 0.6319021411641572, 0.6930970771165894, 0.16784933593829487, 0.12093029127536681, 0.11899449951684404, 0.14170647259078506, 0.1328771986261934, 0.13837820710323356, 0.15019904002664441, 0.16584546390857846, 0.13971129343852517, 0.0095950787683996, 0.1043593468590227, 0.05038125406472849, 0.1300020611823085, 0.11183749247663144, 0.13909561148745742, 0.12153321383663096, 0.030098427066653, 0.21855478679446882, 9.999999999998899e-05, 0.15852331485554683, 0.10669047607339088, 0.018339442818082308, 0.1552024776391887, 0.08005754493382833, 0.09747489319276414, 0.06907343331499938, 0.08085371947321784, 0.1863598278044617, 0.2250802191282093, 0.19751360457557732, 0.055897874068850384, 0.15139513285877004, 0.22458769609579987, 0.13828221710068123, 0.21019909216123078, 0.25378428898516636, 0.08048439912438732, 0.0890700621799213, 0.058689350166762466, 0.1515517256037885, 0.15977679307368908, 0.12213783077797813, 0.16465492580444296, 0.2721966628481238, 0.16756561371424983, 0.28346356924731375, 0.17041223839170672, 0.21042245951144534, 0.19469091036682362, 0.223011649405645, 0.2693563121199982, 0.28949281244448677, 0.2648043056409133, 0.35373886457680614, 0.4897453290551189, 0.5489206782713714, 0.5362577980540217, 0.48142253780176725, 0.23416859068639795, 0.4900536119488015, 0.5368234584395088, 0.6322443236521635, 0.5568514208567913, 0.1170801305947311, 0.11104987614236128, 0.1354889592477755, 0.1153735562647229, 0.12415824930640551, 0.1049722165909368, 0.09340912809950985, 0.10320160176913795, 0.09389523084472107, 0.2004860518584236, 0.14890467690089548, 0.1425263804636665, 0.16090177089577629, 0.14920586848060446, 0.14105591614586865, 0.1646667077038435, 0.13340747624102278, 0.15572436959418268, 0.35819255594112387, 0.2653166954660199, 0.2796155213533812, 0.31311397353114845, 0.24706302833633398, 0.3006341186118149, 0.38821701005022047, 0.38756661188168573, 0.3973977679198185, 0.2701934049201977, 0.2615726457977733, 0.2909793018320799, 0.2469927249541899, 0.23729107217123635, 0.26266383942104077, 0.25614603820883164, 0.3005036430362926, 0.2969315180658596, 0.181855905479132, 0.18861344809988, 0.17884567025338838, 0.1660815685331234, 0.1700622808984179, 0.17968421839700388, 0.18832357358137308, 0.1685057848961271, 0.17440241521636546, 0.2117175781475521, 0.19640971710376076, 0.18549325846144005, 0.22852275481206885, 0.19589449498158296, 0.17936628442775926, 0.19308286042006562, 0.20762582550499542, 0.2538160033699127, 0.1491893088246412, 0.19208752518654448, 0.163869959610349, 0.1778789833982488, 0.21540083653652486, 0.15283258334212446, 0.17539205980093742, 0.17354311019853286, 0.17112377560099923, 0.19057967462550018, 0.191827400810887, 0.14624244988664925, 0.19564883199025995, 0.1558379297720599, 0.16386722525590902, 0.19722801350449148, 0.20412422554859577, 0.2056122469078141, 0.19774817276212497, 0.19225829170843034, 0.17870684439515117, 0.17812225612745913, 0.2123402273836852, 0.15930824936397492, 0.17424694555987608, 0.1560294925646042, 0.17413867288540985, 0.06855307621095086, 0.06712856211762264, 0.06946520000138057, 0.06739439070298103, 0.07129944101072871, 0.0651654665399195, 0.07719256430578136, 0.07690121334918731, 0.07030541719350492]}, "mutation_prompt": null}
{"id": "63be11ef-8460-471b-8505-7628df5929fd", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Incorporating Adaptive Mutation Factor and Self-Adaptive Crossover Rate to Enhance Exploration-Exploitation Balance in Hybrid Differential Evolution.", "configspace": "", "generation": 52, "fitness": 0.38910641646045324, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "35d884fa-f806-45ef-b35c-6926ad2a70b2", "metadata": {"aucs": [0.781992325540999, 0.7746820007391904, 0.7762176755263661, 0.7958706295965277, 0.7815833003737436, 0.7753666836691699, 0.7745192001630565, 0.7805600035971201, 0.7842361461403078, 0.610440990089235, 0.6133954770850325, 0.6257216141897761, 0.6139786250768186, 0.6455692847162027, 0.6122350771347607, 0.6186083641884839, 0.6133362330387273, 0.6255151902847729, 0.10722613583597973, 0.10898873749642646, 0.13518959309703482, 0.1126768764207392, 0.11540327628916924, 0.12160844295933271, 0.10517338847362823, 0.11857835535650518, 0.10896838468632863, 0.11950732013752718, 0.11440881055522545, 0.10057280187198081, 0.09453011295102443, 0.12324675286052011, 0.11509511647540915, 0.1006062867317713, 0.09845972462149222, 0.0879637123828978, 0.962028286686374, 0.9202680948671295, 0.8886376245877832, 0.9600565512385938, 0.9433167026686788, 0.953263939391683, 0.9504095184941703, 0.9629865464474489, 0.9718748664630391, 0.4646821977802341, 0.47515151941004075, 0.5079390465310722, 0.4620490777933396, 0.4858699482605018, 0.49271982847726015, 0.5007285783506126, 0.4727926609944657, 0.49531437566234704, 0.7671975590988, 0.7519856941792852, 0.7295999086063621, 0.8178927125952167, 0.7832667876071562, 0.7764568085133405, 0.7753886825874193, 0.7933969725277622, 0.7693213025610431, 0.2970123415929402, 0.21775138019171913, 0.2666761818924065, 0.36887871234144476, 0.32546831492837336, 0.42505061840218406, 0.48117148738686977, 0.24719796971883523, 0.2584402545293909, 0.2378279551327469, 0.5518841662097338, 0.163857787397523, 0.31035377207012926, 0.2859655215988862, 0.2950491108132265, 0.3409555753862311, 0.2524948552002678, 0.3872966849509841, 0.4920325414904252, 0.44875301757731223, 0.48066834218990806, 0.4054616116611073, 0.46707916924459025, 0.4805040832743378, 0.42600915069334266, 0.4825456995804883, 0.47954301256829, 0.5911614581214902, 0.5809013498545779, 0.5719671429452601, 0.5974698897418156, 0.6012386372760536, 0.5786198808282874, 0.6024469384892498, 0.6240014509600275, 0.6028975613504852, 0.10249196568779739, 0.1002671511394354, 0.11701655774826591, 0.18404425781056122, 0.18221030330771815, 0.18061363400300778, 0.17209827161015234, 0.18418273099693783, 0.1414039430682995, 0.3302602142381933, 0.3650633136458017, 0.3527513815669179, 0.3524667406531846, 0.37867621251558825, 0.3669799596344534, 0.3657335236960143, 0.35849326344187715, 0.3722647924045904, 0.7226235031371981, 0.7058916072557595, 0.7079938235914236, 0.7210004552147993, 0.7150947395251466, 0.7213255274380099, 0.7298715734436716, 0.7202534608943527, 0.7126053939627761, 0.0857643828948016, 0.11075503710747125, 0.09553026061368763, 0.10510714640615859, 0.09568833764260742, 0.0929833039943595, 0.1067547223062778, 0.0963319795155192, 0.09549806522253879, 0.13128549418888835, 0.12933992678385875, 0.17962676311181736, 0.22278200103197132, 0.1543164997435561, 0.1784957721108713, 0.13554911056181806, 0.13712191570047105, 0.17116382300653454, 0.4570224923155092, 0.4217809957969122, 0.4220883535031523, 0.41592663479671366, 0.40594727544958087, 0.4401469043617182, 0.4464298320246667, 0.46125011786654646, 0.44707404732247646, 0.33776390058364136, 0.3436841926210725, 0.34626721751820067, 0.32701313187377834, 0.31646534936360116, 0.31983378481718194, 0.3449035747339657, 0.3751478347953695, 0.36818732051261416, 0.20793804719933773, 0.17439796506242944, 0.19528968835646232, 0.19879415003421896, 0.20191921175089111, 0.19418268961692764, 0.19071214796788638, 0.19116558988596966, 0.2017540142967611, 0.21281242672716083, 0.2037107023775312, 0.18599725374146026, 0.18016179159251622, 0.18330133011538086, 0.229701269064146, 0.22581164932867293, 0.19931558409335492, 0.21304713605591064, 0.15212014425172438, 0.20316007318931872, 0.7547175096830806, 0.6758998584704322, 0.754405626275447, 0.17890073061781908, 0.182445821144411, 0.7572583856137377, 0.674981068174618, 0.6999654052211047, 0.1997214085629888, 0.6149122840874306, 0.20358164756161556, 0.6728261818498886, 0.6202860104659115, 0.2054369787682666, 0.2075271288044147, 0.20249957729515322, 0.18635830137602083, 0.1819920962474182, 0.18555596939121777, 0.18145978009520936, 0.20854570645608428, 0.1836628812471648, 0.18743796852928674, 0.19981458114868178, 0.19877073874534568, 0.0794859569290064, 0.08344882061959302, 0.08316588786021273, 0.08698516187197036, 0.08616174060839987, 0.08078394897765151, 0.08278290151688417, 0.08047597760259528, 0.08147117477355348]}, "mutation_prompt": null}
{"id": "ba0d8b87-e996-4202-9e46-c6069d31b8ea", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 50))\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDifferentialEvolution", "description": "Incorporating Adaptive Mutation Factor and Self-Adaptive Crossover Rate to Enhance Exploration-Exploitation Balance in Hybrid Differential Evolution.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63be11ef-8460-471b-8505-7628df5929fd", "metadata": {"aucs": [0.781992325540999, 0.7746820007391904, 0.7762176755263661, 0.7958706295965277, 0.7815833003737436, 0.7753666836691699, 0.7745192001630565, 0.7805600035971201, 0.7842361461403078, 0.610440990089235, 0.6133954770850325, 0.6257216141897761, 0.6139786250768186, 0.6455692847162027, 0.6122350771347607, 0.6186083641884839, 0.6133362330387273, 0.6255151902847729, 0.10722613583597973, 0.10898873749642646, 0.13518959309703482, 0.1126768764207392, 0.11540327628916924, 0.12160844295933271, 0.10517338847362823, 0.11857835535650518, 0.10896838468632863, 0.11950732013752718, 0.11440881055522545, 0.10057280187198081, 0.09453011295102443, 0.12324675286052011, 0.11509511647540915, 0.1006062867317713, 0.09845972462149222, 0.0879637123828978, 0.962028286686374, 0.9202680948671295, 0.8886376245877832, 0.9600565512385938, 0.9433167026686788, 0.953263939391683, 0.9504095184941703, 0.9629865464474489, 0.9718748664630391, 0.4646821977802341, 0.47515151941004075, 0.5079390465310722, 0.4620490777933396, 0.4858699482605018, 0.49271982847726015, 0.5007285783506126, 0.4727926609944657, 0.49531437566234704, 0.7671975590988, 0.7519856941792852, 0.7295999086063621, 0.8178927125952167, 0.7832667876071562, 0.7764568085133405, 0.7753886825874193, 0.7933969725277622, 0.7693213025610431, 0.2970123415929402, 0.21775138019171913, 0.2666761818924065, 0.36887871234144476, 0.32546831492837336, 0.42505061840218406, 0.48117148738686977, 0.24719796971883523, 0.2584402545293909, 0.2378279551327469, 0.5518841662097338, 0.163857787397523, 0.31035377207012926, 0.2859655215988862, 0.2950491108132265, 0.3409555753862311, 0.2524948552002678, 0.3872966849509841, 0.4920325414904252, 0.44875301757731223, 0.48066834218990806, 0.4054616116611073, 0.46707916924459025, 0.4805040832743378, 0.42600915069334266, 0.4825456995804883, 0.47954301256829, 0.5911614581214902, 0.5809013498545779, 0.5719671429452601, 0.5974698897418156, 0.6012386372760536, 0.5786198808282874, 0.6024469384892498, 0.6240014509600275, 0.6028975613504852, 0.10249196568779739, 0.1002671511394354, 0.11701655774826591, 0.18404425781056122, 0.18221030330771815, 0.18061363400300778, 0.17209827161015234, 0.18418273099693783, 0.1414039430682995, 0.3302602142381933, 0.3650633136458017, 0.3527513815669179, 0.3524667406531846, 0.37867621251558825, 0.3669799596344534, 0.3657335236960143, 0.35849326344187715, 0.3722647924045904, 0.7226235031371981, 0.7058916072557595, 0.7079938235914236, 0.7210004552147993, 0.7150947395251466, 0.7213255274380099, 0.7298715734436716, 0.7202534608943527, 0.7126053939627761, 0.0857643828948016, 0.11075503710747125, 0.09553026061368763, 0.10510714640615859, 0.09568833764260742, 0.0929833039943595, 0.1067547223062778, 0.0963319795155192, 0.09549806522253879, 0.13128549418888835, 0.12933992678385875, 0.17962676311181736, 0.22278200103197132, 0.1543164997435561, 0.1784957721108713, 0.13554911056181806, 0.13712191570047105, 0.17116382300653454, 0.4570224923155092, 0.4217809957969122, 0.4220883535031523, 0.41592663479671366, 0.40594727544958087, 0.4401469043617182, 0.4464298320246667, 0.46125011786654646, 0.44707404732247646, 0.33776390058364136, 0.3436841926210725, 0.34626721751820067, 0.32701313187377834, 0.31646534936360116, 0.31983378481718194, 0.3449035747339657, 0.3751478347953695, 0.36818732051261416, 0.20793804719933773, 0.17439796506242944, 0.19528968835646232, 0.19879415003421896, 0.20191921175089111, 0.19418268961692764, 0.19071214796788638, 0.19116558988596966, 0.2017540142967611, 0.21281242672716083, 0.2037107023775312, 0.18599725374146026, 0.18016179159251622, 0.18330133011538086, 0.229701269064146, 0.22581164932867293, 0.19931558409335492, 0.21304713605591064, 0.15212014425172438, 0.20316007318931872, 0.7547175096830806, 0.6758998584704322, 0.754405626275447, 0.17890073061781908, 0.182445821144411, 0.7572583856137377, 0.674981068174618, 0.6999654052211047, 0.1997214085629888, 0.6149122840874306, 0.20358164756161556, 0.6728261818498886, 0.6202860104659115, 0.2054369787682666, 0.2075271288044147, 0.20249957729515322, 0.18635830137602083, 0.1819920962474182, 0.18555596939121777, 0.18145978009520936, 0.20854570645608428, 0.1836628812471648, 0.18743796852928674, 0.19981458114868178, 0.19877073874534568, 0.0794859569290064, 0.08344882061959302, 0.08316588786021273, 0.08698516187197036, 0.08616174060839987, 0.08078394897765151, 0.08278290151688417, 0.08047597760259528, 0.08147117477355348]}, "mutation_prompt": null}
{"id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Size and Memory-based Mutation Strategies for Enhanced Performance in Differential Evolution.", "configspace": "", "generation": 54, "fitness": 0.3998508312319242, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "63be11ef-8460-471b-8505-7628df5929fd", "metadata": {"aucs": [0.827917846632289, 0.816025337539195, 0.8073175766673704, 0.831512385043134, 0.8231292009620318, 0.8244490526694158, 0.8175440223402543, 0.8178354727110364, 0.8123892812187768, 0.6640085280308743, 0.7102763626612114, 0.7015448375852466, 0.6963513767455549, 0.6884427314310302, 0.6977711917705279, 0.6895518728711967, 0.6829252093334308, 0.6984616992776735, 0.26866823083917624, 0.12085489317771658, 0.12335799694551774, 0.11133610252701132, 0.12568801779213135, 0.13638129202354543, 0.1321323798096108, 0.1333016618186803, 0.135767916754422, 0.12424005411335348, 0.11090571138661975, 0.13535814622090547, 0.12550133459985968, 0.10676002151067732, 0.11231561315261207, 0.1341538308518988, 0.11715200516713664, 0.10199207808017852, 0.9211638874740804, 0.8982065001474262, 0.9475475274578972, 0.8775946228866585, 0.9430957783604369, 0.8440634449103863, 0.883457809259517, 0.8554528682234201, 0.8692989528072259, 0.431131552345702, 0.5348786979248534, 0.42475850418449135, 0.5255575518284422, 0.4618810201204706, 0.5503679274391126, 0.30818789078074804, 0.47126114897119875, 0.48726984725886624, 0.8519652958620458, 0.8234725799896203, 0.8457194766993116, 0.8448135318652018, 0.797323487111619, 0.8295318894195524, 0.8410800799701115, 0.8323856032591666, 0.8188270809649373, 0.16186707651284638, 0.18218240518704532, 0.20621765454329122, 0.17753740760004733, 0.16477781367633748, 0.2854197546991938, 0.3052312162343519, 0.20673874441040274, 0.18431669174567267, 0.1932358842017159, 0.15331201109632353, 0.19728945663055686, 0.14886672229592257, 0.15802308566716206, 0.18421455186176972, 0.19394222066053035, 0.1725946472671862, 0.4694592207149042, 0.5425532192428075, 0.569195015332502, 0.057238365039834704, 0.21624437364534232, 0.12519586845876585, 0.13909845534084075, 0.5521342282860162, 0.6011793725462313, 0.565951383832487, 0.21366489866724991, 0.6831566138368877, 0.4989778312443762, 0.3772631965190886, 0.5972547076225212, 0.680232819307258, 0.2730065659120935, 0.6761825964855124, 0.6680865362729609, 0.15644534465855808, 0.16334916637275332, 0.19491782231108623, 0.1284218017540183, 0.3903958585851244, 0.2106281739677629, 0.17636918424939063, 0.19237141696235371, 0.14254703953430803, 0.41304423953061287, 0.4341242834143806, 0.48322123676941564, 0.43559287455221785, 0.45241302145405893, 0.4739494733734795, 0.45681375821670567, 0.32284710750252144, 0.47446441652693694, 0.7138553217875896, 0.7690735859295379, 0.7437240087129335, 0.7666072623770663, 0.7730833130299724, 0.778343689730882, 0.7764739398501078, 0.7352394244482854, 0.7755820670873138, 0.11451956406979824, 0.11863827814194539, 0.13347364986710597, 0.13669419392452709, 0.1053785130213537, 0.11924636750273965, 0.1368137291663748, 0.10388572380593064, 0.10537487359460906, 0.13852645986109435, 0.1563874456773079, 0.16464229788278462, 0.2237736699902384, 0.2163627809978924, 0.1794244101445851, 0.16032197013509775, 0.2594516851192996, 0.166885736373369, 0.5238477565560062, 0.5221599071698357, 0.5104234741696042, 0.5102458887693994, 0.4951306054824205, 0.4901439175572371, 0.5821867536425631, 0.5856543738088618, 0.5405183970529941, 0.4157617094315528, 0.385698161100399, 0.4370558139758126, 0.35153966618548615, 0.39032858991510655, 0.4211843945488991, 0.4115889752482994, 0.4362236490503688, 0.47875579751694575, 0.19550790569162735, 0.21876051343611358, 0.2253916270746551, 0.20023737448998435, 0.21890257427762072, 0.2104732216159878, 0.1924911917770833, 0.20962417625925822, 0.1983375523148998, 0.2169147072639136, 0.4610320660322512, 0.23100325957946932, 0.18535309771557307, 0.4660049572819033, 0.2024894355255883, 0.2335059428080547, 0.29589213430178807, 0.2248588923467777, 0.18198295555832955, 0.8230947311529662, 0.15058881779461097, 0.7600142649563832, 0.7568355481053126, 0.19599473758007757, 0.860243823854228, 0.7926543012811347, 0.8333576303240295, 0.764859914174943, 0.20240609305628054, 0.20213898895350946, 0.27623247810810614, 0.19871481417068915, 0.3562829146669362, 0.2054475511766085, 0.20609716316129945, 0.5621138261492611, 0.18864779909588636, 0.18333939656811382, 0.19188377003831614, 0.17671147481145566, 0.18956264131427936, 0.18661784252064695, 0.18486274030170013, 0.1839896241317086, 0.188665096286333, 0.08538583570659863, 0.07915005785006446, 0.07935199351355737, 0.08803383798874187, 0.08215480917357743, 0.0851052558516785, 0.0808900040816447, 0.08442206442197298, 0.08555766289304034]}, "mutation_prompt": null}
{"id": "0239e77a-09d6-44a5-944a-c6a0caf5d6ba", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Size and Memory-based Mutation Strategies for Enhanced Performance in Differential Evolution.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'Timed out generating response. Please try again with a shorter prompt or with `max_tokens` set to a lower value.', 'type': 'internal_error', 'param': None, 'code': 'request_timeout'}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'Timed out generating response. Please try again with a shorter prompt or with `max_tokens` set to a lower value.', 'type': 'internal_error', 'param': None, 'code': 'request_timeout'}}\")", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.827917846632289, 0.816025337539195, 0.8073175766673704, 0.831512385043134, 0.8231292009620318, 0.8244490526694158, 0.8175440223402543, 0.8178354727110364, 0.8123892812187768, 0.6640085280308743, 0.7102763626612114, 0.7015448375852466, 0.6963513767455549, 0.6884427314310302, 0.6977711917705279, 0.6895518728711967, 0.6829252093334308, 0.6984616992776735, 0.26866823083917624, 0.12085489317771658, 0.12335799694551774, 0.11133610252701132, 0.12568801779213135, 0.13638129202354543, 0.1321323798096108, 0.1333016618186803, 0.135767916754422, 0.12424005411335348, 0.11090571138661975, 0.13535814622090547, 0.12550133459985968, 0.10676002151067732, 0.11231561315261207, 0.1341538308518988, 0.11715200516713664, 0.10199207808017852, 0.9211638874740804, 0.8982065001474262, 0.9475475274578972, 0.8775946228866585, 0.9430957783604369, 0.8440634449103863, 0.883457809259517, 0.8554528682234201, 0.8692989528072259, 0.431131552345702, 0.5348786979248534, 0.42475850418449135, 0.5255575518284422, 0.4618810201204706, 0.5503679274391126, 0.30818789078074804, 0.47126114897119875, 0.48726984725886624, 0.8519652958620458, 0.8234725799896203, 0.8457194766993116, 0.8448135318652018, 0.797323487111619, 0.8295318894195524, 0.8410800799701115, 0.8323856032591666, 0.8188270809649373, 0.16186707651284638, 0.18218240518704532, 0.20621765454329122, 0.17753740760004733, 0.16477781367633748, 0.2854197546991938, 0.3052312162343519, 0.20673874441040274, 0.18431669174567267, 0.1932358842017159, 0.15331201109632353, 0.19728945663055686, 0.14886672229592257, 0.15802308566716206, 0.18421455186176972, 0.19394222066053035, 0.1725946472671862, 0.4694592207149042, 0.5425532192428075, 0.569195015332502, 0.057238365039834704, 0.21624437364534232, 0.12519586845876585, 0.13909845534084075, 0.5521342282860162, 0.6011793725462313, 0.565951383832487, 0.21366489866724991, 0.6831566138368877, 0.4989778312443762, 0.3772631965190886, 0.5972547076225212, 0.680232819307258, 0.2730065659120935, 0.6761825964855124, 0.6680865362729609, 0.15644534465855808, 0.16334916637275332, 0.19491782231108623, 0.1284218017540183, 0.3903958585851244, 0.2106281739677629, 0.17636918424939063, 0.19237141696235371, 0.14254703953430803, 0.41304423953061287, 0.4341242834143806, 0.48322123676941564, 0.43559287455221785, 0.45241302145405893, 0.4739494733734795, 0.45681375821670567, 0.32284710750252144, 0.47446441652693694, 0.7138553217875896, 0.7690735859295379, 0.7437240087129335, 0.7666072623770663, 0.7730833130299724, 0.778343689730882, 0.7764739398501078, 0.7352394244482854, 0.7755820670873138, 0.11451956406979824, 0.11863827814194539, 0.13347364986710597, 0.13669419392452709, 0.1053785130213537, 0.11924636750273965, 0.1368137291663748, 0.10388572380593064, 0.10537487359460906, 0.13852645986109435, 0.1563874456773079, 0.16464229788278462, 0.2237736699902384, 0.2163627809978924, 0.1794244101445851, 0.16032197013509775, 0.2594516851192996, 0.166885736373369, 0.5238477565560062, 0.5221599071698357, 0.5104234741696042, 0.5102458887693994, 0.4951306054824205, 0.4901439175572371, 0.5821867536425631, 0.5856543738088618, 0.5405183970529941, 0.4157617094315528, 0.385698161100399, 0.4370558139758126, 0.35153966618548615, 0.39032858991510655, 0.4211843945488991, 0.4115889752482994, 0.4362236490503688, 0.47875579751694575, 0.19550790569162735, 0.21876051343611358, 0.2253916270746551, 0.20023737448998435, 0.21890257427762072, 0.2104732216159878, 0.1924911917770833, 0.20962417625925822, 0.1983375523148998, 0.2169147072639136, 0.4610320660322512, 0.23100325957946932, 0.18535309771557307, 0.4660049572819033, 0.2024894355255883, 0.2335059428080547, 0.29589213430178807, 0.2248588923467777, 0.18198295555832955, 0.8230947311529662, 0.15058881779461097, 0.7600142649563832, 0.7568355481053126, 0.19599473758007757, 0.860243823854228, 0.7926543012811347, 0.8333576303240295, 0.764859914174943, 0.20240609305628054, 0.20213898895350946, 0.27623247810810614, 0.19871481417068915, 0.3562829146669362, 0.2054475511766085, 0.20609716316129945, 0.5621138261492611, 0.18864779909588636, 0.18333939656811382, 0.19188377003831614, 0.17671147481145566, 0.18956264131427936, 0.18661784252064695, 0.18486274030170013, 0.1839896241317086, 0.188665096286333, 0.08538583570659863, 0.07915005785006446, 0.07935199351355737, 0.08803383798874187, 0.08215480917357743, 0.0851052558516785, 0.0808900040816447, 0.08442206442197298, 0.08555766289304034]}, "mutation_prompt": null}
{"id": "2b4c63d8-c5b4-403b-80d8-89d1a3ef08f8", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Size and Memory-based Mutation Strategies for Enhanced Performance in Differential Evolution.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: InternalServerError(\"Error code: 500 - {'error': {'message': 'Timed out generating response. Please try again with a shorter prompt or with `max_tokens` set to a lower value.', 'type': 'internal_error', 'param': None, 'code': 'request_timeout'}}\").", "error": "InternalServerError(\"Error code: 500 - {'error': {'message': 'Timed out generating response. Please try again with a shorter prompt or with `max_tokens` set to a lower value.', 'type': 'internal_error', 'param': None, 'code': 'request_timeout'}}\")", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.827917846632289, 0.816025337539195, 0.8073175766673704, 0.831512385043134, 0.8231292009620318, 0.8244490526694158, 0.8175440223402543, 0.8178354727110364, 0.8123892812187768, 0.6640085280308743, 0.7102763626612114, 0.7015448375852466, 0.6963513767455549, 0.6884427314310302, 0.6977711917705279, 0.6895518728711967, 0.6829252093334308, 0.6984616992776735, 0.26866823083917624, 0.12085489317771658, 0.12335799694551774, 0.11133610252701132, 0.12568801779213135, 0.13638129202354543, 0.1321323798096108, 0.1333016618186803, 0.135767916754422, 0.12424005411335348, 0.11090571138661975, 0.13535814622090547, 0.12550133459985968, 0.10676002151067732, 0.11231561315261207, 0.1341538308518988, 0.11715200516713664, 0.10199207808017852, 0.9211638874740804, 0.8982065001474262, 0.9475475274578972, 0.8775946228866585, 0.9430957783604369, 0.8440634449103863, 0.883457809259517, 0.8554528682234201, 0.8692989528072259, 0.431131552345702, 0.5348786979248534, 0.42475850418449135, 0.5255575518284422, 0.4618810201204706, 0.5503679274391126, 0.30818789078074804, 0.47126114897119875, 0.48726984725886624, 0.8519652958620458, 0.8234725799896203, 0.8457194766993116, 0.8448135318652018, 0.797323487111619, 0.8295318894195524, 0.8410800799701115, 0.8323856032591666, 0.8188270809649373, 0.16186707651284638, 0.18218240518704532, 0.20621765454329122, 0.17753740760004733, 0.16477781367633748, 0.2854197546991938, 0.3052312162343519, 0.20673874441040274, 0.18431669174567267, 0.1932358842017159, 0.15331201109632353, 0.19728945663055686, 0.14886672229592257, 0.15802308566716206, 0.18421455186176972, 0.19394222066053035, 0.1725946472671862, 0.4694592207149042, 0.5425532192428075, 0.569195015332502, 0.057238365039834704, 0.21624437364534232, 0.12519586845876585, 0.13909845534084075, 0.5521342282860162, 0.6011793725462313, 0.565951383832487, 0.21366489866724991, 0.6831566138368877, 0.4989778312443762, 0.3772631965190886, 0.5972547076225212, 0.680232819307258, 0.2730065659120935, 0.6761825964855124, 0.6680865362729609, 0.15644534465855808, 0.16334916637275332, 0.19491782231108623, 0.1284218017540183, 0.3903958585851244, 0.2106281739677629, 0.17636918424939063, 0.19237141696235371, 0.14254703953430803, 0.41304423953061287, 0.4341242834143806, 0.48322123676941564, 0.43559287455221785, 0.45241302145405893, 0.4739494733734795, 0.45681375821670567, 0.32284710750252144, 0.47446441652693694, 0.7138553217875896, 0.7690735859295379, 0.7437240087129335, 0.7666072623770663, 0.7730833130299724, 0.778343689730882, 0.7764739398501078, 0.7352394244482854, 0.7755820670873138, 0.11451956406979824, 0.11863827814194539, 0.13347364986710597, 0.13669419392452709, 0.1053785130213537, 0.11924636750273965, 0.1368137291663748, 0.10388572380593064, 0.10537487359460906, 0.13852645986109435, 0.1563874456773079, 0.16464229788278462, 0.2237736699902384, 0.2163627809978924, 0.1794244101445851, 0.16032197013509775, 0.2594516851192996, 0.166885736373369, 0.5238477565560062, 0.5221599071698357, 0.5104234741696042, 0.5102458887693994, 0.4951306054824205, 0.4901439175572371, 0.5821867536425631, 0.5856543738088618, 0.5405183970529941, 0.4157617094315528, 0.385698161100399, 0.4370558139758126, 0.35153966618548615, 0.39032858991510655, 0.4211843945488991, 0.4115889752482994, 0.4362236490503688, 0.47875579751694575, 0.19550790569162735, 0.21876051343611358, 0.2253916270746551, 0.20023737448998435, 0.21890257427762072, 0.2104732216159878, 0.1924911917770833, 0.20962417625925822, 0.1983375523148998, 0.2169147072639136, 0.4610320660322512, 0.23100325957946932, 0.18535309771557307, 0.4660049572819033, 0.2024894355255883, 0.2335059428080547, 0.29589213430178807, 0.2248588923467777, 0.18198295555832955, 0.8230947311529662, 0.15058881779461097, 0.7600142649563832, 0.7568355481053126, 0.19599473758007757, 0.860243823854228, 0.7926543012811347, 0.8333576303240295, 0.764859914174943, 0.20240609305628054, 0.20213898895350946, 0.27623247810810614, 0.19871481417068915, 0.3562829146669362, 0.2054475511766085, 0.20609716316129945, 0.5621138261492611, 0.18864779909588636, 0.18333939656811382, 0.19188377003831614, 0.17671147481145566, 0.18956264131427936, 0.18661784252064695, 0.18486274030170013, 0.1839896241317086, 0.188665096286333, 0.08538583570659863, 0.07915005785006446, 0.07935199351355737, 0.08803383798874187, 0.08215480917357743, 0.0851052558516785, 0.0808900040816447, 0.08442206442197298, 0.08555766289304034]}, "mutation_prompt": null}
{"id": "fa5208a9-ed8e-4014-98c0-72cb3ec4d0aa", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        distances = np.abs(self.fitness - self.fitness[idx])\n        probabilities = distances / distances.sum()\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False, p=probabilities[:-1][indices])\n    \n    def mutate(self, idx, r1, r2, r3):\n        scaling_factor = 0.5 + np.std(self.fitness) / (np.mean(self.fitness) + 1e-9)\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant * scaling_factor, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing a Fitness-Based Dynamic Scaling and Smart Parent Selection to Enhance Convergence in Differential Evolution.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 49').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 49')", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {}, "mutation_prompt": null}
{"id": "d1c8cd92-6ba0-41fd-bb95-065ed38c9af5", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.base_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * self.base_mutation_factor\n        self.dynamic_factor_history = []\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.3 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.5))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Dynamic Adaptive Strategies and Dimensionality Reduction for Enhanced Differential Evolution Performance.", "configspace": "", "generation": 58, "fitness": 0.3463082080952584, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.8512965797751733, 0.8393044653657453, 0.8406438858460853, 0.8319307274408364, 0.8202772728277121, 0.8282625736640917, 0.8509774228667746, 0.8403248625982056, 0.8444365232907853, 0.7103392984438531, 0.7250475422510704, 0.7249206142059985, 0.7233778370492325, 0.7097095669518162, 0.7206501466126107, 0.6972368557539543, 0.7091712869629374, 0.7006891103676112, 0.1967686049277052, 0.15620606652241387, 0.32024025503981934, 0.1285037756188956, 0.16670013103434067, 0.3097415772976244, 0.17033172786784412, 0.14200414254733384, 0.3860525067818519, 0.1451225561777335, 0.13095655975787845, 0.13747624278263593, 0.1729464794292197, 0.14507805702060106, 0.12977076391048226, 0.16659839410837995, 0.11687417294013436, 0.1368619138086271, 0.9234602220518704, 0.876430354763149, 0.8470687540830746, 0.9271779913338007, 0.9324136882672274, 0.8331877093983558, 0.8841727827803318, 0.8293027359475447, 0.9627949155469834, 0.24352336799291274, 0.3385782717663105, 0.39234115174911643, 0.3624703197056529, 0.28555670612643247, 0.14159660427050802, 0.2340145383997716, 0.271091591818863, 0.18314604307908378, 0.8581092466958252, 0.3722364044698472, 0.8626559369329367, 0.8442110969238162, 0.8633148452918367, 0.817358579697282, 0.8275369681589869, 0.8484899457292934, 0.2843193379684402, 0.20123301118398007, 0.1851980388339245, 0.13512926234230638, 0.14908951781316482, 0.13551990994195928, 0.1736851577278954, 0.14929482332599797, 0.4310447651553304, 0.18552200642208383, 0.23966076170609285, 0.2042429646680226, 0.11807938899999915, 0.1560465692883627, 0.1475147450069606, 0.26247054698333905, 0.17902353011602812, 0.17295035399672665, 0.1588970777922406, 0.27179109132368384, 0.17580269590154474, 0.2662064376961719, 0.12343847168309441, 0.08616470848237623, 0.13678759768174242, 0.16459321715657937, 0.06282065359434819, 0.08104960437253117, 0.26654288158483963, 0.16967737905429092, 0.21124930872784864, 0.055928848537030396, 0.32080452049771024, 0.1164598808080487, 0.18002231459505968, 0.2591947657968202, 0.7120465826496525, 0.17205884435604912, 0.21089673605753456, 0.04009617354960715, 0.08803988409737196, 0.19649814718571568, 0.22162907585122438, 0.09955107095968108, 0.22483136435431084, 0.17953135578217838, 0.3012537829086871, 0.23542643005859099, 0.28715022755899267, 0.4191640717172872, 0.3666166770705609, 0.41392855867140965, 0.21254432619403874, 0.22584552943630987, 0.1679546035500925, 0.4677862969493284, 0.544385801862179, 0.7327557496331651, 0.6000651775088888, 0.7400077342851754, 0.5961422166464457, 0.4767801677052681, 0.6093697957459892, 0.6797911630308087, 0.1382677641343094, 0.10537558377709089, 0.1672849326356889, 0.17194179184168423, 0.1324419763444814, 0.11550070982019389, 0.14097961193923625, 0.1611851761594919, 0.14054010062685252, 0.23527065910931888, 0.28513627734696767, 0.3168604005697674, 0.15048602378970277, 0.28134851470456956, 0.1847319549169545, 0.20387692570182447, 0.1894035312221225, 0.25222328311267816, 0.5676604882692914, 0.5454724657266925, 0.4277210199026731, 0.41819028398645286, 0.5003649618499517, 0.5322519521767609, 0.581407476147191, 0.5457188189736064, 0.6691813737997454, 0.3720822619884272, 0.28637588302688366, 0.3983300440190538, 0.38485271385570996, 0.46143521473372995, 0.2424327957086293, 0.42852509327621535, 0.22700465102212708, 0.3498885703170751, 0.21295855106611383, 0.198749159578824, 0.198723920219819, 0.21996654524395465, 0.20047839406358947, 0.20339651988570806, 0.19314666359649613, 0.2112848825041006, 0.20693529787559972, 0.20281991013237444, 0.20406525351398053, 0.63700200832371, 0.23049126539135711, 0.26339784444371517, 0.37345684638246324, 0.6945281378800092, 0.6692703454457972, 0.1950879651884312, 0.33460609330139635, 0.20394598182565182, 0.17012382583370578, 0.17042609696905342, 0.40268479895139675, 0.8418866357125303, 0.258834595069549, 0.16891928626396657, 0.20510109559103729, 0.3440982357739143, 0.20631693631519865, 0.34402420585222504, 0.2070775614292888, 0.19536156938620775, 0.2028385943003802, 0.15295041787309982, 0.1531173804767001, 0.20937946070530233, 0.19552304487049055, 0.18694802220787876, 0.19302843148592663, 0.1890207019637119, 0.19067270238555845, 0.19828440517963541, 0.18303671920814923, 0.184271407175859, 0.2231816382990659, 0.08383554036304808, 0.0881693869008241, 0.08447009546374429, 0.0954393442275061, 0.10080632292480063, 0.10968814169277996, 0.0805332086679117, 0.10659232194426549, 0.08119297974291062]}, "mutation_prompt": null}
{"id": "ad25a3f7-7ac4-4b5c-ad42-d2c81143261b", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.best_solution = None  # Add to track the best solution globally\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n        self.best_solution = self.population[np.argmin(self.fitness)]  # Track best solution\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def levy_flight(self):\n        step = np.random.normal(size=self.dim) / np.fabs(np.random.normal())\n        return step / np.linalg.norm(step)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        levy_step = 0.5 * self.levy_flight()\n        mutant = (self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) +\n                  levy_step * (self.best_solution - self.population[idx]) * historical_factor)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                        if trial_fitness < func(self.best_solution):  # Update global best\n                            self.best_solution = trial\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedDE", "description": "Enhanced Differential Evolution with Adaptive Levy Flight and Historical Best Learning.", "configspace": "", "generation": 59, "fitness": 0.263832489996339, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.700720074332122, 0.6713125233533345, 0.7083017509188742, 0.7061273623392641, 0.6921446467629961, 0.7156028069100885, 0.7147276117640547, 0.6996586063495642, 0.7098672300085369, 0.47110156709508133, 0.45421179566261904, 0.4324741712940984, 0.44760451628955256, 0.45910260598243013, 0.48697743103987634, 0.47448112929584807, 0.46541077900761574, 0.44632225607641407, 0.09868825130147763, 0.11209525060813541, 0.10561211437579676, 0.108681776619318, 0.09349521138120986, 0.09318807746597613, 0.09761084916711205, 0.11744614607294857, 0.09129708585737806, 0.09559957464866708, 0.09947947918014255, 0.09141033306919255, 0.08983779127321045, 0.08564621823232776, 0.08509714683553937, 0.0897130064209739, 0.08878162093532682, 0.09639628863121164, 0.8571158331037587, 0.9664204088716035, 0.8854350550163984, 0.7500951525554604, 0.9135135832426009, 0.9441204382690871, 0.9404752796835818, 0.7659389015819341, 0.9155562648653759, 0.36964208479131677, 0.34122969838297823, 0.3583443620560063, 0.35538234696900284, 0.3836022834954288, 0.3667996461371952, 0.3706508565111848, 0.3150143170122909, 0.3714882258757519, 0.5024668388946021, 0.6521136553994165, 0.6267522147732644, 0.6401590897914329, 0.6179786578429425, 0.6584928519144293, 0.5676647265485539, 0.683292407456557, 0.6605726644518972, 0.1974605120041325, 0.20226275502590374, 0.18202281882410287, 0.18809904261799115, 0.19437303388517957, 0.1701110427579775, 0.1936523124350088, 0.1961705573753083, 0.18073562876920513, 0.09826080308382512, 0.10695734290758574, 0.10820103785248447, 0.1945837836121801, 0.2032189024450195, 0.1695330968392178, 0.20634863755499933, 0.1810245113242036, 0.20234108343932422, 0.007817891733772231, 0.014476432720404997, 0.0033559322901337563, 9.999999999998899e-05, 0.0078060265137033236, 0.014230653101064306, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030867590149189494, 0.07826439538786967, 0.07746319720564987, 0.09571351477424539, 0.051739218631263406, 0.053786154203877445, 0.07378710385402032, 0.10589726874329153, 0.0850361562717239, 0.06461102342500158, 0.004642358567078175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1310816291330621, 0.12325849059497196, 0.12776133114967214, 0.11777098195353686, 0.13401298834530717, 0.14306402839120824, 0.10477245979568939, 0.10953538052308776, 0.10277231305802526, 0.45034517583792577, 0.4668934387761452, 0.5077201434096996, 0.5056040929187908, 0.5120517115587624, 0.49000762854620794, 0.5207121534741362, 0.48908945096806633, 0.48841525928093454, 0.09734924507737397, 0.09688419027133399, 0.11875455139979474, 0.09646938331918264, 0.09662670974710563, 0.08714264270522942, 0.07930391773845424, 0.09300807602899075, 0.09495856232498479, 0.14170790046710646, 0.14519285408111848, 0.14080760602150932, 0.13275361798158536, 0.15388556968989942, 0.15174794954861937, 0.1451189265220344, 0.13942987705990018, 0.14274458503347165, 0.3234388118756133, 0.3341397127194953, 0.34064209100896137, 0.3340345870263596, 0.3283123571223747, 0.349555375704937, 0.3692201389730675, 0.38886048454262045, 0.3881118643362682, 0.24149485020858896, 0.23773993693656748, 0.22419350959801132, 0.21810984331861505, 0.23142363287445733, 0.22946670946582548, 0.27122524243137136, 0.2807803040105068, 0.27925225965671274, 0.19343625243642515, 0.1858375932752635, 0.1939274716851198, 0.20610000180602872, 0.18633680861409152, 0.19411265451663928, 0.2011669242565869, 0.19323590569812021, 0.1970331848276251, 0.1735295934491321, 0.18123185500151617, 0.17347518980639975, 0.18004016201128648, 0.1736122272257875, 0.17222466972555373, 0.17451651283019165, 0.18741902933265486, 0.17815192781273037, 0.312108806167969, 0.5784091186315028, 0.15942544350704646, 0.41131765791060027, 0.18486958249523577, 0.1737253645513379, 0.17757047445918384, 0.4821471328970496, 0.37231608623218115, 0.3264276791881796, 0.19763423272116387, 0.24908021352366472, 0.20463383453293038, 0.19583980519240574, 0.20991966278077612, 0.20029166571620305, 0.4860403236049018, 0.4009460132398621, 0.1779892663524021, 0.17713422936021783, 0.20893341714422708, 0.18306246802458792, 0.18520415516817645, 0.19834158145020764, 0.17437168755943933, 0.17328690575767436, 0.20132802084922474, 0.07511543955475186, 0.07615827751587534, 0.07300617733878711, 0.07568992412531894, 0.07720429091000369, 0.07743061038413035, 0.0810531900669954, 0.07891787613431644, 0.08202880406223467]}, "mutation_prompt": null}
{"id": "718a9715-3cf4-4089-9be5-fce6c4b8fd45", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        historical_factor = np.random.uniform(0.5, 1.0)\n        if np.random.rand() < 0.5:  # Introduce dual mutation strategies\n            mutant = self.population[r1] + 0.5 * (self.population[r2] - self.population[r3])\n        else:\n            mutant = self.population[r1] + self.mutation_factor_adjustment[idx] * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        history_factor = np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9))) * history_factor  # Incorporate historical success rate\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Improved Adaptive Differential Evolution algorithm using dual mutation strategies and history-informed crossover rates for enhanced exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.2727376150040322, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.7937171310917337, 0.798713993668327, 0.7963520448527817, 0.7974663646177826, 0.7803766340478282, 0.7781361288131421, 0.7864634118535354, 0.7970445744918282, 0.7915552200465398, 0.6109331795125181, 0.6115778160861446, 0.6200565659132247, 0.6061937832643474, 0.6218465744444329, 0.6349603213003328, 0.6171292376997197, 0.6052179071722832, 0.5936183572584453, 0.4878948963914248, 0.4657646889023004, 0.4694471641134066, 0.5037179333067885, 0.4830854013610164, 0.4984473522954558, 0.4486011269796023, 0.5158893224087509, 0.49369279046894754, 0.423605681522645, 0.39804499304655117, 0.4519823032536675, 0.3983678145527454, 0.4122207197931763, 0.16462896004026384, 0.3826083943468297, 0.4059843927002428, 0.4332671420954751, 0.9353702601738391, 0.9538343778134762, 0.9293626985499946, 0.9521987840406305, 0.9435946767620391, 0.908358568857292, 0.9534773858010734, 0.9552485467064917, 0.9494736453618533, 0.289411329817876, 0.2835349384899496, 0.26212457991743654, 0.26451901623321206, 0.24344064326230486, 0.2622555415245239, 0.20904954610511517, 0.20313465417446375, 0.24984630375745343, 0.17647550540054968, 0.21038087056343624, 0.1901682064502086, 0.22516025564734554, 0.26609332545625175, 0.22123376807363881, 0.20353387498835795, 0.20089059498147488, 0.24549123037331677, 0.18485163926602766, 0.14072338901019665, 0.15501228538169975, 0.17476120985602317, 0.17038311774209547, 0.19581749678843863, 0.18346044465062972, 0.1820642186182191, 0.171794983406095, 0.16117560309202583, 0.13024927162288225, 0.17545199814514467, 0.1514917634552525, 0.17211095750711736, 0.16107801815313383, 0.14021165693043547, 0.15727093669213754, 0.13096227209690992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08590211385500857, 0.05578041289365809, 0.0728939713454112, 0.08255004545115807, 0.05183041200309835, 0.0745213845952809, 0.0482732356357779, 0.07796512017270218, 0.06429765344978966, 0.002413862949476986, 9.999999999998899e-05, 9.999999999998899e-05, 0.03195606822448538, 9.999999999998899e-05, 0.000134201360519004, 0.002424503340851536, 9.999999999998899e-05, 0.0025062913886045868, 0.0888997821288654, 0.09096794453689672, 0.09670759148779873, 0.10722276079827897, 0.07226286298029738, 0.10921452458885395, 0.08872557050942009, 0.08848186986066486, 0.11051830464617796, 0.42795836410991783, 0.4542264972826321, 0.4646575834162847, 0.41130791679205736, 0.4346941855568184, 0.4459710719807094, 0.4919576664857549, 0.46058898746157395, 0.4870136397958038, 0.10980105765255244, 0.10154651659010616, 0.11171449393713051, 0.1095407868416669, 0.0885652166492571, 0.095064275846234, 0.10086244208901518, 0.0979362244441756, 0.09028506140273107, 0.17625097402514633, 0.1477512789078146, 0.15677849226763296, 0.13183679250672253, 0.15533482430850276, 0.16838607289087737, 0.15357889191793272, 0.15452417116898742, 0.17755586860830774, 0.23780311162695655, 0.25447202084036924, 0.2657905502730161, 0.23439517583629954, 0.24429302411640041, 0.2636816291086559, 0.2617042164569484, 0.2531958515101109, 0.2671109842806748, 0.1718116862177851, 0.17153525314333273, 0.17859000204839048, 0.17145517442150826, 0.17555181813423115, 0.15830419639376048, 0.19024299262940736, 0.17777456130600933, 0.21268306120299174, 0.18593401993316716, 0.20030486881950493, 0.19557838005754247, 0.20230079409931057, 0.17815304401345233, 0.19512249179646124, 0.20182755090417182, 0.18181212327361296, 0.21112262049139885, 0.2283307862049564, 0.25610836243148505, 0.23677518268747, 0.21916940787749373, 0.2404649142740195, 0.23486793240067816, 0.25066178934376304, 0.23359166547935395, 0.23610789798505027, 0.20376333703499927, 0.2899194957951676, 0.26889586296765944, 0.30509647866898304, 0.221263358789487, 0.2294881286501248, 0.35536993437684106, 0.3244426356943475, 0.36410908332973446, 0.23996489230697093, 0.23654581927222085, 0.22196386803085044, 0.24707350548575158, 0.21116081267710507, 0.2679508960437049, 0.23308612459934164, 0.22475517756882668, 0.24373619889127307, 0.18493176644406395, 0.1885679291321819, 0.21881069341460857, 0.19793521107235557, 0.19507746606425513, 0.17727895986185327, 0.19681680355195952, 0.18323656431089141, 0.17458407179406643, 0.08213744720619565, 0.08102504800444277, 0.07595613027165815, 0.08017031454528678, 0.07374774393689298, 0.07552358271833859, 0.08374133654938565, 0.07695582763841247, 0.07902863399924631]}, "mutation_prompt": null}
{"id": "b7ed90c6-acb1-4ee6-984c-c5408da02e49", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.adaptive_crossover = np.ones(self.pop_size) * self.crossover_rate\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor\n        historical_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.2\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.85\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.adaptive_crossover[idx]\n\n    def self_adaptive_crossover(self, idx, success):\n        if success:\n            self.adaptive_crossover[idx] *= 1.1\n        else:\n            self.adaptive_crossover[idx] *= 0.9\n        self.adaptive_crossover[idx] = np.clip(self.adaptive_crossover[idx], 0.6, 1.0)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n            self.adaptive_crossover = self.adaptive_crossover[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                        self.self_adaptive_crossover(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                        self.self_adaptive_crossover(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Self-Adaptive Crossover and Survival Strategies for Robust Optimization.", "configspace": "", "generation": 61, "fitness": 0.3625122652185257, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.8426528110703058, 0.8394556897962582, 0.8346727493425136, 0.8488913590687119, 0.820280719982055, 0.8244319511803219, 0.8363069844307119, 0.8437064168973061, 0.8200177800266486, 0.7015134082564375, 0.7116677797970239, 0.6971142379335886, 0.7208866847228304, 0.6992084213161748, 0.7057368468369685, 0.7014124653951151, 0.6971617113072028, 0.7064011697209296, 0.6005911527364611, 0.6277358834539979, 0.2737325572842051, 0.6165056856613671, 0.5582422142940214, 0.5930428904973267, 0.5338506680108146, 0.17018844632929353, 0.554364939896592, 0.5938932836662774, 0.14803147731375776, 0.16660086478787106, 0.41634495706126495, 0.5604613060091204, 0.14670160832056123, 0.17222203986512452, 0.4067200370338272, 0.1485520827374709, 0.8601339468076468, 0.935638910276489, 0.8994008169181471, 0.9170061713834299, 0.9086534937426728, 0.9326370097816827, 0.9793459409735951, 0.8597905868330652, 0.850484727938408, 0.3836319894680714, 0.11761785976295636, 0.3510321522672939, 0.3388109932758956, 0.29730589642781546, 0.2695191256398657, 0.2299091090391786, 0.2427544039615659, 0.26617954443805925, 0.6733029649798719, 0.7939551689736852, 0.7871093781457164, 0.799165253448415, 0.2709688345147777, 0.7818302050024635, 0.8171953618112364, 0.8183501088645821, 0.3326319099289047, 0.12949189574616315, 0.23122855988553648, 0.1979776585641363, 0.3252884774587136, 0.1700921450376569, 0.42729338549899487, 0.16064584888525535, 0.2995250856990772, 0.1900346249344541, 0.1519380447671852, 0.1372449163799525, 0.14168162632663894, 0.22555699703857268, 0.20838530650055131, 0.14610640552340248, 0.17504643813443366, 0.1458501321383182, 0.1950384198542533, 0.06748027115065014, 0.039289404959732876, 9.999999999998899e-05, 0.013063495979227291, 0.01191081547192463, 0.0698812309091823, 0.024408213876927598, 0.017452600915273786, 0.06038144799568146, 0.21739376610071126, 0.12325705215791027, 0.18402640488847377, 0.12515862368430952, 0.06556979500855975, 0.05162771054328208, 0.19909113343859386, 0.26824063958098454, 0.08365682754435189, 0.22671249157227236, 0.05006364718627265, 0.03491385575480743, 0.0643215869143704, 0.13320327630818263, 0.1356806430096904, 0.055336163753236356, 0.09071235828968127, 0.14319590324126164, 0.22134960314716767, 0.13278155718534979, 0.17991724377672613, 0.1332163469989417, 0.20481322785178668, 0.21907801088541778, 0.22140954819080194, 0.14229097928014767, 0.2903225242144597, 0.5791129994395052, 0.6377155843234068, 0.5591571995530673, 0.5519465776050128, 0.527296377548542, 0.5664284215286476, 0.553538930538099, 0.5937353386922877, 0.5741039456207537, 0.1386175561286258, 0.1339305537231421, 0.1300170920982313, 0.12311141027887229, 0.12836731338862206, 0.132298070864438, 0.10737497584436295, 0.16035985791916885, 0.13214888108412448, 0.171829345400073, 0.15727502895501944, 0.15418144507056075, 0.14157804618867265, 0.16339823306346646, 0.1554238243456706, 0.17894956930089612, 0.19244473925405614, 0.1457128743735011, 0.5176455863083448, 0.5282283895059265, 0.5220060946288365, 0.4512058072612304, 0.5943201967321166, 0.5279274425430659, 0.5967041999807369, 0.5861220699827066, 0.4892500651794226, 0.29695446184645946, 0.27364771337321436, 0.2515603983336371, 0.27046002774733724, 0.26908997631258336, 0.26052840006071765, 0.34623115253887515, 0.40396745764003705, 0.35893118929887746, 0.22902802394246757, 0.20550753558931656, 0.20277431302486904, 0.20440653065883385, 0.19281826917759337, 0.1982084000626575, 0.2205555329869402, 0.20445059568913704, 0.20028366353177973, 0.6355472607217093, 0.5785818807581531, 0.6424553882009774, 0.4782188873276012, 0.5590799233731667, 0.6267249204195295, 0.544313452738596, 0.7026555991584049, 0.39984499974363463, 0.19577999165339077, 0.3412214095987586, 0.769949310336963, 0.4103732226531043, 0.7312760501752801, 0.7685456102573467, 0.1844765187260401, 0.8003024401344372, 0.19528479118567954, 0.6498313885805347, 0.3935179866465387, 0.5444566618217461, 0.20704114189265221, 0.20229064075421743, 0.759010903035535, 0.15277577179269097, 0.20906125481726723, 0.11045833601655908, 0.19048840146582635, 0.1854824986211021, 0.2257190701084777, 0.21135442097888413, 0.17625792476036717, 0.1831286292500408, 0.18540151965290097, 0.18241901869449728, 0.1793678143687938, 0.0844429958164794, 0.08756386536680805, 0.09157211050040348, 0.08729939463867775, 0.07972737434284205, 0.0916739105819282, 0.08707562116485257, 0.08907073673560573, 0.08526303477839448]}, "mutation_prompt": null}
{"id": "38a416e0-2d07-4747-9387-a00f838c8855", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 62, "fitness": 0.40793673176278006, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "01e6e30a-5275-474a-90c8-01ce20b75d16", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "8c2e3269-4d27-4d9b-9370-add1bc887f1f", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "5b29f5a5-38b0-4eee-9a8b-cf2e81255815", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 40))  # Adjusted population size\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor  # Adjusted by dynamic factor\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.5))  # More aggressive size reduction\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Augmenting AdaptiveDE with Dynamic Population Resizing and Adaptive Mutation with Memory for Enhanced Performance on BBOB Functions.", "configspace": "", "generation": 64, "fitness": 0.33350024844250864, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8656593658010738, 0.8607947663078972, 0.8572052751901031, 0.846589263213914, 0.8480689898432665, 0.8462540077096177, 0.8526430085174505, 0.8555920638443884, 0.8444647146378937, 0.745970331236428, 0.7156956535609871, 0.7422276403675321, 0.7443959052672517, 0.7194566209097256, 0.7635692825373315, 0.11708661215076532, 0.7465695414392759, 0.7446781178236879, 0.4891108933088665, 0.5899058181901635, 0.14964074235297753, 0.46829391810265686, 0.27897888613288047, 0.27934404897402687, 0.5802180278434079, 0.6158028988755184, 0.549307205682061, 0.3933464747066623, 0.10830373915640978, 0.12045619661705387, 0.1117942950559373, 0.1360229159385794, 0.13229332366634405, 0.20713755693255542, 0.14698807500315747, 0.1473297845892042, 0.8676140331462734, 0.8947162928491358, 0.8016404400792622, 0.9335085975243003, 0.9167427859874434, 0.8713481911590728, 0.8168070509003271, 0.7931649780484235, 0.9289662512126406, 0.2758272194697967, 0.16433402087207682, 0.17062554511064298, 0.2268048060398582, 0.2956684017161628, 0.26205207997767677, 0.26474226633626463, 0.2928183083348864, 0.2188401948322376, 0.3147386748832982, 0.8716311945714825, 0.3287529484829883, 0.31651170694903086, 0.36355206994805656, 0.36648272755135425, 0.3822155674479, 0.8546304997622644, 0.35046288869213127, 0.19518365181176622, 0.18783780722655807, 0.20523673732774228, 0.18188960866821635, 0.14012530436226112, 0.3057478734789887, 0.23245685207838818, 0.19285017786557634, 0.1595522678126623, 0.13222522723888908, 0.19660211969676067, 0.14168231805844478, 0.14770190582125453, 0.1333405953955462, 0.17810383347893, 0.1727785334862041, 0.18815719027639866, 0.15331956876668063, 0.06925506238602286, 0.09068981990584635, 9.999999999998899e-05, 0.06879466368888532, 0.09107220720355147, 0.08966272411842369, 0.010273539409402788, 0.014948892232719113, 0.1000789054455552, 0.3299294115967869, 0.2079145065862179, 0.16255991269647851, 0.17817735147772962, 0.10467147700283408, 0.10971221408589715, 0.19797284983367902, 0.17943784652658068, 0.12139574387723406, 0.10754561348643432, 0.21287045168268637, 0.06295036420795186, 0.07947130735060781, 0.13535048866558752, 0.20155621697631987, 0.13219921491959485, 0.1377246574562241, 0.1660240676668363, 0.20816648593428377, 0.17789243942340638, 0.24177146056102783, 0.21179629578308323, 0.1200274183361244, 0.28620975521624614, 0.18754331977559746, 0.1266753409614617, 0.297744497229641, 0.6312978206364075, 0.8094287285444015, 0.5631580465105663, 0.495916022018814, 0.5072501344441305, 0.583929257402342, 0.6088451950439834, 0.47845396883293245, 0.6927502758256092, 0.14377957490279913, 0.15002984407065123, 0.1360086777582754, 0.1465630714047882, 0.1754063908367891, 0.15142594934783826, 0.13768677461092937, 0.15888322803046373, 0.41848019398317715, 0.33363562737600805, 0.39052283917200814, 0.25009664159060585, 0.3352447929822251, 0.1844350853890543, 0.2108671631732547, 0.32113564387230786, 0.5091179936362882, 0.22808336914351623, 0.2881279344087493, 0.29593119531661305, 0.6535644658549287, 0.3903389563042281, 0.48246656025092005, 0.4536106256279935, 0.517412021111262, 0.5096760663240615, 0.6213641295210565, 0.24979130549508044, 0.4627671915712295, 0.2869996856230731, 0.3253460595550879, 0.32463478995911077, 0.31262100158169415, 0.2833519529345053, 0.29615636957222846, 0.2466871530307645, 0.2245636147622493, 0.23543191250026008, 0.2292115302458082, 0.21146878382674772, 0.21352383940784248, 0.2011096628672976, 0.23387639303206076, 0.23091181240625036, 0.22827453660790065, 0.6816910501955673, 0.21590119316205847, 0.3210222995739561, 0.44403550979922735, 0.21112488798980555, 0.21570481033292266, 0.20637689066908105, 0.23731754808698857, 0.2380355553572584, 0.19586399944348654, 0.20742484950616757, 0.39657160287228665, 0.9008263980577458, 0.7241990240017059, 0.16571432454995993, 0.1849312538061506, 0.1864402822893887, 0.5575458235532271, 0.7637171607402995, 0.20491763698136678, 0.30717463965903624, 0.2062362674349827, 0.2660085014892217, 0.16519520599654702, 0.20894733937273668, 0.3741117444662324, 0.15246337669437016, 0.18723239461310592, 0.1820263269639879, 0.1781174183579799, 0.1901908138670828, 0.19452278808493462, 0.17226465962738235, 0.23060209678511356, 0.17392702666884963, 0.184940080230673, 0.0950045532429824, 0.08456158969104255, 0.08054523539880154, 0.08720358570284625, 0.08602331200729185, 0.10361302309574971, 0.08025927169528368, 0.09205650244002139, 0.10045814885752935]}, "mutation_prompt": null}
{"id": "a432af95-e7b4-4603-a44c-e2e3a4892fca", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.dynamic_groups = [self.pop_size // 3, self.pop_size // 3, self.pop_size - 2 * (self.pop_size // 3)]\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        group_cr = [0.8, 0.7, 0.9][idx % 3]\n        cr = np.random.normal(group_cr, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Introducing Dynamic Population Grouping and Self-Adaptive Parameter Tuning to Enhance Diversity and Convergence in Differential Evolution.", "configspace": "", "generation": 65, "fitness": 0.3400982356527183, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8512133125386576, 0.831836360430982, 0.8429765466602145, 0.8481417164790135, 0.8295555273768735, 0.8629268413069147, 0.8430055254809974, 0.8341605174180581, 0.8375209319873985, 0.7232781176046503, 0.722643815278551, 0.7190679577951341, 0.7098180886685372, 0.704173686771411, 0.7386809789958734, 0.724279432001143, 0.7164413485264107, 0.7286836334139929, 0.5002942380434818, 0.5423428913098958, 0.1603238665483434, 0.5284724186938011, 0.2788910546643478, 0.49702490563811885, 0.5869906796323306, 0.5099970859052034, 0.5907942283408352, 0.1340281703976145, 0.14873079806953848, 0.1649960227853846, 0.14836392116699804, 0.16045299736009988, 0.1320689998443948, 0.4412740117642052, 0.13538310760544414, 0.13673022425903747, 0.8415849863468252, 0.877856853685537, 0.8198595800653932, 0.8969125686278104, 0.8214150040330976, 0.9329820725913254, 0.9038944881197675, 0.923792865759092, 0.9107201729345734, 0.26832256260558573, 0.3025695297336721, 0.34461646463378837, 0.32000108465787414, 0.2056515272360212, 0.26736173933187424, 0.342782854136253, 0.18724097032542542, 0.21280955884965647, 0.3617256940361503, 0.37612941087431495, 0.3306352462884553, 0.38549724384261774, 0.3464370923397564, 0.21557742445867434, 0.8599768038683853, 0.8046571194642801, 0.8671276001337919, 0.2021316353609709, 0.1558960724872258, 0.14446104258338432, 0.2060004774969001, 0.17253079328910248, 0.14112478040627796, 0.1500341004590633, 0.19418461898682526, 0.14499261098142047, 0.21282432904076243, 0.13507066915837873, 0.14599806910142865, 0.24558983110405863, 0.12826236937900481, 0.16067340659413054, 0.2350247272537912, 0.1656540262781635, 0.16880574545744553, 9.999999999998899e-05, 0.09274956474667506, 0.05905791331435162, 0.024122467424593785, 0.18125767913397617, 9.999999999998899e-05, 9.999999999998899e-05, 0.13589878290106916, 0.047780716556152236, 0.15622664562411848, 0.3611612839154924, 0.24936191927177742, 0.15797821003647494, 0.11903336103569107, 0.16802814756472984, 0.1685255956640218, 0.20040744364417484, 0.18701723937074144, 0.17214593835984238, 0.23325504768366778, 0.18302233192119555, 0.07431936773961156, 0.07221257542970982, 0.1648722948124347, 0.10371766876561828, 0.19585585839534725, 0.10655417807159684, 0.15375456152767075, 0.3843076147178537, 0.3069516177608007, 0.18032687670259506, 0.2957517291139209, 0.18540235418896722, 0.25055257820062116, 0.20083897230948267, 0.26065204223901706, 0.7477405983286768, 0.46934457251698725, 0.49931251273439037, 0.5850596122345417, 0.48385403511722924, 0.4719454228302503, 0.4836122050926127, 0.5067370874813337, 0.5396675891809951, 0.12859391896948658, 0.12284355839261751, 0.15876294120259793, 0.14399161439287167, 0.1387453371186479, 0.13538271445447303, 0.15180582008696875, 0.13339880734936105, 0.1581600781754483, 0.3221127506717152, 0.1557182671960703, 0.16242363060107146, 0.23383271802043137, 0.17807070866326302, 0.20895049714160374, 0.1702039672315785, 0.19510401044862657, 0.22762613681257782, 0.47106460197376754, 0.42445721426565075, 0.5136359758610008, 0.5721063984389869, 0.5046473425737474, 0.558441921114213, 0.6494369626120994, 0.4634177320521645, 0.6122516250304061, 0.2965364891265274, 0.3970140279084351, 0.4401449398207359, 0.28606411910551965, 0.3596346233371942, 0.35751811531117206, 0.4380816708088424, 0.3775139184731402, 0.4082771384269259, 0.24343404137410118, 0.22370776920645752, 0.21151623680294307, 0.22883738898439854, 0.19532707572676877, 0.20926639612590958, 0.21801734576570808, 0.2429889898089327, 0.19263594408081075, 0.5933540865995153, 0.22797470407264986, 0.23122356132617494, 0.23665635550660846, 0.7279332084274293, 0.5239144907250461, 0.23368533209097808, 0.48100693734969036, 0.24171982680645943, 0.19458046395327722, 0.18488202912716156, 0.18367772344900657, 0.5431934216010361, 0.19398358972403407, 0.4973240238415717, 0.846881446279443, 0.18462197955518955, 0.16614582813824386, 0.7334405756818451, 0.20467025979592146, 0.4997182627969323, 0.2071941074651299, 0.358432491482931, 0.1251321731163625, 0.20287794706334272, 0.20404498426422824, 0.21008736636021674, 0.21438728082732583, 0.19042596959607494, 0.18523193825687845, 0.17176886170783234, 0.1915791687516688, 0.17936720416242546, 0.17918681330839425, 0.18454569578725555, 0.18904309344989056, 0.08110814157589685, 0.09225833791816562, 0.08831932885823968, 0.08928402043763328, 0.08963333238737636, 0.08745809052393938, 0.07774368204464221, 0.09472937557874361, 0.09145190934513525]}, "mutation_prompt": null}
{"id": "dd1e1e84-0586-48a7-a5cf-9545e9e5d5b5", "solution": "import numpy as np\n\nclass MemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.6, 1.0)  # Slight change here\n        scale_adjustment = 1.0 + (0.2 * np.random.randn()) \n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def local_search(self, individual, func):\n        for j in range(self.dim):\n            if self.evaluations < self.budget:\n                temp = np.copy(individual)\n                temp[j] += np.random.uniform(-0.1, 0.1)\n                temp = np.clip(temp, self.lower_bound, self.upper_bound)\n                temp_fitness = func(temp)\n                self.evaluations += 1\n                if temp_fitness < func(individual):\n                    individual[j] = temp[j]\n        return individual\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n\n                if i % 5 == 0:  # Apply local search occasionally\n                    self.population[i] = self.local_search(self.population[i], func)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "MemeticDE", "description": "Enhance Differential Evolution with Adaptive Memetic Strategies for Improved Exploration and Local Search.", "configspace": "", "generation": 66, "fitness": 0.24800161653349087, "feedback": "The algorithm MemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.5137252942917, 0.5401823283826844, 0.5163284633700838, 0.5022428950571192, 0.5506897727566461, 0.5822470752221411, 0.53867195250161, 0.5665571735021062, 0.5052574133088307, 0.21867571233264915, 0.19185029864042635, 0.1778748973654377, 0.2097146750807981, 0.21336223088038953, 0.18515081829667024, 0.22015761953029012, 0.19655272017072323, 0.21559869756832517, 0.11706929488091067, 0.13446967253955622, 0.13443409897422842, 0.10456884154042112, 0.1512074927739121, 0.12489278670070614, 0.138820749730595, 0.13529996783304754, 0.11140388598339235, 0.10265509077959578, 0.07637009631086489, 0.1250900955656874, 0.10694304229531004, 0.09143529032990794, 0.10096584137015252, 0.13552122827163382, 0.104374002549529, 0.10085076772038593, 0.8634681089756824, 0.8609490275559941, 0.8816412310208435, 0.7842518788694348, 0.8233049039650346, 0.7831227211110505, 0.7617742660581368, 0.839217109985981, 0.9313321299498312, 0.219529951242443, 0.20511970460858797, 0.23251646022398598, 0.2414601750045643, 0.21086769179720888, 0.2431500785214521, 0.2008192605866187, 0.2187447774158342, 0.24008765838208868, 0.5222012647405274, 0.44408207849832626, 0.5466548296752478, 0.5437679529018029, 0.5594906870588345, 0.5887784844830617, 0.5062595646420912, 0.4474091104594149, 0.7294131177038683, 0.18101435865375215, 0.12708273362943423, 0.15061185529131726, 0.12977844566512797, 0.160757512890349, 0.19077255258566717, 0.1193677988280808, 0.18922905080970087, 0.21105284992732964, 0.16584910814372744, 0.10082433584320694, 0.1717086081825242, 0.1358517486141746, 0.14480692040206555, 0.14598287924731035, 0.20467375008893318, 0.10376506841504085, 0.11598823260258173, 0.10312596265256302, 0.13658537260339676, 0.13869159492628114, 0.18446568586789325, 0.14683867706523668, 0.15824180062041104, 0.15477158503089228, 0.13403966856547178, 0.09295638763613678, 0.2866692325464528, 0.24924279955893736, 0.23968097856460802, 0.2749750131033265, 0.27202898780395623, 0.2780873202873605, 0.2641268081703333, 0.25591446114322924, 0.262489997323907, 0.05738501430779319, 0.03763887623436912, 0.056583491888872905, 0.05209109451405458, 0.05587389343937432, 0.03895148051945385, 0.041374499730069125, 0.06290041152065118, 0.06744555512914685, 0.13274032959655402, 0.13026499836184235, 0.14372906539422237, 0.14266573935679294, 0.1446028408564376, 0.14943343465680303, 0.1569021295598756, 0.14641335370820596, 0.1436149042606688, 0.42869375973266366, 0.4375512564630658, 0.44807945140998173, 0.4061305234967054, 0.4478415192558729, 0.4076874836025335, 0.4423865065797601, 0.422578398593226, 0.4286596200254197, 0.12071147229846013, 0.13817685339603902, 0.13467851531437391, 0.13959229109386362, 0.09764222566043268, 0.111541298193645, 0.11487547523112296, 0.09939883496686996, 0.10645835649404012, 0.18775731536614237, 0.19176342469344632, 0.1929282224659431, 0.21715371971282615, 0.15945606969144466, 0.14509891229337868, 0.16414072206167662, 0.16350717902769285, 0.1844651299300608, 0.2740364522621125, 0.2741284596794792, 0.28750301583599247, 0.26319327636531964, 0.28192997300655553, 0.2813357631414103, 0.2949890106308388, 0.30171245263377844, 0.2741562921499935, 0.21974582760961492, 0.2051654893614655, 0.22681670741415416, 0.19775833473757187, 0.20508212749495425, 0.2241177009160107, 0.24882751666554437, 0.2354640431768149, 0.2172800088035528, 0.187909017849489, 0.21616447741767397, 0.19362067497181246, 0.19532969186216909, 0.18765227684569707, 0.2026068411269294, 0.20672680182754244, 0.19580338755763638, 0.20786572093050804, 0.20635636831091664, 0.18841850899146573, 0.20294474141166774, 0.1843168047366135, 0.17214251116179768, 0.1741515123121402, 0.17475110241432668, 0.20277290710726714, 0.1849166049891141, 0.4503774158596341, 0.14340022674365827, 0.5707553950753714, 0.2866852742096351, 0.16356614483861653, 0.16351224286652954, 0.18160182333126973, 0.17652775201528292, 0.32381579975738695, 0.30729996876116283, 0.1957285114290993, 0.396920582229463, 0.1770180666345721, 0.33455130038723235, 0.24110201153137745, 0.2016498377403415, 0.5454502605436424, 0.27484990410255783, 0.20704180814804418, 0.19914812264848758, 0.19764326634682916, 0.19076767296159391, 0.19955564635440315, 0.20729397606934663, 0.20683352188843485, 0.20501514348265304, 0.19945468480873518, 0.08787424094346896, 0.08171441358529197, 0.08468092267867211, 0.08535818145583529, 0.093754998487101, 0.08511854070619196, 0.08839317458982443, 0.08157580622257288, 0.08237782486677114]}, "mutation_prompt": null}
{"id": "37733a58-079e-4f2a-b818-06c06aa877c2", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + np.random.uniform(0.0, 0.5) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.2)\n        scale_adjustment = 1.0 + (0.3 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + dynamic_factor * mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.05\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.95\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.05)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.1 * self.budget:\n            self.pop_size = max(8, int(self.pop_size * 0.6))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhanced DE with Adaptive Population Resizing and Stochastic Mutation Strategy for Efficient Convergence.", "configspace": "", "generation": 67, "fitness": 0.34617772708506395, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8335038300413615, 0.8220012804801562, 0.8493239733070983, 0.8416728252454122, 0.8291825495238915, 0.8278535448280004, 0.8386051844692709, 0.8518331178354108, 0.8177979502809292, 0.7179384481375842, 0.6959721327710613, 0.7056043937734933, 0.7078513860785709, 0.7088800254002259, 0.7148234248938663, 0.6820353071303353, 0.6925522908287751, 0.7309919998161614, 0.4235762335248915, 0.16170856720557059, 0.38647230693091694, 0.5909295614329868, 0.43842951259472296, 0.32016805869207776, 0.37554206864925177, 0.13728428039547014, 0.32911033044282734, 0.14725308407287574, 0.14019120441524358, 0.13500502658416313, 0.13770054375045948, 0.12185186754470001, 0.14593961135139832, 0.13136978960842083, 0.13965414639152607, 0.1215369135286195, 0.8652440123245001, 0.9373596806085631, 0.9245664402358527, 0.9062544133805083, 0.9132045278582476, 0.8674681122528969, 0.9639598833581405, 0.8235073402079155, 0.9375338638300437, 0.37388397102548576, 0.19196209568927247, 0.32268078741221184, 0.1905597197617518, 0.3356231744582977, 0.19495470997754782, 0.2324967861516205, 0.3486464718265635, 0.3163118820625892, 0.8265444239918112, 0.8496717156646129, 0.3790412538914213, 0.8558467399624606, 0.8415027021593803, 0.3659267703411314, 0.8581676837187397, 0.8474167192887954, 0.8246141294232966, 0.21309687585185444, 0.12967805545896494, 0.14438585960619932, 0.1606967423223825, 0.16178929318380886, 0.6893082843006375, 0.1686011540052157, 0.221743079630077, 0.18591894507161233, 0.138119308839889, 0.12535596761404655, 0.1263783342310535, 0.14637513715484418, 0.18069540066038914, 0.17254494525549524, 0.1328357325333318, 0.1347841691156193, 0.13629282137888754, 0.03639324307215974, 0.1935275367269359, 0.08262312011740325, 0.056112172652350134, 0.1837697691318383, 0.10915235749542429, 0.29755504166295565, 0.19332283132749895, 0.08902557436652425, 0.36508980048662576, 0.24160062915995784, 0.2961150154199972, 0.20393166197335277, 0.12059330680008573, 0.2930659908531996, 0.34015017765866873, 0.3858871133247175, 0.2563161457506876, 0.15595848566362203, 0.09985923291217003, 0.0937259475506369, 0.20282035879646343, 0.2848971484026003, 0.17101229720897448, 0.16008126998811045, 0.13308756722882242, 0.18450863723280042, 0.1729312180741841, 0.27410632521636347, 0.25335884998691105, 0.39861159869359064, 0.27619843432972413, 0.23567741016157195, 0.20069395903062037, 0.3362744919671864, 0.18447743734145317, 0.6217002158844109, 0.6408214940387847, 0.6139314259367146, 0.6530684127130115, 0.5438445404954884, 0.4885162555339819, 0.6633299518642329, 0.6093836572120711, 0.5807630410222657, 0.17119648349434646, 0.15849390053980494, 0.13146595969604713, 0.14806421290804994, 0.1433141611217037, 0.10640205003794034, 0.1291393963601104, 0.15759849825745154, 0.14246143788044885, 0.25446473689106364, 0.1757115009378225, 0.24190331843802748, 0.3805846968758103, 0.2221554546597564, 0.27673684942062693, 0.22271532987704967, 0.19751871083733497, 0.17614235974110926, 0.5360208050596176, 0.40596495500710206, 0.49499268435143984, 0.48649066682823017, 0.33149214602728705, 0.4474976910433105, 0.5708580458829275, 0.5020596789720362, 0.5431739615783546, 0.33860980854284994, 0.244334662623239, 0.3488310862066827, 0.3696866923283537, 0.412564069120837, 0.3943366228590056, 0.35687684096388594, 0.34757628300945675, 0.37973771922286004, 0.20433146003128233, 0.20989109579092735, 0.2179798584331707, 0.19123100641794433, 0.21493499641912972, 0.2069196707522969, 0.20758498816630244, 0.22827474393857006, 0.21072628368897028, 0.21222158500717436, 0.5303090665355734, 0.3530583620660849, 0.23311612564099704, 0.23214117611900675, 0.22673757694050323, 0.6643710251248555, 0.23502130384897402, 0.6669713281378535, 0.1663738995690175, 0.18127982451860103, 0.17940354475881726, 0.17534027962322507, 0.16236191871349126, 0.16608750898857083, 0.18576787416259033, 0.1965169338222631, 0.8477494112105355, 0.20505269001162818, 0.2388906164341177, 0.12473985417118838, 0.20156286355614128, 0.3489603367620171, 0.19432927940024292, 0.20128627450811276, 0.20684781147490106, 0.20847520584317947, 0.19180216927229077, 0.1960290103515936, 0.1946123010248464, 0.18622002185528697, 0.17972183737494785, 0.19851427929253374, 0.18221173918580869, 0.20459744813994074, 0.18371824151424243, 0.0824617600779548, 0.08199851931714908, 0.09618719730714198, 0.08841717003347804, 0.08579725717022668, 0.07719938442052643, 0.09173019479540256, 0.08789146082457044, 0.08768975872278129]}, "mutation_prompt": null}
{"id": "567d6750-ee50-45aa-be22-9b28ad1bd7f7", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        noise = np.random.normal(loc=1.0, scale=0.2, size=self.dim) # Multiplicative noise\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment * noise\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.5)) # more aggressive resizing\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Multiplicative Noise and Adaptive Population Resizing for Enhanced Diversity and Robustness in Differential Evolution.", "configspace": "", "generation": 68, "fitness": 0.3552318029034943, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8158801631909733, 0.8133307078504699, 0.8237806812456149, 0.8175895538354935, 0.8237295808674819, 0.830785819467328, 0.8204461204967484, 0.8224083584196262, 0.819283036280559, 0.6697924111836395, 0.703310897620812, 0.6838164005484013, 0.688781541130299, 0.6886815888647175, 0.7039894461982374, 0.6742238734725554, 0.6787400325605861, 0.6952422828510809, 0.11829969721907707, 0.13633986971354184, 0.16920776113919533, 0.12738723714958178, 0.13689693470425424, 0.19996117538589675, 0.16592829055727, 0.13538265081822032, 0.1198162048122402, 0.12057098912344077, 0.12630844501511018, 0.11237539933256013, 0.11619959765726984, 0.1363556260990466, 0.1342927868991719, 0.11968113576830497, 0.15028719395416557, 0.10879829732649415, 0.892242431917966, 0.865118715754134, 0.8982917653128646, 0.870372064988534, 0.8147458973055137, 0.8655270800605981, 0.8132985334822733, 0.9323579834671754, 0.9236990305672428, 0.46009938882925516, 0.46970463932763906, 0.49456522310227213, 0.42689563394672014, 0.35788252715071145, 0.5102633756572112, 0.5725521018209732, 0.551797841002575, 0.4386915196858471, 0.8301314841875663, 0.8210256084175436, 0.8201829324790226, 0.8258945925151697, 0.8066735263830119, 0.8168189716229471, 0.792233848956165, 0.8143146354617489, 0.8094593417775175, 0.23969182697354963, 0.18938376024513193, 0.18604842821566026, 0.15218908397326214, 0.20023081116388552, 0.23640722749125553, 0.17610601078410326, 0.2795949077015285, 0.16494980707816753, 0.19080400647810458, 0.20724830651703652, 0.18517101609909692, 0.18918662043301637, 0.24899172528890057, 0.2545764778804239, 0.1842835052729036, 0.1891288486332935, 0.4596220041803053, 0.07160858128111103, 0.13925641637890962, 0.08837224530897803, 0.11673458539028347, 0.1173155102963217, 0.10259184361332663, 0.1007685175221319, 0.05997071015908406, 0.09602382404715204, 0.12528298652984615, 0.14043649893966048, 0.12067356069001633, 0.13069699090227294, 0.13520366759043068, 0.11205531263857049, 0.1008043066138693, 0.12407877301911086, 0.14399753998987386, 0.16892190539876706, 0.07339880711672486, 0.050790909718682054, 0.12771133842668791, 0.17796719512183212, 0.08999538609967161, 0.14458728705914092, 0.1046422240751883, 0.21629108226571236, 0.23415863896226652, 0.2507156527934975, 0.2486143294415757, 0.2584042706197268, 0.24843113161868702, 0.2372978896876582, 0.27743940383637955, 0.2606874447984444, 0.24226367622955336, 0.5938803870288598, 0.5778190805109553, 0.6131311876422383, 0.5927531640832421, 0.6006906204100795, 0.5863423444563082, 0.6234029434729467, 0.6466414664667177, 0.6501357800627794, 0.11391957857943691, 0.1245232863990916, 0.1078932599222393, 0.11842540141842561, 0.13825590899489382, 0.11072829341411927, 0.14031810896663266, 0.12147559857214507, 0.11791528229563575, 0.20219945077487944, 0.17869231887539738, 0.15571417298498869, 0.23492301846987662, 0.1949443405327662, 0.13437979679968926, 0.20402553096594234, 0.23882077519883993, 0.2262894550903568, 0.507491741829789, 0.5468823573684306, 0.5416344756858911, 0.49316602236043117, 0.5846779685239782, 0.51249997178397, 0.5699480365129557, 0.6326016623673314, 0.51566973800956, 0.4199576645900164, 0.4166859992442663, 0.2884903540050977, 0.442433615673697, 0.2851476880397953, 0.3795597393193162, 0.3542693097699736, 0.42487785804213496, 0.41927706068025516, 0.2007718105218621, 0.21459575885601656, 0.19736782758594407, 0.20852380814941185, 0.21763240983980958, 0.19975660066085632, 0.1905726917427477, 0.18743257922755563, 0.18784762646936481, 0.4132815924308324, 0.22796379505609632, 0.3913832717780601, 0.22434194300835397, 0.2132908084888141, 0.3831468164225904, 0.3204520236082815, 0.3490554111741945, 0.21650362237505738, 0.1783017850284332, 0.20684755764380447, 0.20342856380258445, 0.7066901048240517, 0.19512364875179222, 0.7715826908467537, 0.1661834157524259, 0.8132172475624986, 0.7757447168690845, 0.8402190695454663, 0.2059654939171398, 0.7417190723354183, 0.3312144499031048, 0.6215995059245019, 0.16386755458171287, 0.20905446234384306, 0.7723960499303024, 0.30440362470688886, 0.1844543291659151, 0.176250630869212, 0.18363581198002432, 0.19608840981351905, 0.18520230005383653, 0.18562045435162555, 0.18047645737289986, 0.18236631192327113, 0.1876779448623912, 0.07542514401327516, 0.09317550547432307, 0.07909965684472942, 0.08135778127261872, 0.0861024826836363, 0.08239898045270999, 0.08923285747092524, 0.0934779019724179, 0.07848793618498207]}, "mutation_prompt": null}
{"id": "eb54c03d-44b6-48d9-a9d1-1bfa6fd16be0", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        feedback = np.var(self.fitness) / (np.mean(self.fitness) + 1e-9)  # Feedback-driven mutation\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn()) * feedback  # Dynamic scaling with feedback\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            reduction_factor = min(0.7, max(0.3, np.mean(self.success_mem[-10:])))\n            self.pop_size = max(10, int(self.pop_size * reduction_factor))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Control and Feedback-Driven Mutation for Improved Performance in Differential Evolution.", "configspace": "", "generation": 69, "fitness": 0.26282327996998206, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.30.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8317346825407416, 0.8237613827947641, 0.8249682922834616, 0.818827517189267, 0.8180374442596735, 0.8240246952278676, 0.8261060718510257, 0.8245550683800426, 0.8192761141077838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.135876220174584, 0.12768467504204362, 0.1405233105030197, 0.10997217283513072, 0.13131481474795215, 0.11549975046098093, 0.13193618373177518, 0.11367191329994042, 0.1608928751800237, 0.08944255461300166, 0.06819713834045904, 0.0875490847071444, 0.11104874209327698, 0.10745495325200827, 0.10327622835514516, 0.11302107873866285, 0.0967753885818784, 0.09113652667632888, 0.9914098786825166, 0.9753517752052409, 0.9711606728663881, 0.8859514272795643, 0.9330399821172902, 0.8824543976516663, 0.9479890312744388, 0.9200641224079715, 0.9669729015661539, 0.2935147841515585, 0.1548841155656161, 0.0574919613339111, 0.2004083445982624, 0.3890545325801561, 0.3416005499713527, 9.999999999998899e-05, 0.1426821573185887, 0.07751687555702824, 0.7991686638609935, 0.8019305164225304, 0.7762432194886444, 0.7717601143245774, 0.8319647426094531, 0.8036536544913798, 0.7727908556302072, 0.8093176051773368, 0.7672358627862491, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050326876840001145, 9.999999999998899e-05, 0.02440223253530016, 9.999999999998899e-05, 0.03138767767749284, 0.011919593185914512, 9.999999999998899e-05, 9.999999999998899e-05, 0.007949064138644046, 0.09105787155718648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06824684766945888, 9.999999999998899e-05, 0.06848231993567955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03369849985859108, 0.032650688994408705, 9.999999999998899e-05, 0.00900896987972466, 0.005747821833869238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006130968116012991, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.3030114142156989, 0.31710662044938587, 0.22056156798012094, 0.18986563306062143, 0.12329167947472197, 0.13516709469867216, 0.018317900585272273, 0.015690727612260535, 0.013690299269463635, 0.7330751880007267, 0.7624073404025596, 0.7431271212031691, 0.5795156430681486, 0.7503689814087251, 0.6762485809504433, 0.7598584833026774, 0.74662985500525, 0.7464173857674041, 0.11368491080165222, 0.10152869547091847, 0.11167791326559018, 0.10729542010302251, 0.10121259664675308, 0.10890971786232673, 0.058773452665846215, 0.1139265303712016, 0.09101975887029334, 0.16402269538797387, 0.17761340308618345, 0.22092482313740258, 0.16244567116445907, 0.1325671520934798, 0.13865506674435712, 0.19571808782596245, 0.24957660644116153, 0.15776991495622095, 0.5085555840978262, 0.45488685875661117, 0.46940108560779603, 0.4897014584183764, 0.5246100187067101, 0.5445170478521006, 0.5296844156164968, 0.554805906642055, 0.5165178165715272, 0.3324308253714141, 0.38029371860190875, 0.314077330285485, 0.4481724086680613, 0.40443972362617986, 0.3090291720467232, 0.4463708084120376, 0.4121817157165074, 0.46240432036141044, 0.1896479566887722, 0.19498517257283188, 0.20930818041768928, 0.21238552638878405, 0.20837404433952, 0.19875602133080128, 0.2237472420566532, 0.20837004502750833, 0.20120562818764842, 0.09140562263166996, 0.022114252350373453, 0.006802284145258963, 0.037029490036274204, 0.05014810575435735, 0.034701085919828456, 0.031991397175432756, 0.011357641588223721, 0.06922185869385156, 0.7734600702447895, 0.18539108920712055, 0.16732322353427698, 0.8086047520260015, 0.19386570122911062, 0.19555371560149637, 0.18533441831765396, 0.5660063167324123, 0.74904004170841, 0.8207169686889433, 0.5760943935154279, 0.1650913455365377, 0.2071339018434568, 0.16388638292056878, 0.24477190695532336, 0.20043072744727852, 0.20293588759972503, 0.2014333999224075, 0.18858696602835312, 0.17913921031859192, 0.1922686323409466, 0.1801075011088038, 0.1872140400141934, 0.1847663702287463, 0.1746968789490433, 0.18224610479451486, 0.17792284123520818, 0.08388019061913843, 0.08324037959753972, 0.09428076270213404, 0.07930416704621457, 0.08337437479738674, 0.08642858836626766, 0.0838049053832528, 0.08407919273160946, 0.0800145522550656]}, "mutation_prompt": null}
{"id": "0a81143d-2e97-4022-b253-5af35650c2eb", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 40))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.diversity_threshold = 1e-5\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.memory_size = 5\n        self.memory_index = 0\n        self.memory_F = np.full(self.memory_size, self.initial_mutation_factor)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        F = self.memory_F[self.memory_index]\n        mutant = self.population[r1] + F * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n        self.memory_F[self.memory_index] = self.mutation_factor_adjustment[idx]\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (np.sum(self.success_mem[-10:]) / 10))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhanced AdaptiveDE with Memory-Based Parameter Adjustment and Diversity Promotion for Improved Convergence.", "configspace": "", "generation": 70, "fitness": 0.4066378763672869, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8023278115509517, 0.8289580882689328, 0.8144386000025489, 0.8173869201331158, 0.8207657569009492, 0.8338001226693106, 0.8121510621801503, 0.8156705394283426, 0.8269815628377415, 0.7009285832642709, 0.6940987231304967, 0.668990090279211, 0.6817611464318829, 0.6855552833131223, 0.7115889070082936, 0.6798364042216241, 0.6867219186967957, 0.6597636665829336, 0.15172610953689036, 0.16185399545911971, 0.17949306918225283, 0.13635341803642165, 0.18047997770147517, 0.14596186751956286, 0.15584770519282487, 0.16508221570700155, 0.13043181255315672, 0.12616861087953202, 0.12517823327238142, 0.13709128337425902, 0.13787483985453897, 0.12568795988729486, 0.1490378212194915, 0.1337377947502475, 0.13211767635738836, 0.11920693246643843, 0.8597481506958129, 0.9423910154082241, 0.8183461499799163, 0.9301818612066657, 0.9065852487017285, 0.9257733642505561, 0.9630211777291545, 0.9115573018503262, 0.809538799867207, 0.5150266970634022, 0.5183673988031305, 0.5240808883031646, 0.30573970289938557, 0.29939205930707125, 0.40628904305223446, 0.4753664644165997, 0.5750641385277213, 0.5039526243840444, 0.7804897652129058, 0.8441449692281483, 0.8294856191421581, 0.8160960257997615, 0.21568264625671174, 0.8273659771762693, 0.8155620112520143, 0.8374156095749146, 0.8178068965684452, 0.15374087513951162, 0.20158659783580202, 0.16761715396224208, 0.49049705764283313, 0.22500285132864395, 0.21013889776429517, 0.1640362131592088, 0.1678243873679086, 0.1682426437297483, 0.13439938155113818, 0.11616010169316726, 0.21847433399772054, 0.18168018844779843, 0.18862583862807547, 0.17464596335426374, 0.2505638886169781, 0.1697275466204774, 0.22086815971352758, 0.5832278661172079, 0.5232831905387736, 0.3744208120072994, 0.5867582764828947, 0.3285462927230933, 0.11619428009654897, 0.586852133005642, 0.5949466085563456, 0.4520552696055449, 0.6589467346212425, 0.673637964807001, 0.6442893267664767, 0.320090666069046, 0.550751404037416, 0.6599923537254349, 0.6818233681404186, 0.6832379363093475, 0.6643194823460883, 0.1674147278648741, 0.1860862956559881, 0.13166524063577068, 0.1593638938815638, 0.308457752024625, 0.15323723701352632, 0.25426034486502, 0.25151435538956246, 0.16902277453743686, 0.35324950493471086, 0.44380605663602213, 0.448389667225494, 0.3848309229378799, 0.38232495881041406, 0.441912672801797, 0.4196011355137199, 0.43626646942104863, 0.4717913227821037, 0.7665446924362861, 0.7644472655519903, 0.7507766613712293, 0.6626664179179093, 0.7643121677291056, 0.7736191043642168, 0.7709847395271322, 0.7753170180781837, 0.762569765807749, 0.11751699139604699, 0.1089000861385484, 0.11708412483633224, 0.09989585570690995, 0.13557484254009322, 0.10758640580770784, 0.13138233569322033, 0.13366951034896823, 0.1012588374765997, 0.2559668947045701, 0.14790664270350917, 0.1991489615595743, 0.17512922250968055, 0.20809130182611568, 0.14915321318288788, 0.2924496247749122, 0.22467097253604296, 0.1788702547200175, 0.5001985698756605, 0.5123051722831868, 0.5523260165232626, 0.4935190255547399, 0.5148964770716427, 0.5297635783921877, 0.5025965615684349, 0.5437713203941135, 0.5953590525435705, 0.37895155450379425, 0.4004500055679149, 0.4461156253417615, 0.43482491558428527, 0.48028402946033644, 0.39002649528091293, 0.46701683755678347, 0.4550050942056696, 0.439299374120264, 0.19372156249410544, 0.21719464241858522, 0.2109818946488703, 0.201901573737727, 0.20250073628860832, 0.19786091696653207, 0.214586073227356, 0.2004036318519583, 0.21600362559859776, 0.4872232657570412, 0.33823659220101443, 0.4781431302291568, 0.3212328415359339, 0.46308585571780225, 0.20945923364831998, 0.5193460760735933, 0.40145341626873565, 0.3444479044926363, 0.17106718300277957, 0.19875012686065419, 0.8155610806415149, 0.8589883584822775, 0.1711905855124234, 0.8281066499353471, 0.1832310352272125, 0.7183386582946834, 0.17019304174325467, 0.8153802287927832, 0.2084332684508997, 0.8171305088361355, 0.20583110270300986, 0.2037287039550948, 0.20707578248807257, 0.2106515006909262, 0.7416917465399724, 0.20689948929878232, 0.1790503497777548, 0.20755589152066345, 0.18308589488436855, 0.18235663159896598, 0.17791755578027768, 0.17888772556820964, 0.17759467892589342, 0.17734269428768035, 0.18204320591679157, 0.08682366492674409, 0.08366093434021171, 0.08475766988842803, 0.08581201575422093, 0.09466375367095392, 0.07966523398739334, 0.08421613682973383, 0.0794280824093303, 0.08675403763053169]}, "mutation_prompt": null}
{"id": "da3e4fbb-0cf1-434c-b4bd-f181424964a8", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 40))  # Adjusted initial population size\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial.copy()\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        return self.best_solution\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Elitist Strategy and Adaptive Population Size for Improved Balance between Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 71, "fitness": 0.40793673176278006, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "2d555f39-64b5-4f71-b2cb-f2a3b58558c1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(15 * dim, max(25, budget // 40)) # Adjusted pop size\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.85 # Modified initial factor\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * self.initial_mutation_factor\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * np.random.uniform(0.7, 1.2) # Adjusted scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= np.random.uniform(1.05, 1.15) # Random adjustment\n        else:\n            self.mutation_factor_adjustment[idx] *= np.random.uniform(0.85, 0.95)\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(0.9, 0.07) # Slightly modified crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.evaluations > self.budget * 0.5:\n            self.pop_size = max(10, int(self.pop_size * 0.8))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-15:] # Longer memory\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Adaptive Population and Fitness-based Memory for Improved Convergence.", "configspace": "", "generation": 72, "fitness": 0.31012164009293897, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.695964357259022, 0.6296667053110789, 0.6928929529737521, 0.6968616452659475, 0.697761043817904, 0.7016924318506588, 0.6972800454432027, 0.6507824614492419, 0.7020624954047315, 0.44055513447152495, 0.4346960760888722, 0.40841808039886873, 0.49922905698942044, 0.42585852396598267, 0.5285433699352493, 0.49318768764690935, 0.39575840490405, 0.3638839642561811, 0.12150397019451031, 0.12546383658910853, 0.12357073908218952, 0.12600168296400738, 0.11285299622811507, 0.12982967740623663, 0.12931288963448473, 0.10499537297483452, 0.1393166981006867, 0.0906473592932302, 0.10693105464983788, 0.1289313209515851, 0.10024375815830444, 0.10450510655046763, 0.10881650287868871, 0.11038915025059215, 0.11630160693873937, 0.10558738507783183, 0.9057598452338934, 0.9583258182376233, 0.9318008605981895, 0.8989183828800973, 0.9826518843475499, 0.7983958460719314, 0.9573323912649889, 0.9712069756404417, 0.9157544887299982, 0.3044364141966168, 0.29469909555955376, 0.30617207202988583, 0.2794924907709827, 0.36844283322448823, 0.3632893213289088, 0.3357536538930517, 0.3412836922196132, 0.34061474169868744, 0.6943956984054898, 0.6835322756688353, 0.6806893131363982, 0.6679776976540619, 0.7105734392849374, 0.6497959660072137, 0.6709220494108623, 0.6551865032696769, 0.7106761688414183, 0.1752699838895735, 0.1548518729013405, 0.17176148850606332, 0.16378308411884102, 0.17302297415402335, 0.21477249271832755, 0.17816675072649502, 0.18350485627507274, 0.20449401065645656, 0.1660121799926657, 0.16829554275346859, 0.15214306225765872, 0.17824743422563638, 0.17221069677042455, 0.19036408246708325, 0.18790644918269872, 0.19344655465748772, 0.17333693612983536, 0.21232613093470487, 0.284869923425936, 0.17705299282789622, 0.20797219237666964, 0.24730812841211514, 0.1844402603821481, 0.2513281016688057, 0.265181922594804, 0.2244565736253743, 0.3554227765360376, 0.3057851512017472, 0.3495548383360978, 0.3992750976050621, 0.2941147013190347, 0.32415181797288295, 0.3965772683278562, 0.4109072831214039, 0.33583489454612614, 0.08583212510751981, 0.07328894055601609, 0.09202782009315302, 0.14648684608830442, 0.09876563979222441, 0.06959434564005829, 0.16224669999538532, 0.11416652989986886, 0.10456174000386254, 0.2500170459307185, 0.2085943924131326, 0.22039028484354894, 0.19599497987679027, 0.2350459039315832, 0.226705544092613, 0.2725880098054856, 0.25875995764988047, 0.24475448596188576, 0.5534857915811497, 0.5610072817425513, 0.5285679169608415, 0.5502633651479576, 0.5622036589683825, 0.5160751416931355, 0.5449207551110857, 0.5387968661079551, 0.6023905967245127, 0.10253762247729759, 0.11018480076451542, 0.10428009039624775, 0.10074428982702344, 0.10277534655647758, 0.10020059595438857, 0.094808615230633, 0.10491514390129764, 0.12435582901942221, 0.1823770650377542, 0.16627900306277466, 0.18399509443731943, 0.1385146328810951, 0.16886421001698382, 0.15241214338586484, 0.14614357062184535, 0.1430419799593099, 0.13382833996714782, 0.33333377654359986, 0.3167409505522034, 0.44534510672643546, 0.3486022635448063, 0.34378387018449574, 0.3812263178882942, 0.37522837664918984, 0.32036401033772455, 0.43670205038655474, 0.27415278679566035, 0.2512501283221078, 0.27818428331782474, 0.31161755569822613, 0.23918040619043746, 0.2790285025673257, 0.27915933671307147, 0.28930022043792236, 0.292029195711068, 0.20192064821389955, 0.18707894037767325, 0.19199415704774603, 0.1877915429799576, 0.21373491143293288, 0.2029418765566141, 0.21267949457350332, 0.21707733280717945, 0.20915381480277084, 0.2090967753575479, 0.18142342668447486, 0.18319602073040997, 0.1773710771587681, 0.18324064738335544, 0.189394500756509, 0.18087069465365258, 0.19711224607273847, 0.195288723078893, 0.3393918720283038, 0.18604037594833522, 0.28462473409256894, 0.6225840182564322, 0.17805890167627436, 0.5555998818782975, 0.49385285396868484, 0.616470204432441, 0.3539453911433966, 0.1957602787446423, 0.1965178713970197, 0.18793353256987033, 0.23064153670181997, 0.6585738590060839, 0.6842006944014354, 0.20418644274643027, 0.6556789416778835, 0.20197617600078088, 0.1914371001512234, 0.1884812627966247, 0.17836183484709833, 0.1736141007197557, 0.1874304332684007, 0.17996935989020946, 0.1940439637090351, 0.19231256416816245, 0.18494733541041597, 0.07619437620061364, 0.07842878662119146, 0.08027897138289719, 0.08216478689518159, 0.0826487662802714, 0.09063964164980665, 0.0825446781421848, 0.08255298328472782, 0.07327276697444918]}, "mutation_prompt": null}
{"id": "e3f6e8cf-20c2-45e5-a955-5554c88487c4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, dim)) * 0.1  # Initialize velocities for PSO\n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.pop_size, np.inf)\n        self.global_best = None\n        self.global_best_fitness = np.inf\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n                if self.fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best[i] = self.population[i]\n                    self.personal_best_fitness[i] = self.fitness[i]\n                if self.fitness[i] < self.global_best_fitness:\n                    self.global_best = self.population[i]\n                    self.global_best_fitness = self.fitness[i]\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def pso_update(self):\n        inertia_weight = 0.5\n        cognitive = 1.5\n        social = 1.5\n        for i in range(self.pop_size):\n            inertia = inertia_weight * self.velocity[i]\n            cognitive_velocity = cognitive * np.random.rand() * (self.personal_best[i] - self.population[i])\n            social_velocity = social * np.random.rand() * (self.global_best - self.population[i])\n            self.velocity[i] = inertia + cognitive_velocity + social_velocity\n            self.population[i] += self.velocity[i]\n            self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.personal_best = self.personal_best[:self.pop_size]\n            self.personal_best_fitness = self.personal_best_fitness[:self.pop_size]\n            self.velocity = self.velocity[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n            self.pso_update()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "HybridDEPSO", "description": "Introducing a strategic blending of evolutionary and swarm intelligence techniques to enhance differential evolutions adaptability and performance.", "configspace": "", "generation": 73, "fitness": 0.11687209249256869, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.2740201585100377, 0.18909990184172398, 0.24653924560423335, 0.1786049053177019, 0.2030008080128055, 0.2024662708670666, 0.20027632327539413, 0.20429980835682449, 0.1603964554810675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06140618079359483, 0.061873558983262744, 0.04948534792104564, 0.054780679041399494, 0.06612242703620996, 0.06030848661833388, 0.050496005052551696, 0.06251322309115126, 0.07482101465645263, 0.041605660062259076, 0.04940626857823627, 0.04051706092147356, 0.07400082814586162, 0.04116204277765301, 0.042163092732954155, 0.0491987871759999, 0.04435846045874936, 0.03469691880213399, 0.9871220750506068, 0.15281682433015686, 0.8956243616810389, 0.11371293702993612, 0.12190540243706038, 0.12261031232667752, 0.2003926423208019, 0.15289819212871558, 0.11430300017830797, 0.17561276969823414, 0.08901670065530021, 0.07857939102202449, 0.10017897629493111, 0.08023614419015646, 0.08384283649325441, 0.11941189778187089, 0.06936454538564085, 0.10740955051882395, 0.22554682602540266, 0.19381505265016685, 0.16361242820621702, 0.17676679085740343, 0.1891460990807764, 0.14899870858246522, 0.10710677859753526, 0.17551246352492578, 0.12726306843577273, 0.07063555173678249, 0.023479905643682852, 0.0015015252479242402, 0.0209118003102996, 0.061841026877909266, 9.999999999998899e-05, 0.06465534460920352, 0.024370031108868706, 0.05398936398994758, 0.07911487114155102, 0.009420225841332508, 0.03373686491813588, 0.06510111698812093, 0.030112888022648665, 0.028187204856116255, 0.09011037542767497, 0.025220401375574353, 0.060227483583964014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09277546103665135, 0.05131208320589298, 0.08950142987044019, 0.058201555199203336, 0.05793610912872049, 0.042028740076434756, 0.0800540843894596, 0.06262313469550973, 0.047837639115507535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008583620229093314, 0.011506896228153485, 0.002113994884575421, 9.999999999998899e-05, 9.999999999998899e-05, 0.007385088236298687, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014081378325486726, 0.23301004559282879, 0.24637983020253285, 0.23338065887073267, 0.2057921357141036, 0.2169350272774957, 0.1868603464330627, 0.28185374962516707, 0.23991959254758033, 0.231601556104155, 0.05616303711118231, 0.04070020592388479, 0.057667999327122965, 0.06467515047785544, 0.04120966588673358, 0.06390748251707501, 0.061335882815520715, 0.06993160655243624, 0.06376119826458981, 0.1620866367897268, 0.12991623072574698, 0.15492495674750806, 0.14466797906930517, 0.14673661224353018, 0.1643659286643211, 0.14182126854930976, 0.13352834429328364, 0.19193999006328955, 0.16295043462232206, 0.18038397209998258, 0.20977283237697952, 0.21866159498160032, 0.18473422415079654, 0.172180305517607, 0.2019685559186125, 0.19887961879656957, 0.17911676620910733, 0.13121991987739945, 0.0914130920672378, 0.1346640396294011, 0.1700126553089154, 0.12116523551843517, 0.15314728817778, 0.14008280809571283, 0.1415606353505724, 0.13427878526029835, 0.2788384668512577, 0.1637281469837788, 0.18567588377214128, 0.20147152081258612, 0.18544833850515707, 0.18272374129181768, 0.18104214298156807, 0.17834601922953663, 0.16748131517166676, 0.15848964655100484, 0.16825498981559284, 0.15672101366183455, 0.1673343706772935, 0.16363862026112552, 0.15980444211640388, 0.17116217794398858, 0.15161142203867328, 0.15618771589292357, 0.18499154245855975, 0.14073982470414226, 0.1474659873030718, 0.2795411544142087, 0.17084233775460467, 0.16776622690082332, 0.2056942350265556, 0.14474431685086098, 0.35569778724281154, 0.2756563969709144, 0.1771596105710228, 0.16824204423913947, 0.21036562763701971, 0.20514512961134757, 0.14909767718062916, 0.17378382380403057, 0.18447609704541723, 0.16571167080346239, 0.19697025551517477, 0.1828788341424049, 0.17485802046522125, 0.17522111983271693, 0.19312583208556888, 0.18291411771212884, 0.18765102938559808, 0.1836201516630409, 0.19145471145638926, 0.05252129031332042, 0.06761676387031545, 0.062493078972842286, 0.06428276615189565, 0.06543107559177175, 0.061395865213958345, 0.05120563588140414, 0.06106752245136993, 0.06380590885473048]}, "mutation_prompt": null}
{"id": "1d32e0ed-a689-4a26-b930-30f7db52613a", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        fitness_variance = np.var(self.fitness)\n        dynamic_scaling = 1.0 + np.random.normal(0, 0.2) * fitness_variance\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * dynamic_scaling\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhancing exploration-exploitation balance in AdaptiveDE through diversity preservation and adaptive mutation factor scaling based on fitness variance.", "configspace": "", "generation": 74, "fitness": 0.18275319057745573, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.3982535801893642, 0.423413767888722, 0.5053120437079814, 0.7593699442446831, 0.7361595292504224, 0.7429643381558829, 0.6482694755656988, 0.6528370435135425, 0.6542658134079443, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021300015544682194, 0.015887736330720714, 0.030957000559229675, 0.05246948301532506, 0.030926622116285385, 0.02572884730150038, 0.05886449466870547, 0.03221753462364507, 0.04210439986737713, 0.031205474448786297, 0.0012880576230552832, 0.009078116746075282, 0.05036453884204184, 0.04547288241741465, 0.030043357338077836, 0.03000808894357465, 0.04489019163211472, 0.022971751569956678, 0.990552427880528, 0.9828825240179455, 0.9944544039525283, 0.9922437510899169, 0.9900726140120568, 0.9776132597302185, 0.9948846314210799, 0.9788799694956936, 0.9938975953377814, 0.32408409764853363, 0.02449008259560248, 0.04458842515872763, 0.04966720534551006, 0.12843111262970675, 0.06979553806210448, 0.017999034575766237, 0.049380611901175486, 9.999999999998899e-05, 0.34305347247385687, 0.12158832672132924, 0.3774583867699597, 0.6876535605417736, 0.23098583982512322, 0.37841281400997584, 0.11580869312073594, 0.49631682120657594, 0.030693775037391458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006033081399952067, 9.999999999998899e-05, 9.999999999998899e-05, 0.014128000709153321, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02774097774018902, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005938889718945739, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047007606144577885, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01474360225263771, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015296836484044452, 0.028181040810346558, 9.999999999998899e-05, 0.03361304456204994, 0.6830703314418705, 0.6749951284516656, 0.6765687781687167, 0.652489056558837, 0.6177356524650837, 0.6560027066249082, 0.7098753703588359, 0.6780465114076648, 0.6764688333312475, 0.06610755765909149, 0.056456787155745425, 0.03545568593822046, 0.05161630430118691, 0.03196713619656688, 0.053187363305142954, 0.03014459958880511, 0.021247318949671357, 0.053819714690026554, 0.09332964805333144, 0.14242188624600838, 0.11842175776965747, 0.22060193788642846, 0.41881396292626627, 0.22512668394889945, 0.1653036008220966, 0.22635450969403148, 0.13080909141081098, 0.4179271242556821, 0.37252398163726386, 0.42061412066925863, 0.4287947119791572, 0.3962632162622748, 0.41783089067618717, 0.4438862025224395, 0.4373641477228575, 0.41353804905637026, 0.24942185768579928, 0.18391207869847026, 0.23030071694713128, 0.27136329837999396, 0.16787315097560074, 0.2941565738557763, 0.20658114326671495, 0.2640299321170969, 0.26990143732632077, 0.18662141023123802, 0.19041910928909045, 0.17635328781832582, 0.16862141025650812, 0.19051270181137092, 0.16897538970683235, 0.18463479506495528, 0.1766623965378754, 0.19929618936090232, 0.017336458658845366, 0.005986283612404386, 0.12694503844411864, 0.03965032213667796, 9.999999999998899e-05, 0.09342286971302804, 9.999999999998899e-05, 9.999999999998899e-05, 0.015650514873939425, 0.09911746012738276, 0.0764203203557241, 0.1492492060478775, 0.16483890378744892, 0.17702593131259636, 0.17496016881574195, 0.16002364420022563, 0.16125294490959519, 0.16186212624808471, 0.20709970235096276, 0.12889447294516865, 0.21388969473145214, 0.10716711510469468, 0.13791669081583535, 0.10350036278104757, 0.18352508370836818, 0.17783255674605458, 0.1778306095275768, 0.17619999620046223, 0.1961011844786178, 0.212030854349869, 0.18483292512946714, 0.19124000749063885, 0.18252483469779168, 0.19848957017780133, 0.18505619422576547, 0.19751427859286197, 0.032700738350859515, 0.02951139631720545, 0.044855589131378326, 0.03243103911506462, 0.0464592983537756, 0.041092028922564694, 0.048492495947930925, 0.05352156546218234, 0.03215988126281322]}, "mutation_prompt": null}
{"id": "b865ca1e-62b6-4d53-98fb-1954596583e7", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n    \n    def opposition_based_learning(self):\n        opp_population = self.lower_bound + self.upper_bound - self.population\n        self.population = np.concatenate((self.population, opp_population))\n        self.fitness = np.concatenate((self.fitness, np.full(self.pop_size, np.inf)))\n        self.evaluate_population(func)\n    \n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        self.opposition_based_learning()  # Introduce opposition-based learning\n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Opposition-Based Learning and Adaptive Population Resizing for Enhanced Diversity and Convergence in Differential Evolution.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {}, "mutation_prompt": null}
{"id": "f2fb327c-782b-4ea3-aa24-9f8f75098444", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.diversity_mem = []\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        diversity_factor = self.calculate_diversity()\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        scale_adjustment = 1.0 + (0.3 * np.random.randn())\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        learning_rate = 0.2 if success else 0.1\n        self.mutation_factor_adjustment[idx] += learning_rate * (1 if success else -1)\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def calculate_diversity(self):\n        mean_pos = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_pos, axis=1))\n        self.diversity_mem.append(diversity)\n        return diversity\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n\n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhanced Dynamic Adaptation in Differential Evolution with Improved Diversity and Learning Mechanisms.", "configspace": "", "generation": 76, "fitness": 0.3692898426060617, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.23.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.7128218271046194, 0.7081839616608625, 0.7114574429653711, 0.7122542966219085, 0.7107804415790204, 0.720476115583166, 0.7137437598083112, 0.7454616933749318, 0.7204543540813058, 0.4744337766812744, 0.475192685938717, 0.4826145295490466, 0.49717437307062784, 0.4882713088251186, 0.48736936881998716, 0.48795666660048365, 0.49734306122189964, 0.4936068364560565, 0.10736403050949106, 0.11405126293363754, 0.12313499189088051, 0.11132060391062548, 0.11282545722444193, 0.10144839818901452, 0.10938855064948094, 0.1297674044452951, 0.12041646820986684, 0.09775868439458668, 0.11199612743770071, 0.10835360465065191, 0.10362386524242517, 0.15152979186686588, 0.0994620617226567, 0.10514605844286473, 0.09803262547650815, 0.11676469461553429, 0.9850529421680703, 0.9696034674175829, 0.9659865212786564, 0.9658709895547649, 0.9368363282225853, 0.9711342326437628, 0.9546531787960236, 0.9488303690499204, 0.9841260061661744, 0.44702104261397757, 0.4511672799217682, 0.38943721822371535, 0.4254742331216933, 0.4090912993404723, 0.4320135955091323, 0.42010608551124173, 0.43259712546289475, 0.4542409504889505, 0.7339459317844296, 0.7442393456719401, 0.6982951821037928, 0.7352597545051793, 0.765686049607604, 0.7405711163036919, 0.7002519427698448, 0.6755140598256578, 0.7382335023760781, 0.3782523652222516, 0.32074107996883827, 0.3574252701389503, 0.31480811703660694, 0.30975136104648626, 0.36043463871091297, 0.2096566342352617, 0.2062630499903121, 0.4274045565955562, 0.41438821669071835, 0.3077804054851826, 0.4714236210357665, 0.42098750184101896, 0.3180747237421593, 0.338457804234893, 0.3913756567925375, 0.2538617049007609, 0.4122853985288605, 0.4123950468758427, 0.3831932862030506, 0.39369335091184077, 0.38413120512006904, 0.4164071952816891, 0.38308058371643794, 0.3727434886532276, 0.3681457088617024, 0.3624276806553578, 0.4997491981330987, 0.5174623431710632, 0.5152519340390708, 0.49791799432098005, 0.5616771433468299, 0.519860077510699, 0.5564895655072858, 0.5215406352153215, 0.5475322870197179, 0.15573272538193428, 0.07970218590709266, 0.19041936520147185, 0.21514922197238662, 0.1574949411400457, 0.24650630087678926, 0.16313332824682492, 0.10371196367546343, 0.11159742540231166, 0.28752885336652056, 0.27905285715790173, 0.26285709716166505, 0.26739089619253575, 0.2750807196458118, 0.28902510452815366, 0.29135194549747667, 0.2758591748334793, 0.2819661374142697, 0.6527414755970429, 0.6542982950342808, 0.6401063110982689, 0.6396291784153796, 0.6687986598360054, 0.6653033149206793, 0.6266177651903689, 0.6459850955615825, 0.6347934583172543, 0.10966950928401475, 0.18484616376530927, 0.12209727436982654, 0.09503200216759122, 0.10835409327948986, 0.09961738518500873, 0.09999992856500417, 0.17462369016294232, 0.1163828297374706, 0.20429201843193023, 0.15670814943538314, 0.18188389909256142, 0.19661451448123712, 0.2074857604408198, 0.14874506991297332, 0.18502507516712108, 0.2692315546195291, 0.17287399162450168, 0.4205522797945125, 0.40000478480844837, 0.42395563263680147, 0.4050832475740713, 0.3764059531286057, 0.4230329928490454, 0.40537150769436103, 0.41966377513890285, 0.4069567459348282, 0.3084695835377065, 0.29432626663382566, 0.33216574281362277, 0.3047392014024164, 0.32653412054147846, 0.3166006753626779, 0.3475304029311911, 0.35852997693265454, 0.32772568251535494, 0.21295528849474255, 0.1852162940936133, 0.21612295052645203, 0.20055951031031405, 0.1877653054669408, 0.20453661988070782, 0.19387548665909704, 0.18255550288882094, 0.19278257692666656, 0.18411030390972005, 0.29557501528530106, 0.19167715923798478, 0.20267364314604752, 0.19052674913068512, 0.19194816995901132, 0.34644490015185325, 0.3614291992648475, 0.27346071272718986, 0.6607746763512828, 0.7179970539355919, 0.15125248498580623, 0.18186354305753616, 0.19915239009905894, 0.18932084232606072, 0.6839312400046975, 0.6100740426390177, 0.708878587108805, 0.7089314612436585, 0.6326465322477974, 0.7005961332454796, 0.1634567799475911, 0.1964593883553417, 0.712278101387077, 0.20348355885618608, 0.20700854370437305, 0.20593874544470858, 0.17462112904442095, 0.1878328588954422, 0.18072716707217806, 0.18124216747457145, 0.16708355018399856, 0.2057234029148367, 0.1758486148836158, 0.17974023062147315, 0.1992652935122291, 0.07642521978340122, 0.07970826497057804, 0.08704930846219594, 0.07782576549307374, 0.08171178429964399, 0.07540464544235781, 0.07873838436831992, 0.06958416958899238, 0.08255751043651838]}, "mutation_prompt": null}
{"id": "921bb3e2-5ef2-4b91-8edd-628c192ab5f3", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "a589ef43-2dcf-4173-bd5c-818d7f52a298", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        success_rate = np.mean(self.success_mem[-10:]) if self.success_mem else 0.5\n        mutation_factor = 0.9 * success_rate + 0.5 * self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.6, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.2\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.8\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.clip(np.random.normal(self.crossover_rate, 0.1), 0.4, 1.0)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        factor = 0.7 + 0.3 * (self.evaluations / self.budget)\n        new_size = max(10, int(self.pop_size * factor))\n        if new_size < self.pop_size:\n            self.pop_size = new_size\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Size Scaling and Enhanced Memory Utilization for Improved Performance in Adaptive Differential Evolution.", "configspace": "", "generation": 78, "fitness": 0.19548203991355284, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.43898056083758386, 0.2675047685713994, 0.5467499584739094, 0.5200403151891767, 0.4101176644430937, 0.49605006138558405, 0.38482962551197175, 0.24112952018739442, 0.5135597908450353, 0.3391151930080659, 0.13098203497269822, 0.10573977769678, 9.999999999998899e-05, 0.021209515604227125, 9.999999999998899e-05, 0.34642446095499513, 0.16315094827645737, 9.999999999998899e-05, 0.06419940945001612, 0.11302441491449533, 0.14807377780904696, 0.1213558426931366, 0.11833298317899132, 0.14785065357166427, 0.11800149021397355, 0.16437405256432835, 0.147705405082023, 0.09793958226689115, 0.0974285002175066, 0.10189854657305952, 0.112565177940678, 0.11217474216407153, 0.027784712801280143, 0.11800938158451701, 0.09749647417088403, 0.06388817977589789, 0.9595998282110301, 0.9468461947747021, 0.9853778010758037, 0.9692352261863473, 0.949980567786712, 0.9713904934282211, 0.943170392596274, 0.9716557015977529, 0.9789648347209333, 0.11590480666386915, 0.09738540155163844, 0.07841137482988547, 0.23530773611571565, 0.41888366441893254, 0.24593397873147405, 0.3686561789439049, 0.1720236862028549, 0.09692174804279818, 0.18613789554141402, 0.3179050392131747, 0.10273597082209074, 0.11373487076386957, 0.07285119553694963, 0.1799231509252368, 0.14997964664379904, 0.1787622439661387, 0.1750922706966408, 0.14502605915137246, 0.13189810610813224, 0.13210449769805221, 0.12964709092707039, 0.16370824145740903, 0.16537883207878878, 0.13177667111469493, 0.0864934310841542, 0.15653767655509632, 0.0048953247063538985, 0.09656742675107366, 0.13126640315746207, 0.12991827725850236, 0.12497055970988002, 0.19088598814273616, 0.026502144138887185, 9.999999999998899e-05, 0.24678763918934088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040021214141884975, 9.999999999998899e-05, 9.999999999998899e-05, 0.0853064848055839, 9.999999999998899e-05, 9.999999999998899e-05, 0.03440797292521147, 0.046850366498444096, 0.08222381870854822, 0.047924330074263555, 0.014437830220619619, 0.0319489435396646, 0.06266468450223783, 0.1328220084556555, 0.06176524823106122, 0.00517787871561981, 0.10775734991534269, 0.07087377929044614, 0.16390932269987624, 0.30095319315357905, 0.12774471783002916, 0.22245442257541426, 0.13226770017919975, 9.999999999998899e-05, 0.05562382122241505, 0.08813435448394247, 0.13855518642816167, 0.05609668867995876, 9.999999999998899e-05, 0.09328170858571316, 0.08589706627989124, 0.1284840933116984, 9.999999999998899e-05, 0.4557895326496627, 0.4289219692229772, 0.39826399168822246, 0.2480421907067164, 0.22559913119645247, 0.4214855013674894, 0.42786761539252227, 0.4492000733166237, 0.38270554364215215, 0.06448307409757903, 0.08220522798741203, 0.10918641040926536, 0.07492417216530045, 0.13732924931028467, 0.09312877815051945, 0.07967574601188876, 0.10518148852169529, 0.11147980759720433, 0.1515482924921061, 0.1369906103348285, 0.14326293503376342, 0.13716242339629825, 0.15464894780778016, 0.11651673970779286, 0.1692763102207525, 0.1608482845285495, 0.12983114224080583, 0.23469530682008288, 0.2321983021985593, 0.1691189392511957, 0.19412546007516096, 0.1994529816426771, 0.18281435021663406, 0.16948837555951557, 0.23084190204903898, 0.19999078703316586, 0.17387232706151223, 0.22720903677881388, 0.09983785008976032, 0.17996205941578558, 0.13379705242618367, 0.13877287393304427, 0.19743563430955002, 0.2589969641914779, 0.10389729553248417, 0.2311720036132262, 0.22721778540806892, 0.2334057775901861, 0.29467085668669446, 0.1932728260558788, 0.30139463087032137, 0.2700405315570865, 0.27342478226375044, 0.2002478960816103, 0.2106977218869357, 0.18921660405709895, 0.18296309449641812, 0.19907978547144978, 0.18631422907812967, 0.19049730346201732, 0.18918250175310258, 0.18923886417665947, 0.18677754873384766, 0.1731307275179328, 0.1878200783923667, 0.16592257879034555, 0.1723166369169552, 0.19991411215262145, 0.17817340058968456, 0.3695417466081321, 0.1869464888778556, 0.19578640167870753, 0.2306946144565849, 0.16998846302541137, 0.16890860078293257, 0.20422944029692502, 0.1688009451071506, 0.20781610257464878, 0.10423016800818319, 0.12459493376176467, 0.11194192645229328, 0.2009292468136723, 0.18825389134974546, 0.1715329407446119, 0.22997312548610094, 0.21329904730555527, 0.181425282195522, 0.19246881080681477, 0.19453105510919633, 0.20570626602876196, 0.09280295191237764, 0.04948239236847218, 0.08237953511787166, 0.08242615151996346, 0.08218924580794906, 0.08862929872422065, 0.08340389124027592, 0.09618819939780243, 0.10305651478177258]}, "mutation_prompt": null}
{"id": "db87dfbe-0d1f-4019-a866-4a1cf7f8267d", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "9e7819f9-16a4-4afe-ab92-a4c0da3f701f", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.gradient_memory = []\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = np.std(self.fitness) / np.mean(self.fitness) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        \n        if self.gradient_memory:\n            grad_based = np.mean(self.gradient_memory, axis=0)\n            mutant = self.population[r1] + mutation_factor * (grad_based + self.population[r2] - self.population[r3]) * scale_adjustment\n        else:\n            mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * scale_adjustment\n        \n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        gradient = (self.fitness[i] - trial_fitness) * (trial - self.population[i])\n                        self.gradient_memory.append(gradient)\n                        if len(self.gradient_memory) > 10:  # Maintain a memory of recent gradients\n                            self.gradient_memory.pop(0)\n\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Diversity Management with Gradient-Based Mutation for Improved Convergence in Differential Evolution.", "configspace": "", "generation": 80, "fitness": 0.10150980600140942, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.17.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.2696171681219187, 0.20868005215394803, 0.24548081349296624, 0.1899347628735535, 0.17381374050628207, 0.1584044718034494, 0.15862549008508509, 0.2980203602978867, 0.14340672925681897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010754135249648078, 0.006592353378601756, 0.008361678284778962, 0.018248263482334326, 0.007792397052521438, 0.02032439645534556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.011929618517360518, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.982101144228999, 0.9869326636050051, 0.9942669557104727, 0.9934314564280649, 0.12862048038738483, 0.11716243981611585, 0.9853273863355961, 0.27704445665050303, 0.9686879421352357, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011367066341531062, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.059824388882108726, 0.06729815308595277, 0.07285119553694963, 0.03336159161846186, 0.028779299948624604, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007819879522246498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002175442058826804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11663350671963268, 0.15756555760738078, 0.18674867299929165, 0.12502402484815012, 0.10274288241579344, 0.09580441870675127, 0.2854340913623231, 0.14953452339168016, 0.17439893370767368, 0.06564362796289136, 0.06144822422387408, 0.02198412468535549, 0.03266886175302153, 0.03184889736706531, 0.01759993274736349, 0.0013248912297382232, 9.999999999998899e-05, 0.0267656688986897, 0.18996956243545682, 0.1888635722771539, 0.12803158907705292, 0.18269863302739653, 0.19997839762623015, 0.2113938687605884, 0.23659268292240854, 0.16847397628697547, 0.20371378375759053, 0.18422718390007964, 0.16453205652468827, 0.20660438822866123, 0.16590705456589672, 0.19297249626755142, 0.17821691968440878, 0.177801092465653, 0.19531078127873946, 0.13310755918500905, 0.07999071386168632, 0.05898296706609385, 0.08398582550377798, 0.15386252902435915, 0.1512253580100723, 0.15913699921943003, 0.10035780741085165, 0.13248603359479405, 0.11235033492269342, 0.19999777966463983, 0.21844332239308195, 0.22233427800299954, 0.2158684345830607, 0.23235923225160182, 0.20131439771212423, 0.25917524977096096, 0.2280320874496744, 0.23537877685716435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.166858190450887, 0.1805996307439064, 0.11812810478445646, 0.10830377705471605, 0.1567831662099436, 0.14265187054729445, 0.17555365399051537, 0.14839096270004393, 0.13998978051044453, 0.11994509126354258, 0.24236588799916114, 0.07323180437258525, 0.09302253660747317, 0.1049714148569807, 0.15475845854634496, 0.06701345937237568, 0.11182414565788534, 0.07047583595420237, 0.1883790417887039, 0.18492367940244103, 0.1735288900401023, 0.18812588981104028, 0.18826391634555073, 0.18448480079544383, 0.22739571724363983, 0.22794575816409302, 0.22667684583725545, 0.08403845648527553, 0.08844694390109142, 0.0818789618231811, 0.0818770267355996, 0.08197745609667817, 0.08808496057386872, 0.0753122886143659, 0.06689385020629401, 0.08076649787319912]}, "mutation_prompt": null}
{"id": "d6ebd6df-3507-4661-bc5d-24c86addc942", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "532b1314-b82e-4f65-a294-20d9add296e3", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(15 * dim, max(30, budget // 40))  # Adjusted initial population size\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.7  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        strategy_choice = np.random.rand()\n        if strategy_choice < 0.5:  # Adding strategy choice\n            mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3])\n        else:\n            mutant = self.population[idx] + mutation_factor * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.2  # Adjusted scaling factor\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.85  # Adjusted decrease factor\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.15 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.3 * self.budget:  # Adjusted threshold for population size reduction\n            self.pop_size = max(15, int(self.pop_size * 0.65))  # Adjusted reduction scale\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhancing Differential Evolution with Adaptive Population Rescaling and Dynamic Strategy Selection for Robust Performance.", "configspace": "", "generation": 82, "fitness": 0.255398849251726, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.6054179232251553, 0.6127591292863368, 0.6076342713136271, 0.60502584908881, 0.6145818147966006, 0.6024389899306667, 0.5866951596526493, 0.6157595345524339, 0.6020323024048746, 0.371268376367055, 0.3755815701990558, 0.37632248114505196, 0.3633974117798138, 0.3746234405507822, 0.38561814822020823, 0.3543257081426159, 0.35392337974199495, 0.3549276466149306, 0.10195589154597218, 0.11630456122232735, 0.11657315650700928, 0.1183712925973156, 0.10257968541290208, 0.1088823513111753, 0.14001096325635376, 0.10361194188603406, 0.11338700242938393, 0.10093696732626356, 0.0988331356538753, 0.11798546664964449, 0.09244696544178277, 0.09971737428161198, 0.09306886552988358, 0.09703995414641176, 0.10216089690338082, 0.10609056300787145, 0.9260930734264523, 0.9444116720498608, 0.9491024806225163, 0.934248377172956, 0.9222944278835302, 0.9160092162123457, 0.9542527900591239, 0.9292626088562412, 0.944201346517544, 0.29912421204354, 0.29440320082852256, 0.3060768836552763, 0.29340059544655295, 0.2864061708313699, 0.30759556387694365, 0.26509267415940074, 0.286423667007331, 0.31020478083361014, 0.4505188910654344, 0.46354410654611167, 0.42456264640848684, 0.4567146494042338, 0.5344574791858621, 0.46758363338517206, 0.4567979107037563, 0.4453500263931186, 0.45252960439146095, 0.1539246384624965, 0.1930589329026765, 0.13739652431885752, 0.1380713287822546, 0.2057515196396983, 0.1529215399872743, 0.18658585048860155, 0.16469079578867918, 0.16121630046595037, 0.13545960634186982, 0.1325262055905172, 0.14622058971619423, 0.17182123226638846, 0.16770097572425524, 0.189070998677782, 0.12291646708371196, 0.168560367778111, 0.14494217838796197, 0.10777527131267672, 0.10056564873828377, 0.08211056698965258, 0.081127723667765, 0.08668837411123442, 0.053131303041891065, 0.1035859844541579, 0.08699363778254432, 0.09073185165092523, 0.21227246496713936, 0.14975233119352183, 0.19381568080614897, 0.1673823907330425, 0.19351354437318447, 0.21612789664180787, 0.19748633479118427, 0.2668854707729599, 0.22999546019352535, 0.04663740610784484, 0.031823837624372575, 0.03214021005271972, 0.03758449945501707, 0.05114196236698787, 0.047811158099732354, 0.052124183461739415, 0.02960005682574607, 0.056084707412682455, 0.13594976753867616, 0.13230981632397665, 0.1391753334348792, 0.15410934567877832, 0.16050570972837686, 0.15297262760445662, 0.13408482036228253, 0.1285206201839827, 0.14158201921206381, 0.4798890487196026, 0.4794219885228317, 0.49576763866974194, 0.4729329122608692, 0.4855793348836288, 0.49770932185713157, 0.4598023264413681, 0.47821581869563656, 0.47385797903380933, 0.08954385248940178, 0.100659717557528, 0.09574372833650635, 0.0839527641827501, 0.09850123998153504, 0.0854821853835569, 0.10050759097960293, 0.08599978547813703, 0.08588678882648837, 0.17667488144131316, 0.14574220868425036, 0.14077164078246185, 0.1576401434002206, 0.14240437388613847, 0.1436184895652174, 0.1431570516550501, 0.14635517820783484, 0.14366219691755033, 0.29780705637305604, 0.304122057483072, 0.27812831558838147, 0.29421141158527786, 0.30334373986456964, 0.30067904536211265, 0.30680420599075964, 0.32306782692975244, 0.30765623967172684, 0.21965425038316988, 0.21970775093102113, 0.2214105752494755, 0.21455172362882735, 0.2120485033863141, 0.2143173704724326, 0.240618659143072, 0.230840537869494, 0.2214725581537489, 0.17701194558514366, 0.1835734344244574, 0.20436470581397193, 0.1891862018345043, 0.22670184737069587, 0.1830070346105538, 0.1828971774949526, 0.18390591942037815, 0.18308056874284706, 0.1781699728474343, 0.19304599293297198, 0.18964463098569717, 0.18670290127729372, 0.19120684360155837, 0.2171339082247613, 0.2338093541867251, 0.21216372333931655, 0.1874914184597768, 0.3626959072953655, 0.16418585758358784, 0.3558354494830476, 0.3950663054393907, 0.2448033266112185, 0.3448298255249722, 0.4620419386671205, 0.16869563232042495, 0.266661475802473, 0.31458508302861043, 0.17025095003695145, 0.23784371527492576, 0.2309771500534158, 0.20960392476056466, 0.18478878005623833, 0.4571977607242901, 0.2862612580095264, 0.22534500395941193, 0.18835570891539544, 0.17588606284173747, 0.1865764845376826, 0.17399140426918036, 0.18613733561495527, 0.1763588856767614, 0.18465650624145513, 0.19185855195841872, 0.19049436741260872, 0.07284669326949011, 0.07099253554398688, 0.07581479306914896, 0.06873650809230636, 0.0737818318265212, 0.0694201425949792, 0.06833605654055497, 0.08282037901932693, 0.07450931906944902]}, "mutation_prompt": null}
{"id": "9a327155-c9cb-45d7-be5c-17069e686ee5", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.elite_size = max(1, self.pop_size // 10)\n        self.elite_archive = np.empty((0, dim))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = np.clip(1.0 + (0.2 * np.random.randn()), 0.7, 1.3)  # Adjusted dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def update_elite_archive(self):\n        elite_indices = np.argsort(self.fitness)[:self.elite_size]\n        elite_candidates = self.population[elite_indices]\n        self.elite_archive = np.vstack((self.elite_archive, elite_candidates))\n        self.elite_archive = np.unique(self.elite_archive, axis=0)[:self.elite_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            self.update_elite_archive()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedDE", "description": "Enhanced Differential Evolution with Adaptive Learning and Elite Reserve Mechanism for Improved Convergence on Noiseless Functions.", "configspace": "", "generation": 83, "fitness": 0.4048920119296404, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.817268537360945, 0.8210120985951577, 0.821392867051125, 0.8095962146819216, 0.8095578096172867, 0.83223696533936, 0.8072089423979776, 0.8202938047180371, 0.8305611277644839, 0.6952867535857736, 0.6815982428477476, 0.7169817828505631, 0.6974922705913884, 0.6962012749712232, 0.6886942452702591, 0.6915833720066829, 0.6812100098027587, 0.6737356148377058, 0.21393210415989894, 0.17511884795225563, 0.1753330489760505, 0.2615543798110671, 0.21877198809284326, 0.13868717974734535, 0.1529568013200031, 0.16001881578520316, 0.13337440509814136, 0.12451922792918535, 0.1325804483401164, 0.14028020136101282, 0.13631529461827507, 0.13045969497152687, 0.13021709712137486, 0.11538647947346636, 0.12192141484097807, 0.14009847269573694, 0.9548027120912915, 0.9186059598371248, 0.8848080421083173, 0.9638520696113724, 0.9547289258856655, 0.8846721021231885, 0.9532013386347478, 0.9497555186443932, 0.912809839763297, 0.6104532333233536, 0.42620038310169506, 0.511534083035195, 0.48892219220466615, 0.547940947745633, 0.44563895133224696, 0.3860229326362773, 0.3330392101777173, 0.5120545221116293, 0.8249015240473101, 0.84374900174655, 0.8262361540830768, 0.8599724418555179, 0.8228679476017144, 0.8380601265911206, 0.8363114611524555, 0.8280353150599442, 0.8307264586876408, 0.19060549994174814, 0.1669021888458263, 0.14311048736790322, 0.20719248312806227, 0.2244108939743762, 0.16619951807164057, 0.21970080129046132, 0.2238691298063884, 0.2124551022188339, 0.6214946263851636, 0.2082469597485057, 0.20043075271271205, 0.175342306617979, 0.16690807970981913, 0.20064435889580434, 0.22292826124507414, 0.17105464003414506, 0.12684888362952296, 0.6265216422107055, 0.13349732406835157, 0.5882288202073488, 0.6206336150405567, 0.34836498164622065, 0.42763225896317925, 0.5316704414560226, 0.6065043592544461, 0.3570611965016153, 0.612928978578954, 0.3396034943189711, 0.6180028215169926, 0.7008646114974193, 0.51721586366023, 0.6621574461688413, 0.7208367343176032, 0.6748739551128148, 0.3232972239130937, 0.17391876187414634, 0.07294122225374444, 0.09391514287243607, 0.24406980572927006, 0.23950556715965576, 0.20341630652822806, 0.16963180975730852, 0.13140100673143662, 0.21230328951441535, 0.34844751979964705, 0.4488911473806282, 0.27068568485835165, 0.38737259944950597, 0.4226182847463362, 0.4483692281563778, 0.3779886234535358, 0.45121630804291557, 0.3926736954315284, 0.7452043256059069, 0.7518493736711608, 0.7697741522049465, 0.6788778095970098, 0.7691655790158665, 0.7724063188916621, 0.7871067386261663, 0.7221511623244883, 0.6038075510424328, 0.10048681015111638, 0.11893140151703951, 0.10581279375230512, 0.14201772635582988, 0.11463131597154441, 0.1186838729477806, 0.12832426115364182, 0.13908179808382415, 0.11028453852304232, 0.14843896678634005, 0.1626444300012574, 0.16772768604924682, 0.1814123942174054, 0.17630820014630166, 0.28541060698521237, 0.16835993572530972, 0.15568060571869624, 0.1590004948629763, 0.520346946814787, 0.5554700254817915, 0.538005944943398, 0.517741004116365, 0.5266812401005547, 0.5103461491853196, 0.5532268343980431, 0.5900111790537041, 0.5321266706948207, 0.40985875350203427, 0.42809916655625535, 0.4193576705704729, 0.40351818584373333, 0.4078543924416763, 0.38282947878830687, 0.41496900825473515, 0.46189818901682433, 0.4438784478429836, 0.1991368559185397, 0.1914365795944546, 0.19817650276749244, 0.21024330769195443, 0.19757054291243792, 0.19681373996146578, 0.18527862331979117, 0.19769633526423402, 0.21785487045355234, 0.42144455313025486, 0.19800504456406032, 0.4752196850882603, 0.42643354480855844, 0.2093294610430203, 0.404557754127322, 0.2212507023523832, 0.20800490109042857, 0.22152685853464926, 0.8085885875604368, 0.1818989793591116, 0.7422269793479473, 0.647226832758445, 0.7838517275222712, 0.1922306415629107, 0.18325498797746598, 0.18089410660199, 0.6486637377037284, 0.7644877595490112, 0.20765971203675382, 0.1646437160070835, 0.20553993315704433, 0.43677170618095074, 0.4382816793582731, 0.40015335855568634, 0.20596054460050106, 0.42791867283640284, 0.21612911012810276, 0.19411352709141239, 0.17918687394956812, 0.18298283485850098, 0.1816593952212896, 0.21630340771911882, 0.19470999303633962, 0.1852645831384574, 0.19695037876294597, 0.07918688023888076, 0.07967142608570921, 0.07327256200071464, 0.08268303041925118, 0.08688809762636707, 0.07704331586936242, 0.08048946498634091, 0.08048188701479508, 0.07867616824715984]}, "mutation_prompt": null}
{"id": "9dd04f60-028d-4697-ac9b-49cb90990f8a", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.scale_memory = np.ones(self.pop_size) * 0.2\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_factor = self.scale_memory[idx]\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * (1.0 + scale_factor)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n            self.scale_memory[idx] *= 1.05\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n            self.scale_memory[idx] *= 0.95\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n        self.scale_memory[idx] = np.clip(self.scale_memory[idx], 0.1, 0.5)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)  # Use dynamic crossover rate\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n            self.scale_memory = self.scale_memory[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Memory-based Mutation and Adaptive Population Resizing to Balance Exploration and Exploitation.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDE' object has no attribute 'dynamic_crossover_rate'\").", "error": "AttributeError(\"'AdaptiveDE' object has no attribute 'dynamic_crossover_rate'\")", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {}, "mutation_prompt": null}
{"id": "89003e9d-8e16-4169-9649-9af17d4967ab", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 100))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.mutation_success_map = dict.fromkeys(range(self.pop_size), 1)\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0) * self.mutation_success_map[idx]\n        scale_adjustment = 1.0 + (0.1 * np.random.randn())  # Adjusted dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.2\n            self.mutation_success_map[idx] += 0.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.8\n            self.mutation_success_map[idx] = max(0.5, self.mutation_success_map[idx] - 0.1)\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.05)  # Further adaptive crossover rate\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.15 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.6))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n            self.mutation_success_map = {i: self.mutation_success_map[i] for i in range(self.pop_size)}\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Sizing and Memory-based Mutability Control for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 85, "fitness": 0.3300356391974909, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8542718765066822, 0.829373850663553, 0.8322385378617545, 0.8369621222116231, 0.8296053374418968, 0.8239854624810854, 0.8462392781591839, 0.8220798084586564, 0.8363485462982585, 0.7035516282070882, 0.689288949675527, 0.6988732426105154, 0.7049266269985854, 0.6869463676407459, 0.7073904640194302, 0.6886000185874086, 0.6923446974253127, 0.7245966041160878, 0.15315600365823245, 0.4675296420735543, 0.1623414151759458, 0.17308756669411562, 0.1639355877894626, 0.16428479158304676, 0.527718926205391, 0.4419084070454319, 0.14775325350806323, 0.1630942293583001, 0.1280220360418376, 0.15801184168483617, 0.12074404362814384, 0.12972108432768092, 0.133801174533963, 0.16483038541766382, 0.1460022974123396, 0.13873044448995409, 0.969043307166121, 0.8672710553138239, 0.8789576705624312, 0.9677274463920919, 0.8637025498622815, 0.9315162918106378, 0.9460892253097923, 0.9232326075038179, 0.9629075760201696, 0.3435654542866087, 0.2529664343951803, 0.36339313016111696, 0.35973901588572754, 0.4073268088128158, 0.345051605588798, 0.3138180795921991, 0.18605567247453036, 0.2794788080938563, 0.879454508246091, 0.8392295303993886, 0.220364696157472, 0.8554476368533183, 0.8596522138320983, 0.8517518506694528, 0.8779254299362549, 0.23897054413336072, 0.8556476496476859, 0.1617401377645843, 0.16622686970901046, 0.16867365524684197, 0.1455840107212114, 0.3804444488961106, 0.1744190727772158, 0.1603577567007649, 0.19238118581069996, 0.21427586902390294, 0.12593260490894898, 0.12695339991059773, 0.16878998222461616, 0.16997470637250334, 0.17598256400436507, 0.17952930193154204, 0.16922711097356447, 0.16508472606251312, 0.1618559090986631, 0.15308955443174233, 0.060984696049118825, 0.00510494732491118, 0.23345674827602048, 0.1628761205508168, 9.999999999998899e-05, 0.15079988650826148, 0.21021717760621728, 0.07464636473083941, 0.199237630048416, 0.27693436113787206, 0.20164023010291876, 0.061201089965650546, 0.04645402440056701, 0.06402743973178604, 0.30936103826780403, 0.24123786978012352, 0.1465816556001902, 0.10141396890650156, 0.26789866795899964, 0.3053103874615214, 0.16693102547963812, 0.2611912592912887, 0.09500884712830249, 0.1535754005377361, 0.23732264133548675, 0.13766394849543795, 0.28398881474553417, 0.10570925314245672, 0.15533172298669506, 0.2854651478844976, 0.4568466304751603, 0.16828552939356012, 0.1739788440252158, 0.2493019057069339, 0.1992879440172508, 0.5982424442407599, 0.5263823804518848, 0.6263017954394429, 0.5757917136919517, 0.5394788694895079, 0.5009647127852881, 0.5713477963538994, 0.5604659394460328, 0.5798367731303862, 0.15642163301650402, 0.1497599737832439, 0.12056417647595696, 0.13231250405055073, 0.14433030363360977, 0.11710117038012957, 0.14074842104703422, 0.12379119875869915, 0.11151375062769908, 0.26934159863730134, 0.2081084236983427, 0.42150966161601877, 0.19979309248190846, 0.1977160586313459, 0.1588555315026854, 0.3462554406104551, 0.4670444684151237, 0.20844876456067374, 0.3435421583826046, 0.3333142424201151, 0.48805360337687964, 0.4663618445884473, 0.5339597150371825, 0.47106910456127493, 0.4507031223195921, 0.4820743988146984, 0.5328854015681679, 0.24774795881072686, 0.3086723159953172, 0.271680339669629, 0.3050495945971383, 0.3372855581246854, 0.3285976127847323, 0.26208874587614495, 0.379484830184844, 0.2341226937408275, 0.2148745410934242, 0.21594297266949758, 0.21878768291188422, 0.21833092696149048, 0.2165230311725117, 0.21077011305282112, 0.20067188248876955, 0.21886774357849714, 0.20846957495493557, 0.19676857108259682, 0.21906813614074794, 0.2367865503520894, 0.19163486540947983, 0.23485857308792923, 0.1958524878757325, 0.21051235238070154, 0.2164354560167353, 0.23731575230436852, 0.16991751593281934, 0.18336678775135262, 0.7348060145389839, 0.16968885843643855, 0.19542517386003444, 0.19390021955238124, 0.18687435623661364, 0.18512205543678173, 0.17021575744096573, 0.36757811714513355, 0.43163820899167415, 0.20562518335975477, 0.20617005237730757, 0.20555268310121666, 0.16360707405739572, 0.20778785747780448, 0.36360439500317066, 0.3215565313424219, 0.18277253503288304, 0.17785078859322634, 0.18401653963903497, 0.1869627223879352, 0.18763263406173747, 0.19591761551385356, 0.18011575580737027, 0.18161627268833358, 0.2124778323918629, 0.08674245240010292, 0.08724998403099216, 0.08526053798602296, 0.09184412905489736, 0.08331209948534612, 0.09971579357143379, 0.09922115689372402, 0.08618848890865283, 0.0822914001031062]}, "mutation_prompt": null}
{"id": "0f3ae691-38ad-47c1-a517-21495b0b2aea", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        fitness_factor = np.exp(-np.std(self.fitness) / (np.mean(self.fitness) + 1e-9))\n        mutation_factor = self.mutation_factor_adjustment[idx] * fitness_factor\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.6))  # More aggressive reduction\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Incorporating Fitness-Based Adaptive Mutation and Dynamic Population Management to Enhance Performance in Differential Evolution.", "configspace": "", "generation": 86, "fitness": 0.33807351914088535, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.7965889501991453, 0.7820441097251118, 0.7874547687942497, 0.7728785469931778, 0.7732508131064497, 0.7879957070652928, 0.7668878510251711, 0.791934735069982, 0.7945906412314248, 0.10829178599691769, 0.15908660154729581, 0.26937099920437635, 0.3093041351722329, 0.08401106440281925, 0.09207751303093248, 0.1330128755945098, 0.2549917143482471, 0.10601995752620152, 0.10509338323593842, 0.10525548362521642, 0.11462064479356926, 0.12897331901580678, 0.13533077222596623, 0.1280225193950919, 0.11959260510668301, 0.12195259627889632, 0.15028927467337416, 0.10462128443788443, 0.09242376380801975, 0.09179909234597561, 0.10277282358178763, 0.11022854203000898, 0.11435587219434651, 0.10390658917428297, 0.10782683586727326, 0.11314194528681254, 0.9460945365986055, 0.9461735211692457, 0.9418494649754255, 0.9297537502667269, 0.943310075802825, 0.967763301534112, 0.9007859101941155, 0.8620652549436962, 0.9823341085662403, 0.5204754185417086, 0.5180310096977631, 0.5050844901724216, 0.5503069992914726, 0.4055062137516485, 0.5111512034273744, 0.26980016954958597, 0.10491983134356975, 0.34816011278397774, 0.8008936532173404, 0.7905539418925265, 0.7961760165559965, 0.7935052936891316, 0.8129273271246052, 0.7742377628362036, 0.7903704227556476, 0.8020134310113991, 0.8136481227452048, 0.6099860472527541, 0.23321453649878698, 0.331636749644983, 0.049120951095437015, 9.999999999998899e-05, 0.015232142211035193, 0.4862532102116178, 0.22491094086410457, 0.410090845752323, 0.5542428458835773, 0.6069235479946335, 0.32824457089421544, 0.27519500674779096, 0.4181942539718241, 0.2683082927008118, 0.4670522119841113, 0.35965261451371533, 0.3023485923745026, 0.1546771606134978, 0.07342071460564625, 0.027875532671640446, 0.5583518544159323, 0.3360729546597757, 0.37553793721965034, 0.027116614894355906, 9.999999999998899e-05, 0.0029053105837734128, 0.654815314443995, 0.37975549818171905, 0.6496997531881549, 0.07488207406159741, 0.06115855684286742, 0.06442482177553543, 0.576141050821465, 0.5700012314928837, 0.6048788625897216, 0.02165279041690027, 0.03563538367465047, 0.02805244832955145, 0.02283445162140163, 0.04492533061866455, 0.16432886250679257, 0.19363785547548873, 0.27594786386646764, 0.20212586426490264, 0.36754807614258467, 0.3577849874868282, 0.36389677751666605, 0.07074813632712373, 0.09685064726008641, 0.06247042124986435, 0.021683182197100748, 0.08780671512282956, 0.022159893190551005, 0.6863762684832488, 0.7232440750428492, 0.7363582324060143, 0.7163127488133442, 0.7042982514229399, 0.6908025051364921, 0.7268651936528068, 0.716279707806041, 0.718940309275486, 0.09810503123234304, 0.12302881174610669, 0.10407238142379283, 0.13676692112293454, 0.0925605403413381, 0.10403211816895708, 0.05321678004884778, 0.05683140972377365, 0.06855618740646408, 0.16251880311199163, 0.1619712965171588, 0.1900145129194818, 0.14736616430939742, 0.20480112782739457, 0.1534240067222361, 0.15980102673201435, 0.14089240180253637, 0.20314306696815987, 0.37778839893177285, 0.34684547026706536, 0.40319469955128884, 0.5039264024089012, 0.42941802846153143, 0.41392906740528357, 0.477986450824081, 0.46331970689940427, 0.43708711380389464, 0.12767197526206653, 0.11770860970675201, 0.12757433988549038, 0.35743720561226777, 0.3516038100754424, 0.3453405737421038, 0.3602255297565904, 0.3925420383195406, 0.3978147552110075, 0.1830350330976126, 0.1861883021540095, 0.2003791201135463, 0.20620245013030503, 0.1934370262160401, 0.18356277449265723, 0.19508324884014128, 0.20804236253342046, 0.2036303949646321, 0.15503700402866838, 0.15449557537223046, 0.1769207318760333, 0.37055810290402114, 0.19773143730190867, 0.23518132403217418, 0.44115715469228467, 0.36770051058990694, 0.3422323797975416, 0.1683842552807091, 0.17949827931237328, 0.7623991492370631, 0.3722849373941153, 0.18346098306663206, 0.363007748364539, 0.719163428260054, 0.6449098267974618, 0.7891099044754601, 0.7564927860013766, 0.16581814602279465, 0.631167750069162, 0.7867873087052257, 0.4217783902928608, 0.16492176142252446, 0.19827810632385234, 0.19850529414471607, 0.19220202202515912, 0.1917269015424523, 0.17532406486602325, 0.18366161827949057, 0.17187015061563926, 0.1849504962754871, 0.1810739552835443, 0.19550122273526627, 0.18098679335504475, 0.187901284778909, 0.07871972209566924, 0.07766499363279744, 0.08802475879479044, 0.08041321920484701, 0.08205290942225418, 0.08671481434431794, 0.07712845188288031, 0.08294293110715711, 0.08597902711688454]}, "mutation_prompt": null}
{"id": "a588aea4-d29d-42e3-83c0-caf8e047e17a", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "37a28e3a-2f9a-412d-bed4-78d79cef4ebd", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        diversity_factor = np.std(self.population, axis=0) / 10\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  \n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        mutant += diversity_factor * np.random.randn(self.dim)  # Add diversity\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.05\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.95\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.4, 1.6)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Incorporating a Self-Adaptive Mutation Strategy and Diversity Preservation Mechanism for Improved Performance in Differential Evolution.", "configspace": "", "generation": 88, "fitness": 0.3422793917493553, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8204742166011006, 0.8198382779690068, 0.8239980443379145, 0.8314525171029681, 0.8390951391348089, 0.8216932952506633, 0.8418371171785484, 0.8207192313657734, 0.8121318541752283, 0.6959733637256464, 0.6978971240436733, 0.6976564316429743, 0.6811870609147133, 0.6967768372279959, 0.6927217848390612, 0.6955234292772037, 0.6818019180811103, 0.6831919877732624, 0.14823653390258096, 0.14907245180566164, 0.12528326552933555, 0.2451696771815085, 0.14536228752033697, 0.1838256098125406, 0.12104506292115425, 0.15983743280184026, 0.44167409466609286, 0.1393126367815929, 0.1154059068508484, 0.1169668846677181, 0.1516008022778058, 0.1302073447269353, 0.12687188337731514, 0.11664585528535842, 0.13809176088457753, 0.12536684696620048, 0.9037673965345787, 0.9419770211981919, 0.8996395333659486, 0.8473792917734921, 0.8837784792606366, 0.929546786929047, 0.9454910504420762, 0.828861964030241, 0.8225032847004803, 0.33365022669495736, 0.2186569327483754, 0.4367768972918822, 0.2740420012547736, 0.28876498001462314, 0.37358131099306713, 0.32975671025968545, 0.328797133239184, 0.3674331053742256, 0.8573136460674173, 0.8124566872773024, 0.8149118497095549, 0.8136237146622924, 0.7952207403263649, 0.8153369001302443, 0.8311469074261175, 0.8192555367032511, 0.8338534768920959, 0.15329072691027157, 0.15491425508464585, 0.14156262609849435, 0.18117694832954634, 0.17267297880413213, 0.126123633959622, 0.39974471679348567, 0.15217788490393214, 0.19514114802683336, 0.11815851364642382, 0.2061328189224031, 0.2337604653389188, 0.1543349338663964, 0.2050341955880578, 0.20220164746129654, 0.17541533735467696, 0.13115106080995553, 0.21813378133371053, 0.0522792434365823, 0.08589694108432777, 0.09538206850403586, 0.04320786400014698, 0.02736631143785584, 0.02204484518876193, 0.05098447153104024, 0.039471286201332445, 0.07552823288937893, 0.12476273346016131, 0.11859726072943944, 0.11563143584887803, 0.1262923144011091, 0.0900059003286573, 0.0929958730099304, 0.1267154629786994, 0.13683330808984484, 0.09733297522435347, 0.012311321624959404, 0.05370549633001642, 0.04137532143940048, 0.03314347930458461, 0.013224119427301728, 0.09201746618080198, 0.010909295177564449, 0.011019382018647383, 0.05058166502657424, 0.23648281234427526, 0.21285040513168818, 0.19614781322687036, 0.21760516464794388, 0.253302197336736, 0.23076545343581678, 0.1909084321945168, 0.18870449723797222, 0.1898351032883263, 0.5777567037984284, 0.5719836633747033, 0.5827179643511704, 0.578432062100356, 0.5762314323356786, 0.5887288847528838, 0.6054927471221996, 0.5813486504438008, 0.6286262633239802, 0.11025608905703843, 0.14756295192227553, 0.16784832318522458, 0.1414652149936415, 0.16031513000420528, 0.12547328863333218, 0.11912295402275852, 0.12552083180184814, 0.11354088007076313, 0.15436962139466137, 0.13586310487420505, 0.2787210542774685, 0.19286900425499576, 0.1439254485310525, 0.14935593245789114, 0.20147289785124423, 0.18590415189065224, 0.14243827398814324, 0.5167553398037861, 0.5380871729751924, 0.5221920397573931, 0.5029970053132493, 0.5761499229668476, 0.603034172201339, 0.5197412930207191, 0.5743974318749874, 0.6113284515875036, 0.3502613550147061, 0.3884866527209039, 0.38129217998477927, 0.42180815246122205, 0.29765589359507116, 0.39491416564986925, 0.4765161279835306, 0.46350654324062956, 0.41342835434525815, 0.19986568557004936, 0.21020872785825406, 0.20608092771937658, 0.21352534299713033, 0.20342338329504617, 0.2165611949283347, 0.21124953795056078, 0.1945832886310569, 0.2069405251971561, 0.1979947286028203, 0.5144019550617782, 0.29567450182072663, 0.23374205145168048, 0.21814585518948493, 0.6225495701386277, 0.26932149638214986, 0.5924189716305155, 0.5487498135939353, 0.7293155076093254, 0.1811775363623167, 0.742151750566745, 0.18443041010528116, 0.19432049287074582, 0.801453116117703, 0.18249605646176392, 0.610217211438129, 0.7853405045447897, 0.7789900696176548, 0.24663860667695403, 0.22606234846373008, 0.1976780621033678, 0.30893029701768804, 0.1633310017826045, 0.20990180107067058, 0.20600292770760875, 0.7763914868441308, 0.20821508609963169, 0.17429974257322678, 0.18210727978721275, 0.18147879383408005, 0.18009770408838488, 0.19140287737975248, 0.17669705131637514, 0.19155330654302305, 0.19289168215628727, 0.08304758513174315, 0.08116719253384796, 0.07622658718192632, 0.08082282112057315, 0.08054129387186437, 0.09761009946046761, 0.09035819751827912, 0.09560272999074115, 0.08925090172934402]}, "mutation_prompt": null}
{"id": "dff53d08-5073-4124-92e1-4454968d838a", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Stochastic Adaptive Crossover and Dynamic Scaling for Enhanced Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8274514929416859, 0.8170232613425814, 0.8261903184494281, 0.8086954031232324, 0.8088258089125755, 0.8326761784114809, 0.8157275327915671, 0.8360674262781541, 0.8294135984627516, 0.7191031377139538, 0.6862432996120229, 0.7032071020548478, 0.6788751572841661, 0.696627902185142, 0.695363400424201, 0.6933076562750358, 0.6777528975239109, 0.6752531707650509, 0.14673405764690994, 0.12492400794063818, 0.24588216342148128, 0.1536438628237352, 0.1546431224766659, 0.15400319664556683, 0.3569332848183365, 0.10717596837347754, 0.13217409500952704, 0.1386700241196942, 0.11944015601272462, 0.1267841471658976, 0.1399876811754155, 0.12243667794270185, 0.13222400140951018, 0.14657422133240927, 0.1324205288520226, 0.1384793165978686, 0.954804608019413, 0.9397990042394138, 0.8679801459840453, 0.932675129273145, 0.8198773754932741, 0.8451184482229316, 0.9168915727343102, 0.852172485405864, 0.953095861632712, 0.5805550409524437, 0.5423747450854414, 0.5373498560993373, 0.5347588525445062, 0.5487226682985475, 0.4673094722805303, 0.37284013698135443, 0.5105589936865644, 0.4355689223666037, 0.8035011943468924, 0.8225872559398597, 0.7999519186600292, 0.8430380855824514, 0.8445039331906824, 0.8255608362375473, 0.8483019692149427, 0.829671062798216, 0.8531493181705025, 0.2028936774503467, 0.15510056052765153, 0.24347352832206903, 0.2644245458696769, 0.1965728322847049, 0.17472570983697555, 0.17294991845727092, 0.23745968600877276, 0.2109455318280754, 0.166249960661355, 0.12371888000977449, 0.17807759116194644, 0.18979967288238186, 0.16409568506096872, 0.18071047542049434, 0.19275601213038251, 0.19335791182292084, 0.15896770584556108, 0.4905795632077852, 0.09107527427995643, 0.5344392114287011, 0.5374184332093552, 0.2945631152520748, 0.6022022564795979, 0.5902366886199297, 0.630123751193914, 0.5335291934941118, 0.44205289532812697, 0.44651722679886985, 0.4218646189017906, 0.5050090004297665, 0.17696819668025088, 0.5218563328212616, 0.7069324606699787, 0.46732375887852107, 0.5703314159772257, 0.06629247595390475, 0.16909830517062563, 0.1381140149896961, 0.10279280191694251, 0.23510349320725432, 0.46618352125815377, 0.132272125765738, 0.2675573802892034, 0.1697176071534071, 0.3866631497879711, 0.43766904830289177, 0.4175183194091904, 0.35356128672731835, 0.41630193828337536, 0.4528361488902276, 0.4138346917621549, 0.4065938980707027, 0.2839711685631464, 0.7548181173686801, 0.766117055364421, 0.7643415433600801, 0.691177306225522, 0.7194140621262244, 0.7612428022348853, 0.6388204754562696, 0.7619059392652451, 0.7670483381554908, 0.11375165474188942, 0.10713375607244924, 0.1027437859281699, 0.1081846758758267, 0.13818737052008323, 0.12363546538919379, 0.15361547936075493, 0.11265550679788217, 0.12865433689732197, 0.1507552930148156, 0.15494651814083404, 0.19998177369491232, 0.1794253037611545, 0.3485030233132027, 0.18053149955110692, 0.15280269086335452, 0.2132984049955765, 0.17125562428539487, 0.5282879495062833, 0.5439867656051224, 0.5661575370042007, 0.5482482007308993, 0.5605032120144857, 0.5121862538033872, 0.5313717479600195, 0.5377344059244729, 0.5175393510701685, 0.43754004638186716, 0.4420290427878092, 0.39675075532482473, 0.44994267869936133, 0.46974242737917504, 0.41060719620278285, 0.44613433336520125, 0.4300430087078755, 0.47027805658994737, 0.21549153445296343, 0.19275973661312995, 0.1885990186690516, 0.2118090565206484, 0.21238981288568037, 0.2772212103032563, 0.20200212943144036, 0.19339681655267582, 0.2358389834436696, 0.2127244610230924, 0.47067876387878693, 0.3175165773088171, 0.20680264395964199, 0.20413622543906385, 0.20979307448476436, 0.22037956826484384, 0.20352442688332573, 0.45891432788467845, 0.8088460879595114, 0.20152836754876502, 0.7454731689751586, 0.7446985761060936, 0.771454934250785, 0.8275999460252146, 0.1840358978967237, 0.18077749729371573, 0.8355093000542916, 0.77436011464843, 0.29936880713606506, 0.7587666542829007, 0.20271745857594847, 0.2018920165449798, 0.8212238404644205, 0.3975776325802761, 0.23076655294491866, 0.20363551977231897, 0.18511366021597964, 0.17414496895281195, 0.18553688282233904, 0.17998506038457485, 0.18903254637600553, 0.18228405035496265, 0.19441553276328638, 0.19331702743254353, 0.17443595834238002, 0.09273037005956453, 0.09713043721184877, 0.08661941998412948, 0.0815560908204126, 0.08442824347860856, 0.0838253367084717, 0.09725045217735073, 0.09219289873245251, 0.0830548045717302]}, "mutation_prompt": null}
{"id": "3f110ac7-1ab5-404e-9bdd-7621a9f1d943", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, max(20, budget // 40))  # Adjusted initial population size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.6 + 0.2 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx] * dynamic_factor  # Success-based mutation\n        historical_factor = np.random.uniform(0.6, 1.0)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.2\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.85\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.3 * self.budget:  # Dynamic resizing threshold\n            self.pop_size = max(10, int(self.pop_size * 0.5))  # More aggressive resizing\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Dynamic Population Resizing and Success-Based Mutation for Enhanced Adaptability and Efficiency in Differential Evolution.", "configspace": "", "generation": 90, "fitness": 0.3834951401124795, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8493597297441993, 0.8219750192877531, 0.8360140482107417, 0.834974323101686, 0.8277379691971208, 0.8357856504703345, 0.8341124758364269, 0.8273592116002773, 0.841409221477583, 0.6913379048832218, 0.689964380703465, 0.7074478279419742, 0.6864955134657051, 0.6897865647214554, 0.7289277709707808, 0.6959607345468148, 0.7101319274474774, 0.6899635656528424, 0.20301735701205503, 0.2501257450337043, 0.1978724661306902, 0.13612518499346227, 0.18960203081727012, 0.43186038984094766, 0.443422063847968, 0.15636944125902297, 0.2169259016819618, 0.13600657486989642, 0.13648948534560446, 0.11951231538505658, 0.132285003432848, 0.14224131647698945, 0.16908901682937993, 0.15077801949750447, 0.14212985581302584, 0.1364467102202398, 0.8854132817966531, 0.931531690201711, 0.9446871846696342, 0.8375502821822168, 0.8572190897289669, 0.846774892890736, 0.8871635164899357, 0.9407668078079371, 0.857996317506796, 0.5332339711519061, 0.47192051153086545, 0.49609841553743506, 0.3362889469978324, 0.4409243768404707, 0.45569380792943504, 0.42322371906409384, 0.2909983314129698, 0.336512443076993, 0.8001689666998361, 0.8696562296915011, 0.8805200683287295, 0.8472508785159891, 0.27188265920540633, 0.8043173839811291, 0.8125751955408053, 0.865150199749801, 0.7739062431383998, 0.1286938521504326, 0.23211492736504946, 0.17101977522235734, 0.21749439432498452, 0.19828012005578521, 0.16447508886401663, 0.18541801557991544, 0.7084352381303216, 0.17676422209835363, 0.21923292438564868, 0.1150793451276031, 0.15824094716480708, 0.19071087366123174, 0.27460144046518364, 0.23473290313749962, 0.16720321992309672, 0.1747181747805293, 0.20972978736952996, 0.10909972418817437, 0.18997693487402523, 0.42600301696446763, 0.5928758701350609, 0.292070714722388, 0.0323253647458559, 0.14392677361129058, 0.16348980059677942, 0.34545252713259356, 0.11309670473434141, 0.3718794175431479, 0.4391123681540603, 0.20724117914356632, 0.11215480783256682, 0.2746959025488144, 0.3198627570083502, 0.39402430182358483, 0.3296136870976317, 0.062082308710310063, 0.14557066318863676, 0.09604836359568036, 0.1401338273438949, 0.1804651685812909, 0.20332937140044216, 0.12673655886048507, 0.221582267151465, 0.23035377027524317, 0.39906146575244217, 0.1898410677604726, 0.3058044933731926, 0.2579542069028655, 0.40219942378571294, 0.3438471242908757, 0.45596907798005726, 0.36774690449315994, 0.3701625202959721, 0.6068072994638105, 0.7102113785839397, 0.5694582152477407, 0.5495905458672639, 0.5676251405906798, 0.5767319812971357, 0.596958698171529, 0.6658526350537527, 0.6254240461908118, 0.11318476113394993, 0.14135352127224765, 0.2834869715621132, 0.1372988491395961, 0.11389207149026603, 0.13176224449989127, 0.10792867611974033, 0.1337729521245241, 0.10684641948949569, 0.40465695143558744, 0.421865341997697, 0.42397627552162986, 0.2516224909959096, 0.14432575911979872, 0.21257307634943134, 0.15437935543684667, 0.4793394832642214, 0.5615778305025854, 0.5961645484064655, 0.6006373013182393, 0.5570813453771257, 0.5472333284194919, 0.48722757681020656, 0.5714551442661475, 0.5765099404422871, 0.6283378770761727, 0.604476365569563, 0.3477330483784311, 0.32968395213897006, 0.28885453402434946, 0.23554067568657178, 0.3348507252069407, 0.4120446721586374, 0.4466088378539288, 0.4260804667948249, 0.264785841461885, 0.2119668104119723, 0.1957151965123396, 0.2127247491087051, 0.20270469021936477, 0.1945286026398486, 0.22735875510684755, 0.20793696332191303, 0.2078973227634512, 0.2114908174397625, 0.6810339129603098, 0.4073105070566949, 0.23488431026204093, 0.5510995091978, 0.20936493095789066, 0.21325703542336227, 0.5683848703790261, 0.21564494106023546, 0.23760519979065897, 0.6870214677770307, 0.1849693550770204, 0.7241092134806753, 0.8149063026701013, 0.19451959997403756, 0.8632240544856327, 0.16210474432060784, 0.8097090435417471, 0.8408889465351168, 0.7402801949449089, 0.21139576140410743, 0.300066252741764, 0.21052927298110913, 0.2041514572166686, 0.16570204750467887, 0.2091041669858491, 0.32208745674482697, 0.20568385292113534, 0.20323815309772963, 0.17312995028935096, 0.19642883947136136, 0.178368617643471, 0.16880827733567205, 0.1823432160543964, 0.18608169146520082, 0.18719460563753787, 0.1841526384991602, 0.09448489149202755, 0.08811412978385835, 0.08991664187879977, 0.08704190847559223, 0.09303157452229027, 0.08603893186918321, 0.09928601405217963, 0.0872598068949143, 0.08965509078025535]}, "mutation_prompt": null}
{"id": "545b9ec5-0927-4964-bc2d-ec4a08c27de4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.archive = []\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        mutant = (\n            self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        )\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.05\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.95\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = min(1.0, 0.9 + 0.1 * np.random.randn())\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.3 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.8))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Memory-Based Adaptive Parameters and Informed Sampling to Improve Exploration and Exploitation Balance.", "configspace": "", "generation": 91, "fitness": 0.39596511831355957, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8259707452895737, 0.8085221126725057, 0.840929272844525, 0.8277636603440999, 0.8184620957264607, 0.8220206999570134, 0.8276899920763513, 0.8202995609548798, 0.8200498901464062, 0.6764187380796574, 0.6953615629689135, 0.6895731527726627, 0.6936489552794345, 0.6804475786367605, 0.711692502080253, 0.6876710583773564, 0.6945404655839305, 0.6706023136599328, 0.1418046222079007, 0.15358937382800364, 0.2772620485697165, 0.12091543243128633, 0.15162486806822784, 0.1395672241444581, 0.12399994020916094, 0.13550447536442733, 0.1291191961687873, 0.11856719467426868, 0.13261646110542646, 0.12311797020166959, 0.12094724315751815, 0.13436534243385434, 0.1516001424223048, 0.12248095342332, 0.1163515753780704, 0.13144146867632334, 0.9014677178190456, 0.8785144643086255, 0.9247017564262774, 0.9440829662249111, 0.9543026195887562, 0.8600542072360249, 0.9285528759872125, 0.8513803185082548, 0.9314835872953083, 0.44570861428209363, 0.3919204565497052, 0.4617433407423942, 0.3811068928466309, 0.4427465739316717, 0.367935246184411, 0.46607064896768224, 0.3937204866202012, 0.5003033459593504, 0.8201345351318604, 0.8501919053520124, 0.8317508975605857, 0.8167538844547728, 0.8248486061241055, 0.8166444484960917, 0.8269752896458009, 0.36893809548128087, 0.8364616959109072, 0.2019595015782677, 0.13500925479731918, 0.2726660495577937, 0.27840762490731963, 0.22259604371611386, 0.16320073252715062, 0.626129140391939, 0.5020586344295581, 0.1478570553463936, 0.14074678728996148, 0.41271733554398493, 0.1761620089426157, 0.23280279310962793, 0.14178537145813497, 0.18858703947011046, 0.12933157487389524, 0.4829791776295578, 0.13101142589520043, 0.1344825841381444, 0.42290927441485315, 0.592005245128415, 0.5797638444068763, 0.511704962644624, 0.11763914812156251, 0.5370534547537251, 0.37391833229668725, 0.40375588671293916, 0.5225708738497825, 0.5424462050390388, 0.4945098914375341, 0.45951527488676136, 0.4863649185767409, 0.6404001975478604, 0.686205759912627, 0.6680782031785613, 0.6826455617768992, 0.0955716642287775, 0.114323650994679, 0.18154795536425294, 0.19302793193683432, 0.42438441747333433, 0.24667458593766978, 0.25775839115295207, 0.18623981199046313, 0.15813956069121426, 0.28327006099439545, 0.36222525697049046, 0.4109853140711872, 0.42619970686490827, 0.4462909531275784, 0.34343472594881863, 0.39851771960115134, 0.42017568240948244, 0.34717815001552055, 0.7575981144161676, 0.7703236875920688, 0.7924874042173494, 0.7927023128418826, 0.7652084568558847, 0.6426470592631317, 0.7613759298465501, 0.6918048214186364, 0.6771692867553974, 0.09635075547613492, 0.12434673794908557, 0.11079869785764185, 0.11008270358904315, 0.11941562746359613, 0.12118646914611364, 0.09183938007232251, 0.12230756057566594, 0.11992240812631005, 0.20471052075547536, 0.1659682173146272, 0.1814187350195886, 0.18624431793224272, 0.15212754812206308, 0.21410156597917085, 0.15803830732335022, 0.17627396082551328, 0.14040958370138346, 0.5122741661205709, 0.5412963553721406, 0.5027131950938792, 0.5349220328368491, 0.4987163254676745, 0.4947806231460765, 0.5533047115196263, 0.5617324402261052, 0.5254407060651185, 0.4254923413400139, 0.36510693915302195, 0.43985046724599375, 0.4426459612390993, 0.3948224479318554, 0.39388996576787216, 0.4332428483679289, 0.4398783483255472, 0.42456251848227333, 0.21162850004955824, 0.19420971862605152, 0.20909284322471744, 0.1968653521793895, 0.21081219159593734, 0.21116707193099027, 0.204184847002977, 0.19400162780804253, 0.20874801464373782, 0.21936870368374728, 0.22264456338031513, 0.29915821327045855, 0.45726602582602804, 0.1914016127342657, 0.36217134572636733, 0.21456507739908082, 0.4063977700179857, 0.6014908028033746, 0.16087711542589422, 0.7992572770512513, 0.17841284752790543, 0.16729765290564758, 0.18930403103721227, 0.7247682847364867, 0.17953682431800821, 0.1820085618760484, 0.661276675105066, 0.7505807593102143, 0.20658076694731053, 0.4468477925303016, 0.20293650398858265, 0.19965624002664095, 0.8276306337990896, 0.208240260296927, 0.44361730497892127, 0.12568972437993486, 0.19437604576823275, 0.17845483292501174, 0.1928509050498668, 0.1903372417106991, 0.18638426072832326, 0.1732282070631359, 0.19222703130188834, 0.18390418933405794, 0.18031095685752063, 0.07983444860695077, 0.09138234109010868, 0.08475422556368062, 0.08172266223344138, 0.09363457732923053, 0.09026539126217303, 0.08888785021377332, 0.07589966428324735, 0.07582654451130333]}, "mutation_prompt": null}
{"id": "d8faa7c7-466c-45d3-b53c-1937533ba111", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta *\n                  2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        mutant += self.levy_flight(self.dim)  # Lvy Flight mutation\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)  # Success-based adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Lvy Flight Mutation and Success-Based Adaptive Crossover for Improved Exploration in Differential Evolution.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {}, "mutation_prompt": null}
{"id": "985caf1e-c863-47da-ae2c-220c1f37bfd8", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.adaptive_pop_size_factor = 1.0\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        self.adaptive_pop_size_factor *= 0.95 if self.evaluations < 0.5 * self.budget else 1.05\n        new_pop_size = int(self.initial_pop_size * self.adaptive_pop_size_factor)\n        self.pop_size = np.clip(new_pop_size, 10, self.initial_pop_size)\n        self.population = self.population[:self.pop_size]\n        self.fitness = self.fitness[:self.pop_size]\n        self.trial_successes = self.trial_successes[:self.pop_size]\n        self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-20:]  # Increased memory window\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Introducing Adaptive Population Restructuring and Enhanced Success Memory to Refine Dynamic Exploration and Exploitation in Differential Evolution.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {}, "mutation_prompt": null}
{"id": "c3ac9cb3-1992-47dc-838f-c71b8816956c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.dynamic_pop_size = True\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = 0.5 + 0.3 * np.random.rand()\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n\n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.dynamic_pop_size and self.budget - self.evaluations < 0.3 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced AdaptiveDE with Dynamic Population Size and Memory-Driven Parameter Adjustment for Improved Convergence and Diversity.", "configspace": "", "generation": 94, "fitness": 0.37986459721938076, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.8343561834816066, 0.8361915154221806, 0.8417432905812672, 0.8396177792759454, 0.8292237316639963, 0.8466247613334043, 0.8352839351493584, 0.8389913975948253, 0.8284261849392828, 0.7301776338476581, 0.7078901663160184, 0.6996242537964447, 0.6865635627941409, 0.7191196027358011, 0.7042961701453672, 0.6947819022790981, 0.7105563516108622, 0.6965895578781623, 0.1375430315651851, 0.15630518991219178, 0.14219948524277626, 0.19014379070621468, 0.1469266869540139, 0.14678331357434604, 0.12731580787939023, 0.12222048460832591, 0.3420305133581304, 0.14474780762610095, 0.11132298375260075, 0.12498989043104336, 0.10933792169908318, 0.10762587206807761, 0.1744736008174701, 0.12708295215975973, 0.13666930236987285, 0.13717268596958654, 0.9225260739779625, 0.915195428275043, 0.8579014413364465, 0.8840238264354828, 0.9426859760013171, 0.9598566523282841, 0.8879444803755593, 0.8647427873224521, 0.7843949313778414, 0.3683767012907613, 0.2225055098306925, 0.2806277309725551, 0.411054034344579, 0.30354307798782953, 0.44623786518591835, 0.29725509753632795, 0.2859251414698665, 0.3060292683722159, 0.37045797608383435, 0.8353675010064687, 0.8389570240861148, 0.8717428205363169, 0.8709353253384705, 0.8429300777922282, 0.851556963206935, 0.8546297730769967, 0.8492869763223676, 0.17633343890650555, 0.18095451355005998, 0.17004762605708834, 0.1456618871215154, 0.17226972116273287, 0.1572168604700973, 0.20893545162676297, 0.16955785484731023, 0.24537965139022977, 0.21303879008949422, 0.13781475131299326, 0.1408274091720596, 0.1570682369464268, 0.15977797434420515, 0.20719103340858513, 0.16708231327073086, 0.15870918695509373, 0.16769996531712827, 0.5861800293130075, 0.2212048491586538, 0.18367675229281433, 0.14032064208382578, 0.24090235656522674, 0.11183089252614287, 0.24367794208375082, 0.5089108218388938, 0.4984183426147608, 0.18644376116087746, 0.5450854268678567, 0.671820872566288, 0.23751337950325602, 0.35481366634195377, 0.12909658327275553, 0.5018366946107811, 0.5857519265088291, 0.5971868520044772, 0.17503143725065817, 0.14121942342172444, 0.10541460397646785, 0.16765696689242848, 0.22534783280071047, 0.13442139372945872, 0.40828537834684453, 0.13707719412407093, 0.1529152562204743, 0.35140132355722264, 0.34852928048735843, 0.4562447204250225, 0.3803650364792964, 0.4629305595345419, 0.40740047300149185, 0.46868905424206675, 0.30362553932721725, 0.326397101009103, 0.7824729337376201, 0.7653439114766976, 0.6656545333669001, 0.6397443092158062, 0.7685462384235557, 0.49321049459133126, 0.6869859523861082, 0.7036656854117569, 0.5513628665834247, 0.12020601553605526, 0.11909042599539066, 0.16213706104666414, 0.13254464523281895, 0.10806157540270811, 0.1245013724456554, 0.12139702626873727, 0.1428037976618216, 0.11604977187727106, 0.1849301834963366, 0.30798607434170977, 0.2290439862960848, 0.15502572529658987, 0.1579776269334081, 0.25401776554601885, 0.1549967916323749, 0.21091520132806063, 0.2560986429054204, 0.5452985497144959, 0.45619140896545685, 0.4297534194304654, 0.5529821456094132, 0.5347014135671714, 0.5101409280239291, 0.5805259068645994, 0.5980094577288336, 0.49931577754821665, 0.3853576461642235, 0.4246790427010131, 0.2759275080735959, 0.3755829862158525, 0.44834138813780555, 0.4418926302109809, 0.4462433678305633, 0.42152575637396517, 0.4971351739827583, 0.21296702228287034, 0.2195255039228614, 0.21398145451500572, 0.1979560127618436, 0.1837095237770795, 0.18780222603814922, 0.20847703174732768, 0.2008275773166388, 0.20969882399887985, 0.5059783434764034, 0.5652487625950032, 0.1957857524625185, 0.40531938669324274, 0.2331721276499945, 0.19609626514277712, 0.29594177781756004, 0.43413657800007555, 0.23127395321184918, 0.17011827479221198, 0.7033647324589338, 0.18869737407849174, 0.7946013006178994, 0.8306765415288284, 0.8412587783785092, 0.18543776905610143, 0.16352112713315947, 0.8021877285303027, 0.7894548216428088, 0.7588580444931772, 0.16362882809954715, 0.2077929220499194, 0.20251906157449884, 0.19778762041628228, 0.20728794046441856, 0.20513152513520472, 0.20809843677605855, 0.19450267783159092, 0.18453682479233324, 0.1913016628719727, 0.17745794927955616, 0.1780490433588533, 0.20539722064185684, 0.1821904667105535, 0.18419017451440067, 0.19936199263438037, 0.08599610550728454, 0.09431035863770698, 0.08307882511376086, 0.09160679461339583, 0.09286098118693986, 0.08844258567785546, 0.07696411010153992, 0.07835768166089396, 0.08062067653548599]}, "mutation_prompt": null}
{"id": "22ec6ece-6bb9-47ff-9cd0-d49a939358fd", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.neighborhood_radius = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.7, 1.2, size=self.dim)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn(self.dim))  # Dynamic scaling\n        local_search = np.random.uniform(-self.neighborhood_radius, self.neighborhood_radius, size=self.dim)\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment + local_search\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        memory_factor = np.mean(self.success_mem[-10:]) if self.success_mem else 0\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1 + memory_factor\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Leveraging Adaptive Neighborhood Search and Memory-based Scaling to Enhance Differential Evolution's Adaptability and Convergence.", "configspace": "", "generation": 95, "fitness": 0.22788899432568235, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.42762985944971443, 0.4340289134920027, 0.4299969606887214, 0.43434696084420754, 0.4487105531049592, 0.4385482546481705, 0.44985151227166953, 0.4477271472704798, 0.42190035885425126, 0.06801976043136349, 0.08089730050575761, 0.06255299548594517, 0.07975755266947016, 0.0750580095326745, 0.08459429558017639, 0.09238255250692962, 0.0855098727988296, 0.07767667937676193, 0.09913120702919054, 0.10674584825965283, 0.09135915617592039, 0.0997988527057645, 0.11484814998675352, 0.12319631168141532, 0.10696951659272658, 0.11103932862644161, 0.09741183824207533, 0.0949166217629519, 0.0965478509426313, 0.10456700638937488, 0.09795823764159106, 0.09943394862058375, 0.10582494055435654, 0.0969162673678744, 0.08705899398347117, 0.09877880292822505, 0.9499945292259041, 0.9424220793244009, 0.9697282559500222, 0.9762038768259416, 0.9171158060976512, 0.941044323974352, 0.9757819810900872, 0.9301528715079502, 0.9749360238872989, 0.2784895087688585, 0.25473010234701976, 0.26652975660766987, 0.26348853424610885, 0.2721709687902587, 0.2651103202128101, 0.2597753177906309, 0.2626390212755151, 0.25925747067272864, 0.6288553738797236, 0.5748924646055957, 0.32801377388765185, 0.6022289166968767, 0.6301115447357095, 0.5917164813651927, 0.35895405055238117, 0.5072254424136379, 0.339644969111887, 0.14810585573168356, 0.17548567875980703, 0.16263733542052783, 0.16363679461746472, 0.16083874654644714, 0.16261606258708106, 0.15258135084270108, 0.1747839571061739, 0.15382449600076653, 0.16703975782430192, 0.11127948819988576, 0.12758736720529218, 0.16252100547272208, 0.1475303129077722, 0.16586998569791844, 0.16248116106016952, 0.19183610322609046, 0.15168537226215795, 0.01767763854664195, 0.020615072883480523, 0.0243544050913177, 0.032939584563862034, 0.02349312678124227, 0.06629500112946185, 0.01995389703382411, 0.046130529234536866, 0.016970886074757274, 0.09517298176967137, 0.10999055982533668, 0.08136637420592596, 0.09609295178499522, 0.07160671995771573, 0.061089671799506196, 0.09124383097041755, 0.09097361574190632, 0.10988259555337676, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029901132570788747, 9.999999999998899e-05, 9.999999999998899e-05, 0.002728392888929343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10964271007071225, 0.09942486214714319, 0.10598688062015482, 0.11923005507117612, 0.10333448450013405, 0.11031809369260626, 0.10043178878148462, 0.10216977639560243, 0.10869821453652218, 0.392068640752657, 0.41259301715636487, 0.4044985559027313, 0.4068322588781672, 0.3889836753699347, 0.3899920577512911, 0.41731515266781216, 0.40365033511092263, 0.4027241065509971, 0.09833674933212677, 0.0995856049849333, 0.11588934206489143, 0.09808649191055141, 0.08456934922327841, 0.1070195336032046, 0.11319811583053019, 0.09451231895475065, 0.09148925092633786, 0.16542298946984624, 0.14130544552499724, 0.22282604489604074, 0.1840969435413179, 0.2045763175528985, 0.19992293688101548, 0.3096221374686937, 0.15178543949749268, 0.15243744189408004, 0.27527022909563914, 0.2762038854585118, 0.2910940741941933, 0.29673183364185884, 0.2826756653049751, 0.28413125575025366, 0.2891209346487982, 0.2988317009380925, 0.28796047834392813, 0.21754683507284944, 0.22478364821376495, 0.23350862468382205, 0.22723040243439774, 0.20021008463017098, 0.22791405167291545, 0.22563387224331588, 0.23351484099648023, 0.22257161178363538, 0.23921322203012485, 0.20584813060671436, 0.2062809372075911, 0.1918815948053375, 0.2002690846609526, 0.19593453280218687, 0.20097052550834327, 0.1955110348695318, 0.19723364729511195, 0.21615141322551779, 0.1784873438210498, 0.20649314463266855, 0.21962477460639995, 0.18518949329510437, 0.20163030882074728, 0.1811434030326068, 0.22493077802900197, 0.19297013821498232, 0.6130062454355182, 0.6415672005644656, 0.6203155114541303, 0.5976429055757043, 0.18249481717987592, 0.17931684692064354, 0.17601550257385956, 0.1719495431745921, 0.20088929307206194, 0.16678066397388958, 0.19774983087160203, 0.483106806253942, 0.19846186750758965, 0.18938258840697986, 0.19276795605827501, 0.20516131239078772, 0.20728379971090805, 0.20522405290607404, 0.17802021336826512, 0.17925921034874537, 0.20356884682482168, 0.19442373991485717, 0.18865525884344003, 0.18085346407763758, 0.1744605759709006, 0.18921388513319737, 0.1964887378480451, 0.09152990919879544, 0.0811622155725421, 0.09728374054671474, 0.08054148856513388, 0.07671508144479378, 0.07875403497656785, 0.08494314817926263, 0.07717418592000336, 0.07706867208789858]}, "mutation_prompt": null}
{"id": "f77d768c-c8f0-462d-a1c6-b209d0dbeee8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.3 * np.random.randn())  # More dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.15\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.85\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        memory_factor = np.mean(self.success_mem[-5:]) if self.success_mem else 0\n        return self.crossover_rate * (1 + 0.15 * memory_factor)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)  # Memory-based crossover rate\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.25 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Memory-based Crossover Rate and Adaptive Mutation Factor for Improved Diversity and Convergence.", "configspace": "", "generation": 96, "fitness": 0.4020062816972391, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.818824160545098, 0.8143060215845581, 0.8112507349930534, 0.8143522867605267, 0.8133540172247691, 0.8260209808252015, 0.84223415039216, 0.8471941433743029, 0.8236250435323144, 0.6687201192712033, 0.6819502034485245, 0.6858284427704382, 0.6720327630389175, 0.7021819990646234, 0.7036742309017653, 0.7009184288885282, 0.6935551885142331, 0.6773457346398859, 0.1297339716335515, 0.2932282616254164, 0.14586035649439544, 0.1540340953618401, 0.124721506716437, 0.2399155576194687, 0.1361306756054892, 0.19814614634246752, 0.13317567493958726, 0.1314704874168079, 0.12787510521473544, 0.1336151972560774, 0.200230974040862, 0.1248748344670414, 0.11143392601042523, 0.13372368176169314, 0.14607453430034745, 0.10972449438302667, 0.7196557228546846, 0.957101059833833, 0.76434823169198, 0.8591110010105842, 0.6970659166788385, 0.7346232362112588, 0.711423187336895, 0.7722003928434559, 0.7786846442589149, 0.44625323313039844, 0.31954366680194557, 0.259067751262555, 0.4322204536836386, 0.3572736576780101, 0.3426249959828045, 0.4187603673615756, 0.45905583280364826, 0.48161595965569426, 0.8783136458523515, 0.8380634662738156, 0.8112829794706882, 0.8386789873570261, 0.842101861702282, 0.8329484371695974, 0.828191671241311, 0.8382970035365701, 0.7999075029562931, 0.2595762915593316, 0.12194779323473792, 0.1828491333251363, 0.1267134658201483, 0.16625201558588165, 0.41922263814193195, 0.49675406783876064, 0.16108647086836847, 0.19632131647187034, 0.12683854955059848, 0.1710353313124724, 0.20233965273415, 0.19109343197910866, 0.18022600386454868, 0.1866998572480194, 0.25195213146228057, 0.13416035486044753, 0.21714543559690191, 0.43289395130708996, 0.6878876616192133, 0.6280920692751732, 0.6786370452443533, 0.06965302948383245, 0.20140083520413876, 0.6517209913278713, 0.5536278060407785, 0.17677055032399436, 0.7046447024392, 0.5598173665313443, 0.6913453977233456, 0.601475122562384, 0.45992935817643343, 0.6994606691687169, 0.24220042349540072, 0.7082478008716018, 0.6805990885992276, 0.07068669438613484, 0.1539695219655458, 0.1329106034249884, 0.27026719522822173, 0.25520495610450256, 0.17379823436255415, 0.14461421313607714, 0.14954439774870876, 0.24753211020549515, 0.41592784670256056, 0.4479591786805861, 0.42710029862010745, 0.3033848944781675, 0.5005984818529762, 0.5533370425508115, 0.4890176889813318, 0.2774681667919858, 0.4932398506279566, 0.788435564837355, 0.7778465238086665, 0.7768976890158552, 0.8071962796026091, 0.7768331830392662, 0.8047725530178812, 0.810231903682354, 0.7944887401976031, 0.7725286785605221, 0.14523707640232864, 0.13237774653555767, 0.13222097795788146, 0.1571815438286539, 0.11116616620843944, 0.34281236694715567, 0.12187191881335802, 0.12980794681328423, 0.13248638526498868, 0.1704540756847004, 0.17412723856429624, 0.2035123731749935, 0.15792563872036658, 0.16127214189230032, 0.2207956564504483, 0.31290166434623845, 0.14929433119184232, 0.18488248522768214, 0.4685419679216911, 0.5187329269723442, 0.55733396685405, 0.5565257385879916, 0.5720986097218341, 0.5634617474860864, 0.528432017516422, 0.5260909548848113, 0.5006244056036504, 0.4377220159769807, 0.4377098039014823, 0.4970491623045664, 0.44572801314997235, 0.46103385318209666, 0.4268783866727027, 0.48388148216390625, 0.5098926676624617, 0.5292893809645962, 0.20263557483158212, 0.18691695969715416, 0.2025561473408587, 0.20758721992884954, 0.19844949891806596, 0.21476947550282033, 0.197045578707424, 0.1922702986274527, 0.21461912944213324, 0.21269767410120866, 0.2234032362507038, 0.20157057049384963, 0.23282883695197631, 0.2969726491434007, 0.5499420298659259, 0.2220035740744699, 0.5397807367873575, 0.21950303747315048, 0.17008225289228507, 0.7149568925144374, 0.8465395322434925, 0.7763696158699636, 0.20146244488678744, 0.8284918272193296, 0.7616525060739758, 0.16494741231501808, 0.7938864898158104, 0.6488779659432227, 0.20678092693310868, 0.15402622234235075, 0.19949036119801222, 0.1977653041049353, 0.16746439145677816, 0.20650115268892844, 0.2084650330357376, 0.21064979907251213, 0.19014171553657333, 0.20356229268917392, 0.1822600864279208, 0.20496718937088632, 0.1787346920630476, 0.19711310629367085, 0.19261814894503482, 0.18014137224730786, 0.18978665152873786, 0.09026373536773913, 0.0867476742624349, 0.07672985808122035, 0.08494759622904136, 0.08511840759192657, 0.08055794258814453, 0.08610698013728413, 0.08504583079271655, 0.07703307209351273]}, "mutation_prompt": null}
{"id": "1cca0231-3f74-4a22-a9d6-cb7b064d4963", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(15 * dim, max(25, budget // 40))\n        self.initial_mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * self.initial_mutation_factor\n        self.elite = None\n        self.elite_fitness = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n                if self.fitness[i] < self.elite_fitness:\n                    self.elite_fitness = self.fitness[i]\n                    self.elite = np.copy(self.population[i])\n\n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n\n    def mutate(self, idx, r1, r2, r3):\n        historical_factor = np.random.uniform(0.4, 0.9)\n        mutation_factor = np.random.uniform(0.5, 1.5) * self.mutation_factor_adjustment[idx]\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def dynamic_crossover_rate(self, idx):\n        elite_influence = 0.2 * (self.fitness[idx] - self.elite_fitness) / (abs(self.elite_fitness) + 1e-9)\n        return self.crossover_rate * (1 - elite_influence)\n\n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = self.dynamic_crossover_rate(idx)\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.mutation_factor_adjustment[i] = min(1.5, self.mutation_factor_adjustment[i] * 1.1)\n                    else:\n                        self.success_mem.append(0)\n                        self.mutation_factor_adjustment[i] = max(0.5, self.mutation_factor_adjustment[i] * 0.9)\n\n                    if trial_fitness < self.elite_fitness:\n                        self.elite_fitness = trial_fitness\n                        self.elite = np.copy(trial)\n\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "EnhancedAdaptiveDE", "description": "Enhanced AdaptiveDE with self-adaptive mutation, elite preservation, and dynamic crossover strategies for robust optimization performance.", "configspace": "", "generation": 97, "fitness": 0.2879481503249717, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.746656090322708, 0.7567697525708642, 0.7532300750167844, 0.7692956500519833, 0.7403234352995081, 0.7554200862628828, 0.7676934981234913, 0.753443882748625, 0.767003120768695, 0.4174199526772501, 0.44849713721849416, 0.4495216626526405, 0.4232727683330718, 0.42112518367282237, 0.4475378182539055, 0.42852484211828257, 0.4522956442014323, 0.48640279573995515, 0.11524567780756845, 0.13626839885141362, 0.14332514761485748, 0.1391955980161791, 0.13007562009376927, 0.11343198785109398, 0.1406895385439495, 0.1163552411284351, 0.12291389272988851, 0.10860200632377326, 0.11111401546517041, 0.12116468928177804, 0.10194653945819754, 0.11210740491837479, 0.10304296096590426, 0.1186538722285746, 0.12349977703465975, 0.10128983631651678, 0.8839284907628213, 0.8588975620162771, 0.9171494218790399, 0.7581185215115163, 0.7682602468975824, 0.9147339957521867, 0.8096045493221171, 0.8319554921130539, 0.8135093106785334, 0.290393198885457, 0.25583657538894455, 0.18168883472103947, 0.3121076709594077, 0.2813273315536241, 0.3673572632192129, 0.36070131503442615, 0.29292408685860505, 0.23156113426477132, 0.7069488144338325, 0.7463032578035514, 0.7577695144505409, 0.7695446964885072, 0.7403053976312416, 0.7215753540786901, 0.24940059669008618, 0.374372148736666, 0.3870813142780498, 0.15539515928463477, 0.15477964729345672, 0.18152860130802262, 0.15717272044939767, 0.4038999172580806, 0.3986296569654574, 0.16695242608903538, 0.17846539895726, 0.19097199631040818, 0.11514735325009473, 0.150450961622849, 0.169639074221838, 0.13739734799643688, 0.15543031527341067, 0.18366317876887117, 0.11798718497325167, 0.11174649328236042, 0.12358783659835859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1402184629394484, 0.09731710825549422, 0.10382596732985161, 0.08470912509646189, 0.06803653941964716, 0.06998006489011699, 0.08041022567478906, 0.08324392802555736, 0.07445487149754682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14515311368540684, 0.21006009979835483, 0.20632059059298746, 0.13521266251547326, 0.14507578013195288, 0.12095616495803463, 0.2207331183762551, 0.25018105082141284, 0.25511347158151954, 0.6698203732611676, 0.6692358920425641, 0.6669045256973157, 0.693255299378036, 0.6886554711475503, 0.652704359688425, 0.6805471323610462, 0.6818713169657598, 0.7142888003733391, 0.11857579527859252, 0.12089593649563835, 0.1083014919000801, 0.10516210146534688, 0.0985353739607181, 0.09906498429084476, 0.08845164916060244, 0.11345703717336564, 0.123140866780035, 0.17434813699075624, 0.15278559424975824, 0.15311220530424674, 0.14302643087420097, 0.13660785371878081, 0.1347186310935642, 0.14680861491776853, 0.1623781039668435, 0.18086992720149442, 0.44445923365193996, 0.40121021496754683, 0.42100164150113806, 0.433338824112495, 0.4528187837352362, 0.42595177306016574, 0.47414751668386945, 0.4611381263030442, 0.4448181451900911, 0.2543935842756858, 0.23400212180262203, 0.2547547107781596, 0.3131606032200719, 0.3148366444134505, 0.3053129405629922, 0.3554344529181682, 0.356437071696977, 0.3477936691758726, 0.1935408598838806, 0.21304921987256065, 0.194278263326081, 0.20011311012227406, 0.18854747318687137, 0.1962168256764154, 0.19562529355592573, 0.21944941850292454, 0.20588401995691397, 0.23572237041831634, 0.23060945722703263, 0.24163536570137323, 0.22173604919152512, 0.26945248027535884, 0.1903955569453446, 0.27259098933440595, 0.20375300734329682, 0.19758580155923533, 0.18572113894324105, 0.1761771867021209, 0.7527165466656341, 0.2176679539093167, 0.21576765590325753, 0.16779619038380822, 0.5363898777165288, 0.1720000126342035, 0.6234753554361893, 0.7840165479291314, 0.2012730360192102, 0.2624333693951475, 0.256219032399148, 0.2847310347711802, 0.5747807572305796, 0.20233156367738658, 0.6652572033302306, 0.20631174920880546, 0.19168334398827558, 0.17157387664023305, 0.19141076479287067, 0.18964984962099884, 0.18357636589363868, 0.18601964543731397, 0.18443898471824427, 0.18000789672229134, 0.17693329410534409, 0.07709932594393154, 0.08491705298493712, 0.08796405441429611, 0.08145141640348919, 0.07881389127339922, 0.08483194195467136, 0.0834268785269544, 0.08659720960555839, 0.07625962647838769]}, "mutation_prompt": null}
{"id": "efed92f4-9c41-42d9-afbb-aeecb9d035de", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n    \n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 3, replace=False)\n    \n    def mutate(self, idx, r1, r2, r3):\n        dynamic_factor = 0.5 + 0.3 * np.mean(self.success_mem[-5:]) if self.success_mem else 1.0\n        mutation_factor = self.mutation_factor_adjustment[idx]\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = self.population[r1] + mutation_factor * (self.population[r2] - self.population[r3]) * historical_factor * scale_adjustment\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def dynamic_crossover_rate(self, idx):\n        return self.crossover_rate * (1 + 0.1 * (self.trial_successes[idx] / (np.sum(self.trial_successes) + 1e-9)))\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def diversity_mechanism(self):  # New diversity mechanism\n        if self.evaluations / self.budget > 0.5 and np.std(self.fitness) < 1e-5:\n            diversity_factor = 0.1\n            for i in range(self.pop_size):\n                self.population[i] += np.random.uniform(-diversity_factor, diversity_factor, self.dim)\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.diversity_mechanism()  # Activate diversity mechanism\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveDE", "description": "Integrate Success-Based Adaptive Mutation and Novel Diversity Mechanism in Differential Evolution for Accelerated Convergence.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDE' object has no attribute 'adjust_population_size'\").", "error": "AttributeError(\"'AdaptiveDE' object has no attribute 'adjust_population_size'\")", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {}, "mutation_prompt": null}
{"id": "3f87235d-8681-4106-addc-a2c2a8397c7a", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = min(10 * dim, max(20, budget // 50))\n        self.pop_size = self.initial_pop_size\n        self.initial_mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n        self.success_mem = []\n        self.trial_successes = np.zeros(self.pop_size)\n        self.mutation_factor_adjustment = np.ones(self.pop_size) * 0.8\n        self.memory_size = 5\n        self.memory = np.zeros((self.memory_size, dim))\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n    \n    def select_parents(self, idx):\n        indices = list(range(self.pop_size))\n        indices.remove(idx)\n        return np.random.choice(indices, 4, replace=False)  # Increase parents for diversity\n    \n    def mutate(self, idx, r1, r2, r3, r4):\n        historical_factor = np.random.uniform(0.5, 1.0)\n        scale_adjustment = 1.0 + (0.2 * np.random.randn())  # Dynamic scaling\n        mutant = (self.population[r1] + self.mutation_factor_adjustment[idx] * (self.population[r2] - self.population[r3]) +\n                  scale_adjustment * (self.memory[np.random.randint(self.memory_size)] - self.population[r4]))\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def adjust_mutation_factor(self, idx, success):\n        if success:\n            self.mutation_factor_adjustment[idx] *= 1.1\n        else:\n            self.mutation_factor_adjustment[idx] *= 0.9\n        self.mutation_factor_adjustment[idx] = np.clip(self.mutation_factor_adjustment[idx], 0.5, 1.5)\n    \n    def crossover(self, idx, mutant):\n        trial = np.copy(self.population[idx])\n        j_rand = np.random.randint(self.dim)\n        cr = np.random.normal(self.crossover_rate, 0.1)  # Stochastic adaptive crossover\n        for j in range(self.dim):\n            if np.random.rand() <= cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def adjust_population_size(self):\n        if self.budget - self.evaluations < 0.2 * self.budget:\n            self.pop_size = max(10, int(self.pop_size * 0.7))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.trial_successes = self.trial_successes[:self.pop_size]\n            self.mutation_factor_adjustment = self.mutation_factor_adjustment[:self.pop_size]\n    \n    def optimize(self, func):\n        self.evaluate_population(func)\n        \n        while self.evaluations < self.budget:\n            self.adjust_population_size()\n            for i in range(self.pop_size):\n                r1, r2, r3, r4 = self.select_parents(i)\n                mutant = self.mutate(i, r1, r2, r3, r4)\n                trial = self.crossover(i, mutant)\n                \n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    \n                    if trial_fitness < self.fitness[i]:\n                        self.population[i] = trial\n                        self.fitness[i] = trial_fitness\n                        self.success_mem.append(1)\n                        self.trial_successes[i] += 1\n                        self.adjust_mutation_factor(i, True)\n                        self.memory[np.random.randint(self.memory_size)] = trial  # Update memory\n                    else:\n                        self.success_mem.append(0)\n                        self.trial_successes[i] = max(0, self.trial_successes[i] - 1)\n                        self.adjust_mutation_factor(i, False)\n                    self.success_mem = self.success_mem[-10:]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n    \n    def __call__(self, func):\n        return self.optimize(func)", "name": "AdaptiveHybridDE", "description": "Hybrid Differential Evolution with Multi-population Strategy and Adaptive Memory for Enhanced Optimization.", "configspace": "", "generation": 99, "fitness": 0.20099773765019507, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "38a416e0-2d07-4747-9387-a00f838c8855", "metadata": {"aucs": [0.4402085195373989, 0.4033292633094725, 0.4165265399634749, 0.4705829857835121, 0.49178971736709287, 0.5009476261844718, 0.4446561271595777, 0.44381659363672266, 0.44320499359981336, 0.23471161373843474, 0.2184855006665828, 0.22004145210884596, 0.21424622296585993, 0.21352480595968948, 0.21363504034189973, 0.19746553978853953, 0.21904031833814075, 0.22602595699088468, 0.07125674737389742, 0.08657242548220534, 0.08325893212732427, 0.06931331113566519, 0.08368553596270845, 0.0828777541434984, 0.09032011584251409, 0.07746351600803136, 0.07459360502825674, 0.07353808398735617, 0.06756717248200761, 0.06184171940220862, 0.07083924191578095, 0.07138868093721207, 0.06768024149453922, 0.06667306219054792, 0.06930052326375302, 0.07558083195754828, 0.9475501066245694, 0.9630928878380813, 0.9608018536848256, 0.9261471064467807, 0.8687527455849458, 0.9256923684277975, 0.9818950367354624, 0.9754137202335694, 0.9601774692192495, 0.20470682262110984, 0.21431342157166178, 0.18988783114895125, 0.2103555598316248, 0.21795130011420838, 0.20991258241061272, 0.22005880527188915, 0.19874618504377728, 0.20592053316193282, 0.3255325868801058, 0.25738400241831927, 0.2935209293193941, 0.3258141179483245, 0.3380176648143468, 0.33635532982381466, 0.29387912203651945, 0.31817802864616906, 0.31890715236378464, 0.11560345074498712, 0.11175489762033974, 0.12445283692427023, 0.1113595535961549, 0.11674509731561211, 0.12550628087257298, 0.12025633071981134, 0.1381700957301789, 0.11440962484853268, 0.15705478448944232, 0.18189814452657282, 0.18220130467291662, 0.14788364716009073, 0.11942632105736661, 0.10213207439759642, 0.09700614187684875, 0.11371167431189277, 0.11091717647157129, 0.060748268622869195, 0.03806321700049664, 0.07360798099456822, 0.03785932712478368, 0.050471413545594035, 0.04699823712590512, 0.04937611757135496, 0.058866473563819244, 0.0580708076770865, 0.16471917361176713, 0.14424377315433035, 0.16489894868838928, 0.15036792492036422, 0.1628429020450598, 0.16215579716906536, 0.18512999382569273, 0.19392599418114642, 0.21862505659797593, 0.014127668965635554, 0.004029971824547229, 0.014177186875431125, 0.0211928449451807, 0.0004289498896927757, 0.013423711789804837, 0.008513139477978271, 0.009963797321010825, 0.014050028823565985, 0.08934208886179751, 0.0899860209345994, 0.09860842594807617, 0.0972577634272791, 0.09802313041995236, 0.10663258167808631, 0.1271009137813266, 0.11299668209374636, 0.10607810623337932, 0.36291534273010895, 0.38553028755562657, 0.35316299732964007, 0.3751351458357496, 0.40249685696509685, 0.39868946201051314, 0.3798065489390863, 0.35672069110356897, 0.38751685716435214, 0.07072956370360828, 0.09092189094482095, 0.08038491494265454, 0.07152546075716759, 0.07420856410971977, 0.07155865165589292, 0.07760292108365097, 0.05999229714061605, 0.07762150853410532, 0.2223641838193292, 0.14787443376911347, 0.18709524057736615, 0.1297654928279084, 0.15450619506275676, 0.16091906590929972, 0.12447113325008907, 0.150650204755176, 0.14059432785315873, 0.20137621558063468, 0.21588513862949854, 0.22996434560996815, 0.21290840560322688, 0.21321817620516015, 0.22355629460803605, 0.2312599986300229, 0.23700802093998719, 0.2335989102437126, 0.15938382239000826, 0.14802934682755042, 0.1853836637865407, 0.16315154428866863, 0.15813330176805063, 0.1543584970896421, 0.17751289110015023, 0.1676502370887547, 0.1695977017073823, 0.16526179930574214, 0.18603881932920374, 0.15657559304657698, 0.15901505819313821, 0.1841870352532241, 0.1688457708554013, 0.18357545229987082, 0.1697577947797979, 0.17271031632740397, 0.17601640946625463, 0.15469972134023735, 0.1574679541649271, 0.1595064023478, 0.16452694324646822, 0.1654915128842045, 0.1580179540916442, 0.1628554603447645, 0.1671913142716125, 0.15867829973273606, 0.1750793838214042, 0.14989319543543211, 0.2156435436283899, 0.18003762850724525, 0.15546692211158475, 0.1629785459437999, 0.17571895171168528, 0.1576905101008571, 0.19406247093113593, 0.1823312621519092, 0.18408894320027935, 0.2158968902111691, 0.19081025690663944, 0.17305008551314438, 0.2011620163223975, 0.20876774798124398, 0.20664276799802617, 0.18263497056880929, 0.17858421952189107, 0.22102102155705639, 0.18738361596080488, 0.21175708712140362, 0.17403343738742405, 0.1792710450977374, 0.18075738885079695, 0.19061029722561484, 0.05764585962489166, 0.056897747059399095, 0.055356701420791965, 0.0542785863792542, 0.06655867721416542, 0.07011221855525296, 0.06218118357277613, 0.06927542372475604, 0.05832491896936831]}, "mutation_prompt": null}
