{"id": "c4fa5b36-d0d8-4b77-9365-89d47d636d79", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            generation += 1\n            self.adaptive_strategy(generation)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Hybrid Adaptive Differential Evolution with Random Mutation and Crossover (HADE-RMC) combining exploration and exploitation strategies for efficient optimization.", "configspace": "", "generation": 0, "fitness": 0.21326143840175835, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.44430831582825137, 0.43667471140128356, 0.4441951409749987, 0.455545411476838, 0.447102473337042, 0.45050733755715666, 0.4414284490122028, 0.465927812902986, 0.4418146635371899, 0.20997258290741183, 0.18788296087506207, 0.19140003443424047, 0.16625994651661136, 0.19332159364442636, 0.19167161257330745, 0.18107068179631847, 0.20716125899246518, 0.1796153132324806, 0.10105370878252784, 0.1101372134583597, 0.08850686227133664, 0.10406342131552626, 0.1055836107425715, 0.09208209789177313, 0.11021092224118334, 0.10567050785275223, 0.11043946188929243, 0.08363722078662172, 0.08671653399009716, 0.07719671897650882, 0.09093819901754707, 0.09003281313049849, 0.08569510268982228, 0.09109301517517254, 0.08933211963970367, 0.08640122132910588, 0.9574703177758358, 0.9260340905172147, 0.9322203772770116, 0.9221285632229772, 0.9296753641449549, 0.9334200725154879, 0.9586417844445724, 0.9191008244669452, 0.9278501339519634, 0.15287778755430648, 0.1598477216464107, 0.15448976729814368, 0.1861954546564757, 0.1770362813363736, 0.1820697156773884, 0.18380280253155334, 0.16296590553418155, 0.18194042230885332, 0.38011563475809107, 0.43226712147725777, 0.3554422073686643, 0.4664692152596147, 0.4359287762126841, 0.4137336167002137, 0.4290796136251672, 0.4158201889886284, 0.446069036258548, 0.12035603195117417, 0.09036986583866857, 0.10785073683015434, 0.11832608466675609, 0.09226412805349171, 0.11254449660238663, 0.1245023644117157, 0.11568656777915243, 0.1016148515666444, 0.12673792954466223, 0.11491510435313446, 0.08577998592342884, 0.10909383992641764, 0.07912776672424282, 0.13691973025140125, 0.10536551858942889, 0.12713120572964565, 0.09311190326621599, 0.07673259221076656, 0.07214157134384314, 0.07024376668042809, 0.08656696604718306, 0.09345047733317946, 0.07125375785410593, 0.07595426317105647, 0.0760676325308487, 0.06404651036321973, 0.1952959044772007, 0.1725535556986777, 0.18240998764201932, 0.17442831343670895, 0.16781042864991358, 0.16394147811173787, 0.20907284889449418, 0.19710473933123795, 0.2165734796171197, 0.023486959788112882, 0.024390011987402205, 0.015789375002598693, 0.01797075518325797, 0.02117523719614367, 0.020944504391950947, 0.03245867057160179, 0.04199413424304699, 0.0184810036253501, 0.09960395810424305, 0.11668938997747513, 0.09175430753339808, 0.1119028718361722, 0.11509313331905158, 0.10281361942309508, 0.1173332927189853, 0.10667772897472838, 0.10253303197369967, 0.3518109704757846, 0.3664446534050557, 0.3630458324260265, 0.35888150571722555, 0.36095301755653597, 0.373134895830618, 0.36901453286933505, 0.3731874251765195, 0.3555990284811502, 0.07515200367761699, 0.08766917390206475, 0.07948083488376156, 0.08626735033274313, 0.07647098085896065, 0.08379137040182627, 0.08349313469059738, 0.08892939679228762, 0.08334806864802247, 0.1493002326361127, 0.13606314650188267, 0.1649951057835759, 0.18005968412961593, 0.168366095579622, 0.1425606597093143, 0.16874101045756396, 0.1524470189572652, 0.13883890093457374, 0.24209388643114338, 0.24147994493217262, 0.25285955290639717, 0.23570203168224502, 0.2281839627905703, 0.23074165480827946, 0.2610345281885281, 0.25783204433800855, 0.2519553894306832, 0.19414181538849185, 0.1766296626325402, 0.17540763513177393, 0.17539289263540936, 0.17644974210511533, 0.17151516335280936, 0.1990350299912137, 0.19822985157554052, 0.19503829383791527, 0.18925454440189804, 0.1696244243582805, 0.17839162896534366, 0.16776456802636674, 0.16115783632290426, 0.187071101561735, 0.1767162979705187, 0.17042333966014356, 0.176799532052054, 0.1989883991659548, 0.1769634088591232, 0.18335176967240696, 0.17769568475339514, 0.18801526828105397, 0.17852340638452258, 0.17437836757196656, 0.1832543602166602, 0.18734689890155287, 0.1786479018237922, 0.2282073229658229, 0.2279913495412511, 0.29370037629585255, 0.17128856386124602, 0.2640577796073792, 0.3793555830340807, 0.18943348270795235, 0.3439733922468692, 0.2607420871769007, 0.20929166136012511, 0.27435124638738984, 0.20557115951918337, 0.17031338990751355, 0.1578469978528516, 0.29603456687331686, 0.29622661118540194, 0.4282796303178813, 0.19047577125723292, 0.18985838048945203, 0.19410430985336602, 0.1978189511914551, 0.18245924410172665, 0.18499310711451766, 0.18251369257756822, 0.18571451889824553, 0.18557784536305688, 0.06887399941495964, 0.06234125031212767, 0.07082784700934774, 0.06723747830195337, 0.06499799501217063, 0.08008237883052194, 0.06726034015769333, 0.06691386048675207, 0.06383445069949467]}, "mutation_prompt": null}
{"id": "3b40b0ea-fa81-4a0d-8a78-85a74c871af3", "solution": "import numpy as np\n\nclass QIDE_AQM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.9  # Updated\n        self.crossover_probability = 0.8  # Updated\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.q_probability = 0.1  # Quantum mutation probability\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def quantum_mutation(self, individual):\n        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n        quantum_individual = individual + self.q_probability * mutation\n        return np.clip(quantum_individual, self.lower_bound, self.upper_bound)\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.q_probability = 0.1 + 0.1 * np.sin(np.pi * generation / (self.budget / self.pop_size))  # Updated\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < self.q_probability:  # Quantum-inspired condition\n                    mutant = self.quantum_mutation(population[i])\n                else:\n                    mutant = self.mutate(population, best_idx)\n                \n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            generation += 1\n            self.adaptive_strategy(generation)\n        \n        return population[best_idx]", "name": "QIDE_AQM", "description": "Quantum-inspired Differential Evolution with Adaptive Quantum Mutation (QIDE-AQM) for enhanced exploration and convergence.", "configspace": "", "generation": 1, "fitness": 0.18821141876621475, "feedback": "The algorithm QIDE_AQM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "c4fa5b36-d0d8-4b77-9365-89d47d636d79", "metadata": {"aucs": [0.39737362889124583, 0.4037584878248178, 0.400161617920221, 0.4543128771391972, 0.42732983319866, 0.4267462255237384, 0.4600094648157952, 0.42707925964783033, 0.4231116044754394, 0.15861833697806438, 0.15195624669640806, 0.15741307427039042, 0.169362254717201, 0.15205703565011985, 0.16466804253698153, 0.16518483898298786, 0.14693239799514246, 0.14938954882456257, 0.09892929050373589, 0.10657298139823235, 0.10394406679137502, 0.10630713893366284, 0.10049564937282085, 0.10395618031612663, 0.11065490433521719, 0.0960447900239837, 0.09584830677434963, 0.08025725320067745, 0.08806135065601861, 0.0826843678670981, 0.09149044951936125, 0.07895922721211446, 0.08945203282191272, 0.08772111378506364, 0.08755766850845725, 0.08499966964265149, 0.9419952358949027, 0.9179627247002634, 0.9302808558571706, 0.8943301017270814, 0.90969531650839, 0.9272667064926071, 0.9610816764109756, 0.9288261857242728, 0.9593968004980784, 0.1710223731910333, 0.16432988784925096, 0.15405035996532535, 0.15715567497471272, 0.15225070667239593, 0.17486736007326276, 0.14224836933889928, 0.17410022364580657, 0.15634570040349882, 0.21579328474107096, 0.2180966378708108, 0.2431292241491907, 0.2162431576588052, 0.28167372137921776, 0.33035531702187604, 0.22762117526673187, 0.2201976829231348, 0.32364562827800614, 0.0929842976404861, 0.09962235588401291, 0.09080796803677826, 0.10111885592918557, 0.1159046048660648, 0.09903211777832133, 0.09401815732192575, 0.09515901056947151, 0.11063051204224106, 0.1572706831991254, 0.08250996381152997, 0.07746299722352634, 0.091968862350153, 0.09375419042569899, 0.09095790312607355, 0.07153448110195626, 0.06966465327512306, 0.08170201769893737, 0.011595916313986376, 0.019205422145011863, 0.014349805979125274, 0.012430812460635376, 0.017935227776270546, 0.005661137811669326, 0.01125580060439757, 0.009392431807658808, 0.003536367561834397, 0.10757666692249057, 0.10467433804024917, 0.1240271174550317, 0.10801905667268019, 0.11011824310002316, 0.11472531676192144, 0.12400797155480137, 0.14933186709670354, 0.11556976985866152, 0.003279331499318694, 9.999999999998899e-05, 0.0035679116774610664, 0.012318364418658523, 0.009719116249551907, 0.002732307894745878, 0.001050414974982261, 0.017356857173960627, 0.001921483996954687, 0.06300290441339262, 0.06879483801171626, 0.07446168619663363, 0.07118629490841977, 0.07939635990753335, 0.066140324003505, 0.08291374680456409, 0.06149686473761662, 0.05792139099881277, 0.3370371418062117, 0.33018331441527016, 0.35620311475695476, 0.3349565538605165, 0.3633874530530441, 0.3561757841039642, 0.3357151203193167, 0.330139101677118, 0.34791524182955147, 0.08517004321166444, 0.09048931117701264, 0.08873335086454459, 0.07903743391007845, 0.09105559818563203, 0.08220820668523388, 0.08388376614653548, 0.07306603483695417, 0.07976828427136096, 0.1932262422712161, 0.16482685037620726, 0.18690456765855756, 0.1625634437462652, 0.17481742255046517, 0.1667396715063595, 0.16114151864676263, 0.1710549409987312, 0.1504943633773448, 0.2261646934679138, 0.22040062869971977, 0.2355079524550966, 0.2074102913864746, 0.22561531663877754, 0.2206005242704654, 0.23740136297027958, 0.24818176315579843, 0.2509215293570619, 0.15218633116734037, 0.1575389642809505, 0.15847672912167143, 0.1495601072519145, 0.16054426535670263, 0.15050057434895958, 0.1824222104518045, 0.1671789803347309, 0.17744376196713396, 0.18646915386923846, 0.18048472000913285, 0.17415263689324256, 0.18471280298754078, 0.17907428600287933, 0.19936913195050388, 0.1795522537570392, 0.18029602030618463, 0.17216807522649213, 0.15728948087984695, 0.17761391829374784, 0.18945255962116248, 0.1646685639675235, 0.18731318477583414, 0.1693732286035482, 0.17633590700505375, 0.18524821063239338, 0.19971573677310994, 0.18313721281793127, 0.18472031471227102, 0.21322974799130934, 0.18277254332033344, 0.1540921429523502, 0.24930050941795634, 0.18859469836807108, 0.24913972054625544, 0.19422718885077284, 0.2200630100545301, 0.17362802612093198, 0.19045933357531153, 0.19402059959753026, 0.20325065843702272, 0.1498819280169108, 0.1955549988690941, 0.2683212560523316, 0.25182716229559143, 0.17929243641784864, 0.18636873752298966, 0.18798551895978943, 0.18268597913626616, 0.17848603389424023, 0.18976456475545778, 0.19403687153065086, 0.19245557152695092, 0.1925607995237446, 0.05796683184846019, 0.06388771372355262, 0.06902596925843174, 0.06336157270385412, 0.0714091973570734, 0.07258486852016033, 0.06801505826589604, 0.06102638907512026, 0.06805114596522632]}, "mutation_prompt": null}
{"id": "08fafe8d-be76-4e6f-bf51-119cec32296d", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            generation += 1\n            self.adaptive_strategy(generation)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Enhance the mutation strategy by incorporating a weighted combination of the best and random vectors to improve convergence speed.", "configspace": "", "generation": 2, "fitness": 0.23373636496812142, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "c4fa5b36-d0d8-4b77-9365-89d47d636d79", "metadata": {"aucs": [0.4833073958810411, 0.5034151492795518, 0.5199922545043179, 0.5194732276131945, 0.5127355481081373, 0.55540415528973, 0.5355762204954899, 0.5222197963655643, 0.5027692136648025, 0.2037928422123877, 0.2353982695998439, 0.25142164102539855, 0.23669779900672494, 0.23391883919112666, 0.23859683043336422, 0.22527293665878756, 0.24742107512886846, 0.22474461170874516, 0.11143921425502779, 0.11212570765857832, 0.11105296473637027, 0.1037814570027975, 0.10166989686847827, 0.11009093088469069, 0.11059463655318524, 0.12759880485712016, 0.1158240679252942, 0.08941723089135611, 0.08662138743716186, 0.08902332195193541, 0.09744366043252994, 0.09434664014341088, 0.0844081702989462, 0.08885198027823771, 0.08853036363374645, 0.10222717681978577, 0.9392679933010201, 0.9429213667606593, 0.9271947483903421, 0.9072446889626288, 0.9259430784157988, 0.9041715312371964, 0.9566471871932405, 0.9350725568888306, 0.9671866790426706, 0.17312719197748938, 0.1988723239408572, 0.15628177514146224, 0.20533926157107563, 0.18036070861586762, 0.1742619893286912, 0.17741412808298918, 0.21741758594631477, 0.1843188549479351, 0.4508117499323585, 0.47444692054499005, 0.4201449335522265, 0.4958287524031503, 0.4834063423825695, 0.5297484513110531, 0.5097456149166253, 0.4608027953067222, 0.5029612852150444, 0.11409226345537882, 0.1652717774992385, 0.12285495927777867, 0.11418133602352032, 0.11666131812335712, 0.10917401811371341, 0.11337661721927761, 0.11876084060698433, 0.13683575666678394, 0.1188798431335566, 0.1291496317449975, 0.1477316730160375, 0.11800516982621811, 0.09376300157825246, 0.12151682671795294, 0.10855796322805633, 0.10037646563006541, 0.11918499430626339, 0.10671267466896062, 0.08766658233750968, 0.117616858462667, 0.09845667847124662, 0.11414096133296603, 0.11163186993163765, 0.1141455366155869, 0.11564426826735652, 0.11775125846357115, 0.21693056345301032, 0.22723323454421795, 0.23269411017771868, 0.21239291001221472, 0.21134378613382965, 0.19700115139865526, 0.24098596986302534, 0.21785401805868976, 0.2613109672765942, 0.05897639409578881, 0.04873143456465601, 0.05135050131137198, 0.059369137088516766, 0.05084049727043205, 0.053607429813747, 0.06487648454714068, 0.04993065019126641, 0.04004168176160816, 0.11302982112486992, 0.1206326572564691, 0.12179869494679718, 0.11958384433842062, 0.1352233626742334, 0.1302872823628317, 0.14542739446044983, 0.13077215764161265, 0.13294311675676673, 0.419263565699705, 0.4183617065315889, 0.4263184632682282, 0.42795710337207626, 0.42194020006663946, 0.4376092932873521, 0.39683588433744854, 0.3881487292771352, 0.4194956234001014, 0.09296384860502171, 0.08454081999076735, 0.09502103429574504, 0.08660277682057982, 0.08474500536035501, 0.09186529945047495, 0.08861024448956245, 0.10070154788179952, 0.08133329687423252, 0.14028532918162617, 0.13565377713319138, 0.1421653172005748, 0.1415527532332399, 0.14342561184857094, 0.13988719725053966, 0.14888254251018374, 0.15702254238230562, 0.13011984538540433, 0.272386806931318, 0.24870384496413367, 0.2737729991750919, 0.26971684307556476, 0.25924560937553154, 0.2784081960936017, 0.27119383910822126, 0.28000619654336256, 0.27970440507680594, 0.20320015423099347, 0.20521591101329517, 0.2007581829848505, 0.20529434611775554, 0.18453058971749858, 0.19896807802278804, 0.22494487977540967, 0.2169211205805568, 0.20708149645256213, 0.1839484519554051, 0.17995826976571316, 0.19485104031951272, 0.18267924625927512, 0.17491183504652874, 0.18665317606734555, 0.17419771383825244, 0.1824156110706291, 0.1745747963797134, 0.1886867225812674, 0.18358861758655864, 0.18256943804498782, 0.1812944333532004, 0.19200334364118465, 0.18036143541270355, 0.1848008303729355, 0.17945328249315973, 0.19422900049737923, 0.3818628751657819, 0.3929617709723763, 0.29112592046478514, 0.2903089238176596, 0.15687770849553706, 0.18837844083986577, 0.27821192349034873, 0.22587954226600426, 0.40300012139784946, 0.2610286247062297, 0.17780737364103594, 0.36575297354852343, 0.3576347268208767, 0.17341858473704852, 0.27145698005059526, 0.1935765568573764, 0.24428557907027637, 0.3275260191418392, 0.1731200120822316, 0.17106460787062439, 0.18608048444977465, 0.19942597187402222, 0.189407375650541, 0.1943661090763118, 0.19623603056710348, 0.18309853867021797, 0.1857923608135189, 0.06857919267263135, 0.06823791075190233, 0.06775225733475632, 0.06889536835778542, 0.0682418876296178, 0.06672284991997401, 0.07373680868058963, 0.07401195193333765, 0.07319405428633274]}, "mutation_prompt": null}
{"id": "f5cd74e4-0cc5-4c02-8c52-e8d6bd694e67", "solution": "import numpy as np\n\nclass HADE_RMC_Adapt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n    \n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.4 * (1 - self.evaluations / self.budget)\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.6 + 0.4 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability = 0.4 + 0.6 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        self.pop_size = max(20, int(self.pop_size * (0.9 + 0.1 * np.random.rand())))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        generation = 0\n        while self.evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if self.evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            generation += 1\n            self.adaptive_strategy(generation)\n        \n        return population[best_idx]", "name": "HADE_RMC_Adapt", "description": "Introduce a self-adaptive population size and dynamic scaling factor strategy to accelerate convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HADE_RMC_Adapt' object has no attribute 'mutation_factor'\").", "error": "AttributeError(\"'HADE_RMC_Adapt' object has no attribute 'mutation_factor'\")", "parent_id": "08fafe8d-be76-4e6f-bf51-119cec32296d", "metadata": {}, "mutation_prompt": null}
{"id": "ed1f115d-6bc1-47db-a0ed-54335fdbf026", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        # Introduce a dynamic lerp_factor based on generation\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce a dynamic adjustment to the lerp_factor in the mutation step to enhance diversity and convergence speed.", "configspace": "", "generation": 4, "fitness": 0.25800691348127625, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "08fafe8d-be76-4e6f-bf51-119cec32296d", "metadata": {"aucs": [0.5755103660472525, 0.5516286521968499, 0.5420842604356508, 0.5775098814974946, 0.5613828244425827, 0.5639113403137134, 0.5621910168522, 0.5570745772620179, 0.5784309749228896, 0.2985929134318721, 0.2508495502064819, 0.29576282540068854, 0.3213886961397129, 0.30171174678004475, 0.2991148691679604, 0.3153624249433098, 0.2874702260424169, 0.29773079041658823, 0.10609160411978369, 0.11105049464043404, 0.11050612802242632, 0.11712463414524532, 0.12009694842885166, 0.12082982137031273, 0.11907834320159127, 0.11820338305454081, 0.12315256698520638, 0.09483777137238958, 0.09767883871531235, 0.09869249208806263, 0.10718031828725016, 0.09810661049765002, 0.10028393004840819, 0.08601816180329747, 0.09652993450103442, 0.09162943147249913, 0.9392682220196454, 0.9429250552829981, 0.9272205965351805, 0.9061423939907192, 0.9259668713675447, 0.9085989315657991, 0.9566471871932405, 0.9350670451738122, 0.9671866790426706, 0.18238906073764782, 0.16830252360374065, 0.17694621663516608, 0.22822462374404395, 0.24241171482436807, 0.19598660900209652, 0.23959732663305588, 0.21279446507897637, 0.21870197880730935, 0.5534418077976688, 0.5327150497052557, 0.5519444604591178, 0.5753827916293255, 0.529134514494298, 0.535249250308566, 0.5642110887048988, 0.5520653477860351, 0.542441471081764, 0.12971938676974437, 0.11550529204355897, 0.1276136564456507, 0.1450499359229669, 0.12350688907412244, 0.10229530204546644, 0.11400440234243092, 0.1267123536008532, 0.13722625803329425, 0.1301015598670514, 0.19837166362139813, 0.10298293819597693, 0.12967348603377649, 0.1088025922026471, 0.12186751886782876, 0.12012368815048324, 0.11490468783497676, 0.11246868413522404, 0.16533236370602133, 0.1611669536784286, 0.13358382039544447, 0.13758240446595305, 0.15313409266036837, 0.14269331821652542, 0.1703275297211312, 0.1614910811137219, 0.15348148494515912, 0.27038060681463716, 0.24548095493774247, 0.24667543936251057, 0.26632662945809393, 0.28414202802946953, 0.25002630294199557, 0.2973331594092138, 0.2854846041161737, 0.2534807108102278, 0.05681377416218314, 0.06161385973997402, 0.07997647147665632, 0.09015566275374154, 0.10539439334613421, 0.058020009834123254, 0.07505816460823611, 0.08896941156143878, 0.06299631801149774, 0.15076319456793152, 0.172523785066645, 0.14900326268559205, 0.15390137591993358, 0.14684934175328035, 0.14408771382044083, 0.16623154974868137, 0.14422590042612482, 0.1702038852436344, 0.4452192024902225, 0.45843775203000736, 0.4633826850136098, 0.47239786540209805, 0.4736724935683855, 0.47782645142913416, 0.45762375934051647, 0.43068977035947353, 0.47859127354170405, 0.09931006718390256, 0.10024318391764209, 0.09465493392631341, 0.11421076850172796, 0.09800006297701092, 0.09878019477384026, 0.09854808001265114, 0.10220241366666638, 0.09183728151682413, 0.13095647546363742, 0.1409636028051784, 0.17299758196518544, 0.1448829118510654, 0.15572193433075732, 0.1527416612066067, 0.18697431833491762, 0.1575640011686399, 0.13225009055971915, 0.29234323345298086, 0.2857000618458132, 0.27446813970968065, 0.273399967501604, 0.2817181787511166, 0.2807559629231483, 0.28298005174774243, 0.2900055295634566, 0.30346850818481463, 0.2322562687174612, 0.21731810029910015, 0.2300830362711711, 0.21448920015176787, 0.21139441993867036, 0.21104806287991928, 0.24043378167450669, 0.2334225083369157, 0.23561654292394374, 0.19801353596181825, 0.18871307541737747, 0.18512755246416934, 0.18668539514904747, 0.1890226458368911, 0.17754465197802982, 0.19060479776884742, 0.21802783565277828, 0.18230171834169806, 0.19241630797320575, 0.19197000804782216, 0.1803505535756158, 0.19461773600205945, 0.21429191259821034, 0.19198193876819747, 0.19564874204824234, 0.20437227057121432, 0.19721505654388494, 0.47157368051526183, 0.4435946980575579, 0.39702923524247, 0.29231100958317724, 0.15886635727499454, 0.36888719854561514, 0.30857616161383505, 0.31174386220496875, 0.4676908525017591, 0.48752362673371186, 0.17976785757137992, 0.18027912329988338, 0.2242708212956045, 0.24148445103157679, 0.4779173449848584, 0.19024803916509858, 0.26621042288030017, 0.43362437214905114, 0.19589550028004177, 0.19649351845824636, 0.18687827849356842, 0.1793896065862589, 0.17914321039172498, 0.18458852534321135, 0.1851115098399997, 0.18519994972408416, 0.1750369750848193, 0.06751973846747683, 0.07572888521422605, 0.06859854880789695, 0.07282480944636172, 0.08521107141687789, 0.07320699124326913, 0.07615866752834421, 0.07317977578347745, 0.08563604112883405]}, "mutation_prompt": null}
{"id": "498f7c89-0ab8-45df-b2c6-0d80c738dbf9", "solution": "import numpy as np\n\nclass Enhanced_HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.local_search_prob = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation):\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def local_search(self, ind):\n        step_size = 0.1 * (self.upper_bound - self.lower_bound)\n        noise = np.random.normal(0, step_size, self.dim)\n        new_ind = ind + noise\n        return np.clip(new_ind, self.lower_bound, self.upper_bound)\n\n    def variable_neighborhood_search(self, func, ind, current_fitness):\n        neighborhood_size = 5\n        for _ in range(neighborhood_size):\n            candidate = self.local_search(ind)\n            candidate_fitness = func(candidate)\n            if candidate_fitness < current_fitness:\n                return candidate, candidate_fitness\n        return ind, current_fitness\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < self.local_search_prob:\n                    mutant = self.local_search(population[i])\n                else:\n                    mutant = self.mutate(population, best_idx)\n\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        \n                # Apply variable neighborhood search\n                new_population[i], fitness[i] = self.variable_neighborhood_search(func, new_population[i], fitness[i])\n                evaluations += 1\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation)\n        \n        return population[best_idx]", "name": "Enhanced_HADE_RMC", "description": "Introduce adaptive local search and variable neighborhood search to enhance exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.15179432202991877, "feedback": "The algorithm Enhanced_HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "ed1f115d-6bc1-47db-a0ed-54335fdbf026", "metadata": {"aucs": [0.27937358847842153, 0.27576017809012243, 0.2587598880320491, 0.2689517480617838, 0.2842144837892667, 0.2752765646004721, 0.260883095209543, 0.26080902733689304, 0.26339288426273677, 0.009631078370732404, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07789455999862493, 0.06365081520311255, 0.08016981399596568, 0.06520814278875331, 0.0757639082880125, 0.09654916473713815, 0.08577023613508028, 0.06819380876270587, 0.0746069464869199, 0.06235509129703709, 0.06328661200602359, 0.05553627531372929, 0.06490128593823041, 0.07267770404984508, 0.06189268333796649, 0.0685664426021142, 0.06818686328196, 0.05665673658495762, 0.8049203759312556, 0.8655330455955231, 0.8618767747908097, 0.7863021319556305, 0.8858673075580379, 0.8828229500435838, 0.8117492021345444, 0.7991242365277695, 0.8392157981329952, 0.13075606830890996, 0.11648305964262395, 0.11980026793392717, 0.11333745379437055, 0.12185200035567212, 0.10606150166883854, 0.13437260372914295, 0.12475323846808428, 0.12948264710323276, 0.16531493262228492, 0.17488675482971594, 0.17745533865097296, 0.1767787782587431, 0.1751901154696558, 0.19050379054103272, 0.18453165912210034, 0.2018564911399876, 0.1783647392444756, 0.057481241319894294, 0.07222937899792536, 0.07754799069473506, 0.07725739251228403, 0.08509515491376152, 0.0750270241192289, 0.07187684021792229, 0.07187209599110123, 0.04844801693347267, 0.06680164538266731, 0.08889380899673127, 0.07796194136586632, 0.07376985618663512, 0.07875074515715808, 0.05939640762243159, 0.06022020583227827, 0.06266602916032593, 0.07683060808652642, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06131075199194713, 0.07697840171355186, 0.1097887630166482, 0.05414227080030598, 0.062351284575554944, 0.08374602995500824, 0.09611202508354166, 0.04864489098423952, 0.04504569262915137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02269187331776068, 0.011340668680659971, 0.017479147781636284, 0.030658224765461095, 0.050479411560770515, 0.03663826755080757, 0.03000895396848413, 0.027629484488627343, 0.026801135141394705, 0.28530662860554445, 0.26690575580848597, 0.26461589299808497, 0.2801887443326615, 0.26880853693815854, 0.27768264153912847, 0.279228634722019, 0.27755410858855534, 0.2691124952395346, 0.06073447088572559, 0.0777939995244844, 0.0653515941004329, 0.0760329550956258, 0.06577236421163069, 0.07078477650319981, 0.07080621553667243, 0.06605742553277472, 0.07877073536766244, 0.14488961715495408, 0.14299998562316618, 0.16721306219554644, 0.14586463986567688, 0.15236584224693928, 0.1340982639083964, 0.1543415463130432, 0.16308049346221865, 0.14749130582837677, 0.1841110106821775, 0.20028527390849948, 0.201246575310852, 0.19034054437916625, 0.1958156117528792, 0.19527806171207518, 0.2021953108208595, 0.19585295235657518, 0.1875809717745952, 0.13311395784991986, 0.14601264595884167, 0.13416141114933, 0.12573669327599124, 0.1435974073009485, 0.1418593851038733, 0.13871625009587985, 0.14075905901480146, 0.13128450174262185, 0.1796957631853494, 0.18360319466121855, 0.18925367045943242, 0.20808747115840553, 0.18615521867001295, 0.18885868405412332, 0.19273603925521943, 0.19311988835916805, 0.17499302468311473, 0.1671165787782527, 0.16572833833058376, 0.1601124456382741, 0.1671202995362533, 0.1665860892467903, 0.1680020420820092, 0.162027364211759, 0.1764958255356518, 0.17479912157922295, 0.28650083495049317, 0.19931296573050805, 0.22854613395976553, 0.25052977923891495, 0.1888791289433318, 0.23264002753502244, 0.19441373031899634, 0.17606957914076793, 0.17474723717872132, 0.22378774419030922, 0.17324633809459644, 0.20270226701251748, 0.2133031118423585, 0.18649597779900495, 0.21194673930217833, 0.159913782086335, 0.22961281749746354, 0.18028097087512684, 0.17393963952953273, 0.17574294864465123, 0.18719787423135803, 0.19399682928207407, 0.19325873135346783, 0.1931426857036891, 0.19257846283010338, 0.18473969168878424, 0.17486359199346335, 0.07103728709350066, 0.06497819308847064, 0.061415037124371574, 0.06838131325851315, 0.0790657189221825, 0.06494321208952802, 0.07536317581070484, 0.07338916107689253, 0.06563287121071393]}, "mutation_prompt": null}
{"id": "3fb84008-c169-4b97-8e6f-a5728b13c665", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce a dynamic scaling of the mutation factor based on fitness diversity to enhance convergence speed.", "configspace": "", "generation": 6, "fitness": 0.2657643021372862, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "ed1f115d-6bc1-47db-a0ed-54335fdbf026", "metadata": {"aucs": [0.6680641291094411, 0.6574371093921807, 0.662301379457007, 0.6619831032126701, 0.6463395577863884, 0.6517765649862786, 0.6646968121330699, 0.6669713299439197, 0.6390062938447432, 0.19607795253212512, 0.19322497981049602, 0.19655539927780097, 0.22575487852100307, 0.2196331597211567, 0.21861249839746277, 0.21972177223505074, 0.22433568752648003, 0.2228468905146801, 0.10854969164762551, 0.12110449133560319, 0.10093525211946508, 0.09948060889330568, 0.09793092092877254, 0.10802434947076123, 0.10238912712985748, 0.11517786715068268, 0.09978291970631459, 0.07762394606591116, 0.08890812141261739, 0.08684711487292984, 0.09070826959613332, 0.10067325216212408, 0.0955962147935957, 0.08415163430964712, 0.08645402491666043, 0.08328946632866141, 0.9390817490075756, 0.9184788195227486, 0.8929456739906024, 0.8820916197755795, 0.8810505993546808, 0.8899456183406137, 0.929348991100909, 0.9027213696536859, 0.8429246117032756, 0.19321881920145978, 0.17964667834037662, 0.12613059761694334, 0.18588429649876237, 0.2048685279539635, 0.1672997975598408, 0.1304330417053512, 0.133543648664339, 0.13189768406721636, 0.5961572647286743, 0.5948738215715726, 0.6006543452883929, 0.6587013704072245, 0.6192862086561159, 0.6309322728209907, 0.5975128376550144, 0.5921880782565648, 0.5634403414901731, 0.19053530043848377, 0.137847389056996, 0.1843266205361077, 0.07809935014971048, 0.08307998735587352, 0.06597909206182173, 0.11825934706342411, 0.15189417751812284, 0.15643274208515667, 0.11429141005864296, 0.23968603974774905, 0.15050828440398223, 0.12710553372123157, 0.11153160216439517, 0.12333430064763617, 0.13084787548858656, 0.1908915500364604, 0.11142035128810712, 0.1764590829521221, 0.1614473675357031, 0.15346460688659824, 0.15006750857359352, 0.15305605493152885, 0.1511408967781075, 0.12837425763451304, 0.1474578760711307, 0.15657030366986124, 0.2275802775155683, 0.212135882473098, 0.2179682485037241, 0.220759554608853, 0.2105049570313171, 0.22853350705357556, 0.27511916866249275, 0.23532660622171042, 0.2325135177593164, 0.09069873277959961, 0.08080663321853576, 0.08175111762009746, 0.1111390251078408, 0.09966318445963318, 0.10430771156833218, 0.06259363790343253, 0.09450833599370456, 0.09636889209215183, 0.20139724240966872, 0.1842194839333784, 0.19071807345592362, 0.11737533769649622, 0.12581279459482342, 0.1252728375929466, 0.06824242222486299, 0.07805444437343556, 0.06687087475706499, 0.5556852793944593, 0.5370537100120957, 0.5520087967205989, 0.5764627625019685, 0.556643424858454, 0.5768217478776412, 0.5574294458058358, 0.5344132125719994, 0.563772157623692, 0.09318112034900783, 0.10369363089562067, 0.08236733925309037, 0.08645461358546003, 0.09604493784687862, 0.08561553789716325, 0.07793266665613396, 0.08092134937861517, 0.07305663572010179, 0.13757052113709667, 0.15628085387053348, 0.1589587573892839, 0.1469022064608123, 0.1398492507468594, 0.1431911612453194, 0.12320495065503279, 0.13818168782815832, 0.1585470946234191, 0.30241158013908065, 0.2905405261130297, 0.31477143239110217, 0.31790932780074876, 0.3303876943590568, 0.32761541938274175, 0.33361803644766974, 0.33215005790697605, 0.34264571784308195, 0.17439044825001349, 0.17399203993948553, 0.176672759428388, 0.23652974880449895, 0.2556047367716363, 0.25188787233395804, 0.27466068382660314, 0.2629319744658317, 0.2708591645983318, 0.20305223444613585, 0.19963739844158745, 0.19931889074881426, 0.22595728459907416, 0.20557669210691576, 0.20083362204374866, 0.19597453072795967, 0.19621178126319727, 0.19346950735934865, 0.16459475200581475, 0.1751864228525386, 0.1730604261038814, 0.17450613705955986, 0.17774434833877606, 0.18045049218673448, 0.18595325380690786, 0.16625602020786556, 0.17855516795544213, 0.501843034289829, 0.5954690335173034, 0.5128926157979072, 0.2163199080539876, 0.18423981093298847, 0.1854993337461811, 0.5955827871632537, 0.48819802785477073, 0.5927085713627621, 0.46429934490152835, 0.1904596673492236, 0.4411541310730961, 0.4537259840096759, 0.3707681345358085, 0.18035222817065244, 0.5423310735373352, 0.37391965558530793, 0.18955323501739063, 0.19775818667189138, 0.20878542821091528, 0.17909272716022806, 0.17858700712265996, 0.20769721040703215, 0.1814368308331391, 0.18781156756163742, 0.18120977724217613, 0.1785369286627796, 0.07898834778969321, 0.07198505354019669, 0.07888766072002074, 0.07236696461442427, 0.08551442553965238, 0.08106917018259752, 0.0832926402500157, 0.08937807328031866, 0.07263478236105803]}, "mutation_prompt": null}
{"id": "2e04bb8b-9317-4c53-9a44-53909afcd03c", "solution": "import numpy as np\n\nclass Enhanced_HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.successful_mutations = []\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        diversity_factor = np.std(population, axis=0)\n        combined = (b - c) * diversity_factor + (best - a) * (1 - diversity_factor)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / (np.abs(np.mean(fitness)) + 1e-12)\n        success_rate = np.mean(self.successful_mutations[-10:]) if len(self.successful_mutations) >= 10 else 0.5\n        self.mutation_factor = 0.4 + 0.6 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity * success_rate\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(1)\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                else:\n                    self.successful_mutations.append(0)\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "Enhanced_HADE_RMC", "description": "Incorporate a dynamic scaling based on success history and adaptive diversity enhancement to improve convergence efficiency.", "configspace": "", "generation": 7, "fitness": 0.15812845209153378, "feedback": "The algorithm Enhanced_HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "3fb84008-c169-4b97-8e6f-a5728b13c665", "metadata": {"aucs": [0.43358148554973563, 0.35629083424709085, 0.3910434630681736, 0.48509112207965854, 0.45361565892688227, 0.4215633104410761, 0.373843439195236, 0.47088094720661433, 0.38404096041541746, 0.11183166352657059, 0.038995820835814654, 9.999999999998899e-05, 0.11483624009693993, 0.011232220755972744, 9.999999999998899e-05, 0.09452878910062101, 0.13027290853382623, 9.999999999998899e-05, 0.09821723692288342, 0.12357244675367807, 0.1049177138331876, 0.0914160946976823, 0.11057761249724207, 0.1003350477944196, 0.09334799207241917, 0.11063971894848856, 0.11040841090198938, 0.053416440209916094, 0.06882258076868475, 0.06542811179268793, 0.07914143732527534, 0.07756228795617304, 0.08440565813327672, 0.09877818101596969, 0.08769828949953151, 0.08570584392757696, 0.9593220521720193, 0.9843623086415422, 0.9345146562927651, 0.9730660647616584, 0.9344889275535966, 0.9212052095483688, 0.9835582179397369, 0.9444225791459051, 0.924183954928506, 0.09571157764619798, 0.07031115288532241, 0.05285472742395447, 0.07357042839492456, 0.09050090972889757, 0.07003555629607094, 0.06617460159472632, 0.07243797405012697, 0.0617936406886056, 0.17354249714430958, 0.15624353541217695, 0.1336082316025673, 0.3410929102619116, 0.14377373155423667, 0.2517480324944489, 0.18878467535820254, 0.13004494134680522, 0.16397830432259197, 0.08095437867076216, 0.07638754027029104, 0.08219716100382557, 0.07169756577359387, 0.07558976812521723, 0.09006220397175568, 0.17595373393277314, 0.08288815579343933, 0.14735044921717966, 0.03853889542508715, 0.009176160560006807, 0.009419114885399038, 0.0477583146367111, 0.07997823029248152, 0.03843583577927878, 0.03985848120898705, 0.03802551692898393, 0.043362995437571716, 9.999999999998899e-05, 0.004354784861271055, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024364636145675633, 0.015055040304731149, 0.04681352783622128, 0.02460433167054288, 0.05856307326719712, 0.013320855871947423, 0.005414293118231939, 0.038109158009696165, 0.011216164230228087, 9.999999999998899e-05, 0.02231078160002775, 0.0015362016447192373, 0.05519279857127857, 0.0042124249936199565, 0.00784042637667104, 0.06485681565089874, 0.06008151945903739, 0.0713841442547185, 0.040806966268293055, 0.020817577514963936, 0.0228770360491386, 0.08233317857442957, 0.09811151818902986, 0.0828395261517586, 0.06347877607783536, 0.07401602507449101, 0.11893566634010277, 0.29940598335808843, 0.29299356806455035, 0.33013342081536245, 0.339349761162688, 0.32655409161518356, 0.3274471721284046, 0.273080864786061, 0.32963537741994, 0.29560651443704233, 0.08074564502546033, 0.08928277837301979, 0.08646918685674299, 0.07477362557516776, 0.059529861230395054, 0.07361389782290628, 0.07658306427502648, 0.06425589199216197, 0.06879600731736024, 0.1389803269438693, 0.13116485626524121, 0.13594447946741006, 0.1422180916981124, 0.14007469914168136, 0.1681873716899287, 0.13334592356213126, 0.1602750574994518, 0.1267258532375396, 0.14732024781625463, 0.14759615526729086, 0.16144563739886875, 0.18077499792531293, 0.15995588743208933, 0.16213984738248677, 0.21302467909778233, 0.23084865973390756, 0.23736703989096664, 0.12002635252708715, 0.07747806147429637, 0.09857504649818494, 0.11010185987889143, 0.11321414409854968, 0.10842364284689543, 0.1571959425776599, 0.14698414345653632, 0.16885762526734693, 0.14563618913302523, 0.1392351828879258, 0.14943218228571875, 0.1390825336506818, 0.15504416559207435, 0.1822040073142982, 0.15162484507456298, 0.15624300743854147, 0.16147902850444384, 0.17409138315895578, 0.16534467964529254, 0.14526415449742347, 0.14833059327046028, 0.173947582676514, 0.16181469459473574, 0.15892754029621559, 0.1337356636335829, 0.1872793943248645, 0.14859242396195038, 0.14279717808100267, 0.13146116474510927, 0.13031731794386725, 0.1580514992986225, 0.11898455026787702, 0.11679440486072967, 0.11674766634891587, 0.13142601247765828, 0.14951248275799567, 0.16355091765285146, 0.17428312418658298, 0.12293316130187104, 0.09002017455698041, 0.09194683573367113, 0.19209480740067653, 0.1468991106913794, 0.16753508180723398, 0.19087901158578313, 0.18773133545453757, 0.17487698318596046, 0.17011192149444154, 0.18962013533357547, 0.17365379564777073, 0.20485713692318563, 0.19048523687790508, 0.18322831285373808, 0.05271461637272512, 0.059645051489014445, 0.049114440724117414, 0.049804604644912764, 0.057825967630663944, 0.059209404033724655, 0.05970494587567354, 0.04739357679549372, 0.052067972221461756]}, "mutation_prompt": null}
{"id": "b35c18f0-98df-4f43-b4ea-c15d4cfa066a", "solution": "import numpy as np\n\nclass HADE_RMC_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        combined = (b - c + best - a) / 2.0\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def stochastic_ranking(self, fitness):\n        perm = np.random.permutation(self.pop_size)\n        for i in range(self.pop_size - 1):\n            for j in range(self.pop_size - 1 - i):\n                if (fitness[perm[j]] > fitness[perm[j + 1]] and np.random.rand() < 0.45):\n                    perm[j], perm[j + 1] = perm[j + 1], perm[j]\n        return perm\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.3 + 0.7 * np.tanh(generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.4 + 0.6 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            population = population[self.stochastic_ranking(fitness)]\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n            \n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC_Enhanced", "description": "Introduce stochastic ranking and self-adaptive mutation to balance exploration and exploitation for improved convergence.", "configspace": "", "generation": 8, "fitness": 0.13942800239036507, "feedback": "The algorithm HADE_RMC_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.09.", "error": "", "parent_id": "3fb84008-c169-4b97-8e6f-a5728b13c665", "metadata": {"aucs": [0.5405208884052801, 0.1827482992095405, 0.44304206766013776, 0.3004444805355304, 0.20127965716239238, 0.15486482104912758, 0.2589388147394003, 0.21694558154989174, 0.16948003334059014, 0.05752482751391841, 0.13110019887522772, 0.014813563929579998, 0.11557706418026814, 0.08589482469308007, 0.0009124049086621788, 0.03735966400810686, 0.11755402845711882, 9.999999999998899e-05, 0.11955319417269061, 0.11493564854874383, 0.08197017330301148, 0.11391622505505417, 0.07427306298981917, 0.09564776580751655, 0.10679414789993913, 0.0929427149519152, 0.11614740530852119, 0.08618010313801827, 0.07356506402424168, 0.0878269250122905, 0.06591816884800716, 0.09407382706486955, 0.08500020505651085, 0.07177216057145419, 0.07231324937931694, 0.07410737755033114, 0.063328713272369, 0.06457015503233665, 0.08276748061074157, 0.0656547003600002, 0.06235256857175242, 0.06461938479480467, 0.07249021741630646, 0.07566457777948576, 0.0745188818718503, 0.06274794416174423, 0.10508072708829674, 0.06985494507322054, 0.09384619011053896, 0.09835608378303473, 0.08034662891332955, 0.08330926707910635, 0.11733124475396473, 0.0998712898928652, 0.20499965315975133, 0.22147822692890695, 0.21837565135110026, 0.1551010959724668, 0.2579053194390414, 0.28337705702987703, 0.21411980113109064, 0.11607091104447465, 0.16132177938877013, 0.060358708233758995, 0.16007411970078989, 0.06448933165859183, 0.1184203810428498, 0.07054052365840913, 0.12705504787845534, 0.21646708023468597, 0.11938387492934743, 0.11395432902937863, 0.14206299682317347, 0.12987504903019365, 0.1281505425997932, 0.12752614264293516, 0.1438425204094268, 0.15318112483583213, 0.11432746825382978, 0.11936455582460004, 0.12932438456524775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005543458783591637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12464334449411651, 0.12780522438153252, 0.10653726177346945, 0.0380122801078735, 0.12680153471169708, 0.06607260802190762, 0.07806876464630985, 0.12317167423419773, 0.10601715145262292, 9.999999999998899e-05, 0.010241219804628221, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0306293537719754, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025469923836625497, 0.012318468980316744, 0.06740695653295992, 0.03661230904559509, 0.027026615967083112, 0.34012851156464086, 0.41227436764192116, 0.38426595676571174, 0.1771490517103793, 0.17382299827476777, 0.1943779524578798, 0.3517371805145284, 0.25545138816972734, 0.3908537401801664, 0.08401539436023975, 0.08726171825365614, 0.08270708893321954, 0.11356155757694542, 0.06663849383174325, 0.0931713951694122, 0.09992396981093676, 0.07862790612150516, 0.1271169954089384, 0.1524027701459867, 0.14612842817614013, 0.1699169603802103, 0.1547449043277469, 0.15900052268037157, 0.13474884109305385, 0.14987260210697073, 0.15546768893073826, 0.15678679062486467, 0.23371960574635564, 0.20820416333531278, 0.2132813235372233, 0.3117316921238368, 0.32404021571522046, 0.3354629413040169, 0.2232563354814886, 0.2289066616182528, 0.20721175677042192, 0.2009778963043677, 0.19324980745319087, 0.15825664563996722, 0.23703056516371923, 0.26846014139235985, 0.24093044513048079, 0.1663470580080837, 0.16754699244004956, 0.17313590300347537, 0.21716693744757587, 0.2240855493479902, 0.2179656772312737, 0.2211290317679383, 0.23488610412113609, 0.2259981845631891, 0.22393574336193522, 0.21061692971140433, 0.23190880782981005, 0.17442276807734525, 0.1885005198885994, 0.16760052343054632, 0.17162193567633954, 0.1816426501619638, 0.17565126157938427, 0.17877165410555662, 0.18575058014454726, 0.18051638710261608, 0.17420556056965764, 0.1821241488730887, 0.182904540059868, 0.19120903664933386, 0.2350001330234751, 0.16314399518438272, 0.24271997569856563, 0.16581453850727046, 0.1548631807276013, 0.3226086199617535, 0.25342386529942695, 0.22455726931352027, 0.16564739492435765, 0.16453686145175284, 0.1183870718916461, 0.27728183610992496, 0.27706794128448853, 0.26894283719221634, 0.1902305023667087, 0.18834354599111724, 0.17930832752725634, 0.18491295291610677, 0.1801280998189122, 0.19329073712709244, 0.1772090325588107, 0.17674967453303292, 0.1840881278194776, 0.08712953495252718, 0.09557469837128751, 0.08722306874879837, 0.07896871768390701, 0.0873637601531233, 0.08792586549960091, 0.09088261456181312, 0.09638169586699874, 0.11204671536144173]}, "mutation_prompt": null}
{"id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce adaptive mutation scaling based on individual fitness improvement to enhance convergence.", "configspace": "", "generation": 9, "fitness": 0.3010738803014921, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "3fb84008-c169-4b97-8e6f-a5728b13c665", "metadata": {"aucs": [0.6766801282990291, 0.679981874726963, 0.6584069287430399, 0.677962206893861, 0.6666726870144113, 0.6513534011940927, 0.6596564122602538, 0.6652558747746671, 0.6549036642558055, 0.42756766807539537, 0.4093577514862463, 0.3946805983930409, 0.4307397251539483, 0.3996651970983197, 0.43549971436114676, 0.39209467682305044, 0.43264119444139937, 0.4225076769258247, 0.10116075973842142, 0.10612987608028857, 0.11114401382426731, 0.10831592540966539, 0.1239656898903595, 0.09382334689668737, 0.10312532944543018, 0.11001891510084283, 0.1229027373330468, 0.0843222330129687, 0.09594051077771204, 0.09149561299197306, 0.10903609255667068, 0.09475566945674341, 0.10379274768504854, 0.09208659001533837, 0.0903849199640141, 0.08834433556010568, 0.8446240619119647, 0.7821862995698579, 0.8406876283397113, 0.8849909772353912, 0.8620468456630883, 0.8790583698106322, 0.8736816002264339, 0.8528130091566805, 0.8889315651111309, 0.19213408710060909, 0.16398635564542596, 0.20080950272203413, 0.19251726442647066, 0.17685394350726058, 0.15513379252630444, 0.22155377249386154, 0.17787230582608282, 0.23054031712749534, 0.666008822692886, 0.6104503012200075, 0.5824544340817558, 0.6400114134492161, 0.678441311342165, 0.656403284732124, 0.6425645287394608, 0.6646062863858697, 0.6547392462525116, 0.1368728701441847, 0.1545065438289579, 0.13583642349078584, 0.14954426698288603, 0.2365567561045615, 0.1450472089877508, 0.21681465155734025, 0.27700692298965346, 0.13732727230741004, 0.14080751693631377, 0.29051304207155604, 0.15302204705208255, 0.13481059671845996, 0.1341422823226267, 0.18769144426917062, 0.1716205399627706, 0.138405550285416, 0.12990136321278933, 0.22270754116661395, 0.25723309706241926, 0.0817492269873672, 0.24381153976883907, 0.23283008958582319, 0.2386483409222545, 0.10350388137952049, 0.18612161114686798, 0.22770709207538897, 0.3376160073698715, 0.36840475134074746, 0.35709184171333896, 0.3236359541300211, 0.3429458712854695, 0.20189777169037082, 0.3617745088392119, 0.3292133296781057, 0.3409205662448719, 0.1882596783390238, 0.05502249476905363, 0.12548953864719314, 0.11618417248466628, 0.15305017305513446, 0.10167385688290997, 0.16505543649025967, 0.19619907725356878, 0.13452703599166527, 0.22745156689755375, 0.20437199999783362, 0.20814582603351506, 0.2216914576053367, 0.25380117447641914, 0.24173181033532032, 0.20426146963602554, 0.23489220397681365, 0.20472474068870594, 0.5808454802079062, 0.5612334066785368, 0.5906980317513425, 0.5784343354734229, 0.5550687498854425, 0.5782985481222135, 0.575806920021708, 0.5656950022215566, 0.5651902142448411, 0.09464316350172663, 0.09928322751447216, 0.09411695805926557, 0.1073464742440019, 0.10551393406386866, 0.09201582468891534, 0.1338128277347561, 0.11349793598884972, 0.12869181611971559, 0.16872556942280192, 0.13928668448791337, 0.13592008910661046, 0.14786237850021278, 0.15797371256739134, 0.14738685432269538, 0.12519691016583334, 0.1368767197212859, 0.1318851935397064, 0.33987831468380136, 0.3234274036902097, 0.3342830218027907, 0.33332028654963974, 0.33371948111298866, 0.3142732361204834, 0.34921039949376054, 0.34527254580169264, 0.343394452733333, 0.2737001889884554, 0.27317141881828944, 0.27377805730449734, 0.2802165708307087, 0.2716798435997958, 0.27944774553128704, 0.26976881385011786, 0.2742525247042529, 0.26229356112946023, 0.19589569833871168, 0.20500689910981784, 0.18240747699958348, 0.19550415487298478, 0.20014381462351105, 0.2242527176799315, 0.19077063239602632, 0.20573043212626818, 0.20715918191510074, 0.17263222224628094, 0.18114996177982234, 0.19604180469569032, 0.19039781537133071, 0.1815691364632085, 0.17924802122896688, 0.18153645325964707, 0.1765667626039754, 0.19456239445160006, 0.6033968919912487, 0.608432554241076, 0.6400170371260234, 0.6872747475198719, 0.7091994625725098, 0.6561701447274257, 0.552559649452934, 0.19953060597255012, 0.42414656274830864, 0.5666955938639086, 0.19157184724884058, 0.4335857573996096, 0.2260874177470913, 0.18900795862402253, 0.49946220169228017, 0.19991611242532004, 0.5987475847915091, 0.40229846407783065, 0.18437052207936422, 0.18844578230663633, 0.18473950848174792, 0.200596391045185, 0.17482682758734058, 0.19457685984503315, 0.17180962058061033, 0.19512627348051748, 0.18956091467473135, 0.08630582976467271, 0.07869606986944, 0.09159140586651593, 0.0798294808654999, 0.08545309482817154, 0.09213981381068148, 0.08101337189902658, 0.08598166734206603, 0.08457565817835788]}, "mutation_prompt": null}
{"id": "79c04470-972a-4b44-a0f7-beedfd9bef37", "solution": "import numpy as np\n\nclass HADE_RMC_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.success_rate = 0.2\n        self.adapt_rate = 0.1\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness, successful_mutations):\n        success_rate = successful_mutations / self.pop_size\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        if success_rate > self.success_rate:\n            self.mutation_factor = min(1.0, self.mutation_factor + self.adapt_rate * diversity)\n            self.crossover_probability = min(1.0, self.crossover_probability + self.adapt_rate)\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - self.adapt_rate * diversity)\n            self.crossover_probability = max(0.4, self.crossover_probability - self.adapt_rate)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_mutations += 1\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness, successful_mutations)\n        \n        return population[best_idx]", "name": "HADE_RMC_SA", "description": "Introduce self-adaptive control parameters leveraging success history to enhance convergence dynamics.", "configspace": "", "generation": 10, "fitness": 0.2101732105396065, "feedback": "The algorithm HADE_RMC_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.12.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.47502133679251557, 0.44670292190265104, 0.4665591479902016, 0.5288119192587847, 0.4942236810972458, 0.5142140505731674, 0.48617824636928075, 0.46798953156203993, 0.4690950654854007, 0.24814085580278278, 0.2536563282358769, 0.2946836660087707, 0.2550373551822579, 0.2467981721979866, 0.2765213244102942, 0.28823152596777424, 0.28697588900481785, 0.17229901230081746, 0.1278068890454953, 0.11846446862532523, 0.12594508569708573, 0.1386942556320111, 0.1298400897104317, 0.13412359536273655, 0.11501897173298625, 0.12959135956687629, 0.12432144605146989, 0.1078096554720761, 0.1115341370850601, 0.11225661038792512, 0.10695948792771415, 0.11470891423262497, 0.11806560905913555, 0.10390176390456796, 0.10889734436319598, 0.1146223934464119, 0.11610815403798858, 0.11139741476563936, 0.13343646533410825, 0.2221172455619137, 0.7195469260533787, 0.8296693741592949, 0.6586381623778677, 0.43255558880127176, 0.32814551797582103, 0.2289089297661412, 0.22120050404207725, 0.2392006263991887, 0.23258476164746034, 0.2306482931310343, 0.23472179585832087, 0.17980753825486895, 0.17945723318819295, 0.1963328027552207, 0.2203008260552498, 0.25511158716098403, 0.20820609809245016, 0.25107966258125447, 0.27214329349829236, 0.24864033233988536, 0.2843273897228511, 0.327075265363308, 0.33696620946577327, 0.14926156262428025, 0.13524616870729822, 0.14628795228335567, 0.1302370957631298, 0.12995185516640273, 0.15478483797270803, 0.14641667174872797, 0.1385464369925452, 0.14239112331608794, 0.14518688881093045, 0.11241406128340736, 0.1581912469682204, 0.15619367271154583, 0.14700237868688493, 0.1412778776527266, 0.16406414828070015, 0.1609929440050233, 0.15143704992871387, 0.17003149475209234, 0.18800595113112273, 0.21840935961748786, 0.20802325521397302, 0.15402367227458147, 0.16180529165098, 0.10596788136572066, 0.1319576367173444, 0.09193217581209667, 0.16836568756901593, 0.20872927585074108, 0.22202807501317845, 0.24979999288163768, 0.2782396608651214, 0.24690817352267636, 0.3158577726127916, 0.2690753158322031, 0.25371269092978843, 0.1280420999444596, 0.05947448737618466, 0.09656005181488037, 0.12830388941094661, 0.07891999771662372, 0.07760982651478276, 0.11304624077057801, 0.11050644953895639, 0.11599306421077071, 0.1513366405979497, 0.16198885332789614, 0.16166033990433393, 0.15222464121101387, 0.1569987814642273, 0.16990700109451995, 0.12236645847713845, 0.10699254134460057, 0.13500156912624628, 0.3633382064113627, 0.3746170004893329, 0.3850018400523576, 0.3681526764221683, 0.38651514713744406, 0.3955232441500157, 0.39953746061357287, 0.4041995454730348, 0.37907793215475827, 0.11267224725219549, 0.08615244062444694, 0.08891471393364025, 0.09470543311690471, 0.09260270847432162, 0.08052543175528049, 0.11213443706541926, 0.10591913021588839, 0.10319446359759332, 0.1332377702903883, 0.14390835740422792, 0.1792772228429621, 0.1528958295629278, 0.15260251052707297, 0.14944726490174765, 0.1316342649729979, 0.1402491331392064, 0.14067717259076817, 0.242564738730352, 0.24586141399522132, 0.25651015445572867, 0.23417741987778984, 0.25650411802775674, 0.22448238739873017, 0.25085025442338615, 0.23699849611899648, 0.26177153067534376, 0.2075043275657218, 0.2191126618092143, 0.21068138017756854, 0.1883966008800939, 0.18261119827252859, 0.18767937919087818, 0.17830211445348143, 0.20771643363557113, 0.1580130462863355, 0.1835689187411138, 0.18922460779744787, 0.1839094028374203, 0.205239152526573, 0.1766253894063251, 0.19956478635439545, 0.20089613665610506, 0.18545681212069565, 0.19029292436659984, 0.19592010306197039, 0.196876041205567, 0.21329048273562634, 0.19799801332542533, 0.19401408862447445, 0.17722946405619244, 0.19100308875370775, 0.19555112051479884, 0.20046327316724166, 0.20713703293531383, 0.26092682119291133, 0.25009166891218504, 0.40111790974714323, 0.19002517692693877, 0.7220879337921597, 0.18646198133577696, 0.19206943255872977, 0.22061851223007278, 0.21404445943779293, 0.16344411814070936, 0.18805982991450743, 0.16205257215554758, 0.2643624293368353, 0.1917395895427163, 0.15149602229391024, 0.2350396312064018, 0.5109636537260563, 0.19509194396398077, 0.19688671911961186, 0.18589418554394788, 0.1854592411676832, 0.1875553333332397, 0.1909201616834767, 0.18229478613415273, 0.1769611338575101, 0.186649156326537, 0.07398610919860293, 0.08144013563005559, 0.08729021879467969, 0.07858945447881271, 0.08314571058578024, 0.07388449621248039, 0.07703731642913758, 0.09100423943829206, 0.07628893567591188]}, "mutation_prompt": null}
{"id": "fec3d107-760d-42ad-811b-013149cf5105", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * (1 + np.sin(np.pi * generation / (self.budget / self.pop_size))) * diversity\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce a dynamic scaling for the crossover probability based on population diversity to enhance exploration.", "configspace": "", "generation": 11, "fitness": 0.24628140493744938, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6419894513943853, 0.6333092234885108, 0.6292264654893027, 0.6315609513152716, 0.6311885818027417, 0.6264925160159798, 0.628686674726368, 0.6328338687256325, 0.6365691168917718, 0.3906066535820395, 0.366343804702589, 0.3684712711689522, 0.40885193430506495, 0.36481739839295235, 0.4233348100915211, 0.3865095594524418, 0.41963991424019975, 0.14795028100609942, 0.13661307209782503, 0.13695389001528624, 0.1376326326484839, 0.13156838776307866, 0.1437375679107561, 0.12436015446626258, 0.14652202008600756, 0.12704364548365865, 0.14451840118747072, 0.11894561814738658, 0.11591201364195336, 0.11301897981768638, 0.12505669780907702, 0.1117139721764755, 0.1143695040051732, 0.12030525020246408, 0.10610552522443173, 0.11673580888409674, 0.8767149414718695, 0.761856537829205, 0.7514113714968694, 0.8450436298839453, 0.8762935559243971, 0.8848927574684287, 0.9061175883713276, 0.887254280422318, 0.8426264935609328, 0.23576238491055168, 0.23197131219139022, 0.24580583573953707, 0.24160412437227574, 0.23753252271958192, 0.20986914885383368, 0.19780056743064045, 0.19142498731627067, 0.200530513350773, 0.24701297379233178, 0.2175274063283208, 0.2552456501354916, 0.3290618112896623, 0.25610058359952004, 0.28917719851828994, 0.5224734396901807, 0.5187981822756208, 0.491308514249328, 0.15010346529247887, 0.19401619500621947, 0.1510813095559137, 0.12686708940757685, 0.14880421311597747, 0.13359372933711677, 0.15366959922732493, 0.15549184290264262, 0.17904116874239484, 0.1361546760908705, 0.13725173610971464, 0.12730251392869463, 0.13176671980884425, 0.13347751736121538, 0.13884138569829996, 0.1361472210830259, 0.12383424749244731, 0.14682365327183688, 0.06333523412061315, 0.09187308450824438, 0.09939726648311786, 0.11341402115661181, 0.11611619332307965, 0.09422473034149681, 0.05923699528209547, 0.01163987387082921, 0.10651848336773839, 0.1807027789684591, 0.22222328193417062, 0.17888946378059223, 0.21032093586386735, 0.2493577910748137, 0.18410383456569668, 0.23862885298886927, 0.22246198759750446, 0.22209645923009969, 0.05220483209674198, 0.11752903162277928, 0.09315692145925425, 0.09309190403952938, 0.05388577119266469, 0.11066799770703095, 0.09860450952172084, 0.08017625360692782, 0.14305452921591555, 0.1461213413632011, 0.11434002628627327, 0.10751685314736859, 0.15043899190449195, 0.15460484159428745, 0.15738904248580132, 0.13948681432484933, 0.09195734325816918, 0.13275641470909472, 0.4223515304746711, 0.41945768261712724, 0.4252859300175782, 0.433782563057173, 0.4034056640125404, 0.4335735195221515, 0.4289770172167173, 0.40854592336453865, 0.4207772653850479, 0.0912116085979453, 0.09039478405729895, 0.08594662870499237, 0.11524977814884063, 0.10386617626809169, 0.0919692648356748, 0.11473293624345171, 0.14329145215081207, 0.10634513497849607, 0.16151117182902086, 0.13348426882950803, 0.14213767688936152, 0.14465646093195628, 0.14243391643645154, 0.14016331688323003, 0.15912670908409543, 0.15251608457394927, 0.1462656388172343, 0.27031157914217807, 0.28120626860887554, 0.2945349312932666, 0.2712837235644806, 0.27682773896665946, 0.27570728884538653, 0.2780151311337118, 0.28762909071980125, 0.26987484368813486, 0.19393865588361037, 0.22258925690289344, 0.24431605265567602, 0.20732689187850484, 0.20857748712046253, 0.20926473835821813, 0.18952160329111756, 0.20501062840310846, 0.18269144914791746, 0.2175949940460178, 0.1949417144365475, 0.1888610998005792, 0.19389207483067206, 0.21611905256981312, 0.1917129778612291, 0.20178187978381878, 0.20891455362105948, 0.1963097248832173, 0.18782052743015887, 0.19532736012004337, 0.18525579682585436, 0.19415820639726689, 0.2037160035640354, 0.18471820887035106, 0.2036721419544859, 0.20328230483383924, 0.20854521841723295, 0.17416162067397112, 0.35435270740745695, 0.3227273437042195, 0.5922377121953981, 0.6773248103424632, 0.6868600589953577, 0.2133026453231217, 0.24823564128750963, 0.2052778649205279, 0.23210571064914431, 0.18426867096670652, 0.22395547883381284, 0.1996425742834107, 0.1789337985550985, 0.1970545115724387, 0.15547985580259482, 0.2574111754015118, 0.39813099465448687, 0.17175089865014437, 0.18597805559456193, 0.18715387332667033, 0.19977720259926057, 0.1823821310193393, 0.1769305644530974, 0.1881098304430382, 0.19783271217537546, 0.18197158763386234, 0.07858923010542107, 0.08835904929200133, 0.08229059445826936, 0.07680185664097972, 0.08051264462060426, 0.07519197785938236, 0.0777266976828298, 0.08262385658510318, 0.07811932102283003]}, "mutation_prompt": null}
{"id": "daaa99c5-5a6c-458e-9848-85bdac5a2374", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        adaptive_mutation_factor = self.mutation_factor * (1 - (self.generation / self.budget))\n        mutant = a + adaptive_mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce adaptive dynamic reduction of the mutation factor to maintain diversity while enhancing convergence speed.", "configspace": "", "generation": 12, "fitness": 0.30022047222898146, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6622607663972195, 0.6632830338342248, 0.6574622835036338, 0.6725545916371545, 0.6540291886950741, 0.6636067051159357, 0.6682114107063293, 0.6753378696894219, 0.6748947562666341, 0.397690418552319, 0.4082571107277043, 0.40580021891091456, 0.41062690932413903, 0.4169493708496338, 0.43475122973139113, 0.4015780737067688, 0.41464919907732334, 0.3954373224077169, 0.1037895598364752, 0.11633472074393103, 0.10064336439100297, 0.12432085318382868, 0.10412149206540455, 0.11012810674700446, 0.11470740048405681, 0.10205003604018525, 0.10232534785386282, 0.08770588628689624, 0.09084587950113199, 0.09190734483182783, 0.10646392947556282, 0.10150068717415284, 0.10525002893437252, 0.08373538415660065, 0.09131836172760655, 0.09807158122063997, 0.8446138678107984, 0.7634586998644913, 0.8406490796166299, 0.8849923131416055, 0.8620460057496834, 0.8790597338197277, 0.8736505226854644, 0.8528261957420741, 0.8889318853543852, 0.16994468309790667, 0.1562068369784858, 0.16295839909885468, 0.2000102540908294, 0.16592379230235088, 0.1513927576019347, 0.18162357527004036, 0.2083789259330916, 0.2889549264955995, 0.6278766564395973, 0.6099709880210181, 0.631536841142673, 0.6282919921194488, 0.6511307312262398, 0.6301757924965183, 0.6682614903993902, 0.651524030731428, 0.6705437488448212, 0.15255302868324994, 0.1594391098908452, 0.16375308396005728, 0.15389555498496232, 0.2836350499389504, 0.1369832660818131, 0.16921767730973092, 0.25515230878672923, 0.18724223608569723, 0.18558585619672252, 0.28144870046943504, 0.14751515002554538, 0.13871461148626274, 0.12786073378495144, 0.18000750085038508, 0.1447228745872322, 0.16086946514999, 0.13307891773558744, 0.2230840732994619, 0.19083158063746142, 0.13255941790345804, 0.2519104769404552, 0.2060419517126929, 0.0654934063750856, 0.05444566273786533, 0.23281193176608173, 0.2452068282997003, 0.3415514863175464, 0.33238786250406915, 0.3725821069602443, 0.3413329127140502, 0.360233659704016, 0.29843606704028935, 0.34791926665614015, 0.3495683756143815, 0.3354790873927963, 0.12268309001834699, 0.18913728126281004, 0.06586808533020139, 0.06055879755255189, 0.0807505952657942, 0.12832842257737886, 0.10449895000042231, 0.08509558448567389, 0.11660045013818165, 0.23124332810884607, 0.2143818684967952, 0.217378121936999, 0.22186379165616676, 0.2549460369957698, 0.23685579252200528, 0.21753425149614225, 0.22050187685062317, 0.20883248101599727, 0.592216096117935, 0.5656727700902764, 0.595266893178106, 0.561827796139069, 0.5471973795048586, 0.5702379984690397, 0.540982068015841, 0.5626388247923878, 0.5846182655052179, 0.09366050406809678, 0.09495388467434329, 0.09310794261356914, 0.09382297454767763, 0.10078980040074781, 0.09558506252429777, 0.14011508745324064, 0.11035351144984484, 0.10814153093720014, 0.19066490005425152, 0.14124418630107716, 0.14230866233022044, 0.1401933185906168, 0.14793333898887173, 0.13904707837501595, 0.12579071347072535, 0.13235880287736257, 0.13573124805975, 0.34824761896758394, 0.3379062198204711, 0.3497684227572472, 0.34526814188015365, 0.3407089891051309, 0.32097579390916964, 0.33624348820761174, 0.34282539790593936, 0.3541905634317364, 0.2905474593350007, 0.27642818802471325, 0.28685562531409525, 0.2716583041343572, 0.2730580789519076, 0.27582644826409675, 0.2821002656206094, 0.27038519611971623, 0.25560176993124606, 0.21938972800441425, 0.18966161176266083, 0.20546378276514832, 0.20637253587380644, 0.196758280913655, 0.18571135940768524, 0.2092625316486999, 0.19704604162369888, 0.18889288032975005, 0.19317794545831046, 0.18430184422365758, 0.1972101484789608, 0.18344766624531517, 0.1873839972971928, 0.1701617240688703, 0.1780746255446065, 0.1791505666570783, 0.1829350086078385, 0.5964941000209669, 0.6113676366557241, 0.6436214672544823, 0.7044647384137372, 0.7062581079633901, 0.6746647665607359, 0.5557722542603307, 0.1810445273044805, 0.4405434673469585, 0.5623333391604726, 0.1916289107374589, 0.45287519721797576, 0.31736182697329574, 0.18905455452396713, 0.5643823156820869, 0.19988769728714328, 0.5819420811443107, 0.40960438839844715, 0.1778632581535159, 0.17582775082898994, 0.18826369379626562, 0.18558503481213784, 0.18324676880695412, 0.1963326743505922, 0.19202609660148307, 0.20220980478741502, 0.19171024711027818, 0.08290973449327921, 0.07213710295295728, 0.08542992238175606, 0.09223665740493725, 0.08028483288725896, 0.08159681004438202, 0.0836673764199104, 0.07958006222187997, 0.07580867022044935]}, "mutation_prompt": null}
{"id": "4ec847fb-8e80-4601-a08c-2a7350bd4aca", "solution": "import numpy as np\n\nclass HADE_RMC_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = min(100, self.budget // self.dim)\n        self.max_pop_size = 200  # Dynamic population size\n        self.mutation_factor = 0.6  # Adjusted for better exploration\n        self.crossover_probability = 0.7  # Adjusted for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.learning_rate = 0.1  # Adaptive learning rate\n\n    def initialize_population(self, pop_size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(len(population), 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * (b - c + self.learning_rate * (best - a)) * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.3 * np.cos(np.pi * generation / (self.budget / self.initial_pop_size)) * diversity\n        self.crossover_probability = 0.6 + 0.4 * np.sin(np.pi * generation / (self.budget / self.initial_pop_size))\n        if diversity < 0.1:\n            self.learning_rate *= 1.05  # Increase learning rate if diversity is low\n        self.population_size = min(self.max_pop_size, self.initial_pop_size + int(diversity * 100))\n\n    def __call__(self, func):\n        population = self.initialize_population(self.initial_pop_size)\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.initial_pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(len(population)):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = self.initialize_population(self.population_size)\n            fitness = np.array([func(ind) for ind in population])  # Re-evaluate fitness for new population size\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n\n        return population[np.argmin(fitness)]", "name": "HADE_RMC_Enhanced", "description": "Introduce a dynamic population size adjustment and adaptive learning rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HADE_RMC_Enhanced' object has no attribute 'population_size'\").", "error": "AttributeError(\"'HADE_RMC_Enhanced' object has no attribute 'population_size'\")", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {}, "mutation_prompt": null}
{"id": "3266b4af-f943-4240-92dd-d8e3b72678fd", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size)) * (1.0 - diversity)  # Modified line\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n\n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce adaptive scaling for the crossover probability based on population diversity to enhance diversity exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.25897662749057715, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6698503642010087, 0.6707476658016669, 0.6538864149007853, 0.6513788299242588, 0.6636686554537101, 0.6823333126780274, 0.6706866779518783, 0.6698792942584011, 0.6560353430322018, 0.297382811696278, 0.29923408968752896, 0.2744249233655812, 0.2982664676634251, 0.29563814402203037, 0.3420289296364869, 0.26099425828383793, 0.29289797672652973, 0.33556796681104206, 0.10848713112391017, 0.1038368660600949, 0.10476891220657414, 0.10376697752507857, 0.10427127935339209, 0.100810160541973, 0.11580388452460988, 0.10552888932038351, 0.10652291842667438, 0.10380832608386681, 0.09445907484702742, 0.09347777198461993, 0.10041062211333296, 0.09675832868339962, 0.11051124743923901, 0.09902767307302185, 0.08618092693256862, 0.09447427208543702, 0.8736337263220102, 0.829263464103295, 0.8575856818193089, 0.8837646201917844, 0.8117434130350222, 0.8790735990574664, 0.8539833517503885, 0.8214221214181546, 0.8629650032458493, 0.1212439803163674, 0.13506608102330886, 0.13776612802295896, 0.16817372173538547, 0.18918270680256377, 0.21491756951625762, 0.18307076264453526, 0.17011401369267387, 0.2687611295451324, 0.6243741898251653, 0.6498988814265702, 0.5848894332501293, 0.6443569058004153, 0.6447688691050162, 0.6349487507226604, 0.5542817697034912, 0.608269095597006, 0.6201054652147298, 0.19970733061013113, 0.1299158933892801, 0.13341195020139662, 0.23724042710962612, 0.10422155660855659, 0.17289243115683128, 0.15652286126285675, 0.16661634267062475, 0.1240642864865007, 0.1290801493104975, 0.1485118338942215, 0.1508380583946386, 0.14413313846717624, 0.13635286610844066, 0.18338947861964683, 0.12234489577870189, 0.12387255079548576, 0.12084489652402575, 9.999999999998899e-05, 0.004625757321397583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005392735667847592, 0.08821253958628184, 0.06556530903786284, 0.06430220466411063, 0.06411275998145416, 0.0796561599241693, 0.07401315314381429, 0.07172999096757393, 0.10722320891444748, 0.06808754774669723, 0.006926881366263515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00016140788941410023, 9.999999999998899e-05, 0.03709098387903309, 0.20377161045010694, 0.1941311283483117, 0.20025011675939874, 0.1258157227794865, 0.10391887470484507, 0.1555337930300702, 0.20768302130146588, 0.1885649640914111, 0.21556875066196202, 0.5821336751143414, 0.5760637537936502, 0.5676644003540645, 0.5749753571245821, 0.5814064859710489, 0.5857131087153336, 0.5569766673942551, 0.5651046285196282, 0.5831542374801695, 0.11038932043798688, 0.10437329020329489, 0.10670112960550482, 0.10644490093448855, 0.10531002722283245, 0.14197525865216098, 0.1114543372445378, 0.08715663056867284, 0.10492281555169758, 0.15374566422433167, 0.15064138178290543, 0.13429238361747098, 0.13766266535167793, 0.14921886584379596, 0.14360184086983097, 0.1318188339828925, 0.15825237317456542, 0.13074914605823995, 0.3419543595335104, 0.31680043079157216, 0.3260511798301362, 0.3222593483074836, 0.32633447359204004, 0.3381997923095207, 0.3479059355070018, 0.34323657097073057, 0.33930176751619157, 0.21174163041926952, 0.18942791914558288, 0.20971541063264454, 0.2635443949231733, 0.26335150142879005, 0.273984073930874, 0.27493832676653296, 0.26689343045583014, 0.27246841376420494, 0.211508022303169, 0.20920563413208915, 0.2002320351858039, 0.18919554152693485, 0.19968048158118368, 0.201224824587952, 0.18554976884269503, 0.19645249154095423, 0.1924494022894443, 0.17620633748849412, 0.17724943098777057, 0.1835192478437706, 0.17709342667553407, 0.18019417730296705, 0.1884498922648291, 0.18730426062334526, 0.18121875027684153, 0.18932080427778142, 0.5236931910499751, 0.6439683782238248, 0.6084722609007469, 0.3663671080973494, 0.3016343664959944, 0.3719344505789679, 0.476848740737172, 0.1829276063676315, 0.5079203115023034, 0.44030057767619324, 0.3402994499146269, 0.5513422851681624, 0.18156266691577572, 0.1890319823497777, 0.5479327938564529, 0.19746951056325002, 0.4670833111645356, 0.18675564572076886, 0.17595430309075621, 0.16589448870475976, 0.17777778948424872, 0.19052519221314979, 0.17516791999245074, 0.1939026703377832, 0.17900748869921446, 0.20287287061897663, 0.1847137789040194, 0.07664280590265349, 0.07618732932019812, 0.09938819291535583, 0.08838250254922242, 0.08375961967160295, 0.07143838414742842, 0.08375178819218176, 0.08210874882222596, 0.08683296485072312]}, "mutation_prompt": null}
{"id": "4cd153e6-4e8a-4da0-9b59-3fdf9d4d90e2", "solution": "import numpy as np\n\nclass ChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.chaos_sequence = self.generate_chaos_sequence(self.budget)\n\n    def generate_chaos_sequence(self, size):\n        sequence = np.zeros(size)\n        sequence[0] = np.random.rand()\n        for i in range(1, size):\n            sequence[i] = 4 * sequence[i-1] * (1 - sequence[i-1])\n        return sequence\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * (best - a + self.chaos_sequence[self.generation] * (b - c)) * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticDE", "description": "Integrate chaotic maps for diversity and convergence acceleration in DE framework.", "configspace": "", "generation": 15, "fitness": 0.26233363626234774, "feedback": "The algorithm ChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6021867041106659, 0.8294631511480496, 0.8202579180416524, 0.6485779965944072, 0.7647691967198229, 0.8212735204229857, 0.3975695862161749, 0.8079295531545408, 0.8232469816874692, 0.16859489457014276, 0.3043318946581578, 0.4939114072051881, 0.18973942475926775, 0.35726435902550624, 0.4553377047337568, 0.4557195165976279, 0.23074136774553822, 0.3149603927740594, 0.1784464209015194, 0.14846811469487897, 0.17601883711586763, 0.34346034061568953, 0.1494479059953021, 0.15120930244017605, 0.1695329247937345, 0.16610118605760327, 0.14495982752054148, 0.16167921736949775, 0.09535506303562746, 0.08913629823914926, 0.13496191887784625, 0.09739751734648217, 0.11010990021232014, 0.10499184452910426, 0.13574470350126666, 0.1321452662878181, 0.3991484895531797, 0.2779070913593701, 0.2520326826034782, 0.17792598036169072, 0.1953079689852727, 0.1966526831135289, 0.17400238558406256, 0.24388996747767056, 0.24707476994026878, 0.16500425212051972, 0.1745069851885842, 0.16229066634009337, 0.1516350345800067, 0.14243413864743504, 0.10679645134448712, 0.15412906912019952, 0.18837297568975309, 0.24288834811109028, 0.16419956063459262, 0.35898176276300475, 0.7959781413214321, 0.3657792585019629, 0.26847211459598297, 0.8373365768226083, 0.2312368854940029, 0.3764258752456019, 0.31432900545305364, 0.13414175486598456, 0.12893967147434937, 0.176767966378245, 0.17734585744660836, 0.1296585756588664, 0.14368896754808447, 0.14943384782165026, 0.14298263106240705, 0.3557759707796012, 0.15988724273565913, 0.2858352268567913, 0.13654697282150285, 0.1436975601972934, 0.12153366177527392, 0.1406950731019755, 0.133229443345939, 0.16426212960487152, 0.18691301679354277, 0.0748286370116833, 0.03901891984820194, 0.06944237194327507, 0.07732787027782129, 0.05686314419063454, 0.1732217870106968, 0.008115550016456696, 0.004953971263627288, 0.014122015504701824, 0.27215942513889413, 0.332487715060766, 0.5261218814375354, 0.1531582653244925, 0.05890204048762315, 0.14571138565171804, 0.16172940313406292, 0.30583808069640017, 0.4007970478651508, 0.033197435021399935, 0.09225316830738484, 0.30715966419644636, 0.1078537115514333, 0.16710042576972606, 0.08946280193833578, 0.26549595433221496, 0.1635484174951083, 0.10874503134041547, 0.06585853944783215, 0.21890068875698077, 0.1638294418467583, 0.18996933760487733, 0.20759240838909665, 0.21885935309486126, 0.11134007311045602, 0.22779645821148387, 0.15535599639255304, 0.5011655029733966, 0.4736423732215791, 0.6045306547878448, 0.5224717039787554, 0.52995344702759, 0.6584631529466982, 0.4404760501195304, 0.6929316686074187, 0.7089258965524303, 0.09789013696064719, 0.10904975464344624, 0.14223342873274336, 0.15434828373108433, 0.12843771502726908, 0.1140338061853432, 0.13380490042027648, 0.12219855939713742, 0.11900779579535903, 0.27948234126374805, 0.20839541816017604, 0.35011964176590904, 0.1703366710224543, 0.3045761790311522, 0.17049286283100373, 0.37749668923662016, 0.14514380657949055, 0.47408012214288, 0.3380887575604373, 0.32875288163486727, 0.35774873909747174, 0.4287361077073083, 0.31518417553435407, 0.3313191932684769, 0.3115537647371225, 0.2999161032018276, 0.2613809802637591, 0.24316670290230402, 0.24175216394101928, 0.2726124144525922, 0.32145413175025206, 0.29272722530373285, 0.33720812540385725, 0.2127700335879139, 0.31650351455666925, 0.2376064568653774, 0.2065169960911193, 0.22765659099332047, 0.23613498578521208, 0.23473513195789553, 0.23206994539035763, 0.25275929957107124, 0.23422331149208075, 0.21970550061677008, 0.21240141191934203, 0.18225345390268755, 0.18372584336671216, 0.20649129904440655, 0.22106228982466314, 0.20458298017828358, 0.21574462892890556, 0.19032254303844998, 0.19821606284025006, 0.21243895942766078, 0.4039527933547705, 0.18525761193310186, 0.7830164707685751, 0.4359991518745663, 0.8295755036925244, 0.6387184316253485, 0.4760280579339773, 0.17711135974412517, 0.8022735314887637, 0.12477345442106269, 0.4291900216634694, 0.20625517456740794, 0.20181743973417865, 0.43548703031997515, 0.1988045648490866, 0.28261129484873326, 0.7721994577357474, 0.1546702288910936, 0.17973071616242253, 0.17855340903303019, 0.20571765785115015, 0.19719772657015056, 0.17867057587893032, 0.18609137779198914, 0.2096899824089027, 0.18253389057220926, 0.18044035405328362, 0.13495951596046396, 0.12382601882509048, 0.11773990817273972, 0.12403440450129477, 0.10845480960121678, 0.0870877091067832, 0.13268723943084004, 0.12828991923610322, 0.09717209919136549]}, "mutation_prompt": null}
{"id": "9179924d-4bce-4607-86d9-75ba36ff5e79", "solution": "import numpy as np\n\nclass HADE_RMC_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.dynamic_pop_size = True  # New parameter to enable dynamic population size\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, fitness_std):\n        adaptive_cr = self.crossover_probability + 0.1 * np.tanh(fitness_std)\n        cross_points = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        fitness_std = np.std(fitness)\n        diversity = fitness_std / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        if self.dynamic_pop_size:\n            self.pop_size = int(max(10, min(100, self.pop_size * (1 + 0.05 * np.sign(fitness_std - 0.5)))))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant, np.std(fitness))\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC_Enhanced", "description": "Introduce a dynamic population size and adaptive crossover strategy based on fitness diversity for improved convergence.", "configspace": "", "generation": 16, "fitness": 0.28789386225269, "feedback": "The algorithm HADE_RMC_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6273459198059403, 0.6678398070742833, 0.6540041953927429, 0.6832342323572174, 0.6208576157789955, 0.751418587107845, 0.6432513865966059, 0.541125817395318, 0.6012328277113682, 0.04857002795372478, 0.3205618325096633, 0.007252107993169887, 0.5125762234730913, 0.13581146476187844, 0.09665704242447426, 0.07724875141537191, 0.13675258615131225, 0.002440839649305193, 0.095112281335754, 0.11548632622272903, 0.113829637059782, 0.12211742546816673, 0.10718855197773103, 0.0992253535701284, 0.09749619913094243, 0.0980762126427499, 0.10135618428674842, 0.09576045590392679, 0.08300957437962042, 0.09121238914756491, 0.10746111527731295, 0.07496993968347776, 0.09563578319679433, 0.10072924110271508, 0.0991939309179255, 0.08724555607372897, 0.33168895845257085, 0.46586799218236896, 0.37909077765872023, 0.6446619923457595, 0.5981402045382072, 0.6098780336582137, 0.7549147632331932, 0.45268954006154893, 0.5311277118276747, 0.27530156165750064, 0.21382388563716426, 0.23988303472529293, 0.2543971138700313, 0.22260674686672832, 0.16875295957462988, 0.24616230970579966, 0.32112296752923564, 0.29322576236270603, 0.7433726764274214, 0.7487388694997261, 0.7185901780384596, 0.7149933259784258, 0.7294527811805651, 0.7221101570138171, 0.730352625864702, 0.7612882517960687, 0.7602701158063283, 0.2504114362610844, 0.1391912852428412, 0.1662334968488145, 0.16539296680257087, 0.25025984560012837, 0.18540905507400385, 0.17529435833951668, 0.14891270097054143, 0.2629587735644566, 0.22628412827825228, 0.22103885795571487, 0.1745831688902757, 0.14606950689318488, 0.2432900760801534, 0.15170166427228016, 0.17702294263274487, 0.20232390155637503, 0.16555816981938842, 0.2731225406794001, 0.10218068952994908, 0.40962855771407325, 0.39148642571381564, 0.40076336160085624, 0.06605356164979115, 0.010334281908015552, 9.999999999998899e-05, 0.35464242435887394, 0.42884696463429706, 0.46921382835808356, 0.4314996193029689, 0.42318024365952445, 0.3049040951651546, 0.29727573413357544, 0.5236522775932206, 0.44664967751988516, 0.535704588951115, 0.167619337870745, 0.10240680558577786, 0.05653020639762818, 0.10215496335557694, 0.0819463442523507, 0.13287558711974923, 9.999999999998899e-05, 0.1704757138075882, 0.18597040984468127, 0.335455623994114, 0.30798671604265637, 0.30728720243587915, 0.06857524981598695, 0.2478479149905478, 0.16736633822861224, 0.05411201460334902, 0.31616884793650013, 0.10492700020184709, 0.517927759618888, 0.4960577666608469, 0.5571346707139344, 0.5383186720576092, 0.5751353145023355, 0.5226747868034247, 0.5818456687157276, 0.4232030627938608, 0.4998427740257996, 0.1088922277440243, 0.09140338652153746, 0.09358481665726281, 0.10119919195294791, 0.1205684470166336, 0.1094396293607901, 0.07733799489451998, 0.10440492251294986, 0.08691476701008505, 0.16324794092039085, 0.14229282317703673, 0.16179644871938748, 0.14299167772911114, 0.1363701483279881, 0.12693071896794716, 0.1338151039200851, 0.13803242153955397, 0.13215628083082243, 0.418393993040332, 0.381610685197043, 0.416718104558222, 0.35404719993411504, 0.34658976051611745, 0.4477914836166046, 0.34963355726137435, 0.37841973202204093, 0.3326081813387164, 0.2628727993704062, 0.3144437957373267, 0.3239109223962283, 0.30380864167786736, 0.34342722731693076, 0.2717439203201083, 0.32881248345414804, 0.3017276053623237, 0.2875407697520356, 0.2161266009207653, 0.2053756990915494, 0.20676030355088182, 0.2032794829527358, 0.19108237049588317, 0.19979568341651677, 0.23102996071175785, 0.18855847495210487, 0.20887656441785774, 0.20458963248938067, 0.18624707833770304, 0.19616809731610518, 0.2104780768932183, 0.246659423405181, 0.19461492784654666, 0.1872424839651946, 0.2895093354810858, 0.20855424054234617, 0.1979206943189432, 0.7425674874139536, 0.7602087601825538, 0.7694703139287824, 0.19472008083662418, 0.19279351351480067, 0.6576869321792864, 0.1652419608388338, 0.6631429707981192, 0.7085806334452608, 0.19764504534308902, 0.6589666133819363, 0.6357886174103371, 0.18263047179187086, 0.3677439911538938, 0.154909104152403, 0.23430733041334728, 0.6811702649781165, 0.1781047340297599, 0.18608691251301013, 0.18174376702063166, 0.17804774083396935, 0.18104633777956336, 0.18476613893195803, 0.19316094149788254, 0.19218004527231347, 0.18433594021960298, 0.08361914463305298, 0.08001184757364177, 0.08454737875850149, 0.08580023076231624, 0.08373853447670221, 0.07903151215377036, 0.08481363508658923, 0.08652132129402212, 0.09268036984586192]}, "mutation_prompt": null}
{"id": "29550ac2-9965-48f8-a861-d6e73f41d063", "solution": "import numpy as np\n\nclass HADE_RMC_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.initial_pop_size = self.pop_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.resizing_factor = 0.5\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        combined = b - c + best - a\n        improvement_factor = np.log1p(np.max(fitness) - fitness[i]) / np.log1p(np.max(fitness))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def dynamic_parameters(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.4 + 0.6 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.4 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        if generation % 10 == 0:\n            self.pop_size = max(20, int(self.initial_pop_size * (1 - self.resizing_factor * generation / (self.budget / self.pop_size))))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            self.dynamic_parameters(self.generation, fitness)\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n\n        return population[best_idx]", "name": "HADE_RMC_Enhanced", "description": "Introduce dynamic population resizing and fitness-based parameter tuning to boost convergence speed.", "configspace": "", "generation": 17, "fitness": 0.20579422237615153, "feedback": "The algorithm HADE_RMC_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.5201000687665622, 0.5543508569704082, 0.509666064346786, 0.7459402646328026, 0.42786107571587706, 0.556339678318456, 0.09975734614470277, 0.0754446916850493, 0.10931182895658242, 0.13652204059087458, 0.17020693877575954, 0.1838749981755885, 0.1757730326344683, 0.19139597497853633, 0.19729899320276467, 0.22078709479235836, 0.19048513137248002, 0.1755801866607415, 0.018550980411068507, 0.02140128133307284, 0.023975333187441494, 0.3162848759845458, 0.2990228282000137, 0.3914943798008603, 0.159620085357161, 0.50818024391189, 0.4084849227508388, 0.12082214081782316, 0.1478864685226634, 0.13571303531712708, 0.10382654132158664, 0.10201501511692534, 0.10297243439340509, 0.151017275045208, 0.12209349357700283, 0.10615082255270569, 0.9270419425307881, 0.9709031484407908, 0.8986113562709073, 0.11994784800473512, 0.1424438494720478, 0.1284848544353956, 0.276963621799992, 0.16717391370531864, 0.1617516005307008, 0.10850659345925284, 0.11602831083634901, 0.12980492871994043, 0.27109602605781313, 0.19969232527576763, 0.1197760944170202, 0.22371131245052944, 0.08627898640528675, 0.11206425351921934, 0.8034441887451865, 0.6601925937371986, 0.7783499267065455, 0.8421803246675964, 0.8142218268856322, 0.2659970307616111, 0.7228217808161603, 0.7073957259620531, 0.724779813119058, 0.1982219506712194, 0.1478850332399676, 0.08075212816377175, 0.05143523223332447, 0.023095316301399493, 0.058353458347673914, 0.13644547691406128, 0.12375121140032386, 0.13219633541769749, 0.14661911769182823, 0.021605852485818144, 0.13580304728042125, 0.1135756522139314, 0.12842305711598478, 0.11624400445888783, 0.15095409629840284, 0.11614281224476108, 0.1264973184599314, 0.0012546013406378176, 0.0009997025817632954, 0.0010317212577017898, 0.00027799376007864307, 0.018809502521441757, 0.00260522586406442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050728967124168745, 0.03853338587677024, 0.06050337912506698, 0.0827973912785932, 0.0284852403115452, 0.07251647516784776, 0.08461642887357845, 0.053121844444950383, 0.07682458847289231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001645950130597651, 0.00019901251777754148, 0.18705651393687228, 0.2066630453091417, 0.18859634168317685, 0.08543041826885422, 0.091951678845129, 0.0947231087642787, 0.047760496860325796, 0.036467441278403956, 0.06856800792992412, 0.12725211533357017, 0.15748132322755004, 0.1696221146064787, 0.16168663979807718, 0.15593686584417465, 0.1472329542472578, 0.5430402328171098, 0.47489354332983147, 0.4397110919281634, 0.14219494486179607, 0.1878369963444576, 0.12759376667031253, 0.12300674513216947, 0.10622115911570595, 0.12250468382535129, 0.09653381754073909, 0.07387184954287007, 0.08400856047443273, 0.1510314576195424, 0.14653087540657728, 0.19116061509963533, 0.13757644454574725, 0.1350323393253442, 0.10789794917811235, 0.1649006818840265, 0.17619451355113014, 0.13360274624120683, 0.1698986392161601, 0.14244858600146904, 0.18914197310408987, 0.44279130413323875, 0.3423899092463424, 0.42660864334049686, 0.2862383770674154, 0.2926595981026602, 0.3021540715804838, 0.14546932955689174, 0.1596448383323088, 0.16791798382833223, 0.282382844122128, 0.27207676435573436, 0.2861944969878585, 0.34610806223884105, 0.36950268939350994, 0.21283994375677207, 0.11934558904189418, 0.10482363617162249, 0.13336421106438578, 0.2273750616523047, 0.21307967169736075, 0.22266637750192397, 0.23770102318509956, 0.21787175165573136, 0.22526545800392572, 0.16669982198335043, 0.16845289530530028, 0.1499274560280246, 0.4289782334593265, 0.2143293561993267, 0.3082213177046478, 0.2256567939932691, 0.27108519306947976, 0.2343803702798286, 0.8260837031643293, 0.18502891977314218, 0.18674306752567205, 0.33056284349463905, 0.19096036880863987, 0.3714548842211519, 0.10692837481480588, 0.10502535409825287, 0.06926818844989102, 0.1103137036995071, 0.10829912054017621, 0.06922728298844572, 0.7833612800991321, 0.6463731786059455, 0.4121966329293387, 0.20449979904400883, 0.11182925100948982, 0.19492251615847933, 0.18026072176667784, 0.18438710608487063, 0.18423956756086934, 0.20030703471452105, 0.1828565389591308, 0.18219275018261127, 0.14961211855402434, 0.15300068442950432, 0.14680476350940774, 0.09587261399373148, 0.08914639771048682, 0.09260154644458019, 0.09188379501504462, 0.09930563373807477, 0.10019633456187627, 0.08689416929117866, 0.0855262474502615, 0.09357542860144297]}, "mutation_prompt": null}
{"id": "6fa72876-f8a5-415d-b4b9-08601480f0e8", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.mutation_factor *= 1 + 0.1 * (diversity > 0.1)  # Adjust mutation factor\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce dynamic adjustment of mutation factor based on fitness variance to enhance convergence speed.", "configspace": "", "generation": 18, "fitness": 0.295561296530204, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6695134245562979, 0.66315500349278, 0.66972505457843, 0.677962206893861, 0.6666726870144113, 0.6513534011940927, 0.651901435235636, 0.6803066300126259, 0.6618514386701294, 0.38420474044185216, 0.39083414106978676, 0.4088633791573456, 0.40541428375271404, 0.37618743533460797, 0.4268949568202003, 0.3875871296341795, 0.4132187585096394, 0.4076126671156115, 0.11653219855376906, 0.11278881786483996, 0.09475945382372242, 0.10870700667165856, 0.10686727860951617, 0.10436389129113721, 0.09539116239052581, 0.11107714063138086, 0.09952445914602759, 0.0901139059646392, 0.08714666104710045, 0.09830810656616706, 0.10192945293030675, 0.10963326679095531, 0.09823566110692139, 0.09904398931734848, 0.09452041878031958, 0.1138305350317167, 0.7925268670134332, 0.7700125632227878, 0.8327342423033288, 0.8849909772353912, 0.8620468456630883, 0.8790583698106322, 0.9178549044297193, 0.8113855364852657, 0.8734563051796871, 0.2063943895303565, 0.17912605184510888, 0.17045935846783233, 0.20181546890589286, 0.19885091535244137, 0.1835270683444694, 0.21517980172945406, 0.18899645466703485, 0.24859795755406056, 0.6348209488360079, 0.597676043973363, 0.5901840280053225, 0.6401536587323905, 0.652374721436712, 0.6384081435798974, 0.6185827128332493, 0.6602682961622561, 0.6586320002698238, 0.18431930223322968, 0.15682014880778983, 0.16017736321036158, 0.1298513978862046, 0.16051779763915552, 0.19299805978261297, 0.14650971142190194, 0.1371556446703014, 0.18197649085570855, 0.18010862451408216, 0.1418594602926292, 0.15141596031690496, 0.20133717913280513, 0.22902170559685642, 0.1386410968249131, 0.16107042370267133, 0.16257401840046204, 0.16118503040312426, 0.08839511423358781, 0.07678007464639869, 0.22817156504365732, 0.22329794535827996, 0.1936915472784696, 0.1921982973828148, 0.2439595696104604, 0.21181244988509085, 0.220543868610947, 0.3441408921341278, 0.35517022049895397, 0.3289216036838509, 0.32573304421167304, 0.13270148530224446, 0.3340594539355539, 0.35840021639545616, 0.36187849722280485, 0.3393536974211724, 0.10470941249919485, 0.14680829348345437, 0.13194978852472328, 0.1570873725437777, 0.11456919655419695, 0.15296001962287975, 0.13878031308791183, 0.07271841143571511, 0.19888412314591342, 0.21124568314823966, 0.21931362395874687, 0.22509141388272158, 0.2267590873465204, 0.2366426553743921, 0.2281154215347394, 0.19866641214676206, 0.2185015017391274, 0.20923143689518087, 0.5677478669971727, 0.5627277335784496, 0.5685507129072289, 0.5768167932818646, 0.5782523387197163, 0.5806211517269309, 0.5759804290317286, 0.5504227825572731, 0.5644573968443141, 0.10216360103369393, 0.0975021620239066, 0.10038181807702184, 0.09976187492171462, 0.10801192079088673, 0.08839200662974545, 0.11600286507996893, 0.09986652326323253, 0.14901961626530724, 0.13320866548227828, 0.141264969271357, 0.14048491294908594, 0.1473552427778908, 0.1542109553828679, 0.15969877962185564, 0.1370728778381357, 0.1319967354321272, 0.1398038173861873, 0.3570618080156578, 0.33952389800464444, 0.3386142863064029, 0.3501190430854876, 0.3491711915383263, 0.32429843531482594, 0.34921039949376054, 0.34527254580169264, 0.343394452733333, 0.2828642349528311, 0.2778175329517073, 0.277419461553543, 0.25345647146844086, 0.2674560144102528, 0.2800369000456995, 0.2862647459159605, 0.265569003599757, 0.2618232004221249, 0.22840230610887524, 0.18996970811848524, 0.20264645110455426, 0.19340028674859855, 0.20130572811535608, 0.1963559838568858, 0.19680458012873336, 0.20573043212626818, 0.19199370334749521, 0.1877117661786205, 0.17527867580380663, 0.17353631245628243, 0.18310943171001437, 0.19530883727420123, 0.19393522658088314, 0.17946857048246034, 0.19458358546035737, 0.1772753144034681, 0.5460837104550731, 0.6481349500732134, 0.6188862737752323, 0.6854929744374578, 0.6067089123919861, 0.7072198457294832, 0.552559649452934, 0.19953060597255012, 0.42414656274830864, 0.5666955938639086, 0.19157184724884058, 0.4335857573996096, 0.2260874177470913, 0.18900795862402253, 0.49946220169228017, 0.19827001736908467, 0.28536968717535427, 0.19161120859926084, 0.1956002991913458, 0.17423439818201836, 0.1842472022426206, 0.18789316578934478, 0.19190632884924397, 0.186779811638501, 0.17180962058061033, 0.19512627348051748, 0.18956091467473135, 0.08592689525107455, 0.08207858610952334, 0.07451703071370486, 0.08552617851002631, 0.08177190389157407, 0.07089584908429702, 0.08013080605031175, 0.09162866426642435, 0.08028393472805218]}, "mutation_prompt": null}
{"id": "02e59417-e1b9-4c70-be50-dfa68b0b8fe0", "solution": "import numpy as np\n\nclass HADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = min(100, self.budget // self.dim)\n        self.pop_size = self.initial_pop_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.2 * np.sin(np.pi * self.generation / (self.budget / self.initial_pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness) + 1e-9)\n        self.mutation_factor = 0.4 + 0.6 * np.cos(np.pi * generation / (self.budget / self.initial_pop_size)) * diversity\n        self.crossover_probability = 0.4 + 0.6 * np.sin(np.pi * generation / (self.budget / self.initial_pop_size))\n        # Dynamic population resizing\n        if generation % 10 == 0:\n            self.pop_size = max(20, int(self.initial_pop_size * (0.5 + 0.5 * diversity)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC_Improved", "description": "Introduce dynamic population resizing based on convergence and enhanced adaptive parameters to accelerate convergence.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 100 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 100 is out of bounds for axis 0 with size 100')", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {}, "mutation_prompt": null}
{"id": "750affe6-ebbe-4caf-8703-9288f4c859ad", "solution": "import numpy as np\n\nclass HADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        dynamic_factor = 0.2 * np.sin(2 * np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - dynamic_factor) * (b - c) + dynamic_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / (np.abs(np.mean(fitness)) + 1e-9))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / (np.abs(np.mean(fitness)) + 1e-9)\n        self.mutation_factor = 0.4 + 0.4 * np.sin(2 * np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.4 + 0.5 * np.cos(2 * np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC_Improved", "description": "Integrate dynamic mutation strategy and enhanced crossover adaptability for faster convergence.", "configspace": "", "generation": 20, "fitness": 0.22746955980477243, "feedback": "The algorithm HADE_RMC_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6388051217156815, 0.6073313870351182, 0.6381012829182788, 0.6313611564063145, 0.6343089241322705, 0.6306422327914254, 0.6296553681875774, 0.6311376048239253, 0.6329211139768163, 0.3553626674205518, 0.3492723384356111, 0.3381552187550274, 0.36607054307473563, 0.35270866756752006, 0.3451521517094164, 0.32472086562032376, 0.3516322004519451, 0.3250314196534938, 0.20695986471512395, 0.18022215995089774, 0.2002722881204565, 0.21703589960411673, 0.18891878502648096, 0.2118949601377198, 0.21761336603433434, 0.21195862105698393, 0.22889828979530902, 0.15245785568681136, 0.15639812221384763, 0.17441057512743408, 0.1631618854872562, 0.13711889650050213, 0.1618624076983608, 0.14742848175504275, 0.1721819895210217, 0.14576108529520004, 0.8030938133424814, 0.7635813421169511, 0.7571384149013598, 0.8409404150739506, 0.7779133083870771, 0.8675341775420141, 0.8902776408426427, 0.8699850257759077, 0.8262062616806298, 0.18506028440791444, 0.13034936852870505, 0.16965587799002202, 0.214836932424034, 0.17837737303830747, 0.17306097421014566, 0.15624930026276596, 0.1470665530896762, 0.1965122961222291, 0.280770130704172, 0.2396070530121155, 0.23835635073734251, 0.36548097204598584, 0.3230734854772913, 0.26740929649852185, 0.2846002646956407, 0.30519409422799293, 0.28398808459404556, 0.15535811697645308, 0.13865247402881764, 0.1516531003089323, 0.17641491974924994, 0.1364384479229731, 0.1709597648954485, 0.1443021413421236, 0.177083519806583, 0.13280402724586982, 0.1320079400939438, 0.1104145581578756, 0.14291524062302885, 0.13568369050376028, 0.1218148111325883, 0.1186082263638305, 0.1556856094643092, 0.13776412080384648, 0.1395208561792468, 0.00019917177877759595, 9.999999999998899e-05, 0.04144158620633731, 0.0009642803495131247, 0.0011831049958295203, 0.00017970865714977968, 9.999999999998899e-05, 0.014267153668529153, 9.999999999998899e-05, 0.10677700035370741, 0.08356296459632717, 0.09202047770383104, 0.09104377613027648, 0.06406361738212196, 0.0694157559727433, 0.11299280591138572, 0.07941894690791318, 0.10123312854671518, 0.020098234925201575, 0.0031631174259501016, 0.010139542061474272, 0.0003639388055620696, 0.006126173209136332, 0.00041714685980254185, 0.021581133046146728, 0.006597972687562459, 0.008752868448487994, 0.08116006327081937, 0.09327941870133749, 0.05775578309990492, 0.0815950894583044, 0.16246524773926208, 0.09016815947637657, 0.08433732076544331, 0.09567921071386953, 0.09410427607371841, 0.4243154090652874, 0.43219337400265245, 0.43556449020306687, 0.38464816746876596, 0.4021423182797199, 0.42867546610245433, 0.4065060582418648, 0.4104109465383631, 0.40570504056156576, 0.11132108894385184, 0.1144671786362862, 0.11368601646826881, 0.11023955448985945, 0.11343690413959628, 0.09367442118457381, 0.09716026648119336, 0.13054968273221768, 0.11625960907182742, 0.1823891710415283, 0.14205795458598225, 0.16358437062391928, 0.18027330068950198, 0.14943962934431088, 0.1359233643884563, 0.17095534746629004, 0.13780902004744533, 0.14937812624144187, 0.27682923796453696, 0.2489800024157779, 0.25338515616839996, 0.2599068899458741, 0.28158133592705514, 0.26614717855718273, 0.2805840302261935, 0.2828136443035376, 0.27969032346238065, 0.1802130737045129, 0.17702569633944532, 0.2040796356662694, 0.18592179871220849, 0.21798923057522912, 0.20346465322822938, 0.1976034262288865, 0.21578922092201291, 0.17869241903187216, 0.20350229272512665, 0.2001824639517984, 0.19338150161881784, 0.1857081358162206, 0.19497638904965708, 0.19798385334629387, 0.2399669745299633, 0.20126259668269386, 0.20582358427635972, 0.19218747655473445, 0.1949801530689408, 0.19271848403306913, 0.2085436898672436, 0.21623435382804668, 0.24738718586231345, 0.23532593251499412, 0.24440151505846652, 0.20157280223129148, 0.2014398722907751, 0.2060861365067055, 0.36722997759268206, 0.316117458589786, 0.19152104742420628, 0.44489442857250994, 0.3204057878068044, 0.19480822863871472, 0.29334963081520726, 0.2329539858216103, 0.1782204621286524, 0.2560306632092594, 0.20798419032905047, 0.21128004487061147, 0.2650185747520375, 0.10275564248827485, 0.296297706064635, 0.35693057399874417, 0.19141507712820616, 0.19271322685355596, 0.18463567232585387, 0.18710071396838845, 0.18275291670152882, 0.19390864385148032, 0.18580067818991386, 0.20965629662801566, 0.18995896815146218, 0.08325784971077299, 0.07694916051052225, 0.08368570243414775, 0.08213102330478728, 0.08067819745395644, 0.07778273007999992, 0.07814311185729517, 0.08922637385676413, 0.08252691582674432]}, "mutation_prompt": null}
{"id": "0a6fdc00-9b76-4bae-82ab-b52ee265a86c", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        # Dynamic mutation scaling with cosine schedule\n        scalar = 1 + 0.1 * np.cos(np.pi * self.generation / (self.budget / self.pop_size))\n        mutant = a + self.mutation_factor * combined * improvement_factor * scalar\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Enhance DE with dynamic mutation scaling using cosine scheduling for improved exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.29387780305646083, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6477547240449977, 0.6595963066264285, 0.6614270451579125, 0.654287940771703, 0.674830567017644, 0.6503036938364464, 0.6563355833967894, 0.653839687522297, 0.6647976117935062, 0.39259382655735786, 0.38171176391011663, 0.4248143079716482, 0.38670035861666574, 0.41435681818147285, 0.4124616387236102, 0.3678162558834239, 0.4117640496595498, 0.3920618515153069, 0.11420128336125746, 0.11767647566730155, 0.10284473017183304, 0.10178166310063896, 0.10078967923251692, 0.10562585240414868, 0.09977473540192683, 0.1102249744182967, 0.104014155781185, 0.09099741947383733, 0.09591502350415337, 0.10436300315973168, 0.0959622691732136, 0.11062507703799751, 0.09330036853596635, 0.09618884534651428, 0.09509144636038569, 0.0990190005703987, 0.7393254647274543, 0.7268990734407212, 0.8412351249674905, 0.8841934287066288, 0.8951925433178709, 0.9083606439143256, 0.9019058541939252, 0.8055136472570682, 0.8901413712210389, 0.21491003415601262, 0.21571285332676982, 0.20967188459956165, 0.22175266173313624, 0.18400154504947341, 0.2112937425623701, 0.20840244354586135, 0.22127503514650038, 0.276484014532587, 0.6362612335614908, 0.6301754205430801, 0.6352267519361829, 0.6562831457601872, 0.6447683352802254, 0.6395091314459294, 0.6291125717144228, 0.6669189099613287, 0.6373622841175205, 0.14050281553876065, 0.14505045315188003, 0.13416155714500344, 0.14923335786609426, 0.31512934117289226, 0.16164211787042126, 0.16358968005323515, 0.18840940172038456, 0.18095965218260235, 0.1523350546495742, 0.15277600380808076, 0.12815961628442363, 0.18496793294886427, 0.17902812749635144, 0.13204367441731157, 0.21195411469175662, 0.1464723935649912, 0.12628911856376257, 0.12549712870875596, 0.24711340658812897, 0.11803432967119987, 0.22783950124853258, 0.25443576048510963, 0.09582753602181926, 0.22374663619592838, 0.09273600545713867, 0.25429083142978504, 0.3144395708031542, 0.3362744681081644, 0.35489855193206565, 0.32299609339795265, 0.29353284977001026, 0.2824040686817906, 0.3498923921141843, 0.3420704420583208, 0.36587570496589006, 0.09520031730563283, 0.0904895901553946, 0.10325867999143701, 0.10883215170047478, 0.07893717475255613, 0.14094267706837638, 0.11930290623722017, 0.13091536468154918, 0.11498981865536029, 0.2188385011929217, 0.2052516328181121, 0.22071969683509118, 0.25242599737881377, 0.247112957019603, 0.2347986002134429, 0.2130115300975065, 0.23717631908465953, 0.20383785958972023, 0.5548998276469097, 0.5335334104458695, 0.579862278968289, 0.5614469150772263, 0.575988711027323, 0.5397750650440669, 0.5522659096677969, 0.5462081936002288, 0.5453883558778225, 0.0908995157771797, 0.09801979620929846, 0.09851741769777889, 0.09153271022545562, 0.08491803752750726, 0.09742954905591472, 0.12899885009704137, 0.11440337555814184, 0.11404413493781107, 0.1567701030975006, 0.15953824000979244, 0.14400343556652584, 0.13811497790262506, 0.13589834181051064, 0.13715072791759408, 0.15628678780074956, 0.13516944426092958, 0.15859778763991472, 0.33678966740089067, 0.3284207065279856, 0.34935013009498406, 0.33125862323069355, 0.33712296216121784, 0.33434086580325373, 0.34263347154804025, 0.36688350114932133, 0.32087970561497103, 0.2769430100577387, 0.270793900002811, 0.2946308941645652, 0.26706515281183485, 0.2619755033448181, 0.2748079095627399, 0.2647446565165815, 0.2693074515479863, 0.2666810667418854, 0.19170379102862145, 0.19337686673958066, 0.20283286240975418, 0.18429704021508664, 0.2152666208924373, 0.2036908887020492, 0.18873776858477753, 0.19358037476422874, 0.1911999793519783, 0.18432609346652973, 0.1801013226647552, 0.17832719746357528, 0.17528640187602884, 0.1910898802675426, 0.175581185071509, 0.19350779863945577, 0.19338302101645521, 0.18117709454743558, 0.17565932474851143, 0.5753999372762933, 0.5905799622328685, 0.7141474439633453, 0.23498084275512177, 0.6568953209410839, 0.5825427021468748, 0.36752083127934965, 0.5933470813813968, 0.1865325390022855, 0.19088157185179933, 0.5141693185399548, 0.47825855045400645, 0.18434198525985834, 0.5071643893139628, 0.1981212375317184, 0.5997332549231178, 0.24870239972077057, 0.18444189762266328, 0.19678767570057742, 0.17835382062944105, 0.18461702312587247, 0.18540331826291312, 0.21956319541633806, 0.18962155109775047, 0.1952754279611989, 0.1756565606196684, 0.07511684868877277, 0.08542336776609094, 0.07436904466866179, 0.08153595896340626, 0.0805637749857755, 0.08489844859766782, 0.08409740103158858, 0.08760603851514026, 0.08514749663822496]}, "mutation_prompt": null}
{"id": "0a883a7c-d364-4fa5-b7f9-e6729a66292f", "solution": "import numpy as np\n\nclass HADE_RMC_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.7\n        self.crossover_probability = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n    \n    def dynamic_population_scaling(self, generation):\n        scale_factor = 1 + 0.1 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        self.pop_size = int(self.pop_size * scale_factor)\n        self.pop_size = min(self.pop_size, self.budget // self.dim)\n    \n    def chaotic_mutation_operator(self, generation):\n        return 0.7 + 0.5 * np.abs(np.sin(generation))\n\n    def mutate(self, population, best_idx, fitness, i, generation):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        chaotic_factor = self.chaotic_mutation_operator(generation)\n        combined = chaotic_factor * (b - c) + (1 - chaotic_factor) * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / (1 + np.std(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / (1 + np.abs(np.mean(fitness)))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.6 + 0.4 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            self.dynamic_population_scaling(self.generation)\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i, self.generation)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC_Enhanced", "description": "Integrate dynamic population scaling and chaotic mutation operators to accelerate convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 100 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 100 is out of bounds for axis 0 with size 100')", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {}, "mutation_prompt": null}
{"id": "af7884f7-193e-4d0c-aefd-f4b359f3f631", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.3 + 0.7 * np.sin(np.pi * generation / (self.budget / self.pop_size))  # Adjusted crossover probability range\n\n    def sort_population_by_fitness(self, population, fitness):  # New function for sorting\n        sorted_indices = np.argsort(fitness)\n        return population[sorted_indices], fitness[sorted_indices]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population, fitness = self.sort_population_by_fitness(new_population, fitness)  # Sort population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introducing dynamic crossover strategies and fitness-based population sorting for improved convergence speed.", "configspace": "", "generation": 23, "fitness": 0.2783159963607294, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.6618011610786696, 0.6590164995440086, 0.6542287614449378, 0.6589712500393775, 0.6564144890933841, 0.6537226687396901, 0.6622620317426127, 0.6415301848096395, 0.6729457514341952, 0.34982168061719365, 0.38688447472790666, 0.38288954022088995, 0.3628318016857278, 0.3699165400136606, 0.40251154681495116, 0.32019815100945925, 0.395242425722257, 0.38533013792246806, 0.10531083070995972, 0.11076181220596337, 0.114299746613159, 0.11267183103722944, 0.11372701101972782, 0.1099080848635291, 0.1221164311499704, 0.10907022503697139, 0.11781634554055109, 0.09749008834715167, 0.09278782832117394, 0.10686640663834845, 0.09667187171256186, 0.09940389448862719, 0.10049846519889638, 0.10162696935942017, 0.10153423377547788, 0.09940459096067988, 0.7954234788857625, 0.852596965505792, 0.8616120554908163, 0.8668019482383702, 0.822321455720513, 0.8767236584557558, 0.8403139768154508, 0.8590956971193342, 0.8139186017733524, 0.13063403398468598, 0.16502842770243842, 0.1749857192070956, 0.15674946892534458, 0.2201112572816709, 0.1355919211791855, 0.1782693185104759, 0.17581941983556404, 0.14974895054188142, 0.563817069303234, 0.5944515725026942, 0.6073198962043275, 0.6314281979577675, 0.6205463721226964, 0.6733996023321008, 0.5918235012142689, 0.6161860648583837, 0.6402025563456966, 0.14981821972350007, 0.16705962855548528, 0.128349031320514, 0.14208914665214922, 0.16414122272366494, 0.1390408340589001, 0.12856000777973076, 0.16078303196155397, 0.18920113431141572, 0.1472045072675905, 0.16175419619560294, 0.13113741750135355, 0.20774273628384177, 0.1678424823817226, 0.14227552792118658, 0.17501076277898686, 0.1253327475610877, 0.13099127305160196, 0.14279386734274035, 0.16008790947804974, 0.1444239363221057, 0.20977150211030593, 0.056460274841182545, 0.06047626351497415, 0.208682564882533, 0.12838432370580322, 0.058892934675398245, 0.311134440167228, 0.29494936759958046, 0.30501021473055767, 0.2894618978019926, 0.17206536616052415, 0.31356779347954833, 0.28865863483486975, 0.34960932715524795, 0.34123297916922224, 0.0647836336866161, 0.10929485006911077, 0.09800586366002084, 0.05357783207402933, 0.06747469463717226, 0.08966442229270155, 0.077576154957267, 0.13213399334353038, 0.11289154831129145, 0.1904609029976264, 0.1935762102736297, 0.19145685278436897, 0.2051513063546908, 0.2156824082204818, 0.20011573499451374, 0.1911912805298327, 0.19826769359167995, 0.2052425030052839, 0.5594003290508415, 0.5397963410885309, 0.5476532673309291, 0.5505671819213453, 0.5316149010178346, 0.5462191194082846, 0.5609754559323101, 0.5155798412603083, 0.5450821309100911, 0.09735023987764124, 0.0920342094245209, 0.08435495074441046, 0.1072079346404371, 0.08833442443978534, 0.106407494070352, 0.09377696239431388, 0.12466504372795462, 0.12218024087810975, 0.12702126968660032, 0.13705843259263073, 0.13536842761849655, 0.1405854415495269, 0.14817339107601313, 0.16043069337464366, 0.1292216402282369, 0.13325721335790963, 0.14276478074235566, 0.3277932193439428, 0.30962352881437893, 0.32767666576919663, 0.32204929209436073, 0.31892963839729505, 0.3247971228335561, 0.32169251283121814, 0.3267454807505462, 0.31384322022827005, 0.2573807740038284, 0.2642799415174597, 0.2607669214809858, 0.2650092056281763, 0.2647016560790606, 0.2698942001296917, 0.25498648628297094, 0.2677438967595114, 0.24837414633898303, 0.1991029956183249, 0.19958836601678664, 0.20664183196379482, 0.2083273988861809, 0.19817157038808453, 0.2240055398857851, 0.19030378544683568, 0.19392326757654732, 0.18918645571158377, 0.17370512450140851, 0.17583937751252177, 0.1717986927226135, 0.18527028109967547, 0.18223101850661627, 0.17740680599092107, 0.1747971779426878, 0.18617425755438577, 0.18524262548632842, 0.5815785222478291, 0.4981809631325065, 0.5065159444708931, 0.6155704340079571, 0.6323761130969682, 0.6485292373232581, 0.3988391336516943, 0.4992390284509316, 0.46900607851452825, 0.4635412740083633, 0.23393933580369763, 0.246948909739246, 0.18311072733799272, 0.1927905201512743, 0.18605687812629745, 0.1912360516764665, 0.16025904043285633, 0.2557685840072208, 0.18822370278772327, 0.18285577745355241, 0.1835417921391902, 0.18209485299719252, 0.19432342182525486, 0.18679713029570377, 0.18283493006480445, 0.1909513441783034, 0.19761602143019263, 0.082352875924112, 0.08385631484967848, 0.073872824845031, 0.07456953088619123, 0.07997716337922667, 0.08460768573453292, 0.08942518477327399, 0.0810570270475589, 0.08477267324644022]}, "mutation_prompt": null}
{"id": "e7b2fa99-1063-4e73-bb70-164555dbe2ac", "solution": "import numpy as np\n\nclass EnhancedHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(len(population), 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / len(population)))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def dynamic_crossover(self, target, mutant, fitness, i):\n        dynamic_crossover_prob = self.crossover_probability * (1 - fitness[i] / np.sum(fitness))\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / len(self.population))) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / len(self.population)))\n        \n    def __call__(self, func):\n        self.population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = len(self.population)\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget * 0.5:\n                self.population = np.delete(self.population, np.s_[::2], axis=0)\n            new_population = np.copy(self.population)\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(self.population, best_idx, fitness, i)\n                trial = self.dynamic_crossover(self.population[i], mutant, fitness, i)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            self.population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return self.population[best_idx]", "name": "EnhancedHADE_RMC", "description": "Incorporate dynamic population size adjustment and novel adaptive crossover to enhance convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 7 is out of bounds for axis 0 with size 6').", "error": "IndexError('index 7 is out of bounds for axis 0 with size 6')", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {}, "mutation_prompt": null}
{"id": "6aafca2b-4478-42da-9872-217f101be891", "solution": "import numpy as np\n\nclass Modified_HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = min(100, self.budget // self.dim)\n        self.pop_size = self.initial_pop_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        dynamic_mutation_factor = self.mutation_factor * (1 + 0.5 * np.cos(np.pi * self.generation / (self.budget / self.pop_size)))\n        mutant = a + dynamic_mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        new_pop_size = max(10, int(self.initial_pop_size * (1 - 0.5 * diversity)))\n        if new_pop_size != self.pop_size:\n            self.pop_size = new_pop_size\n            return True\n        return False\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            if self.adaptive_strategy(self.generation, fitness):\n                population = self.initialize_population()\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += self.pop_size\n        \n        return population[best_idx]", "name": "Modified_HADE_RMC", "description": "Incorporate dynamic population resizing and adaptive mutation variance based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 89 is out of bounds for axis 0 with size 89').", "error": "IndexError('index 89 is out of bounds for axis 0 with size 89')", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {}, "mutation_prompt": null}
{"id": "e37844ba-2384-4c8d-8d06-b3ceaa476b1f", "solution": "import numpy as np\n\nclass CHAOTIC_HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.7 + 0.3 * np.sin(np.pi * np.arange(self.pop_size) / self.pop_size) # Chaotic Mutation Factor\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        chaotic_factor = np.abs(np.sin(4 * np.pi * self.generation / self.budget))\n        combined = (chaotic_factor) * (b - c) + (1 - chaotic_factor) * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / (np.abs(np.mean(fitness)) + 1e-10))\n        mutant = a + self.mutation_factor[i % len(self.mutation_factor)] * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / (np.abs(np.mean(fitness)) + 1e-10)\n        self.crossover_probability = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "CHAOTIC_HADE_RMC", "description": "Enhance exploration by incorporating chaotic sequences and adaptive parameters for improved convergence speed.", "configspace": "", "generation": 26, "fitness": 0.16084171014561033, "feedback": "The algorithm CHAOTIC_HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.34429421700568874, 0.5479022718866295, 0.498194208129338, 0.2467824144495414, 0.3236574265803146, 0.38902286863436597, 0.3404993789502003, 0.3324879582304465, 0.2690136112258882, 9.999999999998899e-05, 0.0019090028456248964, 9.999999999998899e-05, 9.999999999998899e-05, 0.010091137171163611, 9.999999999998899e-05, 9.999999999998899e-05, 0.09615360942638906, 9.999999999998899e-05, 0.14014559331995347, 0.3046879603362097, 0.17167006142657992, 0.11086646006933465, 0.11470127805049857, 0.07169470261007682, 0.175227168080771, 0.12431744071280659, 0.12352621651220275, 0.13198201662985953, 0.08776614636983648, 0.113160456412012, 0.06866883617125807, 0.08497310891385135, 0.09806546123996307, 0.1390888720873691, 0.07803021690167211, 0.10291825768491858, 0.09059430079304298, 0.09123355223642082, 0.07088813358149149, 0.10180081373157612, 0.11050150585409169, 0.0854999784719408, 0.08566032610776197, 0.09309263565156722, 0.1149154141583234, 0.06530578844152846, 0.08751925036876707, 0.10779537947194984, 0.07941705995272186, 0.061889709018570604, 0.05764151187553346, 0.05832971174436119, 0.08729638170965814, 0.08660840957094806, 0.21418889047549916, 0.3884722126040627, 0.9062256070254652, 0.25905434117149584, 0.2734353619406572, 0.16310278081341745, 0.2838622695969666, 0.23278756777791398, 0.1616907392498218, 0.14371280900473482, 0.12982781393563525, 0.011336241134468183, 9.999999999998899e-05, 0.08342091712396904, 0.021462258498174736, 0.197793979595157, 0.08035882870436994, 9.999999999998899e-05, 0.12446139818828084, 0.12720588030005497, 0.12208843181440365, 0.1763519916659798, 0.13414502173657472, 0.16913108372327512, 0.14731322463646024, 0.11047146350813586, 0.12227000073667327, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09362341191251089, 0.05472709102710871, 0.1008478521540237, 0.0617152189094875, 0.17795005019412713, 0.015924986362251592, 0.1297551457398799, 0.09438213318595756, 0.028304959678971175, 9.999999999998899e-05, 0.05008017386226615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051366854979989496, 0.0038030777246110814, 9.999999999998899e-05, 0.07255084205280671, 0.02532463269081453, 0.127650335575897, 0.03064606058358965, 0.06088644342167171, 0.030306989068685453, 0.42361541296302796, 0.4553622670501344, 0.35240408844648563, 0.283053829795081, 0.2371331309521889, 0.24006666265997745, 0.25619815949802205, 0.44740829464309906, 0.27450426940281436, 0.09555597955921313, 0.11116668136362695, 0.08465531303217744, 0.09707933215501219, 0.07087104304269398, 0.11732795572625254, 0.09275749516965082, 0.08577730838255615, 0.08463090798315132, 0.19003476887761295, 0.18835408682574117, 0.1718990524426003, 0.21195774168209236, 0.3433734470257601, 0.2435181539239355, 0.2907602795713953, 0.24653885821066934, 0.1388463713803274, 0.2415844351108284, 0.20356889128305122, 0.22685524858097472, 0.30893316822782724, 0.25027434729103903, 0.2652451430931383, 0.2383238945824151, 0.253740889628578, 0.17934962328096093, 0.24105573781429013, 0.26078974793819787, 0.2582411202882522, 0.28538644769793886, 0.31508063313355084, 0.2848194807308946, 0.20823133970737462, 0.2092153049714589, 0.14675337019928758, 0.22845481923291622, 0.20583680552108918, 0.2375887407147116, 0.2819461185113167, 0.2108331094437771, 0.2272284066733764, 0.26441260450993676, 0.2471722257856519, 0.22908828814447202, 0.1971351638285873, 0.19171427255639806, 0.20657483135900057, 0.19355720965752965, 0.18779906843066663, 0.17776543608533069, 0.19146063873767283, 0.17614980817066972, 0.18280725438063927, 0.18649300127978286, 0.1874429718077366, 0.1575742852624531, 0.19332804458809583, 0.18055616980388345, 0.1432280505673843, 0.1413241299736797, 0.14741892279885072, 0.3566619895374441, 0.40231627885861243, 0.21185697204643816, 0.523132084148, 0.5111937311552712, 0.16520365956657534, 0.5087294247429366, 0.1559717551727703, 0.29879641983741523, 0.43054160095396854, 0.17987389859274894, 0.1928536836070912, 0.17898894450110003, 0.2244968001101072, 0.18288495369443825, 0.18514749949282983, 0.19865262174602782, 0.1985448420929805, 0.17602115556573916, 0.08810108847727738, 0.13708989913350267, 0.09769549322113724, 0.09859004331127141, 0.1039326393553549, 0.09457699984403467, 0.0983090853595846, 0.09072936990425917, 0.08962076938062691]}, "mutation_prompt": null}
{"id": "c5305158-ad82-449c-bb55-f727314cb3bc", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, diversity):\n        cross_points = np.random.rand(self.dim) < (self.crossover_probability * diversity)  # Dynamically adapt crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        return diversity\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                diversity = self.adaptive_strategy(self.generation, fitness)\n                trial = self.crossover(population[i], mutant, diversity)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Introduce dynamic crossover adaptation based on population diversity to enhance exploration capabilities.", "configspace": "", "generation": 27, "fitness": 0.2208855757536893, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.5907338101219699, 0.5906674943318279, 0.5878159062018755, 0.5914835121167977, 0.5897098457123626, 0.5985020590607872, 0.5934394942425518, 0.5778088337985172, 0.5988576774970293, 0.3657320224025189, 0.35062735372244214, 0.3360252786197868, 0.3182413776798003, 0.35943865108775963, 0.3291646855384559, 0.32811353260359966, 0.3366285261190911, 0.316635632611338, 0.2244302851795854, 0.22612922789790246, 0.21172873781067691, 0.22635007707611243, 0.22100856873481423, 0.23265340116120503, 0.23724839519251317, 0.2067923626304421, 0.20046220473613385, 0.18133370881396582, 0.15979237823505832, 0.15256261391185222, 0.15025461997225098, 0.1862811291313129, 0.14064879044184186, 0.17250508586673363, 0.17611552508044737, 0.16641163261034708, 0.8425047630859195, 0.8089085040584884, 0.8128247496707945, 0.8827520826810492, 0.8638792239918581, 0.878679461355138, 0.8904225433511401, 0.8756138157218585, 0.8513236363658164, 0.18579608193596764, 0.17441116053738026, 0.14625684133438444, 0.16942022813731672, 0.16074543203074476, 0.16712131199257474, 0.13047713096739366, 0.12979492605360898, 0.1468149557627959, 0.16353576057907704, 0.1629234151260951, 0.1731407639118775, 0.28027470638103513, 0.24130586740546645, 0.2278907036678175, 0.21170032764209012, 0.23202169584270438, 0.22216947199312553, 0.12958895193813846, 0.14580147291403867, 0.14613654245907803, 0.16526473973347988, 0.12967921656806736, 0.12851201811938084, 0.14996053386534036, 0.13499295720951032, 0.15713284822294538, 0.14404487092964113, 0.13501206121599318, 0.1278066884937783, 0.12678227011503274, 0.1299513163775471, 0.1450635892904395, 0.13275219578835928, 0.15567365471967864, 0.14062569050123275, 0.09643620239571649, 0.0484690991527279, 0.05755034767892886, 0.02715848483811878, 0.06745978300714417, 0.011322636615401227, 0.02512275289071708, 0.020759215640077544, 0.026033843723378913, 0.10303019938588709, 0.12707789432736372, 0.08979381645633167, 0.1409569361543649, 0.15815910709016756, 0.17260359292452032, 0.1460297720616328, 0.16256071292365593, 0.134714158939102, 0.02015689765591322, 0.038897276118490476, 0.027204745928258833, 0.05163892787753377, 0.012280769642893263, 0.02999089255527909, 0.03159763351104394, 0.027326396577275425, 0.05600643175694053, 0.0691389201597703, 0.05853580928565438, 0.09022955946466316, 0.10062886400399362, 0.08948694956923231, 0.10192785970034746, 0.08827892334022891, 0.08256389128476149, 0.07050728645453619, 0.40438115055141055, 0.363733113877482, 0.3682473406608291, 0.3611147072183818, 0.349591744262858, 0.34738888917829336, 0.36922571307407326, 0.35698146524008767, 0.3744733822969274, 0.09800118006489633, 0.11135716930417217, 0.08093481275505843, 0.07738001995241717, 0.07460183841356882, 0.0850090858586362, 0.10652472809851132, 0.10113086671266391, 0.10965907502070327, 0.14960965777478108, 0.1463935004558281, 0.14754487150688078, 0.14607124864287147, 0.1744374208371986, 0.14034609919487795, 0.16438087156822, 0.15582599891209448, 0.1558693310018474, 0.22585464146597412, 0.21232164156474875, 0.25129316845175653, 0.20778845563723491, 0.204074500235646, 0.21216397604262338, 0.20380976307030207, 0.21068835741026448, 0.22124317027572826, 0.17556494855665972, 0.17438063296924577, 0.1774960936341573, 0.16209058897740836, 0.15574341008398518, 0.16016891464195282, 0.16521599803967602, 0.1509868192720336, 0.14379962968175564, 0.1796779821810176, 0.19828668183218157, 0.18951705419035092, 0.1938447257605529, 0.19421904404507173, 0.21676962453803206, 0.18983046601368359, 0.175103819558861, 0.18570189821039484, 0.22070140624068613, 0.20126823829558094, 0.20138588326225082, 0.19888562078538952, 0.19764244830828126, 0.20459011331654142, 0.21963176906032877, 0.22059846246699089, 0.21021928361394515, 0.21913144220039882, 0.1668275781351627, 0.24552720815128304, 0.48768448214344795, 0.4414805753328537, 0.36349310731173246, 0.21903797393800495, 0.19678098417464096, 0.2734921803516338, 0.2645828770768104, 0.22496066810445414, 0.2577522829895966, 0.24611806517722912, 0.1513003001187221, 0.1903517705766331, 0.19955521295220546, 0.28945866351812855, 0.30816858553778115, 0.1765811310225498, 0.18906200496044145, 0.19954946823996156, 0.1751665179469032, 0.20343298657447673, 0.18501418231757083, 0.21192680416451792, 0.18645484970204185, 0.19600196507279088, 0.0721651322044814, 0.07435774115740712, 0.0746982547781807, 0.0779157322027273, 0.07564940518558583, 0.0721982515118953, 0.06632784103443679, 0.07092106785280461, 0.07392034586156748]}, "mutation_prompt": null}
{"id": "78087743-5829-4593-bb4a-dcde57576cae", "solution": "import numpy as np\n\nclass HADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        lerp_factor = 0.1 + 0.1 * np.sin(np.pi * self.generation / (self.budget / self.pop_size))\n        combined = (1 - lerp_factor) * (b - c) + lerp_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "HADE_RMC", "description": "Enhance mutation diversity by integrating fitness-proportional selection of base vectors to improve convergence speed.", "configspace": "", "generation": 28, "fitness": 0.3249211571085028, "feedback": "The algorithm HADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f4fdd518-2fb6-4d5a-b9db-16a2185babd9", "metadata": {"aucs": [0.7350615187847264, 0.691309334364039, 0.7065587210296358, 0.7113230598327216, 0.7065247632058544, 0.6902495359825314, 0.6942827413829097, 0.7031529372697971, 0.6845993414738907, 0.5483561501024248, 0.5325117972634683, 0.5013325616164106, 0.5828896430139132, 0.5578878473302189, 0.5831063685558824, 0.5586190343008869, 0.543002510399482, 0.5529608957535892, 0.31535372486748525, 0.23934478592823605, 0.12671697709436303, 0.2512165839288353, 0.13108384975650245, 0.19114583747832636, 0.13603170060918113, 0.13569025557001113, 0.12966662122824058, 0.10791382574154307, 0.17213400933967604, 0.142955557518055, 0.10519328251014182, 0.12019564850327003, 0.11517441708232312, 0.14644885372812555, 0.12708331244676863, 0.1419477448402442, 0.919487706940757, 0.9390182007093054, 0.9300467070335335, 0.8952165331558966, 0.8999440715434814, 0.9650933991109787, 0.9330214537541341, 0.9386031559034425, 0.9178266767738077, 0.34343184263700355, 0.31461214868725296, 0.35461517206625415, 0.23504832267553644, 0.3654915421396576, 0.32255891762481437, 0.31083796496607574, 0.32426817782750217, 0.31158926180593194, 0.7016906412272546, 0.7440153001985796, 0.6931251346289429, 0.7313954939768408, 0.7259980541082498, 0.2832062574109624, 0.6879825825664794, 0.6245315493712753, 0.6622717166778792, 0.15737809822062498, 0.4435973138029128, 0.4932397436507032, 0.12342669978284537, 0.12484565272440762, 0.5442226724153767, 0.18723069881436027, 0.11055624842721012, 0.19037748357401052, 0.14067433484451664, 0.14587944276389386, 0.1763189774551691, 0.18038094982951802, 0.17417477095792133, 0.12802462971591844, 0.12705576622748338, 0.17737099864602313, 0.18015397084552964, 0.07310607138451708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06143242938837501, 0.04802692494667504, 9.999999999998899e-05, 0.2087853157471049, 0.03411774609256135, 0.13749625522241327, 0.11279571799978372, 0.0916088860306088, 0.040255331683183626, 0.3297266854872556, 0.23857274369917425, 0.3968956521919976, 0.04142997877325927, 0.033190696144653864, 0.219413232903779, 0.06625769643588741, 0.1557106402602445, 0.11028655518031794, 0.2801801140864645, 0.13709944900850624, 0.09497663534186085, 0.29492407196139214, 0.3194644128804669, 0.33191635671944675, 0.34776765067572424, 0.12193022757535688, 0.2342993991150869, 0.31101083583930045, 0.221243503859206, 0.23704754920215843, 0.6051440437133104, 0.6243701769486139, 0.6058221660008736, 0.6234392078104141, 0.5893352238192135, 0.5907518401118756, 0.6065116478462325, 0.5870857008472277, 0.6134419998489805, 0.1362226401743183, 0.09699000237363653, 0.13062367708610367, 0.11351651570451526, 0.11538863790233078, 0.3405251032771657, 0.09081553140872656, 0.10150661860115584, 0.10876279840690017, 0.3373087992691901, 0.19694482944665392, 0.1883736056316968, 0.18672676285805456, 0.20910098808788802, 0.16211830407652417, 0.14889578513196577, 0.1535252533945628, 0.26827107060488053, 0.36223931643648843, 0.35461552816796726, 0.384471338396848, 0.3801173400633132, 0.358322546387713, 0.35613336561550035, 0.3726545267079211, 0.38173008676293807, 0.3838300059635493, 0.34771125522981483, 0.34258695329845634, 0.34027628441046587, 0.2856895001942904, 0.3282190213570164, 0.3305842614093827, 0.3296369669181448, 0.32195225857912113, 0.3203538721562421, 0.20235032357696847, 0.19720885948420508, 0.21745101667083944, 0.21896470795459855, 0.18816973643720925, 0.18761651939318202, 0.21663470323397638, 0.22270119469073624, 0.21428539469127084, 0.19708314597221765, 0.19430247114539334, 0.2884089087860302, 0.2422635074274221, 0.22304501617430694, 0.21530008520236976, 0.19473764508760827, 0.21576455663240013, 0.21363154323926004, 0.18238971616444555, 0.18227555561758513, 0.7356095567147577, 0.3125572932360401, 0.7659923070514899, 0.8057115702620271, 0.7246166396774094, 0.7404545743708103, 0.7599466661224321, 0.7546221123493503, 0.33009622111651815, 0.6777677520984435, 0.726857082278062, 0.16404284793066903, 0.20513169463539294, 0.1654713262299642, 0.16555981911041873, 0.3112789356258183, 0.19645457731273996, 0.18662025886761802, 0.17714484163677247, 0.1972276296088249, 0.1873471245458882, 0.17653278311830123, 0.18825871247633497, 0.18249498654508312, 0.19100312482982085, 0.08600420849531853, 0.0883749796415424, 0.08494543505468077, 0.09509182601438348, 0.09183798086826556, 0.08457762301286764, 0.08749604234662944, 0.08939176622281342, 0.0887907161181758]}, "mutation_prompt": null}
{"id": "86aa83f3-a4b7-4cff-bcda-d9047cce1e80", "solution": "import numpy as np\n\nclass EnhancedHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(120, self.budget // self.dim)\n        self.mutation_factor = 0.9\n        self.crossover_probability = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def chaotic_mutation_factor(self, generation):\n        return 0.9 * (1 - np.tanh(0.9 * generation / (self.budget / self.pop_size)))\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        chaos_factor = self.chaotic_mutation_factor(self.generation)\n        combined = chaos_factor * (b - c) + (1 - chaos_factor) * (best - a)\n        mutant = a + self.mutation_factor * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.4 + 0.6 * np.tanh(0.8 * generation / (self.budget / self.pop_size)) * diversity\n        self.crossover_probability = 0.6 + 0.4 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "EnhancedHADE_RMC", "description": "Integrate adaptive exploration-exploitation balance with chaotic mutation to enhance convergence speed and solution quality.", "configspace": "", "generation": 29, "fitness": 0.26267261814496656, "feedback": "The algorithm EnhancedHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "78087743-5829-4593-bb4a-dcde57576cae", "metadata": {"aucs": [0.6650561051342871, 0.6782602652606502, 0.6694794940287998, 0.6830216692271063, 0.6530905947006298, 0.6768907229736933, 0.6816609217242695, 0.6602222477769962, 0.6571500727102095, 0.43526905361568546, 0.42502851660183427, 0.3855664379320819, 0.44015527753883843, 0.43302351740457024, 0.4376780124244034, 0.4179124844475547, 0.3825526630038193, 0.41589353536702933, 0.19934729707764387, 0.2057505846689488, 0.14400665046098182, 0.16235137704112634, 0.14866494683421372, 0.1685448024643854, 0.1836392953896019, 0.14597901986681316, 0.14454106272844125, 0.10837182063486162, 0.10972518979741708, 0.11271801066843656, 0.11100125594415655, 0.10997275460443667, 0.11113521776989488, 0.12208095331014068, 0.1281609145747027, 0.11427242874637045, 0.5415484118148024, 0.9497386635068072, 0.8133500957452793, 0.5968497656992771, 0.5877134642754969, 0.5546266003705722, 0.6746460184419648, 0.9342569164273653, 0.5580059909259176, 0.1663688566731747, 0.19069802251240153, 0.14552261226285623, 0.17208180926917593, 0.17996626832890938, 0.14144112382004037, 0.15700235765965576, 0.16038488323909406, 0.2091713520759677, 0.7423017016497249, 0.7232073245664554, 0.6990444666265287, 0.6607099652509265, 0.6940839849932847, 0.6867319147398774, 0.6633410313522619, 0.7180367893780015, 0.6856122296448683, 0.1406082153233983, 0.15687631805907132, 0.17387910799600526, 0.18597585515135817, 0.11960101057902861, 0.1996709796054501, 0.15303579950402202, 0.17920303427925155, 0.15912155951360074, 0.1813390960746427, 0.1476846195663718, 0.14088246346349187, 0.20310379451145633, 0.12983357964678466, 0.17751736881766955, 0.13807034710712252, 0.15665830649080503, 0.14594123772768475, 0.08222953400307398, 0.07991177161564389, 0.09686064543828254, 0.0889902131741892, 0.15822391803352964, 0.09649520867770933, 0.03172529814873082, 0.031683279476561466, 0.03801400516218145, 0.249841091910585, 0.2399444121150568, 0.2771742423952346, 0.11543331428514159, 0.20763174388743466, 0.15252559481848094, 0.2743871477085359, 0.2758282249870676, 0.2757746765885073, 0.021870074239422665, 0.02805049230115142, 0.014999073897735027, 0.01947918494840306, 0.03378236688344183, 0.03988376034362395, 0.04695928908106728, 0.04372234223832183, 0.02965327214614988, 0.15320059289162968, 0.1432858840015433, 0.14153722754369158, 0.14363787592151278, 0.1569694631594024, 0.15339022469572594, 0.15083039044691016, 0.13729024480496188, 0.14780715767820152, 0.47949829024859014, 0.4927483614742768, 0.49153941350422703, 0.4752858072408104, 0.46396553275625885, 0.45167618062167625, 0.4975184530586527, 0.4652049448262341, 0.4999930157582234, 0.10678428336030088, 0.10226050422205113, 0.10079237589756507, 0.10229838766504185, 0.10092856148574314, 0.10776829418095024, 0.07664708888136629, 0.07729590361482985, 0.11577482649097126, 0.13741368570457946, 0.19038504156896408, 0.13748009818627016, 0.14846590379315439, 0.15021224431871127, 0.16453443248685873, 0.16218059019696485, 0.14578947691444977, 0.1640661227783634, 0.34207665113789076, 0.3354442570101386, 0.3478625343465175, 0.3359938874752214, 0.3188191751327605, 0.3289265617934468, 0.3966177779933814, 0.3787189322582142, 0.3827217299022573, 0.25232411495011375, 0.16814332292425138, 0.2537021556445922, 0.27116054783267995, 0.25134983936394606, 0.2605150530579292, 0.27053328084040584, 0.2978390481941927, 0.28334263046998787, 0.22061187870851995, 0.196887420090601, 0.2059510072617321, 0.20515992936398708, 0.20532175501505145, 0.21456372687878766, 0.21490446554297127, 0.20374174476844753, 0.22160089018711793, 0.20389014624895496, 0.15383450754200334, 0.21118019026641188, 0.20661414276625423, 0.2063736424245205, 0.19231327935685927, 0.20258581584562219, 0.3207842275631074, 0.18701214816166978, 0.17719184479066297, 0.1815668914634776, 0.17727076659109775, 0.2989790797598726, 0.3058018302102107, 0.32706494981754886, 0.6219216117676647, 0.2845473833465654, 0.3807006165852215, 0.38222686296789943, 0.19862759992102386, 0.2999140482819125, 0.251725159085027, 0.187207742831904, 0.16063750103926522, 0.19630068042660442, 0.19112061544652326, 0.20059019180482252, 0.19561458517849117, 0.19745576941265686, 0.17525535204701304, 0.18687750918690016, 0.1778036969390776, 0.18743166959675894, 0.17979445149925466, 0.18232531271603014, 0.20956553582016146, 0.08309301616164266, 0.0842573043068745, 0.0840521660047765, 0.08742447034440226, 0.08298510473821208, 0.0835747835409133, 0.08281366949004754, 0.08264517864426013, 0.09034659921958887]}, "mutation_prompt": null}
{"id": "e6eb7182-0a58-4de9-9183-f0a8f40ed1c1", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + self.mutation_factor * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce adaptive learning rates for mutation and crossover based on population diversity and integrate a chaotic sequence to enhance global search capability.", "configspace": "", "generation": 30, "fitness": 0.3256524789411654, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "78087743-5829-4593-bb4a-dcde57576cae", "metadata": {"aucs": [0.7480784229433993, 0.7414064439122494, 0.7427310160191362, 0.7387137029577435, 0.73343256193887, 0.7409284217185081, 0.7467537340380557, 0.7271039776018637, 0.7437437916791978, 0.5492258128506158, 0.5678622389934, 0.5508444992679524, 0.5962495438343491, 0.6085556226445267, 0.6347933513096302, 0.5749762829617715, 0.5805120959743062, 0.5928539033129592, 0.29921843357236555, 0.24152973173451586, 0.3769276917281642, 0.24829632308861727, 0.2405902184060149, 0.37217634086628903, 0.16887820877927173, 0.24402986844778207, 0.15753948858429812, 0.14447379726463927, 0.13847585165320764, 0.1999031846979038, 0.16318859932101804, 0.12487960300041745, 0.14862907907285172, 0.14646532128636192, 0.1551712514444571, 0.2419906655191979, 0.8368905694095933, 0.7895806083009388, 0.9255587431070351, 0.9364176491458132, 0.9063368262938261, 0.920592813066997, 0.9432769683248197, 0.9640755045220606, 0.9067134472959902, 0.3768819623859121, 0.34385535933647093, 0.35125098175699954, 0.3643955338038325, 0.3390496355379051, 0.34877382794299483, 0.3193270847729385, 0.3216059323331638, 0.34851208689143254, 0.7296587392279836, 0.7826396297204324, 0.7584753655686619, 0.7346903886150514, 0.7476604611171258, 0.6112800994926221, 0.6923455184695795, 0.6926855572945934, 0.227283534513539, 0.12178022509625863, 0.12505409294375736, 0.15998697000186057, 0.15857938391882997, 0.12819047752725998, 0.35276319800736466, 0.5145629728642791, 0.17251344440965555, 0.16013661692513526, 0.20276125601482797, 0.20324002885551262, 0.1399054139076017, 0.16725989219134552, 0.14177263032834075, 0.12561548163319125, 0.1597600897885053, 0.1616997521511363, 0.12764026419443686, 0.08181168306077602, 0.1582826437842506, 9.999999999998899e-05, 9.999999999998899e-05, 0.0305453346395268, 0.030930394151592044, 0.04979455951328127, 9.999999999998899e-05, 0.010958721655529136, 0.12578378155032355, 0.056809191324296404, 0.12665114516122433, 0.16676438607124944, 0.21448421897387804, 0.0802112954354488, 0.061215840208020955, 0.14349252023826797, 0.08901490179014271, 0.1798917779822239, 0.13896477512827843, 0.15536378616390123, 0.204686879267432, 0.2108066085145247, 0.07798587665083812, 0.16205820935535775, 0.20276430077521368, 0.15611210582414192, 0.24233071659173788, 0.07669865625411243, 0.19400664235784992, 0.24780373161999192, 0.11724253119307981, 0.21881718034118602, 0.2436248042406819, 0.22803845313568039, 0.08307679720611927, 0.5679390194718584, 0.5756693328953992, 0.5810655309240205, 0.5485615633196552, 0.552568199916877, 0.5196919400261595, 0.5647816276237825, 0.5651394098236695, 0.55496388267624, 0.14871065487178226, 0.12218034631883623, 0.11673341660680181, 0.1452354254835534, 0.13776610252426003, 0.15362587599807942, 0.1430403856601028, 0.07435875104401946, 0.09941543625867566, 0.22669782748929013, 0.1632414012015717, 0.17008911279839833, 0.21938697200981228, 0.18632253914938024, 0.1703694940101883, 0.18339747898134195, 0.2002178025868866, 0.18816527879132916, 0.3935910219754466, 0.35728148270117477, 0.38871160284609296, 0.38852271354415957, 0.3873232234977352, 0.40823964578115557, 0.40077413380314164, 0.41005100819852514, 0.3959066679695459, 0.25042093890706896, 0.31413705363783917, 0.31095851420480414, 0.291726040034757, 0.3145319248534588, 0.29554505692848365, 0.31290362926153004, 0.3292785098153036, 0.2901739851423888, 0.22637737942349778, 0.21704920862391108, 0.20958955812246194, 0.2146385719576529, 0.24361286032808227, 0.23158373322497472, 0.20584784031768477, 0.24107837953561762, 0.21403225284001737, 0.18230222286802933, 0.22638538735205105, 0.20786394074408998, 0.24405989771980863, 0.4035663601427183, 0.3520071085564104, 0.20044837586557973, 0.2220997733143948, 0.19373425646612752, 0.17068733741331565, 0.1703543025271762, 0.7870842556413027, 0.8029536932503134, 0.197751559494575, 0.1972255013864639, 0.18317669105773815, 0.1664409079315241, 0.8130682638908944, 0.7886098662159631, 0.2065863104021144, 0.7696274436992949, 0.7841074546740503, 0.7351201981825587, 0.16502707578031273, 0.16653170075770884, 0.8092515064675402, 0.7681495635655278, 0.180997555088106, 0.18329888167853547, 0.18001531698048934, 0.1777115077019814, 0.1973722174302609, 0.17233922793530532, 0.20071294154229713, 0.1724223856175624, 0.18647083180076707, 0.09660287594800465, 0.08775712679089209, 0.08580596320712208, 0.09295774550787939, 0.09011116735234115, 0.09535990836700803, 0.09255557992354424, 0.07656152616811074, 0.09294943935176359]}, "mutation_prompt": null}
{"id": "e1207e0c-6fdf-4500-8aa3-58a75e62171f", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size))) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a minor enhancement in the adaptive mutation factor based on generation progress, aiming to improve convergence speed slightly.", "configspace": "", "generation": 31, "fitness": 0.3291733595889761, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "e6eb7182-0a58-4de9-9183-f0a8f40ed1c1", "metadata": {"aucs": [0.7503626224404875, 0.7393439655000567, 0.7357772559206239, 0.7452529334220783, 0.751380492192455, 0.7411552223061597, 0.7655113526659965, 0.7471107910912931, 0.7448585856494987, 0.5983252524238308, 0.5742952371465792, 0.5549435838319416, 0.5144711261127972, 0.5862194818998656, 0.5859332487387614, 0.5850449119903811, 0.5743191394823652, 0.5950205049871924, 0.3076805990377889, 0.16637409934482217, 0.29231583603905176, 0.43391125716318035, 0.21715183460180465, 0.21749675788077905, 0.3290769281107685, 0.24286003856116112, 0.24562080487331206, 0.13526186860589984, 0.12443585640181076, 0.16096106223369755, 0.1406704118281168, 0.12067810660962386, 0.14320997736037755, 0.12838143071559494, 0.14195772422651187, 0.13670504011607132, 0.9181271248108914, 0.8823572929644201, 0.9255590101267975, 0.934852151479233, 0.9370521213914297, 0.9168587035670823, 0.9104408554931837, 0.9640755045220606, 0.9385069770744894, 0.36322816913747824, 0.37857200744672925, 0.35376887934432455, 0.3652028658778843, 0.366473590072416, 0.33247414918704066, 0.3243250522096678, 0.3106498765450869, 0.37396069024836454, 0.7437923811470859, 0.75833506743228, 0.7039425234007566, 0.7531594093692658, 0.7304960014227506, 0.6810334706427019, 0.7776412824019183, 0.7045679199773185, 0.3166741279890595, 0.3065584032943236, 0.31009084377380824, 0.22602707002333, 0.2585652770003817, 0.1841249992480103, 0.2842576658733549, 0.21885146532847544, 0.15308735645525262, 0.1451033446251453, 0.2201549320785504, 0.1473860028497238, 0.37509689689187664, 0.14904403373456865, 0.21275711177406598, 0.12948724581837068, 0.12318305855197309, 0.1838717859983282, 0.1319016237567079, 0.10091734675423669, 0.11145925121486511, 0.14103227137196594, 9.999999999998899e-05, 0.07585600766659284, 0.07803356166466924, 0.042051470731531815, 0.0481497236003221, 9.999999999998899e-05, 0.08440269715327853, 0.05412802463549615, 0.20440537317356833, 0.13302998708149516, 0.17264146111868084, 0.38437150619135796, 0.07888164812398735, 0.08413405892863435, 0.08931517526803745, 0.04290683182868982, 0.17565117463232582, 0.17692386780342295, 0.18374570237857446, 0.1995094564328338, 0.08804851537308733, 0.11444369289314815, 0.16043710319793913, 0.08250427471067456, 0.2471083631049067, 0.07870376570318438, 0.17302716127441475, 0.16183570364712874, 0.14942515152417113, 0.26667011367992244, 0.19915178654844568, 0.172955211989835, 0.06760119290582878, 0.5501156188103344, 0.5468353917613353, 0.5793117730179889, 0.5731470457824086, 0.5556669363890354, 0.5743346307895787, 0.5778774438526398, 0.5562790210979331, 0.5542600214321656, 0.13188652186271344, 0.1260157257078457, 0.10160199970910855, 0.12410837798062435, 0.14646077063252283, 0.12394652597588174, 0.12360012518841867, 0.12802415092006192, 0.10910261925470754, 0.25848606589569456, 0.1609804517754394, 0.16403000233106446, 0.15722827543761086, 0.16966429467818067, 0.18501750443121734, 0.39892040113467764, 0.14792133958898535, 0.14178041927091978, 0.38366478203153487, 0.3707242729658967, 0.3999643572401661, 0.3955234498263972, 0.410977835893946, 0.376480811708512, 0.3928098661923204, 0.4173462081642777, 0.39758651226034003, 0.2728377891568192, 0.3002736877099721, 0.3418381733205985, 0.29550772458549723, 0.31484034496276636, 0.31931269773971027, 0.3149242865893974, 0.33713653060556015, 0.3090301910762002, 0.21574966771501114, 0.2024285174237913, 0.21603148030846941, 0.22627794472603813, 0.2089481704574434, 0.20898681454099655, 0.2322008787762334, 0.2055403011826583, 0.1939202784529661, 0.20554214612367228, 0.19679433363993393, 0.21175825974796614, 0.22865889723241528, 0.351626843407675, 0.29224245287383055, 0.4046254602145304, 0.2136540217385957, 0.20325933235357074, 0.17074308286911655, 0.1703038786524046, 0.802565230576018, 0.8154936608850216, 0.19829287701522114, 0.1965770993374305, 0.18242440988998398, 0.16747476750689916, 0.812372365538292, 0.7862049490911057, 0.1677810268035852, 0.6971303816330032, 0.7459138224744998, 0.20158215067878638, 0.6557443008753031, 0.16652401535700023, 0.8243208998228209, 0.7102551358373931, 0.18142965579221382, 0.1736957685145868, 0.20020181566728057, 0.18278802006721018, 0.18458596300301766, 0.17316623280748222, 0.1849108190129618, 0.1885791290547162, 0.18333598856447741, 0.09400654529640085, 0.10882836527755313, 0.08643832985191346, 0.0860473880145406, 0.08754547991333417, 0.08954772493490815, 0.09089546715764174, 0.08267164322440601, 0.09202820438755566]}, "mutation_prompt": null}
{"id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a sinusoidal-based perturbation in the mutation factor to enhance exploration capabilities adaptively.", "configspace": "", "generation": 32, "fitness": 0.33723613890175225, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "e1207e0c-6fdf-4500-8aa3-58a75e62171f", "metadata": {"aucs": [0.7358959677709711, 0.7419563743711841, 0.7489600886912637, 0.7482440534750827, 0.7482754609296445, 0.7429249046001893, 0.7486234768374794, 0.7496863727201502, 0.74261839370522, 0.6003854081527527, 0.5956605669927193, 0.5794220454542078, 0.5488817003278526, 0.6008632634520898, 0.5981790656397192, 0.5673373265944945, 0.5965286614350844, 0.6793633463927149, 0.23888473298488855, 0.24334310974231388, 0.2697714404706587, 0.4548743346825742, 0.2584001101080433, 0.36346016681639504, 0.3057540532572791, 0.26657650638244224, 0.4269245006642918, 0.1327885851338202, 0.10626198976647261, 0.10991905652337297, 0.1275918260926574, 0.13851408382958053, 0.12332655511780499, 0.11555159631386747, 0.14670559665286487, 0.1390725361410765, 0.9256083106321441, 0.9532025601024503, 0.882741672218334, 0.9369869090173066, 0.9295101543705554, 0.9226039778262444, 0.8934965136005566, 0.9640755045220606, 0.8999231738931411, 0.3690698656367908, 0.3242647279014367, 0.40697289084985255, 0.36878295500070357, 0.3625626637541596, 0.3410292263991922, 0.28097795273393844, 0.30005009144457173, 0.3245237201500658, 0.7512746604085487, 0.7778542872912987, 0.6981573338215294, 0.7485441189358932, 0.7497222838972623, 0.2611249441144513, 0.7236790593187508, 0.7330452811847001, 0.6961436096011302, 0.27225395629603766, 0.1500395054074385, 0.12348148747839782, 0.18862080890198651, 0.17963472198546093, 0.2705023895813201, 0.20472325023656168, 0.17645967957951125, 0.16009050183880968, 0.19899658593962222, 0.12865693241427545, 0.1629014572918781, 0.16984065382303926, 0.20650077075753426, 0.22912749594279436, 0.16310575307543018, 0.19151235105286046, 0.17676363393457417, 0.22131627036357826, 0.06401123263543629, 9.999999999998899e-05, 0.031246046268108563, 0.03515209244253181, 0.017350407532316425, 0.0100313286381295, 0.002116430870213848, 0.0022143679640496128, 0.08906652549408411, 0.1847026020824185, 0.12832127283862205, 0.2831783536516965, 0.12650377422446668, 0.22014810949706853, 0.08958274854180948, 0.27150388473069176, 0.1676751929289807, 0.15718169886222244, 0.04421904152694589, 0.40080214137142267, 0.24939263485134933, 0.06877560380059544, 0.0795351420944922, 0.08569722710378047, 0.08821010919693639, 0.07850189370925875, 0.14068746860543146, 0.19528639837493433, 0.1627471797845803, 0.19557440754913247, 0.2504488871910987, 0.20614946919493593, 0.2572546590923874, 0.2628363021875316, 0.056923589990419576, 0.5668585884880236, 0.5587083761450471, 0.5804305219849071, 0.5489919928724474, 0.5674105358325727, 0.5734348636978439, 0.5685007652626484, 0.5371868138880417, 0.57363848005034, 0.18043675919944668, 0.12218760085020874, 0.12972097229844237, 0.12950711630837541, 0.11999407186595434, 0.12067268000855091, 0.1623402039434373, 0.08212041684965521, 0.13099123678107316, 0.1873726699205982, 0.17809638452747645, 0.18238102373061105, 0.15733181667164697, 0.29427187738437777, 0.2855942769946067, 0.4003535696948919, 0.32173465606943774, 0.18930613615976954, 0.39138179931047734, 0.3606564430835394, 0.40415694222973086, 0.37297396784699355, 0.3935684432455496, 0.38441460124411686, 0.3940536115439911, 0.4152014729593996, 0.3845727607125826, 0.2793597120972988, 0.3239830553478812, 0.3012871673464127, 0.320037151391124, 0.308493739765052, 0.3015572828793449, 0.30750740667863363, 0.33893540958237733, 0.30056400891904245, 0.20646168870454473, 0.20705217413090216, 0.20288687898557578, 0.20580048547868812, 0.21679361201337433, 0.19968939596033042, 0.2471385934511685, 0.2052990503007488, 0.23031024425704116, 0.2183448265146981, 0.18522818629672433, 0.23514002870493655, 0.20897856536161996, 0.34646805059549146, 0.2101032114662036, 0.28697459284126525, 0.355587777466298, 0.19172241840850723, 0.17063737459740336, 0.16927839095701658, 0.7996982214516883, 0.7717288422415948, 0.198259021354673, 0.19739452155673198, 0.8086275868897552, 0.1696747318906815, 0.815876693070609, 0.7686593928626213, 0.4737693120406048, 0.7292774800308333, 0.7382739330459998, 0.7200386102339815, 0.33206977364017864, 0.1661760852308768, 0.7729247041187617, 0.7821877004446063, 0.1780604172631689, 0.18698503469168914, 0.17886413891989672, 0.17846250891016402, 0.1964002753232017, 0.19427738444531517, 0.1956638855961661, 0.19610730750081806, 0.19238457269862097, 0.09347220723532568, 0.1012262532665833, 0.08714133356972453, 0.09401377524830423, 0.0963627162166838, 0.09255264168550525, 0.07863756379449371, 0.08543794141619432, 0.09503236715642782]}, "mutation_prompt": null}
{"id": "dd596e92-5191-4765-89bc-e61f8a2f16a3", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(110, self.budget // self.dim)  # Adjusted population size to enhance exploration\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.25 + 0.25 * self.logistic_map()  # Altered adaptive factor for mutation\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        cosine_factor = 0.02 * np.cos(self.generation * np.pi / (self.budget / self.pop_size))  # Cosine-based perturbation\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + cosine_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < (self.crossover_probability + 0.1 * np.sin(2 * np.pi * self.generation / self.budget))  # Sinusoidal influence on crossover\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a cosine-based perturbation and adaptive learning to the crossover strategy to improve convergence speed and solution quality.", "configspace": "", "generation": 33, "fitness": 0.31099312893741893, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7392218473818181, 0.7530079699149869, 0.7385182478568442, 0.7308088841187323, 0.730499090159775, 0.7261339669422335, 0.7368350738177818, 0.7180699844362916, 0.7252602862515426, 0.5287624898372043, 0.5561149879688092, 0.5519226197136157, 0.5537457926895499, 0.5820722327223762, 0.583984734674676, 0.0741002315912872, 0.5733958726070996, 0.5452691653156712, 0.3473228902285763, 0.17949545450388193, 0.24103763501040476, 0.3428988786347422, 0.15538234627952274, 0.1491787095351942, 0.290675359561135, 0.26757587482181655, 0.15855123699728102, 0.11658860868111098, 0.130330176352629, 0.15650950093682292, 0.14624964851629252, 0.12681921486232584, 0.13604004161008765, 0.12171910065154201, 0.2336810744355895, 0.14385422580122353, 0.9296151021383999, 0.9187773790413994, 0.9008368480797398, 0.9587456590488661, 0.8573738272273799, 0.9404709836521904, 0.9413850613233229, 0.921677432529421, 0.9509380749032309, 0.35690695083989055, 0.2921523990770467, 0.3120595126743627, 0.35265593315435206, 0.28039449112673587, 0.3568213531264657, 0.3056218421929877, 0.3129019670838813, 0.3187695101615946, 0.7786566487545548, 0.7643575927379065, 0.6918322201890174, 0.772495877619789, 0.7215130465945676, 0.2605445827036641, 0.709670631626016, 0.7215968883454305, 0.23378086282403066, 0.16781465877438462, 0.1688813596213542, 0.16465717108243172, 0.12770947391519638, 0.4479340773817504, 0.14430289285734177, 0.15899310996760374, 0.16403535826286475, 0.12477766665494072, 0.17003997000664128, 0.3473076815217342, 0.17513354808536663, 0.19854371184886466, 0.17032909699617704, 0.20440733964749902, 0.2163527020452931, 0.1284259560969898, 0.1698201061591188, 9.999999999998899e-05, 0.004218101659576368, 0.09363147543929262, 0.013091172727338729, 0.045655915319833706, 0.00690947288574284, 0.03314812217701113, 0.09393164757533345, 0.018493407853681143, 0.13990800440526052, 0.04729943007681647, 0.06278823818615531, 0.10158055683682121, 0.1128817177614232, 0.014845079023911412, 0.35627052635589573, 0.1275060959499693, 0.06558814237751598, 0.06316924792743506, 0.1749342292465106, 0.07439408162345384, 0.07202825782912936, 0.13942437474764013, 0.06266174201372399, 0.17590257563899103, 0.0934559250007011, 0.10235862445657817, 0.23329070988649603, 0.20106674591602236, 0.1954148974074702, 0.06157903215573224, 0.0667728805247223, 0.13736574200040286, 0.10451145842346032, 0.17788806537961988, 0.16310377892094952, 0.5656443541495844, 0.5614561254271939, 0.5491083519381261, 0.5460950292916027, 0.5405936042997874, 0.5547582713398842, 0.5757548416977779, 0.5404542350597277, 0.5664381109810936, 0.16082469493259066, 0.11167232954588091, 0.11223073745861534, 0.1199136865806455, 0.10733705215997746, 0.11816778129243699, 0.11358689797271004, 0.11520402869782154, 0.10690427282082304, 0.1738876206798139, 0.19555163435296574, 0.1629765957132524, 0.1566244395900609, 0.15822955758635104, 0.17720878617418734, 0.14803500768460476, 0.19331923529110162, 0.1592959736931403, 0.37964275095996214, 0.3540391893415673, 0.410599123257004, 0.3874411202493585, 0.3975013501840593, 0.39584741506694976, 0.40285008800155087, 0.41701224432495276, 0.3978500216596502, 0.25236539643481104, 0.3177225679557819, 0.2993569492779822, 0.2860215594481911, 0.31084348283397445, 0.3010728051480235, 0.30365416016440405, 0.3631402392370564, 0.27957817579096444, 0.21710681760388806, 0.21363338576527313, 0.23306262765097707, 0.21391957223248215, 0.21205316580055966, 0.22225241103864124, 0.2096591723397654, 0.20642127661753606, 0.2070398413675062, 0.18677567958876518, 0.2016418956081628, 0.20366968609624703, 0.21093753141062155, 0.21363321459151152, 0.2134088776136015, 0.4142624748061404, 0.2228453337414248, 0.1940561983759138, 0.18337460190531663, 0.1959419497025453, 0.7432781644915272, 0.8352189464102779, 0.19898223824393013, 0.8357517363503181, 0.7169023793574416, 0.16647233291083485, 0.2087193811375938, 0.7641593145604354, 0.2074232431793399, 0.7523973656923686, 0.7507999653225608, 0.20626013774413454, 0.7482613801394659, 0.16423127776151647, 0.34029097500818384, 0.29655706300109996, 0.18511139515474784, 0.18286157850666818, 0.18622800963854502, 0.18612811342419766, 0.1975017128401343, 0.18469365538817506, 0.19116265375352937, 0.1782082854814131, 0.17776345119122583, 0.09382677883987145, 0.0860587679046404, 0.0871804917995661, 0.08539418716049785, 0.0866119813989149, 0.08989023996319889, 0.09113695382231213, 0.08581798698057574, 0.09890460548548141]}, "mutation_prompt": null}
{"id": "fc7d204d-b3eb-4f24-8f0f-4233a47bcbb6", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n        self.gaussian_noise_strength = 0.01  # added parameter\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        noise = np.random.normal(0, self.gaussian_noise_strength, self.dim)  # added Gaussian noise\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor + noise\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a Gaussian noise component in the mutation step to diversify search paths and improve convergence speed slightly.", "configspace": "", "generation": 34, "fitness": 0.29543193497268466, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.5903095219737649, 0.5912157088796091, 0.6052033207252421, 0.6005409458209271, 0.591878104999118, 0.5971123782393196, 0.5853918738003191, 0.6110526933783298, 0.5960779864146462, 0.23886310225820695, 0.25173853078163855, 0.188121887764936, 0.26669212049263347, 0.2562544040326624, 0.2569699542791207, 0.23698491868398508, 0.26162097638059967, 0.2769446485835888, 0.1870271524182534, 0.23603689544660555, 0.23225012598705574, 0.1489840791672601, 0.17862007251642065, 0.160806158781982, 0.27353794746357984, 0.16006838616374985, 0.16257604924864533, 0.14019837062987972, 0.13815841888249814, 0.15072973609033802, 0.19985075584723677, 0.13233781590756732, 0.12829644938243112, 0.13356123849856072, 0.12667875825923403, 0.11317191977271324, 0.8520258057307631, 0.916862947960274, 0.9202795691411636, 0.9598432411448703, 0.9092496364766316, 0.9296652384403734, 0.9195277116239085, 0.9500017206272479, 0.9090101257608869, 0.392977503963826, 0.35075717365190917, 0.3712031208226625, 0.3495988100660946, 0.37522375376203176, 0.3463204090063733, 0.30859474642611173, 0.3520172196001471, 0.3512221173535639, 0.784462051175143, 0.7621978576501033, 0.7588633837489704, 0.7117440964927904, 0.7417862271954303, 0.2095733632698975, 0.6390973496414261, 0.8216753476770824, 0.23110370908322186, 0.18855127460358756, 0.15132099882875227, 0.12451717225264725, 0.15871982174076948, 0.2472349781745783, 0.29970874576104334, 0.16378888543580072, 0.33648635294961404, 0.13964256815087206, 0.19377482655765366, 0.12487890198284513, 0.21682910648122222, 0.15334183839231008, 0.1377627587209872, 0.16405334467385269, 0.25526041353224116, 0.18368037433534778, 0.11872781383610653, 0.001862967069985677, 0.06982624479890875, 0.10780870884395444, 0.03922755116097576, 0.043117844692738605, 0.07332711282618853, 0.08494541508065923, 9.999999999998899e-05, 0.006576638307526861, 0.14107923412907453, 0.04597663585786427, 0.13059157675987831, 0.09549481233806945, 0.14682009869797907, 0.04915382786165867, 0.23789183097652944, 0.062185033473326934, 0.09777061373279705, 0.030215112183104242, 0.06512187348162568, 0.038270731242545986, 0.13221576774146415, 0.07329598891360489, 0.08329486711610246, 0.0873101567613086, 0.08792960555783358, 0.08999566260284031, 0.17834021669050526, 0.1765430225182788, 0.166986494285148, 0.1339640976893497, 0.14420576672180718, 0.21975925016816178, 0.1655151957092239, 0.09951308328542674, 0.19332272347211543, 0.47418080921990724, 0.48395915060484507, 0.4860269212309226, 0.4761796860418067, 0.4709655774786884, 0.4792807909070814, 0.49578514984593636, 0.4919569546107727, 0.4808507686513457, 0.13238947209853502, 0.11923185678967696, 0.12001248749329774, 0.11282958432869017, 0.1460675313467933, 0.10965663769520506, 0.09262412206779103, 0.08786953797448316, 0.09132487697456437, 0.17848057082200885, 0.17268156322425499, 0.211572628909111, 0.1512947357578942, 0.2265314971297464, 0.18584407604255904, 0.16254689511766085, 0.1625007001755735, 0.16592170216247648, 0.334341718199639, 0.344676026622053, 0.3465616794894836, 0.3571726090034989, 0.3406146449401335, 0.3455460118659974, 0.33894664736267754, 0.3532987779605331, 0.3448181401359489, 0.3007309303892518, 0.2865021667809128, 0.28917910146674153, 0.26592831155769314, 0.277043735873411, 0.28709250122478003, 0.28012734023206687, 0.2909312172510716, 0.28922029487703727, 0.20855630736548425, 0.21189332856959853, 0.21975946738678975, 0.21967956107512032, 0.21302951282465032, 0.22896243091861268, 0.2210943952569141, 0.21140320975414628, 0.21440714695253005, 0.20151228499694385, 0.20408820107004078, 0.2892627108020793, 0.34778813544079434, 0.34783445373635435, 0.22283637993189054, 0.21670924282722626, 0.19791890211040086, 0.19382568193901184, 0.18542880839729758, 0.18411859054082758, 0.781530904683507, 0.8276595931370572, 0.1974186731232025, 0.19005127706099212, 0.7675239711141131, 0.6860336254827233, 0.8195226791316839, 0.7525609211111035, 0.6376894182215022, 0.6407403069691788, 0.7708999397540156, 0.7515696556446041, 0.7137089356758399, 0.16414529389887134, 0.10373633560434337, 0.6534178953211591, 0.18396273059950463, 0.18003790522203122, 0.1800929792728473, 0.179290374399537, 0.1995899092129848, 0.20469328346676507, 0.1720137095873555, 0.19107075403467366, 0.18495227873286835, 0.08847132993111428, 0.08857566813106077, 0.08834882003431443, 0.08439295584159678, 0.08878780229623262, 0.09111763323422362, 0.09873846415629484, 0.09119641502048503, 0.08976503855647022]}, "mutation_prompt": null}
{"id": "5d60f5a9-5906-4fb1-b1bd-27150d51d045", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        dynamic_scaling = 1.0 + 0.5 * self.logistic_map()\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor * dynamic_scaling\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Enhance exploration by incorporating a dynamic scaling factor based on the chaotic logistic map to better balance exploration and exploitation.", "configspace": "", "generation": 35, "fitness": 0.3160553657586366, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6971711694939524, 0.6870774859560675, 0.6877364334668181, 0.6858031690735749, 0.6951806805648566, 0.7013324382524195, 0.6985494290645125, 0.6923609595508771, 0.6913674991633, 0.5972054131036517, 0.5516518421301781, 0.5022635984181609, 0.5547904921131074, 0.5187046570873948, 0.5451891162325493, 0.4890172316001934, 0.5543022905458403, 0.551669319631487, 0.16922284151803157, 0.3193740230831884, 0.2849699627215715, 0.22507807358680487, 0.19506067558064455, 0.15630233440169472, 0.14673360341439912, 0.1614143591739743, 0.38795626452744403, 0.2094770025311583, 0.13419234961458915, 0.14038002317747067, 0.14633715617546206, 0.1417057302610394, 0.12315497854091406, 0.15653500720021107, 0.14030710671596802, 0.12584418238927064, 0.9185074419796334, 0.943193658173192, 0.9218507586463592, 0.9713143487812621, 0.9637960337717789, 0.9404863544281244, 0.9375330656413067, 0.9148597420878735, 0.9628658690056029, 0.3325290329292596, 0.3237616281120117, 0.27757579280796674, 0.3019778493741474, 0.31829343362860996, 0.3042454212814656, 0.27888385263806614, 0.3265266098918511, 0.3350744760428036, 0.6501981849086028, 0.6248796690889014, 0.60825857872408, 0.6571644893462305, 0.6636713229451124, 0.5723681202321067, 0.6568610078146708, 0.6647298013437153, 0.6676918795554545, 0.14923926644946828, 0.15367733873420708, 0.14907141832061666, 0.10835766447655693, 0.16597829465658254, 0.2387599950862339, 0.1532338581509124, 0.16211222952863913, 0.17613305614312103, 0.12950551944556354, 0.10535430182114669, 0.1582880241687199, 0.17168767307051513, 0.13511651916966605, 0.2792140535153059, 0.14823724220139323, 0.11840128833616514, 0.1404731915992612, 0.09267320921607392, 9.999999999998899e-05, 0.05740475315511884, 0.06438986577702599, 0.00521749295331575, 0.0014525124605843098, 0.06428035912185637, 0.07424241795540787, 0.06241844807933117, 0.32942571995932435, 0.24113660131295234, 0.3918770110391966, 0.1328623646717415, 0.16225475214443907, 0.09539955233342645, 0.13292580821358568, 0.18196038522972036, 0.11466109970793936, 0.0400233987532852, 0.04749827458411493, 0.11014881697221512, 0.06892586541317125, 0.06597869882369067, 0.08691001936893039, 0.09742978548388748, 0.0802804108185512, 0.1474472165711761, 0.24570436910581106, 0.24844515093099373, 0.2714123171427393, 0.2700462017491836, 0.2898981477391088, 0.2066925375417592, 0.18132409089756507, 0.22986003829111412, 0.2460482842090913, 0.557738131229857, 0.5567310045160416, 0.5461917306807764, 0.5638829779622182, 0.5284410408834355, 0.5155455739412771, 0.5507082206890317, 0.5480619356494412, 0.5398422859510879, 0.11493544450022875, 0.10911855801693038, 0.11435305423229458, 0.1125914164614289, 0.12734089962461315, 0.1100404408362452, 0.1451927665175966, 0.12330167015143001, 0.14969726759537827, 0.14601888923085005, 0.15037930415616507, 0.1641777747971126, 0.14556623990682815, 0.17206947653462157, 0.14210305363188813, 0.14781962631436796, 0.1358172723245501, 0.1445351483304108, 0.3527568139652213, 0.36006659165910215, 0.3818254137839162, 0.37154658012062725, 0.363392386124919, 0.3652322606231806, 0.3558510554786056, 0.37800627178414137, 0.3595515232938373, 0.30622075013017624, 0.26645667159812825, 0.2931123073795233, 0.29684022601450777, 0.25940030688995097, 0.29344297534660535, 0.26394530747438416, 0.29242950974917437, 0.2891741707892824, 0.19784698524720057, 0.21071131559488543, 0.22926610929544344, 0.20920925039948923, 0.21200100454981818, 0.20117948525421436, 0.21596724970207748, 0.19213359907944694, 0.21311346097334205, 0.21302326509472946, 0.26723917946803344, 0.2404078841355317, 0.21602254108553776, 0.23591028964498528, 0.18598932599338813, 0.2077313909732852, 0.21250214858859084, 0.20798637546357612, 0.17934934899235344, 0.18358131994325888, 0.7428746747697674, 0.7000460187336465, 0.19727767989523137, 0.7526519156000592, 0.7021743354590464, 0.17663153586152058, 0.5930951712213832, 0.6905056040937696, 0.5958867283407776, 0.20049963726273423, 0.6475374664824242, 0.638438546476515, 0.6624111426367129, 0.16713752466919618, 0.6958928490699243, 0.7118545047472082, 0.19452420397106884, 0.19747740629516985, 0.19095276455149102, 0.18981843864967263, 0.19198709181324725, 0.19646625129046036, 0.18029670113579377, 0.1784970712988817, 0.17705924033491716, 0.07875752714794038, 0.08554143576654571, 0.07845059133991639, 0.0879691878004003, 0.08688083774137612, 0.08008460138109785, 0.08438501332762494, 0.09718576878487906, 0.0879714437200495]}, "mutation_prompt": null}
{"id": "1faef3c0-beea-4182-8dd5-7701f745929c", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        dynamic_scaling = 0.01 * (1 + np.cos(self.generation * np.pi / (self.budget / self.pop_size)))\n        sinusoidal_factor = dynamic_scaling * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic scaling factor in the sinusoidal perturbation to enhance adaptability and convergence speed.", "configspace": "", "generation": 36, "fitness": 0.33203427373483624, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7392562289664497, 0.745990310186463, 0.7472339761403575, 0.746464650668434, 0.7532057550589625, 0.7470182097135414, 0.7498534135064003, 0.7372072345430829, 0.7468565653292932, 0.5498609954198197, 0.5657049492857549, 0.5688384888555382, 0.5662847976840103, 0.592583698625226, 0.6166303981447991, 0.5726412471133173, 0.5711487916685724, 0.6592006407032993, 0.15302498323203728, 0.28864238987978863, 0.2984660693548372, 0.4465716740742759, 0.29254134783610075, 0.30100278361320354, 0.14348536559548697, 0.23295095533734123, 0.18743927210237354, 0.1375522803000464, 0.13748122811911867, 0.11093596903354686, 0.13448887974527968, 0.13256927405575059, 0.14780574233528132, 0.19145797167530443, 0.1395962196703202, 0.1323965604478371, 0.9256082692289656, 0.9532025605078155, 0.8827414517696816, 0.9369869094221756, 0.9295101240047753, 0.9226040162857111, 0.8934972605270193, 0.9640755045220606, 0.8999221218919483, 0.3349207943714866, 0.36486628419334444, 0.3860577586610847, 0.37193741405273106, 0.3822094586123841, 0.3351546452812322, 0.3589345132492474, 0.3281558492535609, 0.3504461605038022, 0.7236821033422804, 0.7452059612048387, 0.7101921704697001, 0.6973503362853737, 0.7409636963294186, 0.21327096467512652, 0.7237475109904682, 0.7303868152838149, 0.7359095202697923, 0.12024742117212173, 0.1517775000067455, 0.2137437267578164, 0.16870278616791134, 0.17357920399445725, 0.2994228458543814, 0.20196069009389206, 0.17769411453479456, 0.15921606578923508, 0.191135582434931, 0.1342695033234047, 0.16112884752823287, 0.18830127987312684, 0.17890808092564237, 0.21041379331267418, 0.17946020553089237, 0.17524229535347913, 0.219062254774122, 0.12433598268206691, 0.020357226048126953, 9.999999999998899e-05, 0.040574873946106704, 0.08952316587455789, 0.0357473472713602, 0.04718462369746934, 0.03667099709901955, 9.999999999998899e-05, 0.09178773601692114, 0.258917931885738, 0.1181462151794318, 0.22349838340971362, 0.14025325341396744, 0.034848149602466405, 0.09092802897858288, 0.2110740970504621, 0.30845850516067264, 0.03400466586272033, 0.04306856324928576, 0.2575131173477282, 0.3263531493039534, 0.0711400457207465, 0.08629847793690026, 0.11239367321580829, 0.1410402578107347, 0.08898161453586584, 0.18538078445887252, 0.14848244428528556, 0.15007893311789067, 0.29083756447046993, 0.24040168658984462, 0.21307099291434717, 0.2806689388696405, 0.17839172255651015, 0.05731831550024813, 0.5619333213616857, 0.5661339909201759, 0.5950727581631245, 0.5526954020734041, 0.5703890106817778, 0.5740517912218261, 0.5680739880548001, 0.5679294644539717, 0.5845652136509535, 0.11345925246960065, 0.13027582776938817, 0.11410377623162349, 0.17352713966739297, 0.12868567015134813, 0.1431816165034856, 0.11275294287015658, 0.11897043590629419, 0.13101921930895988, 0.3344297316469773, 0.13832911901611566, 0.19312989958683702, 0.1498635766281715, 0.1503163140602577, 0.14489653970161975, 0.2551295446942833, 0.2168489311720606, 0.14988955431148665, 0.37152749766447735, 0.37503642172381624, 0.41089048333785705, 0.38755341702806567, 0.38288711287411414, 0.3871226981427046, 0.3988056291770278, 0.4101585517356552, 0.39555659737932525, 0.3164476565917129, 0.32473638468431887, 0.31160131912903133, 0.3121904643755934, 0.30702399508500455, 0.3073661644881619, 0.3237748072519052, 0.33230582993439695, 0.3180284004364484, 0.22522234766113347, 0.25306733878507404, 0.2149016241903252, 0.20785367325542137, 0.20662476144269093, 0.2348941218978201, 0.1977254484868085, 0.24355005482756276, 0.20705228257037755, 0.19512982625955866, 0.18692748230891343, 0.23236630673000747, 0.22686719433464264, 0.31522913821338716, 0.21931892694862465, 0.3397522247352044, 0.2019985409373135, 0.19157275435170618, 0.17083050904017183, 0.1692757841599608, 0.8077618362686162, 0.7683161929923618, 0.1982605248330397, 0.19739534827896543, 0.8095660386765956, 0.16964426804914656, 0.833168942047239, 0.7611959616110509, 0.38468300483588413, 0.7018241572902782, 0.7460465962550138, 0.7294815082686397, 0.29674852063175117, 0.1661761240018128, 0.7682344547800396, 0.7821059029341071, 0.20546523134873929, 0.1903186998809795, 0.1840269340036652, 0.18796358865045992, 0.19214582906807554, 0.19178404688828354, 0.19874806396883637, 0.1862940421116005, 0.18555103658689454, 0.08701658046332339, 0.10393458795303068, 0.08572761664000739, 0.08901237330663081, 0.092403515246134, 0.09161107536510149, 0.0906949126965283, 0.08337674052808708, 0.09176391010714013]}, "mutation_prompt": null}
{"id": "b85efc7b-619a-42bb-b4da-439bdc3fcfd5", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        dynamic_crossover_factor = np.abs(np.mean(fitness) - np.min(fitness)) / np.mean(fitness)\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map() * dynamic_crossover_factor\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce dynamic adaptation of crossover probability based on current generation diversity to enhance convergence speed.", "configspace": "", "generation": 37, "fitness": 0.28408663455412203, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6940064511278521, 0.6846893765855534, 0.6920736732881874, 0.6822559735703416, 0.6889824062998849, 0.685824801892811, 0.6842108577386308, 0.6970386672722032, 0.699007606444527, 0.532605751291584, 0.5252935721103176, 0.49772173955639676, 0.48984799043010463, 0.5436937595872828, 0.5534576157079399, 0.5532250169047239, 0.521684531824053, 0.6413995247555792, 0.29498065122341155, 0.33268676757725857, 0.33840976195197203, 0.38768995956846986, 0.27951245231826183, 0.3328783987166031, 0.31072699396854486, 0.293891203634135, 0.3418498355280908, 0.26267901601693644, 0.13790895014186244, 0.2421183874846583, 0.19738976055399848, 0.18803334301163688, 0.11720675082259535, 0.2312369031330067, 0.23005461974937558, 0.1644312449084686, 0.9055837051372415, 0.958115474189045, 0.9431591666962025, 0.9026605318478159, 0.9037201599896143, 0.9072628092042112, 0.9358488956566057, 0.955569604303219, 0.9377482647978337, 0.2970059246193305, 0.26823311399861127, 0.29016309256893646, 0.3029003003872386, 0.30960475418765065, 0.28802760542773553, 0.2983772815900071, 0.2423806652652264, 0.2590288472061165, 0.47826854141016206, 0.31278751102661695, 0.4024514455039465, 0.2755445480234915, 0.5221084836068425, 0.34312307356062743, 0.5458608841332675, 0.6625642942995091, 0.49189375923679457, 0.15172465838050375, 0.15378541279888436, 0.30200176371530585, 0.1577309344440737, 0.19015232073293242, 0.25239040971727256, 0.1466599873512876, 0.15755462116278818, 0.1460672517682029, 0.158113727290785, 0.10793852167550355, 0.1520563068470845, 0.13782263723963606, 0.16160011361080273, 0.19975352912392597, 0.1263146489254987, 0.12366339451083241, 0.14756743641855752, 0.12546784209396322, 0.018973501964223538, 0.05217720469853826, 0.040003249504323546, 0.06603792993391289, 0.046239613815371894, 0.008514277691226368, 9.999999999998899e-05, 9.999999999998899e-05, 0.08232905077237795, 0.10955909822748577, 0.13123475663392725, 0.10593305230940953, 0.09257107874982007, 0.08975066089691519, 0.0656444521626458, 0.19025680395464384, 0.14286678563857913, 0.030285798852290102, 0.09111468489072416, 0.16561290905234416, 0.20470402977719726, 0.11129452541322804, 0.06919987611067169, 0.23286151096009466, 0.08356042762859273, 0.08924773907156192, 0.17797796368092245, 0.1618349786532426, 0.17652169771953963, 0.17979455353986284, 0.1523158550458653, 0.10523867350204641, 0.1419025891014959, 0.10130889106188279, 0.1690966775408309, 0.42215532386422017, 0.469002626381256, 0.4480799791606349, 0.4362737013984743, 0.4422206333608404, 0.4482548505740922, 0.4499414253515964, 0.4532257428792167, 0.4429180166260246, 0.11663043300582854, 0.12414212347661013, 0.10732205821296115, 0.10565163138775169, 0.11150584091650817, 0.12433672125030193, 0.12637136709515218, 0.09399391818017488, 0.10735326275035662, 0.17196517975975345, 0.14672248594746284, 0.1519259994186366, 0.1655339979516588, 0.1502693820354576, 0.16102893208921087, 0.16272193424206993, 0.15129833601184162, 0.1408132225756713, 0.2797060994175833, 0.28084831491457796, 0.26926797890962184, 0.2965285870640295, 0.2967296471044937, 0.2872609780298143, 0.3115976205280092, 0.3245659557427545, 0.3071704756561626, 0.22255260234466745, 0.2312481990285682, 0.21063711876318925, 0.19444140979812075, 0.21264728090766005, 0.2326295798895366, 0.25295176889913695, 0.26586390418066885, 0.21156441448586105, 0.1870316873251504, 0.22888917012903065, 0.20140857828979963, 0.1938462993135157, 0.22074063288504908, 0.20560906940177381, 0.19813422032676187, 0.2137242635422658, 0.2232028773385697, 0.23088955374819142, 0.19403875054426012, 0.21796489485959603, 0.2322211302488818, 0.31627546029107156, 0.21149306467527584, 0.22161437869343203, 0.24490914749390702, 0.20809512138103292, 0.17353592555045638, 0.19431253680276217, 0.5945634360002252, 0.3941515454546899, 0.2096705134753949, 0.5757216503179492, 0.5250368919355103, 0.22660967141601263, 0.6121936706508863, 0.4530320947873353, 0.20544307982386345, 0.42387110617588164, 0.1990592691990305, 0.19992447419635273, 0.3314043235918239, 0.166755375932105, 0.4789605535206327, 0.3472346411457504, 0.18955437437272782, 0.2221243791788171, 0.18615867542110798, 0.18868963950609452, 0.19923520867281608, 0.17478171752063465, 0.1900449820983371, 0.17487633144650228, 0.18806817920311647, 0.08723656896583021, 0.08576023057482796, 0.08504004992698444, 0.0910746285841103, 0.09159884192342038, 0.09465755319125924, 0.0878412752986174, 0.08667425835828113, 0.08262857647963806]}, "mutation_prompt": null}
{"id": "fa6d65a9-ed66-4231-bb18-4f75b2fcca4d", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Exponential:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        # Add exponential decay to mutation factor\n        decay_factor = np.exp(-0.01 * self.generation)\n        mutant = a + (self.mutation_factor * decay_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Exponential", "description": "Leverage exponential decay in the mutation factor for refined exploitation balance and improved convergence.", "configspace": "", "generation": 38, "fitness": 0.32807415003979523, "feedback": "The algorithm ChaoticHADE_RMC_Exponential got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7802860355196565, 0.7492983171588131, 0.7557123926893636, 0.7545408614193587, 0.7608060079244819, 0.7442886357733532, 0.7576161748603271, 0.7472184534444505, 0.7593828132049187, 0.6186777599450484, 0.03841584814550847, 0.5648734036042782, 0.5876501066083861, 0.27288362838819147, 0.6123534547439334, 9.999999999998899e-05, 0.6302272106062582, 0.6051293029760585, 0.3288486690200524, 0.3088888794717959, 0.3313298292985476, 0.1806105729545341, 0.29449594409937674, 0.15055742395141425, 0.3562775361474043, 0.25343840513004756, 0.2674223339459818, 0.12410007721641536, 0.11032908615750314, 0.13920655580902241, 0.14269335435560837, 0.14717281959001305, 0.1509671184187128, 0.14998849744249765, 0.1287990539349878, 0.1485974893071842, 0.8451884145881812, 0.9462298963908717, 0.8610854400665797, 0.9479093284043087, 0.9458963325333708, 0.9100118921291608, 0.8992488516664279, 0.948837258514757, 0.8521848776669649, 0.3197711250846085, 0.26980018076057666, 0.3771389107480142, 0.29773309336590703, 0.33605096580693894, 0.22404361611980605, 0.2525598789000665, 0.24085726004887964, 0.34317669329162503, 0.7844779185020679, 0.7807248992044845, 0.7374673205513076, 0.7876785972692588, 0.7609577125647748, 0.20293322413424342, 0.7416043253276194, 0.7618048227716656, 0.7434453375319391, 0.16127073639228162, 0.15348909881211714, 0.20147904957496365, 0.45703507568007185, 0.32380285322153846, 0.2192913194303403, 0.43911660477975833, 0.24036959199731023, 0.14293439760370752, 0.2608203836288454, 0.06848806862916412, 0.17090234771780766, 0.14445376786488195, 0.12635469633529794, 0.19834591839237214, 0.13659675715077724, 0.14842893023536685, 0.13480878710448074, 0.09906105314239888, 0.14876628588362695, 0.03507720801089165, 0.014103085592707787, 0.0008166838694745326, 0.05074824388457022, 0.04786774568518559, 0.12342625320177336, 0.07655050140265285, 0.07858381354221344, 0.25259536371301805, 0.3287570505579809, 0.0735178509603216, 0.1786109890910237, 0.03417086663060964, 0.130740017802645, 0.09813766049704009, 0.14962192008768793, 0.05351416688911759, 0.0736664765852838, 0.2378503790940203, 0.21436797397109597, 0.0923137302399647, 0.10832806395958161, 0.1410567689438229, 0.09282102257702596, 0.06926986166413496, 0.13621091695383314, 0.0560803908980555, 0.1817020537518692, 0.287531993663229, 0.23947730626271446, 0.18394267980182932, 0.10665888333950535, 0.18095480742944592, 0.20020494707370606, 0.586579281426884, 0.572570819210332, 0.5498111486958508, 0.5681667056223006, 0.5684059613662596, 0.5809170751497422, 0.546598240125846, 0.5435692772773082, 0.5360862311231007, 0.1384077225638688, 0.25587263081267564, 0.11198857251210481, 0.14640793086728443, 0.13108641504395835, 0.12911949964710545, 0.13968941117643718, 0.1351798184946923, 0.08003658394805757, 0.204765712056164, 0.21619572866741033, 0.1590925497256367, 0.1619576678315673, 0.2076424514774382, 0.18134797977478812, 0.25433531750149774, 0.27760157728246004, 0.30972983196270865, 0.37679797488538347, 0.4128104832592764, 0.4143682202626786, 0.41560899868746115, 0.41688285495250366, 0.4159816386410894, 0.4073782380111587, 0.42480514645567546, 0.4361630971985636, 0.24856415793917985, 0.3282945478736883, 0.31419194805152617, 0.30151815435520113, 0.31589036000965875, 0.31218472502127237, 0.34726682958970945, 0.34998262289750803, 0.2109608904176623, 0.1987459125775033, 0.2244342078505115, 0.21818260049591864, 0.2109603224999359, 0.2090207261931848, 0.22602048631835492, 0.21294355757438455, 0.21271103233599764, 0.22351477572208, 0.29027404312364447, 0.20828258368803143, 0.22958979118852563, 0.21422861507299362, 0.34811248399321104, 0.22739840907010878, 0.377553388971852, 0.3359163626882451, 0.19664290099030612, 0.16709061212569032, 0.7957795101298152, 0.8079752283587326, 0.7735229070929499, 0.1980596260440548, 0.7747511262865425, 0.7469814912598332, 0.16942815477559692, 0.8383106837644889, 0.7605641512022296, 0.16726141564455443, 0.6948143291711927, 0.742845621104248, 0.16497144655323226, 0.3758543069080843, 0.16628501274334717, 0.5542192046502847, 0.49171402910776363, 0.19117520045769787, 0.19012543228306822, 0.17829090259907043, 0.18076284259343012, 0.18477741761256417, 0.19124518780431798, 0.17597490801518978, 0.17791705714251838, 0.21518630167924235, 0.08723811748920052, 0.08700867677414281, 0.08550539176228467, 0.08175555486564845, 0.09193570029467923, 0.09141794066211928, 0.10152571561105783, 0.09241366653941763, 0.08489067886698487]}, "mutation_prompt": null}
{"id": "0ec6ae22-95c5-4085-ac83-2a85079532f4", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        chaotic_factor = 0.5 + 0.5 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        offspring = np.where(cross_points, mutant, target * chaotic_factor)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Improved", "description": "Introduce a chaotic perturbation in trial selection using a sine-cosine function to enhance convergence speed.", "configspace": "", "generation": 39, "fitness": 0.28472620996672615, "feedback": "The algorithm ChaoticHADE_RMC_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6106742101388187, 0.6535872361520851, 0.611061651045448, 0.5546183171733905, 0.5460647334087079, 0.5697309426547853, 0.5821107416712802, 0.5960945820297621, 0.6061240614332402, 0.35245040178334075, 0.3982182755410453, 0.3220553473924237, 0.44423937407528336, 0.43315042202035814, 0.42771605649551525, 0.3694226034025073, 0.4065325634152168, 0.3061172867311961, 0.14560260963769978, 0.12522342538078646, 0.10785041720498534, 0.15389046276977392, 0.12374325688631194, 0.11655741660428198, 0.16120839811703358, 0.13353233125445274, 0.12264881068607703, 0.1184863441324242, 0.10710583241251226, 0.11522157464287541, 0.11592154454154169, 0.10100907871000675, 0.09165317888107927, 0.10491580238437981, 0.1117174253206975, 0.11057707204252654, 0.1243505569302239, 0.9076080084684861, 0.16274571982716912, 0.2547013133291294, 0.36714643195476315, 0.9443457648819242, 0.9154641097557983, 0.9463726959974866, 0.8997325202173297, 0.33935973881255355, 0.2933238288983916, 0.25409052369248175, 0.2667597310381753, 0.3000781306012812, 0.31071573537336794, 0.30770447491372865, 0.30984836414601247, 0.30659969274621535, 0.742273648009316, 0.7252540038838802, 0.68898842789973, 0.7516531371363786, 0.6595140800029301, 0.2656601880358156, 0.7548027431138978, 0.6903369668433637, 0.6385384795369258, 0.20886852169676307, 0.26341870851325944, 0.19365209918139403, 0.11251386554570342, 0.2894504194073907, 0.2224222983167451, 0.23033708289520505, 9.999999999998899e-05, 0.38194154252922596, 0.2616501645116217, 0.27407353020504943, 0.2570479083530679, 0.1828148264729339, 0.24310596690241426, 0.1315927461008941, 0.23573734730385176, 0.2033597532357675, 0.2612797552119629, 9.999999999998899e-05, 0.009493254845615362, 0.06635279327176302, 0.12557238603207355, 9.999999999998899e-05, 0.0196183088082289, 0.12101987208802967, 0.013438237448572199, 0.06274074639753557, 0.21884310980289046, 0.09925101662029934, 0.09042276577859176, 0.14721466685184137, 0.08956105905648204, 0.1389090040366635, 0.16827963618655262, 0.20726379213531887, 0.16854841774522578, 0.10998342428995656, 0.12142055672099794, 0.23841766400690867, 0.05889431557682889, 0.10275748598857992, 0.11685209929226348, 0.1605053549797818, 0.0476074142239955, 0.08972539747538433, 0.23207507936843141, 0.14018208248069275, 0.16187540437938464, 0.24528107664635357, 0.19546245737964596, 0.06967258914926844, 0.2338015362878666, 0.1891300478049438, 0.14594458124572407, 0.4696377384863456, 0.4972681892090417, 0.4689710131001755, 0.4403013089692005, 0.5104727178303081, 0.5077544014896158, 0.5317859309676705, 0.5375398336841184, 0.5245557394035629, 0.12480677173421095, 0.10187392305097842, 0.1045141534680557, 0.1243798279755367, 0.11233598773439113, 0.14855767800996622, 0.07663821598340814, 0.14305250215539, 0.10430029963240195, 0.345108098097463, 0.23129804660918307, 0.20790268825822544, 0.1756928576890947, 0.15925560142706285, 0.15239195744646916, 0.3168357263429076, 0.16975233905303433, 0.29117888362636635, 0.3552057226440998, 0.3392011207522473, 0.34208417265570557, 0.3638801308013482, 0.35875985029801705, 0.37046629941655085, 0.31656974957082396, 0.3473470112544981, 0.3323536114057736, 0.2536977168505551, 0.20047404053235496, 0.30227849489597425, 0.29802577296392896, 0.29889644629543044, 0.318811546730872, 0.22567043136871667, 0.29834842298494246, 0.27268877534363756, 0.25042509345714337, 0.23696437670171777, 0.2551705859585711, 0.22543303808630621, 0.22042761387209664, 0.2080604919415996, 0.25066361209644605, 0.2198895268420864, 0.22876422310895805, 0.18147989670045817, 0.19968243150220777, 0.26637696557933477, 0.19828196588576097, 0.19990148467400237, 0.20163163458980105, 0.1826225243080467, 0.208338264664782, 0.19253379902034262, 0.18554566557410157, 0.1855969362387826, 0.1853328428627451, 0.7515968663151175, 0.19784864874208874, 0.19544881786188362, 0.6913252583622096, 0.7347583325558238, 0.7906362691423258, 0.7823983736157539, 0.20485484742429338, 0.7835041051958518, 0.7485912384345796, 0.6638045215916646, 0.16674728144170914, 0.1669901214414613, 0.33601034170582567, 0.7095623174878016, 0.18819683811499377, 0.1885707844666007, 0.19228724630339977, 0.17343074549194648, 0.18231594075700375, 0.19350822503554332, 0.17752632666682933, 0.17770015677499362, 0.18139100443714828, 0.08802968855398119, 0.09717087120253987, 0.08370013310440028, 0.09244567493111622, 0.07938770329889755, 0.0894482435703765, 0.09114417597669888, 0.10793275826102888, 0.09206579767546141]}, "mutation_prompt": null}
{"id": "0d4788a6-d30f-416a-b498-2ea922dcac12", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / max(np.abs(np.mean(fitness)), 1e-8))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        normalized_g = self.generation / (self.budget / self.pop_size)\n        self.crossover_probability = 0.4 + 0.6 * np.cos(normalized_g * np.pi)\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / max(np.abs(np.mean(fitness)), 1e-8)\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a sinusoidal-based adaptive crossover rate combined with a normalized improvement factor to enhance exploration and convergence speed.", "configspace": "", "generation": 40, "fitness": 0.2887398495146326, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7702435653908993, 0.7588157291912534, 0.7541580603334956, 0.7545497034715251, 0.747802517833944, 0.7589839441418897, 0.7718360398050012, 0.7425890738911424, 0.7549116928373794, 9.999999999998899e-05, 9.999999999998899e-05, 0.003190289247517075, 0.027029060935290006, 0.04979015489953853, 0.11264656423465835, 0.0925343498028266, 0.0495566391544342, 0.06371514412702595, 0.3325673309679019, 0.21381479104375434, 0.35131157132718294, 0.15318192107872897, 0.26369129633118327, 0.1545207803245996, 0.15098425859136844, 0.2798420441101164, 0.15924312455368472, 0.11471581770717953, 0.11835645252172633, 0.12750819631285926, 0.12419722440429282, 0.11272504897060642, 0.12205414534654935, 0.10549436057786332, 0.12836021143257348, 0.12121650286431174, 0.8303802200046373, 0.952640993374017, 0.8693050570721814, 0.9276443884810937, 0.9376051973820297, 0.928001299847726, 0.9553669646235319, 0.9639167288933634, 0.9647218751113064, 0.4237537831212794, 0.2878956780466079, 0.4390723363303839, 0.4476961416837938, 0.3548763105840862, 0.3365037412610866, 0.24704665749387578, 0.3532899039802532, 0.3577150923617858, 0.8137765784084504, 0.8500977626954314, 0.8094104455633613, 0.2760877282577915, 0.8414102571901478, 0.7623235612565653, 0.7849972862290163, 0.1499881631920882, 0.8353907859490796, 0.1273724935068029, 0.18275225027816955, 0.12642246382003364, 0.13651047118840942, 0.13881533782637778, 0.15067272621980532, 0.29621646061204143, 0.022543161660951605, 0.16188992714592154, 0.2234046773573357, 0.200578819685843, 0.2722559486672047, 0.18574033726570005, 0.4200023511932006, 0.12792613110895912, 0.1629676629647705, 0.13361655703494635, 0.12686824004511532, 9.999999999998899e-05, 9.999999999998899e-05, 0.03291863023854402, 9.999999999998899e-05, 0.05144668267831698, 9.999999999998899e-05, 0.012018544322855429, 0.05063912025559181, 9.999999999998899e-05, 0.1173177877960716, 0.19822761381438625, 0.059810346481179666, 0.07293943199486386, 0.07777531081293931, 0.02831779561144654, 0.12015347289725664, 0.10225290786756636, 0.0968259233538653, 0.00971801676715145, 0.03945043344943022, 0.09302188985098403, 0.12048714215259171, 0.1245805901865431, 0.054033989854512576, 0.12533780073113143, 0.09770160946156048, 0.06781012219398586, 0.23887728794873853, 0.11675419514574237, 0.2432006551222201, 0.09372446008832591, 0.18695584082747685, 0.045012799143349325, 0.06435699079591817, 0.12809192588993612, 0.1550686164864512, 0.5058178052549748, 0.5087394373630896, 0.5143150294972965, 0.5049619271609096, 0.4979209567975036, 0.5002886669074138, 0.5249240499294585, 0.51084512460939, 0.5326659933670985, 0.1410708596722805, 0.15956176273557154, 0.11094380581244245, 0.15673198486940187, 0.1460143598700493, 0.12629248291689987, 0.09230852487905306, 0.14181662044135246, 0.08733992712181882, 0.18962497902755449, 0.26673143929193444, 0.18783623644908376, 0.15568829846951504, 0.3119443618728285, 0.28149089657798965, 0.1554871159213781, 0.1735579015662675, 0.35414331086640527, 0.35923022612757183, 0.34513512458608353, 0.3669778981292414, 0.3675068534677799, 0.36781722545172435, 0.3571228033053456, 0.39780113209499735, 0.38948143776320476, 0.37950758241870475, 0.2993414704527978, 0.2494036892566338, 0.33350232184631967, 0.3042865406441633, 0.28471792966229936, 0.3335408588263161, 0.3375791451375465, 0.3227028373331927, 0.32039207903926614, 0.21326977886748444, 0.2392667746486713, 0.21296302350266028, 0.22499436716520793, 0.21501281742611977, 0.23147832119559786, 0.20581053977338104, 0.23097548937421308, 0.2280810795541146, 0.21698431297151388, 0.19772057025889733, 0.2081693821888586, 0.233424767408824, 0.22068267935151908, 0.21711789287379402, 0.21418854021514622, 0.19351894386031843, 0.1837742579877839, 0.1667981142932342, 0.18537213409689124, 0.852741730516412, 0.16918585122646124, 0.1991132461050319, 0.19597675993957675, 0.7961605136886205, 0.16315725323837127, 0.7945077243084487, 0.8247930196171936, 0.16881199755843312, 0.7273844407289238, 0.8697439742455926, 0.5948319026190105, 0.16654080056579024, 0.16741613440439906, 0.38663944485470625, 0.32656303960389876, 0.18239738695909935, 0.18822681366598804, 0.1846097921667751, 0.18297854890546128, 0.2101973822583777, 0.19158548149101895, 0.18526687862700675, 0.18887382823496268, 0.17167962638758238, 0.08574632173101804, 0.09504756082052734, 0.09274724655261668, 0.08069500468091084, 0.09418615708842282, 0.09106671461698368, 0.0933475142962561, 0.08973525941426996, 0.09200084427431743]}, "mutation_prompt": null}
{"id": "806ecfe8-e99d-4ed5-801d-15eb28f72c2f", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness, population):\n        diversity = np.std(population) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n        if diversity < 0.05:\n            self.mutation_factor += 0.1\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness, population)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a population diversity control mechanism to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 41, "fitness": 0.32909306130049504, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7342015876720096, 0.7121154423964818, 0.7142192683219037, 0.7172277221595798, 0.7176563385359416, 0.7050698794272621, 0.7198746526126352, 0.7200377355412884, 0.725846831462466, 0.6072005883172009, 0.5948480442624251, 0.6001577912976148, 0.4098175319594032, 0.6405969995184031, 0.6161282114548796, 0.5781239698261053, 0.5984744460949516, 0.6591047666596661, 0.3158138881770638, 0.1593702061311989, 0.29408249696986355, 0.2606645517838245, 0.22789879758638498, 0.13724411504834733, 0.33927029677978227, 0.22363214351256333, 0.1629662787293159, 0.14186537084082596, 0.10518152664724711, 0.12550159541597183, 0.13354632865960103, 0.10902152157272615, 0.14027615362245893, 0.11828324161859549, 0.1468800681640683, 0.10848754209035505, 0.8737856622440308, 0.8814416345881835, 0.859271049043661, 0.942871547814457, 0.9425741218871326, 0.8738322252930331, 0.9447937343101198, 0.9649621175963734, 0.9130065476353925, 0.41797731477505606, 0.35037109203561967, 0.37245079179238116, 0.3851495408304758, 0.36361940131717996, 0.3665308580956306, 0.32548500165484995, 0.3537657510587011, 0.36503038782070285, 0.7345145937673165, 0.755846212810636, 0.7215660066323926, 0.7701851321216346, 0.7851591561831215, 0.25934178837440724, 0.7306323838917639, 0.7101048058656576, 0.7614211103640564, 0.16307863368396336, 0.14228721034008318, 0.12336083767459427, 0.2461016216674905, 0.130398204010012, 0.39230642016141726, 0.5791004811128391, 0.19928231959478726, 0.18897254671565145, 0.19207554783111846, 0.11120343990093406, 0.23934561479450045, 0.13837603566333545, 0.5145869787322233, 0.1409105595791168, 0.26323927539132386, 0.1635447974539257, 0.12839230863948414, 0.010690785578533868, 0.13872635449100323, 0.07841277915820732, 0.0826325077519563, 0.1439069096209501, 9.999999999998899e-05, 0.02421903788832047, 0.05256299189577607, 0.0171000206988976, 0.12539162275921079, 0.17331317586467465, 0.43519417020327156, 0.09039218489917233, 0.11499641977613428, 0.10722497756154847, 0.061434822633014474, 0.06870609578352482, 0.07153701165083115, 0.14390016334193334, 0.08302809423131496, 0.14231911743501058, 0.2992341283300981, 0.148034943940057, 0.14393331240665008, 0.12139404722236302, 0.09138731950625079, 0.12010065866212993, 0.26116759965303493, 0.20326130062261105, 0.09207315271554495, 0.11830974273507633, 0.18559283119789327, 0.2240122061067108, 0.11929750499360647, 0.19714279794722955, 0.1993529075419832, 0.5518688407508958, 0.573035461934445, 0.5642684114815619, 0.5438481193011195, 0.5460464699912306, 0.5623352998475873, 0.5596394951073018, 0.5530873599859008, 0.5671722581148433, 0.1390797240262306, 0.21531186166879557, 0.11083725427792557, 0.12958542155150132, 0.13613913547224987, 0.11231971584887501, 0.1426573460767615, 0.1131771229543641, 0.08309854631172398, 0.1767868152565869, 0.18285995537498545, 0.1765517186708203, 0.1566613105016087, 0.18673798669094654, 0.14545232039117018, 0.39560021872141726, 0.16253480931908182, 0.20580900667888236, 0.389593347006709, 0.3775287658382058, 0.38385864649756873, 0.3745112676621839, 0.38361926372320954, 0.38689437509978275, 0.3854230662829451, 0.4049621925639615, 0.3682604166237663, 0.305821567872851, 0.26494027479321214, 0.32293796890759696, 0.30187224501159615, 0.2975137531016466, 0.32347837579717476, 0.30082446163630483, 0.3098158126606839, 0.28084165180140097, 0.21627876885823039, 0.2054718590307918, 0.22059339983441062, 0.20924835323421176, 0.20794173719270326, 0.21591215593107793, 0.21600282133181603, 0.21799122728352505, 0.20451758188917224, 0.20400888800890493, 0.21805474534138436, 0.21857780818244954, 0.2547208459223125, 0.21849592154273567, 0.19839647724203402, 0.381373665268422, 0.19354160021505962, 0.20450571144638618, 0.1684291936071528, 0.18411037721521928, 0.7963703108832415, 0.7008396519001445, 0.19613314682319016, 0.7149335693199511, 0.6356666669939178, 0.16976195169700936, 0.7938532863787959, 0.744439456246925, 0.16764964828811246, 0.7309726994027297, 0.7303547269457502, 0.16463026174861173, 0.7337132355245368, 0.16684147256310167, 0.413267216049644, 0.7410537710479029, 0.18435057701947744, 0.1884187617029337, 0.18006079550844734, 0.18104666723854246, 0.18865116446355557, 0.19164975311195664, 0.18526220789025782, 0.1772571040316956, 0.18110165902537434, 0.08898208343096936, 0.07743439464361057, 0.08675178889103008, 0.09206341211052838, 0.09667525036371194, 0.09575744172009149, 0.09861827875602358, 0.08729206633754583, 0.09584975465430412]}, "mutation_prompt": null}
{"id": "8b8bfbce-4d95-488a-b5b5-9adc11b40cbf", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size) + np.pi/4)  # Added phase shift\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamically adjusted sinusoidal perturbation with a phase shift to better explore the search space.", "configspace": "", "generation": 42, "fitness": 0.328750647493824, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7461011658584924, 0.7570441495504993, 0.738540511619659, 0.7356650197909429, 0.7311149689659471, 0.7343916639371015, 0.7369183528901131, 0.7342719962696437, 0.7426610618474576, 0.5684147557667647, 0.5665802405731598, 0.6106521674412075, 0.6113495450826919, 0.6158382972409643, 0.5791216647216327, 0.5546358352917902, 0.5621034384969292, 0.6078171660637005, 0.15377796783585018, 0.15558773598948594, 0.16106319542064207, 0.31832072081720486, 0.21724088339084646, 0.2508425836401932, 0.3229986015882551, 0.1442013743533218, 0.34102476148321526, 0.1349966354216886, 0.1413656567500362, 0.14366002695401325, 0.11088564512769006, 0.11008525686240267, 0.16349063487200677, 0.14030421650746305, 0.1373853785865704, 0.1407577923029698, 0.8707759480720052, 0.8298526700941359, 0.9252791806143227, 0.8763351452217328, 0.8912804482079736, 0.9203461750961267, 0.9220850461808185, 0.9328850806012408, 0.9368373654490438, 0.3636470362652613, 0.3622193724056749, 0.2981980007775846, 0.3557383526043082, 0.33273220219232746, 0.36779426503364077, 0.3655464764272036, 0.32780183162222054, 0.35245721115323525, 0.7774626310888655, 0.7434352567448901, 0.7302557020679534, 0.7115264230520878, 0.7428033362356096, 0.2563065213162796, 0.7374391592738548, 0.7433961549469414, 0.7483575327485945, 0.13531716222699064, 0.12509915327405996, 0.14775216403088032, 0.1224545271225177, 0.1298377439502878, 0.27153430202468243, 0.16929226468505165, 0.21434350198981322, 0.16498733986300373, 0.233724423058846, 0.18985569179701345, 0.15831653723041472, 0.14432411761129427, 0.31241721695959546, 0.17969428480420624, 0.1294178159058056, 0.16649013293180193, 0.22174935467705026, 0.17188184464419032, 0.05452296141491386, 0.044285144767725826, 0.1031935416020191, 0.07807173571051085, 0.0913909529749024, 0.07041986760847829, 0.006896122955688422, 0.04498324459561642, 0.12966158568495012, 0.10743401584100354, 0.06883303231980842, 0.11229792459481136, 0.1482640824810011, 0.0650648551153481, 0.269761792540952, 0.12240796738022386, 0.0851963318730593, 0.20004357648452953, 0.05369285218587361, 0.1159820699896712, 0.13486982494330968, 0.11477776195887834, 0.07427624214171213, 0.09839114068242183, 0.08460785458076969, 0.09076898240788689, 0.18374532356805162, 0.2020793743640089, 0.22919374856766206, 0.16971779135018117, 0.270751860350676, 0.28213673787253213, 0.12991596367549796, 0.21664066688357408, 0.13558204721631517, 0.5665592311626737, 0.5682780567742061, 0.5796262747030854, 0.5295952493898755, 0.5741538576404157, 0.5414236726727519, 0.56192926143918, 0.5348317888567988, 0.5538171550652495, 0.13218866523885642, 0.13408740214838877, 0.13264495261083997, 0.12913234116521088, 0.1554554741608848, 0.1539825457317422, 0.14047981584718183, 0.10866781764894529, 0.13580603412649217, 0.16236202499483388, 0.21752088403330194, 0.16587227464060783, 0.17903812556291265, 0.15797217967646815, 0.2514416478320901, 0.15159159074810702, 0.19186189829211608, 0.15153732791938201, 0.36605207598472134, 0.36844365252441447, 0.3946170831519952, 0.3696243053734377, 0.38236874229209006, 0.3858818042246226, 0.3911237423857099, 0.40476393148846634, 0.407122545322984, 0.2174493219280772, 0.31236910142989915, 0.32219262335701593, 0.2889723035737669, 0.31379484814613223, 0.30103385325667076, 0.3250825249671241, 0.3248711289773075, 0.3264052930218425, 0.20369535817651063, 0.21921630856820018, 0.22362459218958042, 0.20293549115287146, 0.20955825957106322, 0.20672534870574732, 0.20716793929054989, 0.19920687417560767, 0.22502226404560133, 0.18875338633169136, 0.1790867440256576, 0.20118163588135418, 0.21344137429544197, 0.23723856594279225, 0.2206111539371335, 0.20630882143955964, 0.18626973039761419, 0.19409610652424958, 0.1833923426465197, 0.1844083935243246, 0.7794930445561896, 0.8177581243290378, 0.3682088515091546, 0.7610452573771742, 0.7855165460540591, 0.6931308090012334, 0.837839841218328, 0.7687608658209709, 0.2065358570167788, 0.7502949821432743, 0.7705971259231413, 0.16290722153345905, 0.6624357192939178, 0.16737166913877877, 0.7155316629844719, 0.7132109787301033, 0.17352979546063074, 0.18387017593959476, 0.18228529332477783, 0.1833456660607331, 0.19503753493313136, 0.18047014156567587, 0.18312963888446243, 0.1835270264310297, 0.1902025520366687, 0.09054161425081331, 0.08808037984076122, 0.0953537987156553, 0.07954751333208843, 0.090464124348419, 0.0910371221944275, 0.09478823483754517, 0.09881340209693423, 0.08715601319304422]}, "mutation_prompt": null}
{"id": "b5159608-9ae7-4936-9b18-89c81da796a3", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        improvement_rate = 1.0 - np.min(fitness) / np.mean(fitness)\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map() * (0.5 + 0.5 * improvement_rate)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic crossover probability based on fitness improvement rate to enhance convergence speed.", "configspace": "", "generation": 43, "fitness": 0.3092981577869454, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7240693865775853, 0.7198773961486202, 0.7010851833046706, 0.7134235560398589, 0.7144399735841442, 0.7083198031803987, 0.7071537268804311, 0.7159841556391273, 0.7378217759328172, 0.5565689336052282, 0.5991552772453612, 0.5287845433920351, 0.47234578807008, 0.6043250963256843, 0.5515359736578864, 0.5631903751416373, 0.5614461644537965, 0.6492144969063622, 0.383269799346855, 0.26139023632817104, 0.3131684543460408, 0.3101083108199941, 0.41276191836365794, 0.3564525037078178, 0.16157581531366738, 0.46397686031104646, 0.24858878128159223, 0.12499081246748878, 0.15753863166607385, 0.14056453819411596, 0.13668538588783608, 0.1448246378589323, 0.1843383498890454, 0.15123841244849612, 0.2438106578400947, 0.13727671252652285, 0.8456222180715764, 0.8810267045604785, 0.8407398876488422, 0.9580245207536765, 0.9190196236076879, 0.9288922820741023, 0.9473845026970898, 0.9134508075422154, 0.9252131961416696, 0.3169757442030581, 0.3310206007643577, 0.321339034202327, 0.3456995324364357, 0.3598227949513674, 0.3315262829943081, 0.3472620280243771, 0.3097737577225764, 0.32168220935152636, 0.640582392208892, 0.7144211283867621, 0.6362936617374082, 0.7759118458553038, 0.6714661487371546, 0.5752189554922039, 0.6953449624487891, 0.6679926054672711, 0.6417504305589117, 0.12246787877275034, 0.2017242162813404, 0.29425658939760746, 0.1763313970817555, 0.18428933326534525, 0.26456720474174955, 0.16741553793036978, 0.15575898065697913, 0.18996931877794132, 0.2512197658936005, 0.10933360814959614, 0.22884536761122076, 0.15969533915228107, 0.19342293330967697, 0.19486300196467665, 0.1251417039070457, 0.14915193035626106, 0.13655581846852216, 0.07201498665352413, 0.055050252791983056, 9.999999999998899e-05, 0.04460014866650219, 0.08277918890826097, 9.999999999998899e-05, 0.00807513963452966, 9.999999999998899e-05, 9.999999999998899e-05, 0.0851485502128766, 0.23251633462118237, 0.13815262120132188, 0.12167247975146167, 0.1110876148933918, 0.1060342513223308, 0.07013709891047382, 0.1631881789955345, 0.21018706054379876, 0.11075253813255437, 0.1320104855713502, 0.24049292403796863, 0.2790505805481548, 0.11982789008159767, 0.08658615182402285, 0.12230543742120314, 0.08252622596140158, 0.13026653563786617, 0.1325459474251185, 0.10214601556636793, 0.12083178824141327, 0.15807394459737456, 0.1546378373549211, 0.15566688196139, 0.19221965293083132, 0.11223661297772813, 0.057454903256784706, 0.48244621173655, 0.4926366348729967, 0.468991222982024, 0.47658788914546124, 0.4779434202310465, 0.47652625822062644, 0.4867951644202856, 0.4919634023492132, 0.5160323116244128, 0.15800157219277922, 0.13487059965385484, 0.11246580126848549, 0.12981318673250297, 0.11273424039810565, 0.14161897636039433, 0.13003947096886181, 0.12838955131419227, 0.12006744395349778, 0.14986985780575302, 0.15590525982315118, 0.14809074554057156, 0.14750791572568178, 0.14739522667309557, 0.1418096170626404, 0.26051196320541137, 0.19466374751320303, 0.14903527637247294, 0.3273120987485377, 0.32723746797927766, 0.3267229200529044, 0.34364106887458457, 0.3429890807531246, 0.32150217274952075, 0.35706906015422035, 0.3621012800441521, 0.343552204776564, 0.2575101094699176, 0.2486065103013353, 0.26997789434831254, 0.26428629981187834, 0.25815142259851365, 0.2822879618457572, 0.2948158001013612, 0.28644346618491345, 0.2649613357404921, 0.2189506698405096, 0.21273250600213978, 0.20350891765901802, 0.1901901143451844, 0.21512353070230827, 0.2197537240451901, 0.20118781883579617, 0.19146817301880903, 0.20525959791599846, 0.21863053827575463, 0.2156987347842816, 0.21421949297095955, 0.24158549863781453, 0.2617338911134274, 0.20692765688078674, 0.2639545458816005, 0.2891621626710512, 0.1899967026732161, 0.16913354900259014, 0.18309043324396346, 0.6732052290584103, 0.6764677193635144, 0.1968595225005464, 0.19607528628246174, 0.7391529216219097, 0.16653992593529876, 0.7556043992637518, 0.5835479699036765, 0.16798038920793368, 0.5023281985020638, 0.5572636182105547, 0.16421863952664584, 0.48133836809603936, 0.16682933575433345, 0.6078256629596798, 0.5117484107333452, 0.2152149713451187, 0.17769683004854997, 0.1783331163656905, 0.1893927857293315, 0.19071038437395005, 0.17061320608948005, 0.17507431535382223, 0.18749520078265736, 0.20251296229671145, 0.09794983023936621, 0.08887732848590568, 0.08822770140072644, 0.08868127908724732, 0.09058833301890046, 0.08634117867115076, 0.09516702633088203, 0.09924951085933864, 0.09465467372069014]}, "mutation_prompt": null}
{"id": "12f4fb7f-a95c-4b1e-a9c7-a9520eef9afb", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        improvement_rate = np.min(fitness) / np.abs(np.mean(fitness))\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map() * (1 + improvement_rate)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic crossover probability modulation based on fitness improvement rates to enhance convergence speed.", "configspace": "", "generation": 44, "fitness": 0.31350662131939927, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.743609494284154, 0.7444924787477368, 0.7595852495880506, 0.7494577277655563, 0.7436477212543043, 0.7436415775708363, 0.6842108577386308, 0.6970386672722032, 0.699007606444527, 0.48632559103753936, 0.5031903184261197, 0.5111307920706627, 0.4909432493806233, 0.5202868516797947, 0.5296933672175269, 0.5078485233215997, 0.5157858178844466, 0.6026225494987605, 0.29498065122341155, 0.33268676757725857, 0.33840976195197203, 0.16271220553720633, 0.1480734488794928, 0.22775708408535555, 0.2366767323609098, 0.2682816995869448, 0.15623598594283827, 0.15313466375746643, 0.13790895014186244, 0.2421183874846583, 0.13459778232018305, 0.1336892352744108, 0.1270068385934623, 0.12781615086536025, 0.14014532031688687, 0.15118052952062644, 0.8815056770590808, 0.9234241647500228, 0.8858959284011958, 0.9598034554485393, 0.9348793354372811, 0.9452314464995929, 0.9503733533119495, 0.9462874227636882, 0.9199110552186764, 0.34863952104525453, 0.3733056659617343, 0.28127475525783974, 0.3738252799172924, 0.3419652553232553, 0.4286700781853804, 0.25379639447058455, 0.24541292780329482, 0.26254408398567786, 0.7768881594922603, 0.786555291288423, 0.7892780853365873, 0.8225493673747927, 0.7893166138882444, 0.749618468884049, 0.7916459632067674, 0.7168498145483547, 0.2388201126090711, 0.12731706804360454, 0.2843367421541697, 0.15266130510470466, 0.15790129663073071, 0.17052779936525042, 0.27779667885882486, 0.20218907413152387, 0.19670842308266334, 0.29514559101853455, 0.20681583788937552, 0.11066798756221996, 0.18442850035657377, 0.16977277223920006, 0.11336960108815508, 0.30850684713130827, 0.18679833065749307, 0.14527899609600425, 0.18272033280793243, 9.999999999998899e-05, 0.07213456110333705, 9.999999999998899e-05, 0.02476069054982566, 0.08048491481243802, 0.003036771946738015, 0.009616218035358726, 0.024041691799238873, 9.999999999998899e-05, 0.12256019434998511, 0.38178101589869584, 0.36736858034745223, 0.10069901732118436, 0.14823553386526678, 0.08658450916198779, 0.0650423448981422, 0.26372510504543656, 0.09518498694591038, 0.04370182617245988, 0.09829160005441828, 0.16499592711070077, 0.16766610942258864, 0.10433305766641876, 0.08504894679861663, 0.11257400965413322, 0.14625906971638036, 0.06790748072613628, 0.14253624738753556, 0.19534140690494717, 0.30532274334086607, 0.13260286853979908, 0.12401811011767117, 0.09333607587861281, 0.1569028240846243, 0.13670160321797176, 0.13369951200347752, 0.43833044828781553, 0.459153681485134, 0.4480799791606349, 0.4362737013984743, 0.4422206333608404, 0.4482548505740922, 0.6234795892371671, 0.6580714787796778, 0.6550792756270463, 0.12481074515673296, 0.11188604608857444, 0.14186973444372308, 0.14070651808940182, 0.09847301112737583, 0.16776670517547732, 0.1250093619656092, 0.09698813370139503, 0.126245752729937, 0.17011766714222099, 0.21636036179820506, 0.40641978161233205, 0.1655339979516588, 0.1502693820354576, 0.16102893208921087, 0.46437604337942184, 0.41887214911629367, 0.17157840543328662, 0.2747401007629503, 0.2613659575958527, 0.29150961213669346, 0.41277032671262703, 0.4203233683573472, 0.4226593341776076, 0.4201311680179811, 0.430902076348076, 0.4161514139419641, 0.18852884413334237, 0.1993819741781162, 0.22632951141858026, 0.22670516100667337, 0.3410871795244189, 0.3443245153602066, 0.3625840934993738, 0.35653032448195643, 0.3303601023669305, 0.1870316873251504, 0.22888917012903065, 0.20140857828979963, 0.21908946844308452, 0.20672123575409007, 0.19083225752072008, 0.20699710630129087, 0.23649830636875113, 0.21798157991835676, 0.2174431052565755, 0.20570060112458177, 0.2818125793993237, 0.21166689562165086, 0.4554663593387417, 0.20810941648559989, 0.4806161168293228, 0.204921907303816, 0.20177853454846295, 0.17090230612741508, 0.18318919095266584, 0.8327113439614473, 0.2815942296035028, 0.19861448398197923, 0.4583657140237559, 0.5250368919355103, 0.22660967141601263, 0.6121936706508863, 0.4530320947873353, 0.20544307982386345, 0.42387110617588164, 0.7806256855410585, 0.2079172455503755, 0.20534868840042309, 0.2052464768141664, 0.3126550375893604, 0.3822849256057441, 0.19034983368766933, 0.17402105041293003, 0.18120333091234475, 0.20028480467704013, 0.1894750890077156, 0.19476506733757937, 0.1900449820983371, 0.17487633144650228, 0.18806817920311647, 0.09115639291675359, 0.09366845830859971, 0.09425421719240945, 0.08871168413330488, 0.08672671032002233, 0.08886616576547857, 0.0905481333367315, 0.09431325192426432, 0.08991128927291447]}, "mutation_prompt": null}
{"id": "b00a7cf0-3f12-4c9d-ac6a-7dc46f3f2911", "solution": "import numpy as np\n\nclass AdaptiveChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n        self.success_rate_threshold = 0.2\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + sinusoidal_factor) * combined\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, success_rate):\n        if success_rate < self.success_rate_threshold:\n            self.mutation_factor = min(1.0, self.mutation_factor + 0.1)\n            self.crossover_probability = max(0.1, self.crossover_probability - 0.1)\n        else:\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.1)\n            self.crossover_probability = min(0.9, self.crossover_probability + 0.1)\n        self.mutation_factor *= 0.5 + 0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size))\n        self.crossover_probability *= self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        successes = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            success_rate = successes / self.pop_size\n            self.adaptive_strategy(self.generation, success_rate)\n            successes = 0\n        \n        return population[best_idx]", "name": "AdaptiveChaoticHADE_RMC", "description": "Introduce a self-adaptive strategy for both mutation and crossover rates via success-based feedback mechanism to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.22487388798826122, "feedback": "The algorithm AdaptiveChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6854721177351466, 0.6709294391989131, 0.6775955834919771, 0.6730951269444805, 0.6650011084834336, 0.676696040174743, 0.6694448834301063, 0.6607610890892268, 0.6638344687721242, 0.4213985677787817, 0.38300112843384926, 0.3867636490561095, 0.39171969258676276, 0.39705486779440335, 0.3929513247699621, 0.4025744104964992, 0.4311683530768572, 0.3957151308199405, 0.2988332566853207, 0.30852252213906917, 0.334607493244232, 0.33823588891603396, 0.25143142877368296, 0.2992255463086675, 0.2777640324925311, 0.2559931053035406, 0.3208118363850009, 0.19426449929566514, 0.18893520551968024, 0.2183020710777478, 0.2511194279463229, 0.2446988136445376, 0.20935767368064018, 0.2470156820638435, 0.20222797339385057, 0.19843356603875895, 0.7924204957817313, 0.8499229978341725, 0.871978668809454, 0.8258658242753827, 0.8228666121137203, 0.8019770176969516, 0.8184896717905148, 0.8135388113957808, 0.834166828705078, 0.13330770579638118, 0.1338398696446793, 0.14175314404282813, 0.12921899393927017, 0.10083010669699599, 0.12540783656621934, 0.1392698482167376, 0.13327716734929396, 0.1436735222908948, 0.17430864303755678, 0.191157317645818, 0.16803824386453747, 0.2639713941762316, 0.22155108904335652, 0.2541776099382892, 0.2163031994755491, 0.20787239632674914, 0.23475765630037315, 0.17933467402680014, 0.16373173270846852, 0.14346772366651606, 0.12802242509800565, 0.1564549287652539, 0.18255738305937208, 0.17854133540715011, 0.15473987404797285, 0.16461864196085263, 0.1231575792640569, 0.12420175652033671, 0.13860744379173118, 0.12885852511420903, 0.11906180450343895, 0.12614479082088348, 0.1225023849853043, 0.11766470335064227, 0.12474762309230303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07083764060016551, 0.05732224674377051, 0.11501960086029817, 0.0679834790031848, 0.065192397630633, 0.06016706318827869, 0.11539226037337902, 0.07559328501270735, 0.06301736277114978, 0.00011229709258331333, 0.0001857108525262774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015002315541519096, 0.011808882756101258, 9.999999999998899e-05, 0.07406962060075162, 0.061379796433941425, 0.07346651653544145, 0.08303112702516047, 0.07509234395934727, 0.0907718594074306, 0.07226823414022232, 0.077156837570306, 0.08993246901466778, 0.37870352068143553, 0.40730555585350947, 0.41597259773385664, 0.3824782117448521, 0.3821092376209595, 0.4077051890368476, 0.39586604762645405, 0.38601460272300236, 0.3843462052013027, 0.08556207487761569, 0.09322696373105555, 0.08846692839199932, 0.08795749382626528, 0.10933568712412689, 0.09350156611013316, 0.09190064708673051, 0.09058906474686723, 0.07776576736458651, 0.14438829945532672, 0.14951277201278212, 0.1681190190402283, 0.14610493876201258, 0.17127787688711338, 0.13511010560858194, 0.17006824194449455, 0.16497972073262535, 0.1507143882648323, 0.2261232707257912, 0.20512579065329062, 0.2334208379830065, 0.2416858080070583, 0.23157259179763123, 0.23148521235780517, 0.21475737228629554, 0.2440395864196775, 0.21508853117838245, 0.1597409243361292, 0.16275337087241837, 0.17766062296173912, 0.1589632384779779, 0.16546770783436038, 0.1616438163575047, 0.1785966392155326, 0.16919636271428795, 0.15398323760535493, 0.2019004943161814, 0.21698036586529523, 0.19806644267722517, 0.19691515744714028, 0.20412541932314965, 0.18763697502655519, 0.18207556945957315, 0.19979333491994444, 0.1947848863145336, 0.25706923211893307, 0.21746438429877613, 0.20653636257970187, 0.21739194274851004, 0.2909869947427738, 0.2233667006711777, 0.2552501279126874, 0.225482880927814, 0.23068322140840403, 0.2273122954228205, 0.20443427071940934, 0.1876531221639962, 0.24366904907533338, 0.23304993115292505, 0.2787710716161804, 0.3322877779170068, 0.24814886696083815, 0.25320762320653256, 0.2434485402413641, 0.2102666121281419, 0.24785498226381675, 0.21368425074338415, 0.23457413597025012, 0.17612786894502297, 0.3170058317727984, 0.20317873464997604, 0.14727220715347522, 0.178406059322333, 0.19870437135148744, 0.17948819427735763, 0.19196761425830877, 0.1720133094779105, 0.19044557187119548, 0.17875465596510853, 0.20790411338651893, 0.17444294176003838, 0.07444429003563635, 0.07150347238630583, 0.07331600235539903, 0.07487569637684033, 0.0745276475569423, 0.0813200173462113, 0.07632719986346725, 0.08053704646005788, 0.07341793548396014]}, "mutation_prompt": null}
{"id": "de3cc84c-3bfe-4b99-930c-10f9c7ec55a0", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = 1 / (1 + np.exp((fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness))))  # Sigmoid function\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Integrate a sigmoid-based improvement factor to more precisely enhance the exploitation capability of trial vectors during mutation phase.", "configspace": "", "generation": 46, "fitness": 0.3044752871816005, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7825021367175423, 0.771953354013906, 0.7849867583568466, 0.7720644307720134, 0.7784832101310583, 0.7702384044968428, 0.7882219330952632, 0.7808223825539058, 0.7716204960228032, 0.5827396973992232, 0.08160185514438345, 0.15255021678369118, 0.6290977293799915, 0.6151397974999455, 0.631136450206148, 0.5789203348516434, 0.6356742770475516, 0.6445020890205444, 0.1697304522615506, 0.16848674785746331, 0.42356331316403106, 0.388376562246189, 0.15028570968547028, 0.39710266879950806, 0.1492220134625455, 0.46970190263791534, 0.16140353466693091, 0.11669769651442696, 0.13668965086014995, 0.1327589544544695, 0.15136728932738697, 0.14171393262103793, 0.11010138056125907, 0.13798438369230404, 0.10958530460297367, 0.14877009506585814, 0.7483057886171234, 0.8783351661307006, 0.8517852548212066, 0.7051840442985255, 0.9287977375554212, 0.9118165600727343, 0.8626233728425556, 0.9426314203357962, 0.7262022991901123, 0.29919175063267767, 0.19135755782782593, 0.23358373352723816, 0.15977154831440543, 0.33470034705935015, 0.1932305397634485, 0.16504103739517884, 0.1906393958757998, 0.2395089176350309, 0.22716602289170817, 0.8430802225188943, 0.7690014369473509, 0.8127310444995055, 0.7344810585854826, 0.21514441984775634, 0.7899746782079091, 0.8146131253277009, 0.24132996961109798, 0.11437273707602946, 0.13545713898545542, 0.29287826258611305, 0.12923104410355957, 0.17710029071465083, 0.16975511900084728, 0.18839463433186998, 0.1652596879385354, 0.34954613404231416, 0.16880761083776274, 0.13692051719150655, 0.138108365538946, 0.1701426904514075, 0.14481348754129486, 0.14153065032282497, 0.19856828001042415, 0.12763934110195674, 0.1283239380953437, 0.011744996582758405, 9.999999999998899e-05, 0.04708959842032967, 0.09453369675827694, 0.03358628898282601, 0.011715687966032395, 9.999999999998899e-05, 0.013379954523725757, 0.008474441450645687, 0.07603194757972209, 0.08985464084393968, 0.06842357099281493, 0.09179953042509348, 0.03232865341477831, 0.02147473341987005, 0.1625548466290595, 0.1207575725611727, 0.10955901532790335, 0.23931695812620968, 0.1083056241905721, 0.1956687618134314, 0.1080669460574738, 0.21630507361948847, 0.08653690925542556, 0.3026191635829668, 0.09318770854493064, 0.2691888809320706, 0.18371221790452108, 0.1988656685474931, 0.1433146634197635, 0.04815597886103262, 0.11101760132801342, 0.1227304977915068, 0.144270449415692, 0.11057507448463333, 0.1157199816430381, 0.5381974437138034, 0.6052176924766248, 0.5139320908799024, 0.5424559779580429, 0.5486251069786239, 0.5759510764438205, 0.5724061462222978, 0.5717221958829086, 0.5787948198336417, 0.13440339887288644, 0.13029749301931515, 0.11848951404126529, 0.13885612381610712, 0.14089734373194407, 0.1353301810072708, 0.13885298159190118, 0.11590873013114233, 0.10687083573635392, 0.2036285715801135, 0.18401487987827803, 0.17839648989172907, 0.26541837752853936, 0.4478977031752258, 0.3338062345766565, 0.24644086918711183, 0.2974086169864413, 0.22036164527936908, 0.2891348784275577, 0.38463309811207014, 0.3998261260264332, 0.42182989530910575, 0.4126685611143639, 0.39564976329103196, 0.42000811449213493, 0.46044279612428685, 0.4514822718971393, 0.28148913281379273, 0.311315331781568, 0.28164460745165465, 0.2927052338756848, 0.26573697618204983, 0.3252923556916014, 0.3326480230476284, 0.3597214971270246, 0.34565754870483534, 0.2136785931691797, 0.20685436395915446, 0.2430433284656105, 0.21649251233632416, 0.20071680638253697, 0.2195967353489766, 0.22200914684443118, 0.2145993711779277, 0.2236646475186269, 0.19326618304486254, 0.20982347032783089, 0.2185259407800244, 0.21550340705513937, 0.4879792396677056, 0.22129716680681144, 0.38901084839630606, 0.2112802759677137, 0.19244929621664597, 0.1839941384626962, 0.187211587804487, 0.1868786343447264, 0.7696610643915043, 0.19900325841712496, 0.4646468647081812, 0.8185523054673618, 0.7290080383867307, 0.1775080684847884, 0.5697276535732945, 0.2103371702269633, 0.261407568759608, 0.8188734962233891, 0.20783170869459, 0.16678004546656444, 0.1673857401344674, 0.32432170310607633, 0.3744947729114406, 0.1788620624038938, 0.1976500930882682, 0.20368771367860128, 0.18251457721103082, 0.1908962239543721, 0.20730372166281863, 0.1983079651521047, 0.19339829423118915, 0.17665752056063388, 0.08876447021105682, 0.0904349120233201, 0.07928332617439993, 0.09229242496956469, 0.10123753595046969, 0.08164106365785961, 0.08938726838192301, 0.09389656233301902, 0.09261952908473847]}, "mutation_prompt": null}
{"id": "da814bd2-608a-4374-a292-9fe2a779bae8", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * np.tanh(self.logistic_map())\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a hyperbolic tangent-based perturbation in the crossover probability to enhance exploitation capabilities adaptively.", "configspace": "", "generation": 47, "fitness": 0.32870027023311643, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.740796332056554, 0.7258928351521485, 0.7211519778335709, 0.7343712304369846, 0.7414905834378451, 0.7413286656365912, 0.7352128051987223, 0.7182263265307278, 0.7395030737037407, 0.5285978281169833, 0.5267744058251785, 0.5562612006803451, 0.59768229470507, 0.5647185383306991, 0.5810337288369205, 0.575486567461378, 0.5442143891533141, 0.6129527455104817, 0.20245668100317926, 0.3690840808619389, 0.2920872809966477, 0.3887147289053686, 0.2602155564972243, 0.28071645285049196, 0.21019841635205228, 0.2367279043614794, 0.15954108523976196, 0.13145915718942158, 0.1555061092790585, 0.14571761581219855, 0.14928030149190286, 0.1617761303411327, 0.11361102200158313, 0.1507873962416334, 0.15458498835059076, 0.11320572833927689, 0.853329298185096, 0.9374248492068155, 0.8884492923401317, 0.9606401331030684, 0.9278576098943618, 0.9344690500551048, 0.9612587592035601, 0.956303877135083, 0.9451002018809674, 0.35033525548174727, 0.3157603856529825, 0.32541328341794473, 0.3593812693374764, 0.2836313460618586, 0.35694181237969513, 0.33522406727072795, 0.31708445339626945, 0.336989583077124, 0.6811917337024942, 0.6861881132081991, 0.6474983253589306, 0.7380734972092944, 0.7794780688470033, 0.6584938536790215, 0.6624193391763266, 0.6237830406784306, 0.6715873751334924, 0.16046768443387516, 0.170738325648647, 0.20603849946530095, 0.25563795674819745, 0.1548783131631899, 0.30459391329712926, 0.14873254077732978, 0.19565171857433994, 0.16633093631289053, 0.20256462859084312, 0.22343109097822766, 0.23195453688820655, 0.1505107405373094, 0.13588728735280942, 0.2473188289386471, 0.12829588180118967, 0.3565747670886541, 0.19133604651638558, 0.04517155624421343, 0.17695058929233087, 0.04845887026215989, 0.003611108317867595, 0.002020516518361881, 0.16966271607393568, 0.04388841227540252, 0.1308299143092494, 0.00010201777078400198, 0.170736940194393, 0.10687760782533295, 0.11663666474022671, 0.08440632250022062, 0.1128409796543961, 0.12918518069331097, 0.09478380946996035, 0.15806563423606945, 0.12856564347635757, 0.029271401210295145, 0.0328990985373846, 0.15883107999754886, 0.130084298586278, 0.26384635062442285, 0.17948718959842658, 0.12353364899147323, 0.17805533615355473, 0.09219188153878144, 0.19367834260360073, 0.14506210534189667, 0.2082422527749973, 0.1894365744330978, 0.252548220938409, 0.08656795657543848, 0.23439931677977288, 0.2665318959689116, 0.08028157229634492, 0.5243665045332794, 0.5510820431691553, 0.5221598215330436, 0.5159322050315077, 0.5191546554101014, 0.5077336351161481, 0.5320315538391476, 0.5003598095251844, 0.5210917075133096, 0.12563502633593782, 0.13215873073652695, 0.13164360715967283, 0.11591350005812096, 0.1500922161178453, 0.1357311690927665, 0.13145157693848464, 0.084905377388928, 0.13122054292738594, 0.14575274281132222, 0.21636367429639447, 0.17088141220263187, 0.18691295275683073, 0.14521341496670392, 0.13509956955567437, 0.18679389397028778, 0.16342388888200654, 0.15371894988835189, 0.3625943673173778, 0.363915761909422, 0.3999881426196449, 0.368342778858051, 0.3723525093698129, 0.3471170596293607, 0.3799212005900088, 0.388626886768069, 0.3883114844716452, 0.2758838412941639, 0.28016563492833724, 0.28425570002728506, 0.29152635071178257, 0.2863047449906557, 0.29627952450783857, 0.2910415112541689, 0.30831285482093196, 0.3044499774301145, 0.20142708985474522, 0.2017085586976176, 0.19179291349655447, 0.21731421617504898, 0.20515168707363407, 0.2064789025907966, 0.20109298281266208, 0.21015197096415006, 0.19157794387469496, 0.19929853076364257, 0.351361525882372, 0.21544744515151615, 0.23842479833460384, 0.3547923472768575, 0.2113547362966811, 0.3735335859783059, 0.34553540948184425, 0.2007645981995988, 0.689289064707075, 0.725622495789732, 0.7772637511202476, 0.7881051471629229, 0.19757788966842293, 0.19708522828879949, 0.6980784205706005, 0.1708436227946466, 0.8111388653108691, 0.7360039182262086, 0.20341270447332627, 0.6772670204236679, 0.7340868778994893, 0.20235359086656124, 0.5623081229695963, 0.16691435427175005, 0.7695004467229886, 0.7123859766113964, 0.1892481362677103, 0.204137932987136, 0.17844430111818887, 0.18322379171573122, 0.1738101352854866, 0.19750158820153274, 0.18563552496871372, 0.1799831161360116, 0.181058251014115, 0.09684953138075048, 0.09695471962387414, 0.09365296400117873, 0.08770738899197983, 0.08445492326081039, 0.08496546783480607, 0.09105327838591637, 0.08732824961950558, 0.0862270728068748]}, "mutation_prompt": null}
{"id": "09e4564c-0c80-43ea-8c7d-f9e314b0662c", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.9 * (1 - generation / (self.budget / self.pop_size)) + 0.1 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic crossover probability that decreases over generations, enhancing exploitation in later stages.", "configspace": "", "generation": 48, "fitness": 0.3129722268826567, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7482688414386771, 0.7624780728508738, 0.7526858183619659, 0.7398636935789273, 0.7577268410895958, 0.7489678129606014, 0.7526925440199483, 0.7321638134176085, 0.7736776535776255, 0.5822592961840596, 0.5551936060946135, 0.4397710988086777, 0.10594762543152814, 0.6139313328280733, 0.5899913139538444, 0.10154113191439995, 0.5985041201718835, 0.5365232964883071, 0.23636413386869415, 0.31300474722880167, 0.15670362684919514, 0.27519622918324693, 0.3054096412871209, 0.15464612354110718, 0.2606044489642776, 0.16504745579244806, 0.302336557679901, 0.12933465193610683, 0.14600242228825955, 0.12720144088745944, 0.14262581894261583, 0.15401230584428305, 0.16820639508046875, 0.1112926331440609, 0.1317606606281122, 0.10475927447655342, 0.8011549152102511, 0.957761413014833, 0.9309228597110819, 0.9531944082118992, 0.8158216244275409, 0.8909657786910073, 0.9390752171002705, 0.972723556310051, 0.9632392872019446, 0.4079648655535961, 0.34377037361682183, 0.35626437657846066, 0.3542594981332471, 0.3436674104723316, 0.3895325754796777, 0.31204501921285, 0.2576592242556147, 0.3697494636026858, 0.7839225853813386, 0.7772016889427397, 0.7496430594015346, 0.8375166766574594, 0.7770976788053311, 0.21700310257614364, 0.7601969565897079, 0.21700911144038815, 0.7704928006324637, 0.28927699130268136, 0.12721173454394752, 0.12726039021381552, 0.21594525829680122, 0.12754721223928867, 0.29583119446067996, 0.14286449253574884, 0.2778841959014454, 0.17534350578855118, 0.1896424569387123, 0.06794340005256705, 0.1575051857599441, 0.1331987062040242, 0.08841993843453799, 0.12487353651511279, 0.330761491407191, 0.1613407957487527, 0.12986692172750658, 0.011642635543592017, 0.0001913966072530915, 0.1233616755681971, 0.00874525983147234, 0.07990283942030219, 0.014116028088561161, 0.17739636919766033, 9.999999999998899e-05, 9.999999999998899e-05, 0.11182909792866014, 0.10415578865066766, 0.10306308116450269, 0.07954885451056692, 0.1465721620297754, 0.01384715962454297, 0.22895269010225028, 0.15098840048826, 0.0506484155471546, 0.056208269788231124, 0.06453313624757717, 0.13409930987073748, 0.23778300871118774, 0.09496507720434288, 0.09361875172296219, 0.24526537422576877, 0.11549303469234018, 0.08838805358326951, 0.2208579818799179, 0.18042717825607835, 0.1904363919210884, 0.10898535561109512, 0.2413873536547062, 0.17333229094963587, 0.1496673936560481, 0.15164837273721898, 0.20037902754260561, 0.4947082096387184, 0.5257734003270175, 0.49519675500339944, 0.49767217400347974, 0.5241683828047687, 0.49570417253766386, 0.5061710909259878, 0.531876083945725, 0.4859135335699203, 0.10897691804252663, 0.1271595578119975, 0.10843924020674767, 0.12435483417384441, 0.1619393063018395, 0.128793189383836, 0.17427378722368425, 0.11570550689679326, 0.07214489557259762, 0.3956564837081562, 0.12110403027396022, 0.15465153381664698, 0.206433757587423, 0.156881815996898, 0.16153760795449257, 0.2956461687351326, 0.15381814559491302, 0.1311555525953496, 0.35208813428764507, 0.3633458223417575, 0.37620174884474233, 0.37304831964944796, 0.3678361989611123, 0.37389415249262137, 0.3706244230242791, 0.3792304972764824, 0.36189440562194763, 0.28101159908810036, 0.2674800805478359, 0.31550074941360584, 0.27994379157913085, 0.26799605226712353, 0.27452945928957706, 0.2941712517333406, 0.2999212612730303, 0.29571963823417236, 0.2504998377794353, 0.2153641338407365, 0.21755927270007447, 0.2234287050104654, 0.20694260247230045, 0.2065774660466776, 0.20299052908574422, 0.22397108094784335, 0.22417621635321872, 0.21531169603217604, 0.19474018427852613, 0.2222755016419179, 0.23735061613767816, 0.21625384262892966, 0.2242578604726604, 0.2055583785846804, 0.22316099808846346, 0.1943273358138794, 0.16969187497903693, 0.17101108451409086, 0.8296757513988702, 0.8481632147971391, 0.19968777981250097, 0.1979279723561177, 0.7853993836761981, 0.7952783095330654, 0.8320451112283981, 0.7799589731849927, 0.20897769983744352, 0.30872628861501283, 0.8205348841576777, 0.6995546969897668, 0.5713173971876182, 0.1670535202333716, 0.10452818437152622, 0.5594851932260189, 0.1762839493950763, 0.17607459749530607, 0.18886655491880944, 0.17621469735870743, 0.18568465189088024, 0.18678928163117448, 0.18488715512284093, 0.17403048986783343, 0.17481333689240586, 0.09064863415375113, 0.09187229837599697, 0.09311663015405192, 0.09137460469659675, 0.09104222708533594, 0.08852557122840976, 0.09308458315522183, 0.09532503752075516, 0.09740277450223789]}, "mutation_prompt": null}
{"id": "4081dc62-d1eb-457b-a752-7f3d95eec98a", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        periodic_scaling = 0.5 + 0.5 * np.cos(2 * np.pi * self.generation / 10)\n        mutant = a + (self.mutation_factor * periodic_scaling + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Incorporate periodic mutation factor scaling to balance exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.2849216970556376, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7671249296672688, 0.7732031715181764, 0.7508443865069406, 0.7447360307076076, 0.7450991952186943, 0.7673436789858947, 0.7535061160390647, 0.7373596406399694, 0.75499266574321, 0.5331938484183072, 0.5665872686234271, 9.999999999998899e-05, 0.09721846905573261, 0.17361548076515643, 0.61072767599801, 0.635278301888826, 0.26928844925358275, 0.33459749415793416, 0.16260823105777467, 0.15712183998213203, 0.17187597631558205, 0.6229945897537281, 0.1292774264934171, 0.1251267102103245, 0.670010130946963, 0.5238508267038675, 0.17446856199905947, 0.15435725757105323, 0.11546239005043513, 0.144299827940501, 0.14952095874311566, 0.14837247378759966, 0.14850264817567926, 0.1368231605449397, 0.1477334392036479, 0.17372361600350106, 0.7867290373145315, 0.9060700038772472, 0.17229880748283233, 0.9253346807179209, 0.7294216530722759, 0.8859038471442281, 0.9152789620159585, 0.9181925921411865, 0.747399494376668, 0.2339372690968201, 0.20438834292398622, 0.16703950105763166, 0.13806700942605454, 0.31037641485146583, 0.20777051670104119, 0.16211162163178527, 0.13057290134287158, 0.13556526456911688, 0.7811609837760407, 0.8244960339176097, 0.21112837607010382, 0.2674186113774505, 0.8361883857778152, 0.1585698030542395, 0.761103159614248, 0.7758806703573056, 0.23777696825213834, 0.1293755500217192, 0.13883086085032215, 0.13189318264492067, 9.999999999998899e-05, 0.12180995959326191, 0.12514536209220228, 0.14045163460157728, 0.15325179465019334, 0.14749612874594276, 0.19176440627225488, 0.12961513999068264, 0.27354406100925766, 0.14637937269398738, 0.12346337144141906, 0.12250955557589094, 0.12913360352904424, 0.11967258221129629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0051482464419592144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03809434032251935, 0.08894489398452898, 0.04230009193513784, 0.06095184434657408, 0.09669132895673682, 0.12015474011018146, 0.07108272632769475, 0.2546423501191786, 0.06778268213362881, 0.07344490557480454, 0.09670562877502875, 9.999999999998899e-05, 9.999999999998899e-05, 0.1728408933824156, 0.14113460856791826, 0.06356125301327487, 0.23499209518036046, 0.19301160966948816, 0.17411981527128684, 0.1635137507230675, 0.06049890282826487, 0.038228602271281, 0.07153516767414092, 0.05677358590913684, 0.11919591587170619, 0.08432891704051837, 0.13377463911144316, 0.1975837250080963, 0.5331171143970085, 0.5929142225923496, 0.47664775730470565, 0.5865214517016886, 0.5359521093054276, 0.5591728040791334, 0.5474311019449969, 0.5698105590082655, 0.5523770932058159, 0.10571914711241748, 0.14288106999223582, 0.12430877839476562, 0.1346084001887643, 0.179887906480641, 0.13377371162855467, 0.15148032189171767, 0.09725958858743655, 0.07145722777980523, 0.35451133594881346, 0.22576225928158333, 0.19716650989765672, 0.16668062958737007, 0.408356517548515, 0.5371857131227422, 0.43017571794389087, 0.18937932683888714, 0.34139882382858655, 0.44152942535053274, 0.38510119419853894, 0.4284191806379938, 0.42396832100099113, 0.40851750159371836, 0.41049389222301247, 0.40795017757931273, 0.45768163483608737, 0.3923227791403323, 0.2381630877791806, 0.27642562009184946, 0.3240031639007228, 0.2353171949338051, 0.2633192216587761, 0.30988654791178993, 0.2696406363276985, 0.35087292297841055, 0.2282424076260119, 0.2312717699084319, 0.19814668042163908, 0.21783707435217536, 0.21302111781819644, 0.2568593705395381, 0.23021395767487152, 0.22622901987428345, 0.2521209366770206, 0.20582634282195533, 0.21722651020744965, 0.5604023031534804, 0.2218676909068702, 0.22158302213533165, 0.24583867988763297, 0.21204322064285008, 0.21380395364783766, 0.21679045834203925, 0.18200993313210012, 0.18403809836305995, 0.18427593422205368, 0.26891382508406536, 0.8490174636598058, 0.4416956898120562, 0.8369756629282712, 0.14135291197650734, 0.17064562006952633, 0.8123593902718447, 0.6501275292528634, 0.16848837204082556, 0.20480637837659355, 0.5989885715916821, 0.16390945738518914, 0.30736428749420797, 0.16655425211569197, 0.2537979265994167, 0.24211034132451537, 0.1797332057077905, 0.18868874908875, 0.18078413124741688, 0.19802548844581158, 0.1808370287969313, 0.18506995180733488, 0.20074943397251765, 0.21715678643768588, 0.17755116283535222, 0.09451572680629872, 0.07664200193423165, 0.097214060744376, 0.08192558769099612, 0.09685994398453546, 0.09578564288265623, 0.09159755960928373, 0.09077407693642237, 0.09526855392886313]}, "mutation_prompt": null}
{"id": "0989c625-23cc-4177-a4d5-664532cbc2ef", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / (0.5 * np.abs(np.mean(fitness))))  # Modified scaling\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic scaling factor for fitness impact to further refine the optimization process and enhance convergence speed.", "configspace": "", "generation": 50, "fitness": 0.31260743192135254, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7417294126147196, 0.7513914360308622, 0.7345464601614893, 0.7527341303735329, 0.749004210887678, 0.7463262268507014, 0.7351679185406369, 0.7353255011676032, 0.737671662977565, 0.5884500078959433, 0.5933210910472166, 0.5495722160264978, 0.6260068905995213, 0.5990095177987484, 0.5764161467253889, 0.5933608917652907, 0.5681407730541705, 0.6047192690627683, 0.16029529758226713, 0.16812352748757586, 0.1877888157458456, 0.1715776731102162, 0.12774896819638049, 0.2628191620879242, 0.3620493739184725, 0.35393061820570026, 0.15313808324470957, 0.12844711529800112, 0.11773638713381773, 0.14422454644179594, 0.1278459104267864, 0.16684105899241752, 0.10335338220021928, 0.16001296822259514, 0.10597067463013121, 0.12981673878545041, 0.8652704359581141, 0.8551643629850716, 0.8347662767914557, 0.9105042237052041, 0.9635575487469611, 0.883123741928901, 0.9279399689613702, 0.9266159658272807, 0.9089019185364566, 0.22801842366565184, 0.3738149696876176, 0.2956814998946645, 0.2617429403773788, 0.30646794058567306, 0.40208377688997476, 0.3710607002448314, 0.37740211661838685, 0.3584307896246617, 0.755762386934307, 0.8060820985726025, 0.6552619500209618, 0.6888864346205332, 0.8057237443068139, 0.20718745725556587, 0.7174421484732947, 0.7605672395075778, 0.2417395472900684, 0.12214285301929262, 0.1494102312827965, 0.1294901506957895, 0.12683542643963464, 0.2334256830243855, 0.14911145681105664, 0.4984015529665602, 0.3259423984162799, 0.19021469141411096, 0.20893806278540572, 0.11593214374669003, 0.14764083541587425, 0.13346961079167907, 0.15237394709178553, 0.12495745095714705, 0.15442162841628926, 0.14373634622263998, 0.11144971973597895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03603985139431132, 9.999999999998899e-05, 9.999999999998899e-05, 0.00990210708344641, 9.999999999998899e-05, 9.999999999998899e-05, 0.10377786776162479, 0.08504406663499631, 0.06597604329465778, 0.09095789144058875, 0.06866271491230036, 0.034625516217097196, 0.23789006209889252, 0.1113425658594479, 0.05873142580110602, 0.1147264873669328, 0.1718137264162477, 0.04115215007446149, 0.10205433453744428, 0.10135655319625825, 0.08979410711546465, 0.14797303880507573, 0.14599890780531877, 0.1681388109959211, 0.21738202964986963, 0.17988508593499808, 0.16852625513195385, 0.1016860196421665, 0.20818466014342363, 0.13098858428923832, 0.090356510066251, 0.13924023414892184, 0.09690205651090733, 0.5566586673964318, 0.5676470867817782, 0.5652662657101742, 0.5658545485107425, 0.5490631709705422, 0.545453323656304, 0.5720511803865169, 0.5771021865013495, 0.6079329620444862, 0.12678137681186508, 0.12175562316793109, 0.1222564671266535, 0.15002572995835162, 0.14693700744925808, 0.14104507060973825, 0.10426012999341505, 0.1245637783886705, 0.15734643078277422, 0.21850168903897516, 0.4797001488471021, 0.2831341163488893, 0.17390483903710807, 0.20370748577413977, 0.22388986340812622, 0.16615162229340874, 0.17572593085847144, 0.2134026034448575, 0.39140193773372645, 0.40358061872674944, 0.39807217527615335, 0.4029727972029391, 0.3948972207685424, 0.395515240442986, 0.40718076588037355, 0.4163777917592806, 0.3974115926573134, 0.3040235703350469, 0.3134891425159285, 0.346366302298464, 0.29189371825405264, 0.3330096656610202, 0.3133658338540042, 0.34002372624197663, 0.35712863364826164, 0.31060178427149565, 0.21709747578963023, 0.19626666304404083, 0.2250364692371748, 0.2014917068930694, 0.2130537816336292, 0.23106970788870995, 0.20122653126181567, 0.21658442088393137, 0.20534005809716604, 0.20182599487708763, 0.2081304486033625, 0.2028563324955137, 0.21547302192440299, 0.2182553258104032, 0.37588475447019776, 0.21426779299820886, 0.18662555531254787, 0.19528174842848467, 0.18581360784998313, 0.18795432267411416, 0.16748708512423927, 0.165038529441625, 0.8562330071172204, 0.8352582496704267, 0.789002569960164, 0.1737153609016845, 0.7822911233540193, 0.722932979313994, 0.1691360625072702, 0.7289112292088283, 0.7681556021613911, 0.1522760536826765, 0.16412894643697107, 0.16670644262404544, 0.3391638829421675, 0.4890970421611158, 0.18425466476049257, 0.1830675362218359, 0.1857889227791688, 0.19193895624481194, 0.17422982785433028, 0.17980675895281273, 0.19568379726091711, 0.1818118278541958, 0.18713984970941866, 0.09384311828441583, 0.09355380255525092, 0.08124961099205463, 0.08938337333494495, 0.08367371330244766, 0.09015285607255641, 0.08794044507615595, 0.08157080389439308, 0.09009519338950756]}, "mutation_prompt": null}
{"id": "503a0341-604b-4f2d-a777-d6483ef99d3c", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map() * (1 - diversity)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Integrate a dynamic crossover probability adjustment based on fitness variance to enhance solution diversity and convergence speed.", "configspace": "", "generation": 51, "fitness": 0.2992344849734248, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7386709436865396, 0.746103498753997, 0.7376093103053589, 0.7502379590955861, 0.7271419730215597, 0.7378865611113729, 0.7236656647993496, 0.7300558733368882, 0.7359486142873856, 0.4106303779044723, 0.4410710869458908, 0.4216056059254446, 0.4284408952006258, 0.45673906380706464, 0.4216594924369278, 0.34411458098138414, 0.40043174462979225, 0.481105395747366, 0.173189117775721, 0.23132177681960764, 0.388024040415772, 0.15994365981556147, 0.3150879113738887, 0.1554171348516018, 0.17226720245867833, 0.43941782268866514, 0.31943222700509555, 0.12894568349253765, 0.13106416016185207, 0.14060880343170212, 0.14932360355588847, 0.12700093931363188, 0.1386611461789753, 0.2225105381046425, 0.1341436959844543, 0.1339072500012337, 0.9123037117577727, 0.9072311486036124, 0.9025996664002507, 0.8667935070493684, 0.9361372869912823, 0.9107966248005153, 0.9466834611066572, 0.9605290522248092, 0.8791485527551344, 0.1741891973276104, 0.23063170211922823, 0.24072097003416115, 0.19618926880646537, 0.16652242081194313, 0.26928307417386665, 0.21776076600791372, 0.30404132806605444, 0.3202346469784886, 0.7085629689147916, 0.7434157395023421, 0.7488325486776622, 0.7359757107371412, 0.7677008969688737, 0.20417978587036567, 0.5992939781124875, 0.5719791358396511, 0.5107569920526598, 0.1487766105139091, 0.15342602525158944, 0.31052232698791016, 0.1055455325125566, 0.1175207387997732, 0.16156790180643277, 0.14034744187017478, 0.14910114170349875, 0.1581270477067268, 0.1787217066373712, 0.1313869765452924, 0.22280736610186358, 0.14511182044513604, 0.1878929751946432, 0.18293215431295629, 0.1548202469947344, 0.13051263361092547, 0.15227613802360773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028786274936666634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05759982914601458, 0.022000647355803427, 0.09245959408084525, 0.06086142766224434, 0.0934086001391572, 0.09329678553330922, 0.10052565899905674, 0.06580130045220589, 0.05794765151548875, 0.00259584700855342, 0.0006627559564327257, 0.04409058121377696, 0.0268410113669153, 0.014664248668718183, 9.999999999998899e-05, 0.019005560256875054, 0.058388812979846993, 0.008340222991554014, 0.15787776043171886, 0.1227612298523798, 0.22457244214665684, 0.23427283116393804, 0.15881891968734652, 0.1987983506278882, 0.1952636792064696, 0.09199439227550033, 0.22680964401302994, 0.5643339532366056, 0.550476317941444, 0.558876451981322, 0.5670591173228667, 0.5700927167023155, 0.5637890102519462, 0.5775618790678412, 0.5800777046893376, 0.5577605852902718, 0.13070767804601058, 0.12798813445140622, 0.11176246594701156, 0.12117636165360546, 0.14891222743790566, 0.28769401413239015, 0.12134544657431101, 0.10092284663756623, 0.10371081230551227, 0.1394252968569828, 0.20408241987510123, 0.22895048911855687, 0.16189736718088332, 0.1932710069759116, 0.2194106096542635, 0.308313735667623, 0.27396742782269645, 0.15390666789210683, 0.38700061677478437, 0.36270969676621334, 0.36108567175115847, 0.37919547521145525, 0.3804020386085023, 0.4079259597080238, 0.39591113704960423, 0.4020491954433564, 0.4173937601752996, 0.252722603409827, 0.2283190768219242, 0.2525190555050766, 0.2844271811037805, 0.2922707447300653, 0.3034802334255714, 0.329509252911685, 0.33619001869207044, 0.2964722981972425, 0.1952108381244002, 0.21435979878983424, 0.2159744513478824, 0.2154967481213873, 0.2425218545365685, 0.20870549648822867, 0.20969462799118688, 0.2440645094773276, 0.2344764342511212, 0.2026451251428144, 0.2850989216775369, 0.31440540040702336, 0.21133411849754058, 0.19989494980818934, 0.20099741338609145, 0.3069828203592463, 0.19282360610603277, 0.21822866133799912, 0.1689798994531806, 0.16947311408981258, 0.7905128360801904, 0.4432515859154055, 0.37638080575605193, 0.19678642327737594, 0.7015219326782065, 0.17160060417105583, 0.8227284990201269, 0.7672808118753154, 0.6672364317376009, 0.695157051761147, 0.7467149148859713, 0.16482607434029672, 0.4789777779687211, 0.16347013058147364, 0.6244524438489932, 0.15602352264798558, 0.21243014628736767, 0.18751063511047716, 0.17824260109394685, 0.1796797272210492, 0.18154579307439556, 0.17941160383326082, 0.1732474834280081, 0.21115734990665158, 0.18574236849190429, 0.09041745965508963, 0.10725362668000782, 0.08436188165926084, 0.0869457311389098, 0.08169645107897683, 0.09078343504010677, 0.09057142792140971, 0.09475331688092647, 0.08692797603414004]}, "mutation_prompt": null}
{"id": "f5343b40-5307-4b3d-8dd7-aa0195780c08", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / L) ** (1 / L)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / L)\n        return step\n\n    def mutate(self, population, best_idx, fitness, i):\n        idxs = np.random.choice(self.pop_size, 3, replace=False)\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        mutant += 0.1 * self.levy_flight()\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n\n        return population[best_idx]", "name": "ChaoticHADE_RMC_Levy", "description": "Incorporate chaos theory with Levy flight to enhance exploration and exploitation balance dynamically.", "configspace": "", "generation": 52, "fitness": 0.22134510217161515, "feedback": "The algorithm ChaoticHADE_RMC_Levy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.4567575725825507, 0.4414279204194608, 0.43942592946362957, 0.4409240291637361, 0.4291425457935477, 0.4485412208816326, 0.44683367964768894, 0.44194601138485623, 0.4411140232863109, 0.08190181511498418, 0.07908696483238908, 0.08916851237084189, 0.0669633350976303, 0.06666959516810733, 0.0681691637875862, 0.08468717357448097, 0.07353579778931763, 0.08534993274319513, 0.1232075894395337, 0.13514775789844657, 0.12264140907656695, 0.12817078508664215, 0.12302225209601236, 0.11683533637497545, 0.12104563742773167, 0.124696916519217, 0.11504531457530343, 0.10743383816141538, 0.11080132528040265, 0.10445280343239338, 0.10604140296542086, 0.10780146900105958, 0.105239865505658, 0.12487563747015085, 0.11798623767769911, 0.11651027698621763, 0.8886685979766709, 0.8975266977358066, 0.8703153099969616, 0.8835273640120882, 0.8689773520031683, 0.8509960783514052, 0.9141537388689213, 0.9112221742577614, 0.9098916697949736, 0.21927168253291174, 0.23025649021178274, 0.22118270724381317, 0.22477171573044008, 0.24143920248849604, 0.23551840691259063, 0.22416025761038816, 0.21568878965027893, 0.24082043110403195, 0.5847222208234532, 0.43910460429068643, 0.2888317365732772, 0.311854296206707, 0.30002852433928406, 0.3971903715892363, 0.32536077910915606, 0.3184223878024418, 0.31467918250457816, 0.1446148153478538, 0.13683267344088235, 0.1340461972575242, 0.1373990714749167, 0.12408075811638697, 0.13631149506005935, 0.13728598515679802, 0.12710581890236117, 0.14770406569963868, 0.14014593812783627, 0.14742717058285726, 0.1320896790702243, 0.13712235634464853, 0.1362594869497632, 0.1368690063000435, 0.13507717442259215, 0.13553391982081864, 0.14142846641958529, 0.02544140459050559, 0.008130910327830532, 0.019927136585476513, 0.014743773519410364, 0.003328529096217281, 0.015753381707766856, 0.0021341957284847224, 0.00023670488765037412, 0.00031453381931045854, 0.08694985870495953, 0.08917156943409754, 0.08654082896060189, 0.07049959950075646, 0.08408827808622776, 0.09515093179746381, 0.09498757287585069, 0.11098327252390461, 0.1047711846364433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10424942809390281, 0.08168159561173927, 0.08698846063268284, 0.10570943517130416, 0.11666729217220162, 0.0942797278282167, 0.07840270769881696, 0.09973921952223064, 0.093533977017902, 0.40199857736558864, 0.4004936310657111, 0.4005344829777763, 0.3825545209229524, 0.38921067302941814, 0.38368590896858445, 0.3937531145529348, 0.412911968750892, 0.3850817163428999, 0.10338147946191689, 0.1000691977678122, 0.1038114384377774, 0.09901798548455154, 0.09866580660040669, 0.09478105296959471, 0.10661571040672102, 0.11288142363184328, 0.10284609135014211, 0.15248204487947914, 0.14632244436135566, 0.15482337171950944, 0.1559862360923986, 0.14257321107185128, 0.15646668383815754, 0.13784707222191095, 0.13708545274212225, 0.12953332321327904, 0.27503882882909025, 0.2763396626523468, 0.26804308706815927, 0.29429579016596397, 0.2791310598107607, 0.2742902844566363, 0.2740394141340369, 0.27578465399730945, 0.2709028639303426, 0.20727578797161428, 0.21342369179259701, 0.20838791281053093, 0.21115713947975245, 0.20590441067388665, 0.20947070968370796, 0.22562406860653006, 0.2201899884642896, 0.2145909713197094, 0.20482293905766058, 0.2239239810703788, 0.20558799677303563, 0.19720350811059195, 0.19247018346677536, 0.2029227554319557, 0.2089060695277326, 0.2257923279284263, 0.21369687130811088, 0.21461549805952496, 0.18005202767427309, 0.20885182408419245, 0.1968443721349017, 0.19404777887063052, 0.20676306288494106, 0.18674538603935575, 0.20559851839584664, 0.18756460369912353, 0.4757804046469458, 0.1797646186601718, 0.5162026965686549, 0.6037637248799552, 0.5061208889900357, 0.6255481427437002, 0.4382767163309512, 0.4791590348125433, 0.4583839864215916, 0.3903912483381816, 0.3714083961005211, 0.3761288335814872, 0.1914754424985251, 0.22244834630756327, 0.32799825464296883, 0.3125463850481973, 0.4188207551948716, 0.32786884580375397, 0.1867812562833917, 0.18134373769696754, 0.17253449253499875, 0.19179623888175534, 0.17794890566271138, 0.17527854231452333, 0.1813655715447613, 0.18429911884016414, 0.17819430124495428, 0.07985574904388926, 0.08575564413784453, 0.07576916957949065, 0.09467560103062389, 0.07945348410708741, 0.08569977743178947, 0.08372367938627134, 0.08159841941149004, 0.08284357094838346]}, "mutation_prompt": null}
{"id": "8a43fd53-98f9-414a-9fe8-063d5c7a6490", "solution": "import numpy as np\n\nclass EnhancedChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.3 + 0.4 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.03 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        diversity_factor = np.std(population, axis=0) / 5.0\n        mutant = a + (self.mutation_factor + sinusoidal_factor) * combined * improvement_factor + diversity_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "EnhancedChaoticHADE_RMC", "description": "Enhancing convergence by integrating adaptive scaling of population diversity and logistic-inspired weight adjustments.", "configspace": "", "generation": 53, "fitness": 0.247539243921639, "feedback": "The algorithm EnhancedChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6678505007775656, 0.7141355841860406, 0.6722010015071334, 0.7497780039720483, 0.47178269053029975, 0.45583010574317073, 0.610471716138505, 0.5353764407228156, 0.7062718719648862, 0.21794555456015063, 0.3427160837123503, 0.1780071008436136, 0.20455169843402732, 0.44046490431485785, 0.24450382170434382, 9.999999999998899e-05, 0.08752227088847153, 0.1292492623381939, 0.13215565450418365, 0.20529095253553242, 0.10468809574560323, 0.12640758545242348, 0.14054433708067593, 0.14787642321245675, 0.16566204611889457, 0.14797768594568428, 0.1411151978977705, 0.1304528715449409, 0.13549232219491336, 0.1838533802250899, 0.10651279716610573, 0.11109132817143852, 0.08605704009937876, 0.1866918467581935, 0.24059018701414703, 0.13154663055845084, 0.9231012277923256, 0.9812152434762274, 0.9276059081982371, 0.7469369966013588, 0.8717192908112228, 0.8511584231083961, 0.3684861187070011, 0.3344174631448934, 0.39441939600124565, 0.39757705452736014, 0.3173488232801267, 0.2586652211124507, 0.302411393672128, 0.24203722875288358, 0.3282814915624782, 0.2557654655642535, 0.21181573068244097, 0.2535359502687443, 0.1694785416436807, 0.7761660950131948, 0.23627903355402835, 0.7838285635271384, 0.26978003679540374, 0.26424966466250877, 0.6658108089785673, 0.6964347454517359, 0.6969926254702379, 0.15630436068289433, 0.4105523741568431, 0.17478891179399847, 0.14101222229472987, 0.1929337443697242, 0.3077154448662621, 0.1823647846007428, 0.15409702510758794, 0.1768048743547992, 0.1982927972061741, 0.18526966171225934, 0.3547845988462883, 0.035762838737727565, 0.12948740517260127, 0.1462976426253404, 0.2439419418642893, 0.15299299617988327, 0.12259345927819543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056925242899162565, 0.0004841633058912942, 0.014261120941175598, 0.0021069070583870086, 9.999999999998899e-05, 0.018342440421407313, 0.026914263225412238, 0.022990771795316833, 0.09796760829756623, 0.09300707155876264, 0.05708201497896881, 0.04806204012258497, 0.039623771429618704, 0.05567798705018945, 0.17681414151472874, 0.10214987324744618, 0.11094401964537304, 0.09948989985408863, 0.10043909557148967, 0.02150137107002925, 0.16948792897554577, 0.1396831689293282, 0.20888897857412636, 0.0650366581388826, 0.0111749220502263, 0.03569833274264278, 0.051079692914805075, 0.150069535258205, 0.045559063136843214, 0.22329545285528207, 0.1589045159639474, 0.18205316742532063, 0.4693564953307052, 0.48148063285731346, 0.41083651354470885, 0.4301072600555147, 0.4039803554429916, 0.48029470844701705, 0.3953635110055356, 0.500536520350179, 0.5363925684362351, 0.09650282588930292, 0.09685082571081272, 0.07297438172560455, 0.09468361405657544, 0.12997673451316427, 0.11775776809536942, 0.09782797067021987, 0.08807400622767059, 0.08582642239069171, 0.14170653383670273, 0.14583602700521847, 0.18100110623602372, 0.15359754324211972, 0.17249751031602611, 0.1531637154904555, 0.21360259042745178, 0.14608397761686442, 0.17182677909145683, 0.306980184552335, 0.289832577426523, 0.2790245343707567, 0.3650414750068973, 0.3522807008626333, 0.33684994177731487, 0.36854197720484283, 0.3479838741893161, 0.37082879823683534, 0.2721875535531183, 0.21317934551750717, 0.2759148299194324, 0.22890410328589805, 0.23502902435381723, 0.23563023645701464, 0.21271159568034836, 0.3269274884109934, 0.18264675980974776, 0.2133994273723343, 0.21407553899045384, 0.20094002333031435, 0.21410588782819684, 0.19980752255830136, 0.21792493336943386, 0.20037750459245363, 0.24223951655737375, 0.25062568941121, 0.20047679692302467, 0.20888568369614335, 0.2352512432848063, 0.18515416647231986, 0.21439912414176454, 0.19895360178691768, 0.21563563242865957, 0.21481960670792, 0.23329676364066354, 0.18212130377111257, 0.18601979803030066, 0.18361753910465572, 0.17026426158952468, 0.19033812332677158, 0.6859960027510126, 0.4655483795758909, 0.1728931885560041, 0.8124433807685996, 0.20378766187468478, 0.16849992618821874, 0.7059849922261041, 0.20485061893649392, 0.16675313140784442, 0.16702918880560902, 0.6610062765236273, 0.10291940822680534, 0.39061933833551954, 0.2014801748150118, 0.18173253830706282, 0.20006859500826313, 0.18208031642991696, 0.19439710427191836, 0.1785944341654485, 0.1845245578987771, 0.18526825427677718, 0.2006356637958987, 0.08315919228657787, 0.08092962265927894, 0.08220820377828986, 0.08985843458602649, 0.08472751947097745, 0.09630880038115142, 0.07917255003898338, 0.08866400255541373, 0.09447579890218605]}, "mutation_prompt": null}
{"id": "d058d44f-5d76-40c9-b5d7-ab0f69868403", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        gaussian_factor = 0.02 * np.random.normal()\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + gaussian_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a Gaussian perturbation in the mutation factor for better exploration in distinct regions of the search space.", "configspace": "", "generation": 54, "fitness": 0.33385390266367454, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7522275751966259, 0.7456268254613827, 0.7504790817855441, 0.7375429477584696, 0.7185097682310437, 0.7425473447286803, 0.7541776189259547, 0.7331983840434002, 0.7283461334294972, 0.6096952179023327, 0.5529903377725627, 0.10318441511951804, 0.5600739992261595, 0.6283592017283889, 0.6035611354431626, 0.35171138077452857, 0.5913264011564647, 0.6266514568615431, 0.3105649981242913, 0.16611167523412151, 0.3460029442940986, 0.2843263250412059, 0.42062119916175433, 0.21122805322592986, 0.16072052584986374, 0.2653092590732177, 0.3396024732809463, 0.14237468491068572, 0.1253635296535034, 0.14475989506000042, 0.13874437030632036, 0.10803668635428043, 0.13031014301829824, 0.20167755008357002, 0.1394344309843213, 0.13354516624043467, 0.9028419062179881, 0.8228981489804823, 0.9288438708473938, 0.9472786876129123, 0.8829844221605208, 0.904148104594035, 0.8571930474028878, 0.9637082733961307, 0.9090831662862892, 0.38185718707741667, 0.35551618487524583, 0.25415213739657905, 0.3144084772864615, 0.3607693802577401, 0.3154339804550822, 0.35333580822611466, 0.30888269537402835, 0.31294743411072024, 0.7464488516102108, 0.8140559089583284, 0.716243252041678, 0.7353361480043854, 0.7518941354423978, 0.6762070453210565, 0.7360532066381769, 0.7580511411377112, 0.7847905026857381, 0.12349699472724385, 0.16183899140856606, 0.1242674357256528, 0.20117659168830337, 0.16032760650193978, 0.20695971470821273, 0.1429216080049489, 0.34217718131787156, 0.15752630764901077, 0.19469127471375347, 0.49235938068928176, 0.12866800479322793, 0.15230166028897762, 0.17015740894011067, 0.2170980485619468, 0.18962773693822477, 0.18682274699714363, 0.18350626963244654, 0.02318570130354003, 0.08803107414066158, 0.07561003895938379, 0.06976960856345193, 0.05051875938212402, 0.036242767314662694, 0.03179866893527705, 0.005453545725295772, 9.999999999998899e-05, 0.21884951137062902, 0.16136156745171826, 0.21075526645835085, 0.11805530706027456, 0.28045723391336874, 0.07699451377650202, 0.08311807015765627, 0.09740658976939998, 0.2804997504526626, 0.029895055668808124, 0.2879923762279806, 0.25675194541346935, 0.15013800086440876, 0.0906808884689162, 0.09085490212512282, 0.09145915120028691, 0.23414203905901687, 0.14450076399779266, 0.26371656499246177, 0.18469842666121195, 0.11921095882658628, 0.1690723904141721, 0.2885312376083965, 0.15831601470427015, 0.11410913378305687, 0.25104805103223193, 0.21184572232501198, 0.5518235185462809, 0.572984109901312, 0.5873289260091992, 0.558959094349427, 0.5791590074942681, 0.5614628253847622, 0.5764431503834917, 0.5504552187111882, 0.5759417209918647, 0.114324006235758, 0.13265045459847025, 0.11002472556874887, 0.1519759999180036, 0.13702455061339913, 0.12089815530411308, 0.1146466719256829, 0.10255945137618694, 0.07650406689393985, 0.15392052251385735, 0.37401253247951705, 0.2774568700776866, 0.19637226947483, 0.4659286997519392, 0.16441499597308906, 0.1749098882648792, 0.24475256676634083, 0.17502129278623635, 0.38044463138735785, 0.3850343245096376, 0.39194472839229644, 0.41204594790793525, 0.3884472772431321, 0.38683942171442187, 0.4165721783413807, 0.4055787357026027, 0.3888034459249404, 0.30862431508167665, 0.31751618911241963, 0.3289465619807699, 0.284892276719658, 0.3138292608053288, 0.3242962571845108, 0.3309656215572915, 0.30436981457571566, 0.29013784778915985, 0.19999972599914895, 0.20441768862013587, 0.1988242782658156, 0.20822402857487488, 0.21061980696937022, 0.2077791585409715, 0.21869420891462044, 0.20081827765133298, 0.2081349820231191, 0.20373588515764718, 0.22777641942590876, 0.24867047981730372, 0.19516119935652787, 0.36818872264898905, 0.3825900598570994, 0.24049703162590108, 0.191342618884754, 0.1950197306293514, 0.18272822893804475, 0.18527479880574282, 0.812783248167608, 0.7176219701683697, 0.1975630767420794, 0.7857069530824525, 0.82445480140065, 0.19216524104913513, 0.7638772083582707, 0.7365742500371548, 0.7078733556466044, 0.7306194321310435, 0.7965343382662515, 0.20770019280316132, 0.1669186479473903, 0.3320991744748518, 0.7725011354938834, 0.16345253533797555, 0.19788642304486737, 0.19366170437678654, 0.19190999146580912, 0.17811265146842215, 0.17823409912831445, 0.17680166520240004, 0.18875195084480856, 0.17715323807934857, 0.18318498066921096, 0.08920498632132434, 0.08483702523199987, 0.08564703302524723, 0.09615064710244892, 0.10490556146162633, 0.12622613528566162, 0.09785721579380147, 0.09328662887281569, 0.08504121670572817]}, "mutation_prompt": null}
{"id": "d8bfa922-16af-4676-8864-0fd70893725e", "solution": "import numpy as np\nfrom scipy.stats import qmc\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        sobol_engine = qmc.Sobol(d=self.dim, scramble=True)\n        halton_points = sobol_engine.random(self.pop_size)\n        scaled_points = self.lower_bound + (self.upper_bound - self.lower_bound) * halton_points\n        return scaled_points\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Improve exploration by introducing diversity into the initial population using a Sobol sequence.", "configspace": "", "generation": 55, "fitness": 0.3341785399117172, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7408296008933961, 0.7472963012801833, 0.7433709579409897, 0.7421110076548671, 0.7355729102839372, 0.7484679108027185, 0.7421796781600263, 0.738135725639268, 0.7449904347253793, 0.5692473294270113, 0.24470746492084294, 0.5771860784719283, 0.5048818714756503, 0.6310701147760889, 0.5846627852991402, 0.6095859360054505, 0.5900019837653074, 0.5534245427540085, 0.24022944672362478, 0.2667125887051701, 0.41939543236796173, 0.4225968244406625, 0.31725940111527917, 0.19683839261531644, 0.17766143460655026, 0.16036286030883895, 0.16046796451315526, 0.13750705612127934, 0.1326944124747248, 0.13321566252544703, 0.14933399107838796, 0.21482048971880474, 0.13359558653549453, 0.13292810322445725, 0.1523606298703265, 0.15105178990511137, 0.8859635650985, 0.8488817429823433, 0.916211684713515, 0.9435317544249264, 0.9228963427246555, 0.9350193324722045, 0.8945643298820476, 0.9482075845110417, 0.927663465017515, 0.29296277172092666, 0.3259051367385155, 0.3459900282620937, 0.32457272196878384, 0.3774316649267334, 0.35519899890359197, 0.31353350026813265, 0.33892039087986003, 0.3503836822190184, 0.6805451642873601, 0.7755220356075418, 0.7573399855964852, 0.7289694254585686, 0.6739189202002321, 0.7948120600997874, 0.7093171095221797, 0.7968376453906132, 0.7834914911433543, 0.09765934690615086, 0.1310704062989606, 0.17433422371169405, 0.12166988740957296, 0.20035731500041676, 0.18958264596749463, 0.12450711105074774, 0.12728894229486654, 0.17905818581695243, 0.12626805244818917, 0.18280683019764676, 0.14325099149592568, 0.2078829076609483, 0.12560814683444643, 0.4891735147128685, 0.12909998014615598, 0.16091070675783103, 0.16878896673408905, 0.16180550474097521, 0.005975741020909808, 0.048939617415053926, 0.06812988895071848, 9.999999999998899e-05, 9.999999999998899e-05, 0.027839634083240306, 0.15057462397639376, 0.11821372722175383, 0.11486801715353157, 0.09771471944473009, 0.09390281340156603, 0.09003262050496796, 0.06316968722325889, 0.07569915802654503, 0.2737352943091591, 0.11403037259073057, 0.27000070660395525, 0.1743303034730963, 0.05246919918366644, 0.05362058324477348, 0.07921478446220831, 0.132347750060838, 0.10799844860652597, 0.2004373530049114, 0.14941438843793953, 0.14564231391035987, 0.24931656602291785, 0.24787262274923538, 0.22503279740668936, 0.1498686157805107, 0.2601148740902389, 0.08820300344307974, 0.206123053864545, 0.16943759412667037, 0.1830765096723137, 0.5488678496637465, 0.552314526016859, 0.5835063011047492, 0.5579593589760318, 0.553519118143718, 0.5568841719766459, 0.5491294214120794, 0.5559439977365508, 0.5740330680997636, 0.12156267126001208, 0.10579793532578585, 0.11344098481479814, 0.15923357652989345, 0.13516359983955661, 0.11232178316991936, 0.10101054973924528, 0.09020447137835985, 0.08621787602375641, 0.13663806892515518, 0.15170977090231896, 0.1631258713541176, 0.18139798679096297, 0.19392563621152292, 0.15927210894308264, 0.1635330872757137, 0.1782868006014151, 0.23103938331383722, 0.3906541273497721, 0.3694864266489818, 0.4003556195686422, 0.3758749314374533, 0.3740001496247758, 0.37463420559527494, 0.40239927013094534, 0.3964161207621145, 0.39736155102787496, 0.329204409453721, 0.3252980444833228, 0.31069526039690565, 0.2997662239811859, 0.30104618361993907, 0.3180452815879433, 0.29691158163312237, 0.3178548985625054, 0.3308109326358806, 0.21393519102840963, 0.24253409516368496, 0.22254144311460722, 0.21871483272627767, 0.20644850651154967, 0.21173242611879828, 0.22988866258787966, 0.21106196615363404, 0.2467069805365968, 0.2338998719347225, 0.22568296237170926, 0.19600242799260625, 0.2210275183536482, 0.20556583245558147, 0.18036695978142958, 0.3998627259990505, 0.3622241692742958, 0.22454004033230457, 0.7926307031111922, 0.8281631193801021, 0.15617348291483557, 0.7892505735313303, 0.2030853491913237, 0.7948159385979924, 0.8063077631549131, 0.8160710957676607, 0.7147531063749607, 0.2064059823757476, 0.7380201539827693, 0.7259453374689313, 0.7551246247135184, 0.20711540231283543, 0.2065609894077386, 0.3124304804215505, 0.7863415228908395, 0.7471691989508169, 0.17795039276214897, 0.17533047332494056, 0.1971604740539007, 0.21138189914692607, 0.22303948495422743, 0.17611962547761995, 0.18105204741233683, 0.17614703070981086, 0.18146917326476886, 0.08878130674544371, 0.08741712323353534, 0.08751612533790609, 0.08954036028167756, 0.0879812108459852, 0.08511756662877035, 0.08661551164191117, 0.09306628008897189, 0.08690361820393921]}, "mutation_prompt": null}
{"id": "0fcc9c86-35be-4f5a-aafd-79e7672b65d0", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.03 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Adjust the sinusoidal factor amplitude in the mutation process to enhance exploration dynamics efficiently.", "configspace": "", "generation": 56, "fitness": 0.3210758164373698, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7416524750114376, 0.735674075804751, 0.7267236752740986, 0.7429326388406206, 0.7377263088397412, 0.7407222988524946, 0.741094910057819, 0.7303334033640354, 0.7370599040546808, 0.5519408633083376, 0.5780787327000698, 0.5752212281505994, 0.11967203260789883, 0.6183057675513022, 0.6021181761421694, 0.5765626595255386, 0.5709234301148849, 0.6478616945930453, 0.15440120535437074, 0.29360015458633626, 0.3777047347658242, 0.2994635514462677, 0.15937822449781947, 0.1617890899670147, 0.15993975393979742, 0.25704065500057016, 0.29583215193748824, 0.14094218150600568, 0.10519244128947358, 0.12334054712704223, 0.14115285863268, 0.12737055519131302, 0.13028108407285566, 0.1769337351280703, 0.13531274814450223, 0.12005815885229187, 0.9364229566068624, 0.9356650298643029, 0.854874974668377, 0.9456549848816516, 0.9426306508735764, 0.9025424834836361, 0.9156872602410503, 0.9640755045220606, 0.8789646586490584, 0.351134543038347, 0.24821724286345592, 0.3536186444114109, 0.3143250003136302, 0.35242046061022814, 0.34831412668676953, 0.3763613507831842, 0.28673684788024845, 0.31787977253394306, 0.7534100222259646, 0.7947579632948389, 0.732767318375845, 0.7168676051479257, 0.754932559179254, 0.7410865345842698, 0.7324399426410388, 0.6404153914258688, 0.706331922273097, 0.12639860185192797, 0.14399060596871005, 0.24833623819914674, 0.1931582062757855, 0.14974301571145154, 0.2929512736392147, 0.14568189015638577, 0.16289344925003557, 0.16523352944617686, 0.12839666220337298, 0.09203183744368637, 0.12459829970730074, 0.13463243870301922, 0.1290340463624221, 0.13397928503053413, 0.1538327837241712, 0.2556073224298796, 0.16367907893488753, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02157583214618375, 0.07266739942003264, 0.04383876908347972, 0.038289332338386495, 0.05744059757271225, 0.0025615390676999583, 0.10246689019652389, 0.15246690623207237, 0.12738636645865076, 0.1731274691845578, 0.13224588504829404, 0.1897299381659142, 0.0684915598421072, 0.17801141396081044, 0.11812137869525452, 0.050553888773057776, 0.06621495822498868, 0.13127126756028007, 0.28216709204701707, 0.1523987160953555, 0.09647894106981114, 0.09687991188386735, 0.22641622783769544, 0.08509240799650031, 0.1367653493388289, 0.05957109237396363, 0.2299725178045674, 0.24356947040500165, 0.27506783829682446, 0.16322838570638454, 0.19774409805034188, 0.2108307140403155, 0.11859083287644256, 0.5896116112043703, 0.5478176250827226, 0.5293057611944655, 0.5716827589386249, 0.5397248643583203, 0.5779223439214987, 0.5715753314152479, 0.5619648609184766, 0.5669957620291377, 0.14127529056440036, 0.17410795725946715, 0.14952725693101587, 0.1315313990630257, 0.14369844826307931, 0.12286907024704075, 0.15374452157741447, 0.15056608006348338, 0.11690030717115585, 0.20294917506693633, 0.1556471060618405, 0.17490497637882563, 0.17684093761520747, 0.1496367065034241, 0.1566339949191763, 0.19532911308714407, 0.2255175046622151, 0.1502420700450846, 0.36550342224657084, 0.3791909628303831, 0.39806897458736346, 0.39492396499885785, 0.3912167444788993, 0.3752899950934808, 0.40453500894514205, 0.42212547839790926, 0.4048001125745474, 0.3277019984125418, 0.2619169001667596, 0.3419167023529235, 0.290453499117478, 0.2832306157247976, 0.3060734128183933, 0.30811748749801304, 0.335309746107027, 0.3113022094231206, 0.20508838599941714, 0.23475132047603575, 0.20286201526467462, 0.2501152686710576, 0.2181084005074212, 0.22948488350601004, 0.20995038640691377, 0.2105631622191575, 0.21346838735867701, 0.39405129115656845, 0.19979003544080476, 0.21643331662418386, 0.22061076960877057, 0.4118278423738003, 0.3260000331506814, 0.21468628679205337, 0.21042932503568768, 0.2146835488945762, 0.1707064398051985, 0.16992124029653255, 0.8025601285528932, 0.8148516093387843, 0.7940383768664734, 0.19706747177367445, 0.1691166521351024, 0.16328996438423204, 0.8133571301409541, 0.7309883781672877, 0.16654679211803247, 0.7407062497589765, 0.7149539679773909, 0.20540675659584118, 0.16461488580485462, 0.1661388782005171, 0.7542271787660519, 0.7213992823481925, 0.17701056404473658, 0.17158578537870617, 0.1736820580877113, 0.18159006325828753, 0.18023493899302634, 0.18312444223454483, 0.1845327928052547, 0.16963557270017737, 0.18013067292197904, 0.08335064049309582, 0.09386465037246383, 0.09275614965027013, 0.08439395629864599, 0.08806519742325725, 0.08698037308898687, 0.09128711645412746, 0.08606804339299667, 0.09249980891395915]}, "mutation_prompt": null}
{"id": "ce3ff72c-f822-4459-b59c-9d27656721fd", "solution": "import numpy as np\n\nclass EnhancedChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.3 + 0.2 * self.logistic_map()  # Adjust adaptation\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        exploration_factor = np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutation_strategy = np.random.rand()\n        \n        if mutation_strategy < 0.5:\n            mutant = a + self.mutation_factor * combined + 0.01 * exploration_factor\n        else:\n            random_idx = np.random.choice(self.pop_size)\n            random_individual = population[random_idx]\n            mutant = a + self.mutation_factor * (random_individual - a) * exploration_factor\n        \n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.6 + (0.4 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.5 + 0.5 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "EnhancedChaoticHADE_RMC", "description": "Introduce a dual-strategy mutation mechanism to balance exploration and exploitation, enhancing convergence speed.", "configspace": "", "generation": 57, "fitness": 0.2675404870952956, "feedback": "The algorithm EnhancedChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7896323549181122, 0.7360930255096221, 0.7837367842087615, 0.773993297206273, 0.6995364955586494, 0.7045842555583798, 0.5313316656922509, 0.695954707917633, 0.6483057863956276, 0.21080604159523086, 0.28390006459935146, 0.20192176938280915, 0.325768986307729, 0.21568847852089634, 0.23634363099310207, 0.3100837414500479, 0.2423344739792278, 0.24116932494756216, 0.17163374265550124, 0.15529957082581636, 0.13939227941734167, 0.1535226319010835, 0.15472073640108974, 0.1752010677300967, 0.15596162545961, 0.17447985671634547, 0.13498031623922202, 0.09038113458097818, 0.12965640212953855, 0.12205044076839, 0.10836356646810441, 0.10855294081355027, 0.12540529359346309, 0.1395915572223304, 0.09582949480707981, 0.12025262995438935, 0.9385580480338663, 0.930761659753848, 0.917155461549913, 0.3247410496795329, 0.9190624537116163, 0.2374658463675584, 0.3198708852076657, 0.3928205203405095, 0.3319329471466018, 0.2156195699679836, 0.26405150005179356, 0.3139165156978202, 0.17975660095550938, 0.2996105252692811, 0.17968777543061365, 0.21770785517876579, 0.27487778028759713, 0.21968859439917532, 0.3616733604684821, 0.8639838569417924, 0.816433395874115, 0.8242676888319068, 0.360524794787239, 0.7614894126898533, 0.818717167655283, 0.8405660517361138, 0.24210469697158676, 0.18096216840160972, 0.24477321863085622, 0.10966749056372604, 0.10913723466732395, 0.22042438417204024, 0.2626633104728454, 0.17277617654420008, 0.14720145006072816, 0.16197009945385432, 0.14390494397613707, 0.10613379922059407, 0.2107458623691727, 0.1457081390264764, 0.13366520297090678, 0.1291468140141807, 0.1254212943123617, 0.1341369962406379, 0.11242347482024506, 0.06000832327919725, 0.056694463319946986, 0.09271819311863072, 0.0013906444785322103, 0.034928383059010804, 0.05985653039517835, 0.004948016251484444, 0.13435429563286272, 0.024758708336882762, 0.08036925629752945, 0.14998636899808138, 0.17129830932185452, 0.11898616902228298, 0.10895805257701963, 0.029718659679335402, 0.12515196002788365, 0.1508130859986635, 0.08036400259859455, 0.09141860623923637, 0.071327479824562, 0.06665221559575163, 0.06955489320625419, 0.062352847523256205, 0.04957817702991307, 0.09547608416680342, 0.0898458313372692, 0.08345892657170206, 0.12588165516595706, 0.09748828870713444, 0.09806667951906856, 0.14780792377057494, 0.0865536680628235, 0.08081541548151727, 0.28515791128169576, 0.26533145746765496, 0.21820504477225966, 0.5541253357780356, 0.5429290720973752, 0.4877962477911125, 0.4533187715665914, 0.5308162632409534, 0.48365699228841175, 0.49539710126903613, 0.5706221907398301, 0.6153882752892144, 0.14751118702049226, 0.14927213095562164, 0.07955525268177221, 0.1760580696161974, 0.09134638985701637, 0.17358952946935347, 0.11962882661830843, 0.10164196768421463, 0.07663159902199879, 0.19571585909351885, 0.29509598663547953, 0.1759282832027702, 0.18069092867815284, 0.42854737567092993, 0.21930417873017838, 0.4111285804861047, 0.20308630731117205, 0.3212053671679699, 0.3919192049109509, 0.3680091391781285, 0.3986052079994742, 0.4430956921756931, 0.40176060015260573, 0.4420795799180506, 0.35355047631788517, 0.44199159584594094, 0.4011637567686145, 0.24169905510643153, 0.24515801802847959, 0.35436132197768233, 0.2353090554019318, 0.3322484209781412, 0.3064902091849596, 0.23419958682869346, 0.3374287860899261, 0.22921924661073312, 0.2082806924312649, 0.2198172834407246, 0.21500003457827732, 0.21753405418448124, 0.2357042479088708, 0.21011808086575112, 0.21592703363088517, 0.23304879964627034, 0.21431455241174746, 0.2579726859718444, 0.20535183159660753, 0.17195644676989563, 0.2445995806942335, 0.19481274364435053, 0.18810497765584144, 0.3415627776977276, 0.200071990680891, 0.18174255085745628, 0.12966540822149852, 0.18547983850075767, 0.18809603742484338, 0.33819344180484345, 0.35013932121474356, 0.19261203071240718, 0.787874089737615, 0.5754920411160822, 0.16003359625260016, 0.5619263145053153, 0.16951637777301987, 0.5861606017021712, 0.6320649851819542, 0.16562935770865173, 0.16778786951876556, 0.2520410876052612, 0.31035818685653016, 0.20527610494411042, 0.17949720738128383, 0.20264677106649387, 0.18879958500350358, 0.1921880429460573, 0.18807705342860992, 0.17750344887385439, 0.18659029731346377, 0.18768500665818522, 0.1828751182309135, 0.09911391261306457, 0.11911229077458008, 0.10095780023041223, 0.08549499931619253, 0.08765948288759406, 0.08990481861733457, 0.09801651043334292, 0.10206941944655468, 0.09336459303246591]}, "mutation_prompt": null}
{"id": "35efa710-6456-4398-8317-8129d1d3c493", "solution": "import numpy as np\nimport scipy.stats\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def levy_flight(self):\n        return scipy.stats.levy.rvs(size=self.dim)\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        levy_perturbation = self.levy_flight() * 0.01  # Lvy flight perturbation\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor + levy_perturbation\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Enhance mutation strategy by introducing a Lvy flight-based perturbation to improve exploration efficiency.", "configspace": "", "generation": 58, "fitness": 0.2340499905182797, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.46272818089367296, 0.4645375366830321, 0.4696243401398581, 0.47271136703886674, 0.47437578705615224, 0.4391519997617179, 0.4598186413469051, 0.4645196312236284, 0.49631311494500185, 0.1373052873521179, 0.15824478465906655, 0.11355515345739498, 0.1572974740905, 0.14831476343337258, 0.14086292111318743, 0.11728243647042214, 0.0524280035212632, 0.1336682789984085, 0.12276588538598265, 0.1367914018981372, 0.12232967407336126, 0.13402835153394677, 0.1258914603197836, 0.14363244972525513, 0.13936722018835046, 0.12738471959259423, 0.1408080273204727, 0.11672056806886033, 0.13410076070795718, 0.118610213425702, 0.13198826442180311, 0.12277634745646626, 0.1147905876226809, 0.14690705664056392, 0.11306624725040637, 0.11892300301306646, 0.94358899737929, 0.9512213442437738, 0.935785848338232, 0.9453813676081313, 0.9203284958303525, 0.9015804535025495, 0.913155695943676, 0.9264916120661184, 0.8348194151195188, 0.2742147413741728, 0.28683923184370275, 0.2687223829436012, 0.2743396505734922, 0.24602923843943925, 0.2686689024680219, 0.21020163619695087, 0.23572297328839853, 0.25975994344495346, 0.3127771477556982, 0.31790899691584174, 0.3508946574612143, 0.33721145756278015, 0.24931207006774025, 0.4787251606753292, 0.38247230335566607, 0.3677371393833222, 0.451201751311872, 0.156072117547567, 0.2547033097185477, 0.1638420426297078, 0.12431752724521117, 0.17794970736075433, 0.1948132515822275, 0.17401395803035413, 0.2604595034093119, 0.18136092565629303, 0.18454079067619622, 0.1760566410732003, 0.17373540518386832, 0.15411436154516045, 0.14558771438684037, 0.13195067168677055, 0.1766763818214485, 0.13235860717311043, 0.1244570613949274, 0.050911000647938076, 0.002022998038412327, 0.018079926838626803, 0.004439097575992701, 0.02457715733555066, 9.999999999998899e-05, 0.0028472597618623974, 0.015370277387150244, 0.0022462113454640997, 0.08236684260466931, 0.05392250246697383, 0.12339610560625913, 0.13295052911477, 0.08490712177061199, 0.03513764980753964, 0.14628797419115358, 0.10668240395207762, 0.14224584966095077, 0.036950782450290154, 0.014848634016077833, 0.042275350042355386, 0.004366958708516, 0.01905880428959894, 0.05754737228356355, 0.016313909455177744, 0.024739740551374623, 0.014818912372733806, 0.06873916690770043, 0.11608451304543266, 0.07203613468302306, 0.14720207505993654, 0.08247914633647524, 0.13751512835616397, 0.10354771758338488, 0.09757852585033977, 0.11190478159439932, 0.4091001256785177, 0.39898928507271725, 0.40948298843402675, 0.4107951950673172, 0.4327659667610618, 0.4077121080582622, 0.40319620595598016, 0.39793464123304956, 0.40764678972429047, 0.10081988298572597, 0.10485565744832459, 0.09317590450421298, 0.09831895576819627, 0.1171465773143806, 0.0853733311432503, 0.0907974753663191, 0.08857193979870703, 0.0936630736448556, 0.1351162872636298, 0.16089714150269652, 0.20097312995759808, 0.18835438101144675, 0.15115060957255877, 0.17964217870125543, 0.13065144006810514, 0.13835908373350303, 0.14451746550116606, 0.2783640733840098, 0.2776152799818328, 0.2915792998968575, 0.2860828302041707, 0.27446728740276416, 0.2825527719806511, 0.29061951922911156, 0.2951146964188922, 0.29085479165825634, 0.23603232308419697, 0.2642131044541651, 0.23835860386364416, 0.22786246921108788, 0.2400542319115384, 0.2532093205237823, 0.22794233657825158, 0.22204291534088638, 0.2174612266718946, 0.1975357790862058, 0.21451073834236856, 0.21020588149764885, 0.19755773071477223, 0.20599524186796736, 0.19933838839117513, 0.1977250819395805, 0.20401873036369889, 0.21368042039934276, 0.20665131277788606, 0.20667560742601743, 0.19464148477896825, 0.18836856195674367, 0.2066486186746611, 0.1901055698260975, 0.202735464683105, 0.18840777175214185, 0.19766704818610337, 0.18409164852240312, 0.5932696125250289, 0.602431788782843, 0.6310290962902867, 0.19904705246059973, 0.16588324198711857, 0.13981060268007572, 0.6181084147462306, 0.33333883932584285, 0.567744607503224, 0.16928255615319177, 0.20558644380633573, 0.5968169478803962, 0.23168710774269008, 0.16535075035738556, 0.44349486197682175, 0.5899012828048495, 0.5380599455874544, 0.18342692428025342, 0.18555648909877875, 0.18283566785998917, 0.18092894420723804, 0.19526634112606922, 0.1923523848819867, 0.17874177488251664, 0.22172750161604438, 0.17824791924432015, 0.08291147771521068, 0.084436161627231, 0.08526108613382255, 0.0920497700182954, 0.09328490735205874, 0.08264027058036683, 0.08728061008528443, 0.08709396036727557, 0.08669352826941923]}, "mutation_prompt": null}
{"id": "26bd356f-e133-4e0d-af48-be8e9273d745", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        cosine_factor = 0.03 * np.cos(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.03 * (self.generation / (self.budget / self.pop_size)) + cosine_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Integrate dynamic weight adjustments in mutation factors and utilize chaotic cosine perturbations to enhance convergence speed.", "configspace": "", "generation": 59, "fitness": 0.3253275769873337, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7372191906243142, 0.7410572450072302, 0.7358931825926153, 0.7372411279967268, 0.7323539738540463, 0.7328838846278252, 0.7389898205805481, 0.7371525704148966, 0.7294774158891246, 0.5630222240428093, 0.5133545852201267, 0.5706704926741054, 0.6050619294320656, 0.579694117794008, 0.5720923655985553, 0.560206086843271, 0.5788954198107241, 0.6133117953519119, 0.4947001792778519, 0.368108289689982, 0.1847620938078579, 0.2213775865298777, 0.32400462389440166, 0.29187897456096934, 0.23744902532054935, 0.3131918025093189, 0.2373794120362246, 0.1263076227732457, 0.12847560522019197, 0.1603694019407963, 0.3179392332297811, 0.13355665310626863, 0.14921487505378828, 0.1419491374998486, 0.13723678658966387, 0.16061216959231583, 0.8568251105622322, 0.9259460504651766, 0.9240338692887899, 0.940887767734962, 0.9377906544871483, 0.9460585058308769, 0.9641428950774548, 0.9178568483230984, 0.9397502811858792, 0.3835867255448393, 0.3424223541312291, 0.3459014055688332, 0.3496267914834488, 0.37383186653750544, 0.316748136430558, 0.31213819336029136, 0.3151456365933667, 0.3403842456458944, 0.7470928566477776, 0.701451817778262, 0.6887055646338132, 0.7898956180780803, 0.7858612816909744, 0.7135568853931928, 0.7355618067310674, 0.6853851562963107, 0.7030393507274428, 0.15697834757183715, 0.16875370671831547, 0.20878367902461392, 0.10485722454009361, 0.25136463713578383, 0.38757176801892546, 0.16507434723182413, 0.31511883628171167, 0.1407742881432802, 0.20772243720537953, 0.49013813349035695, 0.12220741740644825, 0.17591099365573115, 0.17606584183423346, 0.1417506942290544, 0.15363215446210288, 0.16350544176707005, 0.12810813115138064, 9.999999999998899e-05, 0.05431351445716959, 0.12406181283879159, 9.999999999998899e-05, 0.03141722344432951, 0.02653404949899507, 0.10717131438374383, 0.05699740989806745, 0.002617322061605032, 0.15269859980097478, 0.033946936225061064, 0.1046114193347436, 0.07107252496746441, 0.18186039128480103, 0.10658210526236744, 0.21449183752256673, 0.05815956803537903, 0.05279766749412507, 0.1150761305476733, 0.0742799922924271, 0.20258084274265054, 0.19989686344950597, 0.12492318119887202, 0.07505431676102448, 0.09835229469914486, 0.21507838931200118, 0.14016432026402104, 0.1842644825024553, 0.13449486078824358, 0.25074012780375277, 0.2509391141504008, 0.28625435547086464, 0.21226744795375696, 0.21250087514502625, 0.2046737378280863, 0.23565871659298476, 0.5778315153567165, 0.5644356872290848, 0.5816925754648321, 0.5538066810337952, 0.5478628150591968, 0.5649471077144443, 0.5563756738965988, 0.559020533927435, 0.5913740113111841, 0.13408138671445557, 0.1197641402005547, 0.12000851074495078, 0.22679308925615027, 0.1429890617697156, 0.14024590665942194, 0.399735141943664, 0.09948788754580251, 0.0940110542432645, 0.24425253661379243, 0.16228727271179288, 0.16369878764163492, 0.1657555093837153, 0.17932862958216678, 0.14843538851248506, 0.15092651998993956, 0.18406617060316366, 0.19207153139265687, 0.37442728408132797, 0.38089212735211986, 0.40641599674384987, 0.38372087413869016, 0.38430696795727026, 0.3774995827398674, 0.40927795763849373, 0.40824157279015927, 0.38832571657102, 0.3196832824212986, 0.24195486542220657, 0.3312230083433705, 0.28228980890614574, 0.305747186611356, 0.314067531950991, 0.3208191628586612, 0.3487655168814434, 0.28056751849687456, 0.20369447084332337, 0.21273229374441793, 0.21534308766376742, 0.2112489617492347, 0.23064524031092204, 0.2057943408497387, 0.2308062034673919, 0.21453158802240757, 0.20277062467804574, 0.19192697556709104, 0.19548410723648335, 0.22280555266370317, 0.24039206058857487, 0.22074560439182234, 0.23152263876910917, 0.20679770950190213, 0.19615647625928478, 0.19741279943745726, 0.16923752152831673, 0.1827879154510127, 0.18422759291740298, 0.19608175363916858, 0.19918780615237186, 0.8471712473864619, 0.16607465568543645, 0.837594289851433, 0.8228742442283854, 0.7332986647706858, 0.1677136525297961, 0.7123038284964032, 0.7434304458623218, 0.20564208521048422, 0.16668287087014255, 0.16706184393145596, 0.10439078679825053, 0.769378661449976, 0.19838866423097157, 0.18812828100255452, 0.19363988627673245, 0.1771840865782126, 0.1933493345832501, 0.18140353234824746, 0.18887863734447619, 0.1842699993750555, 0.17935357169008914, 0.09356053895946315, 0.09434252597419723, 0.08598726958634018, 0.09301017692126456, 0.08722052574602257, 0.08752517657991377, 0.08806715873946813, 0.09203377419123226, 0.089181395127084]}, "mutation_prompt": null}
{"id": "2af3c23b-1f09-4e46-8c3f-3ac194a90abe", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n        self.best_fitness = float('inf')\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        mutation_scale = self.mutation_factor + 0.02 * (self.best_fitness - fitness[i]) / np.abs(self.best_fitness)\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (mutation_scale + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        self.best_fitness = fitness[best_idx]\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        self.best_fitness = trial_fitness\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Improved", "description": "Introduce a dynamic mutation factor based on historical performance to enhance convergence speed.", "configspace": "", "generation": 60, "fitness": 0.32845145431616884, "feedback": "The algorithm ChaoticHADE_RMC_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7480069480194853, 0.7490774569394247, 0.7413140157112572, 0.7605386418258758, 0.7393402491848529, 0.7389466624751246, 0.7327860398899892, 0.7358976101276962, 0.7306546788458406, 0.20207121708819487, 0.5718576536637864, 0.5911445287941901, 0.603803274768561, 0.5491579689362153, 0.6012085793483027, 0.5988645908595958, 0.5862146565583163, 0.571863551813249, 0.16891419405342, 0.30009007357167805, 0.3935559543932744, 0.33641027884872954, 0.16126104069427805, 0.16873136727101068, 0.3569861436276125, 0.1830495207112275, 0.3625967864415143, 0.1463775598791044, 0.12046275712141419, 0.13766117804641886, 0.13299124641903126, 0.1365002347212556, 0.16023571830496985, 0.13891736465691462, 0.09334691505717019, 0.14565442434766174, 0.8839210114031403, 0.9400728342535455, 0.9299114902508985, 0.946410124723073, 0.9631401562957256, 0.9453301671624048, 0.8977666686656661, 0.9484348412564275, 0.9545087671583761, 0.34184597479357826, 0.3021397813526938, 0.2637494127809421, 0.37383560358650536, 0.33307004005912155, 0.3542019865716527, 0.3282682006030595, 0.347293902705335, 0.3361104998671689, 0.7491990571465872, 0.7506049414083655, 0.7256920993394935, 0.7387118075691377, 0.7756877626759191, 0.20760344254325014, 0.797409497754581, 0.33140289748595875, 0.765363609276976, 0.14831366459557416, 0.1665637915822863, 0.16226948836595823, 0.20347095155226846, 0.27533553173391634, 0.16132170843541993, 0.1733797003535139, 0.4097397352379102, 0.22820601577942112, 0.22287335840292155, 0.11106226043450573, 0.30871114991683, 0.13052979955765276, 0.17245306162102902, 0.1832220647175158, 0.1844847893538778, 0.12008253368595778, 0.12723463637711607, 0.07620913296408349, 0.07691122175548148, 0.13150611319552374, 0.05302007473118231, 0.03997877608685596, 0.05579082887335185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2901913357603503, 0.14592695979919867, 0.17958524959379996, 0.07432582300660484, 0.18311222224713375, 0.040333360817678465, 0.125668087311696, 0.26651855742443453, 0.3229036132312484, 0.1352778528038895, 0.06426334242255505, 0.10020045961027135, 0.12209483550372202, 0.17440988815229086, 0.10113575706810807, 0.3013129133262217, 0.13692724586329952, 0.0899015633541339, 0.2536017831010938, 0.10239986873924878, 0.24624072930087926, 0.24577978200089612, 0.19576349698372275, 0.14930992215853478, 0.27635852803241057, 0.13796574010914997, 0.0796667861274174, 0.567360501328713, 0.5651217452708919, 0.5825591627429496, 0.5861131016424141, 0.5669902974585186, 0.549845920848079, 0.5726023975877295, 0.5510416149593158, 0.5751320060574039, 0.11818617669593079, 0.13399140628135842, 0.12870352262262164, 0.1386956552673002, 0.1194874468349344, 0.11330545696045902, 0.10771036576402893, 0.15137556434916655, 0.12372624214673289, 0.3184911266509972, 0.35713412737830197, 0.15895434852162438, 0.17553452595883468, 0.1440554849032003, 0.16570836814873569, 0.14979844240072893, 0.15727062863284025, 0.24868777410850984, 0.3801092135506239, 0.37218808231231626, 0.3843702701441055, 0.39704420331666557, 0.39342254656210995, 0.3911076441425796, 0.40515187146857357, 0.41267675566371165, 0.3777641300063136, 0.3315308689542956, 0.23903556771584755, 0.3392581656628376, 0.3090255158095683, 0.29968380661102734, 0.3307410742388923, 0.32111451254366974, 0.34011019491394634, 0.33164988525131023, 0.2281332714756268, 0.21891538315508952, 0.20055700064572723, 0.2098359667559616, 0.20131507626146017, 0.2137257090809812, 0.20689585390798793, 0.198589258450661, 0.2220644155515541, 0.19902547940024273, 0.20568494158121653, 0.21253974861698022, 0.35294473325519415, 0.4319400613740856, 0.21510869325941528, 0.3439518104657109, 0.27436075124593495, 0.1926005491607149, 0.16971171074734248, 0.18416242149185968, 0.8058517427004052, 0.1663341340416653, 0.19834341617432738, 0.19545305636443455, 0.7650446140641586, 0.16740517435507896, 0.8197353722182433, 0.7735776509249459, 0.7023793328596348, 0.7584590513089536, 0.7610373888071957, 0.16480568290559006, 0.782359366532795, 0.16673087476085258, 0.34482247636992336, 0.8062741483884155, 0.19525352122314976, 0.1955506953541848, 0.18323272208237007, 0.19380211353951793, 0.20310365562113042, 0.18409071630290763, 0.1853129156379011, 0.1847940535032826, 0.17617234471155585, 0.08776950169443754, 0.08743827621856182, 0.08886272182673383, 0.1001275663404182, 0.08597015604061053, 0.08034741610459128, 0.09012089539817536, 0.09396606482857528, 0.09303100194692338]}, "mutation_prompt": null}
{"id": "20127c84-a788-4b9f-a6bb-7bcac07bdba1", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def chaotic_sine_map(self, x):\n        return np.sin(np.pi * x)\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.chaotic_sine_map(self.z)\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.z\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce chaotic sine map for improved mutation adaptability and exploration capabilities in the optimization process.", "configspace": "", "generation": 61, "fitness": 0.32528477223008917, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7564772911729802, 0.7326101869128843, 0.7463117925484306, 0.7459375555064431, 0.7442454606131668, 0.7493041543571213, 0.7440055239530712, 0.752679348764886, 0.7337946709646752, 0.5673623065251345, 0.2594899961423409, 0.5910840102894066, 0.595280241596067, 0.5877150872758428, 0.5136242490893854, 0.5764423679338319, 0.5806281958841195, 0.2068136146845363, 0.14919547293004232, 0.1471331291034016, 0.15379955618489782, 0.15445554687680052, 0.16315735474627857, 0.27531258479442955, 0.21918649557918357, 0.17974921684160816, 0.16062031538125687, 0.18675182353923592, 0.14450417375669544, 0.13537459305913313, 0.16551445816783927, 0.13218441939433656, 0.1294947915867558, 0.13937998566212206, 0.14905171264022488, 0.1475188393513347, 0.8712952186269455, 0.9624438398054479, 0.9137946879012544, 0.9081013465692384, 0.9646052575838474, 0.9060878190594726, 0.9321235061633517, 0.918004900802962, 0.947036642742879, 0.38347805010427993, 0.34805437652836146, 0.39131330200253844, 0.3676058344943941, 0.34003132253412216, 0.33793307407712303, 0.33964644424633683, 0.3071531250307574, 0.3323875342274232, 0.7536333199961605, 0.7791983642115052, 0.7462517012527359, 0.7685825411521796, 0.8394768589065451, 0.20384029575436458, 0.7321409146896501, 0.22232603915537663, 0.7563633376023029, 0.16229338509299518, 0.14108381615093113, 0.12732856081252397, 0.10321520084350955, 0.1636700601582528, 0.49931152167904025, 0.1738110404723926, 0.1634364547689009, 0.14560031869654633, 0.17670636448931998, 0.13303343909658105, 0.1574317076877334, 0.22592392337213962, 0.14207060762315593, 0.18067943021601296, 0.25956761209128787, 0.23895982439535068, 0.14510568554664005, 0.04818153518721979, 9.999999999998899e-05, 0.09620827532531873, 0.04188335226075379, 9.999999999998899e-05, 0.05211334779766452, 0.06409998789777727, 0.12661873306638372, 9.999999999998899e-05, 0.09136827662530211, 0.24514114725637814, 0.080903772100125, 0.13400540503548442, 0.3181121755021532, 0.018867152480419147, 0.21974555393546347, 0.1564545946134176, 0.08915391339058765, 0.35047392195495997, 0.11972154074432295, 0.19211251760581183, 0.21329247796282247, 0.10615548812034814, 0.13255405669227438, 0.08799279948750738, 0.20470663225947827, 0.1557347872813134, 0.14007440118428383, 0.13538122145857523, 0.186087060844917, 0.055448404025380316, 0.13131948083620992, 0.16988385347613988, 0.11514728915667605, 0.14636281642212, 0.27996605418126497, 0.6018994015969025, 0.5897102327564292, 0.6284931559464875, 0.5955811853072663, 0.5824687347362086, 0.5707295577821705, 0.6084598500665082, 0.6117028619633462, 0.5861627560498678, 0.12571751332711012, 0.12196563163642316, 0.13586684389937997, 0.12500615143175164, 0.15380598852665006, 0.136832012287334, 0.09233636983063975, 0.11343398942865934, 0.14723218286507767, 0.19917275924977906, 0.15587208928644847, 0.24749876000539228, 0.16720905515841533, 0.3585224091504311, 0.1334359318628725, 0.36561152467876123, 0.2410109120741929, 0.20884537991106333, 0.38808429061490957, 0.4012424462778098, 0.3974105718261839, 0.39952276638912687, 0.3950516172838069, 0.4192279253202066, 0.41952752411596317, 0.42910193433146904, 0.4254713561434137, 0.32784810123596175, 0.2339557675959274, 0.24420177007431565, 0.3203910688443721, 0.3379184681910966, 0.34196380397876924, 0.35906473227098845, 0.3526989515377549, 0.32365047335807795, 0.21866789798451836, 0.24050215837438904, 0.2154699535599056, 0.22805185579612175, 0.20491556213459194, 0.21518646940703579, 0.22247662172780247, 0.21457454186605618, 0.212807701141568, 0.22773776034967408, 0.21971081512786472, 0.20586461843216075, 0.21736057323274727, 0.3430580406461269, 0.21796583505288047, 0.3396442490654086, 0.19606085471119894, 0.20030031685794347, 0.17051621632832648, 0.18605332136862174, 0.8101383558292371, 0.7864325427644379, 0.199183147237473, 0.19815855063317467, 0.7508872027839893, 0.7850736958170909, 0.8325633636206301, 0.8042242601015658, 0.20724249838405018, 0.7805224415640583, 0.7311000417933553, 0.16566285904587752, 0.8089288592461549, 0.16805504044070552, 0.26975740790451774, 0.45077227711024204, 0.18139035278431082, 0.17904806501540638, 0.18119082141010046, 0.1859234290801398, 0.19038068136256425, 0.18496523941764142, 0.18038186047061977, 0.1771526482634006, 0.182855792931213, 0.09188622878761221, 0.08813512545793167, 0.08918452959683287, 0.09298163003174575, 0.08779773281821202, 0.09189908392702195, 0.09354019340870146, 0.09044034581218807, 0.09191116508275587]}, "mutation_prompt": null}
{"id": "46cf4afb-e098-474a-abdb-4870d5b30f4c", "solution": "import numpy as np\n\nclass ImprovedChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        diversity_factor = 0.1 * np.std(population) / self.dim\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor + diversity_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ImprovedChaoticHADE_RMC", "description": "Utilize an adaptive scaling factor for mutation based on the population's diversity to enhance convergence speed.", "configspace": "", "generation": 62, "fitness": 0.32543207795581425, "feedback": "The algorithm ImprovedChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.734801022235138, 0.7427339804780597, 0.7261271426265541, 0.7338094081811612, 0.7253472794011497, 0.7160902606595614, 0.7338955949170534, 0.7225387316838618, 0.7244433982833118, 0.5925953783376443, 0.5445655290809446, 0.5793716155928241, 0.5948696058760305, 0.5960425596695389, 0.5344667680398871, 0.5796775203095657, 0.5838995290003763, 0.5831949324744821, 0.3504654697927698, 0.334081734496673, 0.14148431338317147, 0.44045868132111243, 0.2861754309107095, 0.14828366792952186, 0.16295086934603953, 0.1637715209122178, 0.20467952830951408, 0.1338874354116577, 0.16214396977432566, 0.1539643149813955, 0.13046090299362512, 0.1373471649161484, 0.11042445788462574, 0.14954340835792868, 0.11081690287021562, 0.1265958229335118, 0.837412244753936, 0.9591457334079251, 0.9024736787500518, 0.9286060564064325, 0.9249647832339825, 0.9367701998714241, 0.9650980875527662, 0.9373315025882517, 0.9171218056534037, 0.4046337219989258, 0.33996494015605283, 0.31088724626990405, 0.3572770133495219, 0.39812859115956023, 0.3908265415335219, 0.35802852588792067, 0.2820262997554014, 0.33814155812088564, 0.7250322445276565, 0.6655810493622638, 0.6788821872484011, 0.7291921464818908, 0.7563986297416138, 0.69939831205685, 0.6735818422528441, 0.7912748889101426, 0.671266583971229, 0.16426411788468853, 0.234379157712312, 0.1276275173126944, 0.13460720943054583, 0.1204885789633352, 0.5021783893914809, 0.16145936031414188, 0.11048891838681285, 0.17845087367935253, 0.18342011327857988, 0.4089868998720958, 0.17185599775273108, 0.15495050668244603, 0.1822949817599412, 0.12963188010950033, 0.1293476638961265, 0.12789856390505028, 0.1514715748116785, 0.053804833739698354, 0.029041136407308876, 0.04482867051310746, 9.999999999998899e-05, 0.04088807457605692, 9.999999999998899e-05, 0.0693572227304059, 9.999999999998899e-05, 0.05117005000509178, 0.08949967542325243, 0.06950290632188716, 0.056620990848299524, 0.09333693684033828, 0.37865290010899455, 0.21153845457676457, 0.2047556047977066, 0.21377678899372832, 0.11077523800343425, 0.11859944092129804, 0.0411080590258609, 0.1898074765981821, 0.06948697935549464, 0.14832967479471149, 0.07736277587961282, 0.09398267516570291, 0.10647450356403876, 0.08393540919607734, 0.24853496351831772, 0.11842816770760489, 0.22815720128217531, 0.28538717101173783, 0.10170832863676316, 0.22816134047560932, 0.23331531697976204, 0.25338485596352067, 0.24264639783961084, 0.5482044479951775, 0.5594868116307175, 0.5873229842633919, 0.5507298304924426, 0.5491919511203739, 0.5480167344243281, 0.5557098695653767, 0.5823216455297257, 0.5669189665796133, 0.11814634946074143, 0.11555971938971377, 0.10875146535164548, 0.1253695138156531, 0.12152051585982648, 0.1210298717960262, 0.18379813160055491, 0.08984701577455001, 0.11996413580813203, 0.14350448763579315, 0.16331222113829647, 0.2657192349667784, 0.21157033458469654, 0.20020834951737643, 0.27083850523356723, 0.18586758604631282, 0.148285923681452, 0.14259990969246283, 0.3765047189892229, 0.36497089832842244, 0.3831841137360178, 0.3607608713082483, 0.39506788379620694, 0.4106957152402855, 0.3845003972840495, 0.41514313944836023, 0.3964423588910575, 0.27709500929162023, 0.2949959142381272, 0.2522971278666043, 0.31413431856775165, 0.32455978162312826, 0.3185878394874526, 0.3086001201027706, 0.32117270019264677, 0.2978082040091874, 0.22792062546392622, 0.20763061386445947, 0.2077488674883602, 0.21326655024227825, 0.22059991034868953, 0.2095426365237908, 0.2185357166808478, 0.19949947397899648, 0.20121880351126287, 0.19643555966655568, 0.19458214345707603, 0.39513793353165383, 0.39237672059698836, 0.2401013010596409, 0.3509950093899451, 0.22203232473882262, 0.35276355961463446, 0.19472566809830727, 0.7381388229086652, 0.18280033514660998, 0.7419430201239908, 0.19404200395921412, 0.19916196918650364, 0.7690807262851262, 0.7779558334308609, 0.7279710516606808, 0.16329109633721473, 0.7390039423537182, 0.20891090561002557, 0.16704860082392903, 0.7641623070385704, 0.722328869392703, 0.1667034776394799, 0.1665847874153733, 0.1048879249917718, 0.7219025679389264, 0.20027642414241265, 0.1804912451555547, 0.18558737400109004, 0.17641851295074262, 0.1848610983889376, 0.19126158987428232, 0.1887886116910652, 0.17380163567188445, 0.19727113406382335, 0.09272105413068499, 0.08211551393277494, 0.0877329228723347, 0.08056977040346514, 0.09329164407748303, 0.08877537988335682, 0.08574598216313767, 0.09849317122625867, 0.0878616926503697]}, "mutation_prompt": null}
{"id": "9d3cddc8-4130-495a-9939-ddb34c88a5a7", "solution": "import numpy as np\n\nclass EnhancedChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n        self.chaotic_map_type = 'sinusoidal'  # Added to explore different chaotic maps\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def sinusoidal_map(self):\n        self.z = np.sin(np.pi * self.z)\n        return self.z\n\n    def select_map(self):\n        if self.chaotic_map_type == 'logistic':\n            return self.logistic_map()\n        else:\n            return self.sinusoidal_map()\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.3 + 0.4 * self.select_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        # Slightly increase the influence of the crossover strategy\n        perturbation = 0.01 * (np.random.rand(self.dim) - 0.5)\n        return np.clip(offspring + perturbation, self.lower_bound, self.upper_bound)\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.3 + 0.7 * self.select_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n\n        return population[best_idx]", "name": "EnhancedChaoticHADE_RMC", "description": "Integrate chaotic maps with adaptive control to refine mutation and crossover for improved convergence.", "configspace": "", "generation": 63, "fitness": 0.2940156992880951, "feedback": "The algorithm EnhancedChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6503532139640229, 0.6409733307303371, 0.6441317743668477, 0.6479124141865311, 0.6475069532166181, 0.6592711550323396, 0.6392509882890706, 0.6390400755961105, 0.641760368549374, 0.27217940125483087, 0.25671515307112536, 0.27210786692118816, 0.2524078086604499, 0.25588305453108673, 0.2464926565760499, 0.24819515193966024, 0.23353480479011612, 0.2769815310115492, 0.34196541931730584, 0.3350399768886767, 0.16632193296070485, 0.1465598211283532, 0.2734167195639038, 0.25164864042715906, 0.35026506736415597, 0.3444006843190297, 0.3413012479166526, 0.1145015773211493, 0.1331136118139299, 0.12374018508621665, 0.11884718085473034, 0.15352211249284864, 0.1417346616344577, 0.14413041406111538, 0.12975456958853515, 0.1295132583340073, 0.895286369666343, 0.8479366397769156, 0.8386309488118306, 0.7798469900308047, 0.808142434823889, 0.8522978015043735, 0.9107129401234347, 0.8219671555199054, 0.8897216388896747, 0.2775029227944428, 0.361082928369464, 0.36989919502302615, 0.3813263229024456, 0.3472823279122774, 0.34810390377723455, 0.3750713681024277, 0.3002693242873634, 0.30925819857413894, 0.7357136151092272, 0.6477912163708017, 0.2181119254663707, 0.27470944147947374, 0.7559504672932301, 0.7816770404642572, 0.7546938181257739, 0.7197978595333682, 0.7048197941074741, 0.13716241606833024, 0.1781787531825063, 0.19011683367864884, 0.10438029450543129, 0.2213048733349554, 0.1872675808196098, 0.14698924815202785, 0.15224507103065366, 0.18542601625552102, 0.21194631569041655, 0.10868976469508562, 0.2055690412640616, 0.1313275530418343, 0.14759629083612014, 0.16694487503935307, 0.20028585039664293, 0.1829170462848435, 0.2186587241139646, 9.999999999998899e-05, 0.14880300984129968, 0.050774722774318604, 0.04687273614191656, 9.999999999998899e-05, 0.0992328972698957, 0.032118741918604976, 9.999999999998899e-05, 0.07329373475090306, 0.14997612352143974, 0.05350408812679375, 0.07409986097958388, 0.1257457692787015, 0.10929413126614473, 0.13627141205333282, 0.12046529785233795, 0.09734974682419484, 0.06636777906204605, 0.06858231825514505, 0.02802887706186541, 0.15554457420967005, 0.0687191055286166, 0.10271459418970919, 0.06929464660901541, 0.07892616884192316, 0.13227079419479382, 0.07840769130200698, 0.18646337436594196, 0.14225576107332694, 0.08106221424427162, 0.083579812416954, 0.18805024181027297, 0.15556088541269675, 0.21428216154999113, 0.06268858016596135, 0.16594875732361347, 0.49656884325024164, 0.5228154137355231, 0.519655956083326, 0.5186636725103548, 0.5128719353686505, 0.5222055927066361, 0.5243854949215045, 0.5296894419293436, 0.5315844543099342, 0.13890791521477164, 0.12317915805158786, 0.10757060472423896, 0.13081172264765428, 0.10712049214058572, 0.1139938692577851, 0.1416610337685985, 0.11366270027704728, 0.12074803345407326, 0.17903501308768888, 0.19878564814039978, 0.2982561572043776, 0.24933910058001518, 0.312271650661031, 0.16201405571752914, 0.14907257815455177, 0.1800808729090262, 0.30360508197533664, 0.3671210188447651, 0.3589820879783834, 0.3629952678735696, 0.3818845428189088, 0.3723637548361819, 0.3658932727033173, 0.35344164366843756, 0.384474572834955, 0.37612517849089333, 0.3151609012277138, 0.2799475404037145, 0.30528419691780484, 0.217093987904601, 0.30379392988024767, 0.31671041591174665, 0.3086386288057239, 0.26592943527108504, 0.2511595488355789, 0.18818736706223882, 0.26728368263090696, 0.20795982655510492, 0.21985745423984293, 0.20466216399230264, 0.22640258782065537, 0.22295771890266258, 0.2425444384105142, 0.21031471574725413, 0.20644478197831506, 0.40560310643717534, 0.2183858136299115, 0.42402096247417276, 0.40721571332650963, 0.22732831332149517, 0.20718821525332975, 0.21255345122663327, 0.21829531910248356, 0.18512703320265567, 0.18174044610719353, 0.845949216805954, 0.7464764470724621, 0.19849272600324697, 0.8135961141268381, 0.6883905326580408, 0.6598438098459316, 0.13292900846969136, 0.7850945994609311, 0.20828515958835936, 0.20396288358554526, 0.20569252307383823, 0.16461565136282896, 0.5214028123240505, 0.16560179058514035, 0.7610007142544253, 0.6388447777315833, 0.19002350436907267, 0.18813835263354006, 0.1771468225510907, 0.18569133382499792, 0.181691966659691, 0.1948830531081177, 0.18789417270012299, 0.18662843410815122, 0.181171052845173, 0.08654871480490778, 0.09866162815488988, 0.08908437440905559, 0.09556255009359027, 0.0912991309749881, 0.08483594209984424, 0.09529817574309252, 0.08866297493664499, 0.08842403464440163]}, "mutation_prompt": null}
{"id": "98d44741-d4d6-4a35-bb99-044cdffa46b2", "solution": "import numpy as np\n\nclass EnhancedChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        # Modified cosine-based perturbation\n        self.crossover_probability = 0.4 + 0.6 * (0.5 * (1 + np.cos(2 * np.pi * generation / (self.budget / self.pop_size))) * self.logistic_map())\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "EnhancedChaoticHADE_RMC", "description": "Introduce a cosine-based perturbation in the crossover probability to enhance exploration and convergence balance adaptively.", "configspace": "", "generation": 64, "fitness": 0.30278626631003014, "feedback": "The algorithm EnhancedChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7248091424295326, 0.7251403246612447, 0.7045278065983169, 0.7181856595979625, 0.7289188356985916, 0.7125033793883754, 0.734494918412749, 0.7154152681958681, 0.7274688420623998, 0.5322343558620455, 0.5154983065571581, 0.5596679101956064, 0.5551374087222138, 0.5785198845242623, 0.5763987840362106, 0.5061203921161093, 0.5543483813990947, 0.5921678170789597, 0.32553421272248984, 0.2768088633699365, 0.4425888515923859, 0.39497655584519464, 0.3511495475563441, 0.17657459239611906, 0.28196007181777094, 0.1532276178215085, 0.28154069128847026, 0.15128052236597, 0.1431799171259316, 0.1609479229935934, 0.24633419733053163, 0.14106905207888776, 0.13527224015469708, 0.14742535661085132, 0.13084400242397154, 0.13177300742772857, 0.9101563249418582, 0.9532026558515391, 0.88901746227858, 0.9413102648612777, 0.937226386728748, 0.9340492856335915, 0.9520737378958603, 0.9480805381981972, 0.9221394700841408, 0.2577232499315182, 0.3037032233379562, 0.3147310723783655, 0.3516139750245767, 0.34746266398723535, 0.33796135602777433, 0.2824659591572247, 0.26191287539778796, 0.2868912414709046, 0.7571307347225185, 0.603365534260203, 0.5602775259790005, 0.5906364465000411, 0.6625793908495032, 0.25265806897030496, 0.6165941393073768, 0.5475492815636047, 0.5023818957163759, 0.2422280541798939, 0.152117205663458, 0.24305970130770116, 0.15375127599069327, 0.14507071905069102, 0.12953494456684, 0.17551508655478898, 0.15120258466936487, 0.24803249636883207, 0.18914108920053652, 0.1094232384098428, 0.14998928100223552, 0.19155443778992398, 0.2323803802820925, 0.24067963990104357, 0.2163635617768096, 0.12538653975268166, 0.15975970977584897, 0.025856937776962297, 0.054611792521990554, 0.03290771267935122, 0.04716234916077955, 0.04881853041903328, 0.02921232947145913, 0.04765725565853096, 0.07345400284389403, 9.999999999998899e-05, 0.12562869740100868, 0.10346315349516477, 0.1221317663223217, 0.07608452077573369, 0.08905073793993201, 0.050409601722701924, 0.15374234819882748, 0.13114817997419848, 0.09179610275848793, 0.04635387901310728, 0.13985803096718952, 0.17805487764790873, 0.21099118354321444, 0.1824271471928106, 0.07008846090483545, 0.1149129689087608, 0.13341427727759725, 0.12662586455890845, 0.12450641169804388, 0.09749838491734286, 0.20728710544626372, 0.13714746026561186, 0.21594551430401054, 0.14058831608062772, 0.15719713592238516, 0.18843813763953032, 0.11239510905536954, 0.4860514253447876, 0.4903686168627561, 0.4590666085347759, 0.4816864501660717, 0.4722791452643973, 0.4837163027972943, 0.5016467290307696, 0.47142501221618927, 0.5002003657972074, 0.10766246385801714, 0.12803898940906366, 0.12215169368547862, 0.11677332333427948, 0.11823028015011727, 0.1201514648848453, 0.10945095423451057, 0.10808820657747908, 0.1389121125140873, 0.16512260796386868, 0.1407085220048353, 0.1565630568331453, 0.17547275380766003, 0.15375234909586943, 0.13941357508204133, 0.3012578160970616, 0.15997580852214544, 0.1381440971857082, 0.3409105483199626, 0.31026987912693793, 0.34700484483129557, 0.3324052962539311, 0.3374471839986064, 0.34939236345123725, 0.34393770856385986, 0.36536290013721295, 0.3474207152542146, 0.26369135002872146, 0.2533599161448261, 0.288908794316205, 0.24764205776402104, 0.2561192145046379, 0.2481485472587377, 0.27238311992454545, 0.2847065948701286, 0.26318328099782906, 0.25052035459147914, 0.20943901762603045, 0.21532603216409696, 0.19576356144257456, 0.20403790113219789, 0.2202116932502417, 0.19797404046007328, 0.20687809488795716, 0.22056652004881183, 0.22922686744481402, 0.1924558558667765, 0.2171635260635698, 0.22681384667912508, 0.3154983139617439, 0.21384908956218796, 0.25049162930565294, 0.22107619625124875, 0.192136351090881, 0.17067318411366283, 0.16844598014715717, 0.7368135264905662, 0.641229358707365, 0.19851972845501697, 0.19735797948446976, 0.4152617998028779, 0.16967202527026015, 0.7703944631089488, 0.5381170381727012, 0.3710457610428164, 0.5560255454928693, 0.4889495251299546, 0.5291531488625413, 0.4828290417358967, 0.16583030557855272, 0.44891490896918473, 0.6278306055872032, 0.18052991300530052, 0.1909839807615734, 0.1858370612754311, 0.18452719345111634, 0.18759845623252236, 0.17894871867884354, 0.17046349055042576, 0.17515808726428694, 0.19161587850722273, 0.07977934422011035, 0.09958878323708975, 0.08585202609619358, 0.08999182120248128, 0.09232890221036427, 0.09303985571483608, 0.08241181879278703, 0.09189538827637478, 0.08508930628433786]}, "mutation_prompt": null}
{"id": "da35b7d5-ff2a-447e-bc96-df7400201933", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \\\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        levy_step = self.levy_flight(self.dim)\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor + levy_step\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Levy", "description": "Enhance the exploration by introducing a Lvy flight mechanism in combination with chaotic perturbations for improved convergence speed.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {}, "mutation_prompt": null}
{"id": "a5f5dd0d-82f3-48fd-a17f-5576aa71e3e6", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        hyperbolic_factor = 0.02 * np.tanh(self.generation * np.pi / (self.budget / self.pop_size))  # Changed from sinusoidal to hyperbolic tangent\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + hyperbolic_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Use hyperbolic tangent instead of sinusoidal perturbation to enhance exploration capabilities adaptively.", "configspace": "", "generation": 66, "fitness": 0.3299298112490129, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7331865151437348, 0.7431820342857782, 0.743073111634321, 0.7419954027073967, 0.7421015250075095, 0.7433518008136712, 0.7512951632408343, 0.7365198092801, 0.754182203524768, 0.5737757527568328, 0.5685422158618662, 0.5920032236055568, 0.5409111087316412, 0.6207908264754836, 0.5854353456783429, 0.5783459240330302, 0.573418534179349, 0.6700051599261115, 0.2245770495090773, 0.26773461540149057, 0.33851809819905954, 0.16645575687708747, 0.14810300847469482, 0.23957476247566079, 0.16126678916377335, 0.14943494379433864, 0.2701794590756107, 0.1264712330399922, 0.10661642471589605, 0.13284316399231122, 0.12990872320281976, 0.1327737845608281, 0.14077708050851656, 0.11522119269100917, 0.14187489803281383, 0.13127395913122308, 0.9256082834123742, 0.9532025603725885, 0.8827415269192638, 0.9369869092845305, 0.9295101342636158, 0.92260400299666, 0.8934970008536725, 0.9640755045220606, 0.8999224829710237, 0.36257846820692896, 0.32230704321179204, 0.3444001359236568, 0.3488961397327519, 0.3507094691119135, 0.3589542656337721, 0.34705813412745323, 0.30664819061188486, 0.3390819410219016, 0.7531039610722396, 0.7834038376854869, 0.6890406539647467, 0.6947220419738072, 0.7174507367137455, 0.21327096467512652, 0.7024106710465353, 0.7650277037166469, 0.7157657680818501, 0.12076259076407081, 0.1518123516505866, 0.1234309013112892, 0.17006005970896365, 0.22119440755076247, 0.280898105731194, 0.1985315953042608, 0.16989043688193073, 0.1667899597667003, 0.20345381525219364, 0.1352422934051214, 0.16105897769935928, 0.18636229022922035, 0.16088017199518012, 0.22367377524485565, 0.1743845962087629, 0.1904200748264595, 0.23333833152701666, 0.11846889475631284, 0.020422675622164377, 0.013981892611037772, 0.03220543996330161, 0.05540454130443617, 0.017586443265073415, 0.03300365596799404, 9.999999999998899e-05, 0.0018820757387687514, 0.09348745992036633, 0.08873653742991505, 0.12347804242073146, 0.3165400606856752, 0.18062318182975867, 0.03690455090777067, 0.0961404990902478, 0.12439792473146971, 0.11146013333520244, 0.07531237093921006, 0.02918205766239046, 0.3311536602514621, 0.31673323663091746, 0.0666688024914951, 0.07225734662751371, 0.11375727451237239, 0.14340067692521663, 0.08989036761300395, 0.14033397486687105, 0.16521816238116538, 0.1250946868116697, 0.2897746326819438, 0.2391498179216579, 0.17922603173742446, 0.26968543883239726, 0.22549677814553926, 0.05635492800412323, 0.5698469865055253, 0.5915466354231329, 0.5877277393698694, 0.5643313884786159, 0.553669452663905, 0.5597898333785556, 0.559389602410101, 0.5446273765032028, 0.557441559560307, 0.12225268845171722, 0.14557541909789828, 0.12899667117261215, 0.15087524591154666, 0.12675142764010194, 0.12921424236045964, 0.16760171859714135, 0.11910585515764927, 0.1310149364397717, 0.16043308343433071, 0.1596791080592851, 0.28926462028773636, 0.17314273789593426, 0.1744732470883391, 0.19780971702727912, 0.46630826766364464, 0.31237048976415793, 0.15759791302890136, 0.37556109991748454, 0.3739028090725903, 0.4089456683737137, 0.3811798438069789, 0.37958199327449205, 0.4040388144090481, 0.38952523765034786, 0.4188033707638793, 0.40433579454521407, 0.3183386170033409, 0.33561330078867946, 0.30874873450752693, 0.3081696963548809, 0.310096998711735, 0.2882545774556299, 0.3224672328272178, 0.33917054830118964, 0.3048672486226718, 0.2262760777340187, 0.2052964211958319, 0.2012689684081853, 0.20793747463989443, 0.2058528693006042, 0.20618615363686943, 0.1974232219063108, 0.21574185035739724, 0.2193102645342958, 0.1818816022277865, 0.19603030513929665, 0.21869622459664484, 0.2083144064504654, 0.29953249278702543, 0.3216368950185332, 0.3041190066021492, 0.20332699149461841, 0.19147616563346193, 0.17063974976476826, 0.16927570424394367, 0.8018015458856327, 0.7752949324329882, 0.19825894841352587, 0.19739567918019685, 0.8102749501821076, 0.169666977569793, 0.8331823391853339, 0.7469343282143049, 0.6381619986791004, 0.7030475234153071, 0.7604279270718903, 0.7438856962744227, 0.3563823380525494, 0.16617615327731006, 0.7684424286478997, 0.7862263082054348, 0.17905007779788307, 0.19348255682090698, 0.17659185986065973, 0.18504444489948568, 0.17955677235487932, 0.18726531403333924, 0.1888657765801478, 0.19932671128829327, 0.18619895850232915, 0.08814710463776376, 0.10897681644216972, 0.08146332804328593, 0.08334640840290963, 0.09663731781872398, 0.08486222160516532, 0.08788202576826387, 0.09181818911442219, 0.0837027541828318]}, "mutation_prompt": null}
{"id": "86a5f726-347e-4a46-98d8-e1020b7066b8", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        random_perturbation = np.random.normal(0, 0.05, self.dim)  # Added stochastic perturbation\n        cross_points = (np.random.rand(self.dim) < self.crossover_probability + random_perturbation)\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a stochastic perturbation in the crossover probability to enhance exploration in random dimensions.", "configspace": "", "generation": 67, "fitness": 0.3267381904285838, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7305666189969744, 0.7356701462914899, 0.7442026021509645, 0.7487896455101957, 0.7476756250114793, 0.749997420656145, 0.7372956987244954, 0.7352602300227578, 0.7344680942734614, 0.5780044269588449, 0.5589778289008442, 9.999999999998899e-05, 0.6151081619034262, 0.6258241925080548, 0.5797402994770162, 0.5312812715790055, 0.6141930362352246, 0.6012902205206002, 0.42274418880477327, 0.2904599508013296, 0.23691620302112393, 0.15388081630266426, 0.22382027832574836, 0.38316436083971117, 0.31103018253759496, 0.3657073547813937, 0.14673762238801813, 0.1314466708072296, 0.1317481792515377, 0.15383150164759496, 0.13473220270261677, 0.11734094785500981, 0.20710161656545611, 0.1399448991822565, 0.12828997226994743, 0.10932374845311665, 0.8689561205248485, 0.943048300095981, 0.9179812623416612, 0.9456934194979818, 0.934334969371478, 0.8933069961693401, 0.9547025192350106, 0.9466475676156892, 0.9506775689200375, 0.39566623535984213, 0.33155108775704933, 0.3524471151404013, 0.347170528325083, 0.32747954218091435, 0.3150291087815864, 0.2620047694112291, 0.320541211393474, 0.37409435987043116, 0.7499324667316769, 0.7158271988411192, 0.7326661921272332, 0.7754416934442452, 0.7618529169732562, 0.20732205465977227, 0.7137037343169066, 0.7059323497159005, 0.7124618779350119, 0.12649404527607533, 0.16593118574076782, 0.18125595439937559, 0.14908439174794808, 0.15526853659835016, 0.1270020997426744, 0.4904358455813814, 0.1649656752629608, 0.17106037713921252, 0.17283804706984396, 0.1796235317348297, 0.21400670150123702, 0.1428688332318928, 0.14917028850780878, 0.2753432553412728, 0.17676416909513426, 0.480067608450534, 0.11081964438192504, 0.011670952666342993, 0.006441759685231974, 0.0938026334006048, 9.999999999998899e-05, 9.999999999998899e-05, 0.13883763864128973, 0.11227532657041539, 0.0290678538336806, 0.018610681992572764, 0.1291652332425154, 0.13726381177111346, 0.06831247699216947, 0.06599258303371847, 0.08707644200536835, 0.018725876655688034, 0.10403181232642178, 0.1228511581118169, 0.024341340560595337, 0.056035533569616436, 0.09956434950692605, 0.12566380826449508, 0.09435788838798709, 0.12037482607170336, 0.1938787560900841, 0.13370570278038507, 0.06772498089808687, 0.06484026903276241, 0.2796171053619011, 0.08744846199586576, 0.2580341657576217, 0.20345486792847456, 0.2682851878109852, 0.26854562440391616, 0.24350577483993396, 0.16170572607884937, 0.1883360748073173, 0.5535940105579356, 0.5937182446027338, 0.5602783453054658, 0.5326897892545606, 0.5586067061796176, 0.5609425346205221, 0.5571775806731358, 0.5809860352112765, 0.5733620125017425, 0.1133241680760726, 0.16005059702645763, 0.12319554052270487, 0.12932697880835553, 0.12730048381266168, 0.29319851276322495, 0.11234461846483024, 0.09761316199151604, 0.14400037241548158, 0.15538424769742742, 0.17270816115184862, 0.20002257077202334, 0.14799334272339726, 0.2039180607281108, 0.1499049713049524, 0.2347620266567314, 0.16287967766487566, 0.13937464609883266, 0.36789606247101814, 0.3987293527597371, 0.3708394093634544, 0.3793666299844408, 0.38027853715438364, 0.3907035818560939, 0.38489077824254614, 0.40137710089802026, 0.3821526804616934, 0.25625723081140206, 0.3424981731424427, 0.33780890075612247, 0.29373496638972596, 0.30243197706734093, 0.31116408943418217, 0.30547874117524876, 0.3239421676557941, 0.24984417230745148, 0.23558089883002986, 0.2205945538181483, 0.19243819830566167, 0.22752505598398065, 0.2006249197740121, 0.20958314268909084, 0.205212954183442, 0.21196424427259586, 0.20440225459746575, 0.2125807253625599, 0.19557115962276705, 0.20385839880212075, 0.20688700368814517, 0.23324998273835673, 0.2298920880321712, 0.21126378680380098, 0.2135614389537791, 0.2253407947539614, 0.18306456177271635, 0.7988867298619812, 0.18601261747627407, 0.8068609878423962, 0.19928045601849798, 0.7805814589214017, 0.7647529121508393, 0.7569458965002405, 0.7994358827185872, 0.7978416956034102, 0.1679097759543472, 0.7181120079619101, 0.7239549919598168, 0.20379305836422668, 0.7067728644880451, 0.16570636381448967, 0.5243021870874092, 0.4654515963749324, 0.19100760839334263, 0.19519571564184757, 0.1854901878242482, 0.20238353207957172, 0.1900563639946451, 0.19349983807724824, 0.17060833522571162, 0.17989733891947912, 0.20743316695617597, 0.09166939232645777, 0.08678500214196117, 0.09411493776112967, 0.08222351178273113, 0.0991617250771184, 0.09396718433650453, 0.09383588329987902, 0.0903935083454307, 0.08999004591447224]}, "mutation_prompt": null}
{"id": "61969559-2aaf-4d5b-b96e-f539b1d992ed", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.03 * np.sin(self.generation * np.pi / (self.budget / (self.pop_size * 1.1)))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        harmonic_mean = 2 * (diversity * self.logistic_map()) / (diversity + self.logistic_map())\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + harmonic_mean) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Incorporate harmonic mean for adaptive mutation factor and fine-tune sinusoidal perturbation for enhanced convergence.", "configspace": "", "generation": 68, "fitness": 0.32298810817457074, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7327844744232113, 0.7326661776516671, 0.7390022281838748, 0.7560350539839547, 0.7332433629134931, 0.7423766980783101, 0.7337271525654623, 0.7408040513921942, 0.7311136791416611, 0.5218127735123496, 0.571339084446965, 0.5722704789893598, 0.5408131387876691, 0.5951302395346445, 0.5801349766321091, 0.5951189212051453, 0.5841300584610469, 0.6257336431155314, 0.27713364569828414, 0.27031867153046485, 0.15529368763099005, 0.3191363744939957, 0.28118968739441885, 0.25792146606016964, 0.30931582829762183, 0.3009327543285125, 0.32153494262231463, 0.13646586860065002, 0.13792335305634185, 0.14898838599640563, 0.13966779313854405, 0.11472246140290643, 0.13872627796403703, 0.12422779244810567, 0.1514572713814749, 0.14046347029110262, 0.8783575601731812, 0.9584441637355755, 0.9523947028669528, 0.9304343490481601, 0.9619611836540766, 0.9309764225779229, 0.9242187832548022, 0.8677601447013905, 0.9533303547109957, 0.3801349027922116, 0.32358743818059943, 0.3477390379467582, 0.38829630658971925, 0.3614753216555381, 0.33444580503475974, 0.294996370669123, 0.32829419780101443, 0.37103633332325925, 0.7646668674902494, 0.6771926024940216, 0.7298782341912118, 0.7931157104844667, 0.7395227326014298, 0.7128646040089848, 0.7075225687824016, 0.7442639783650944, 0.7388970158133127, 0.17572409485890117, 0.12343247659511958, 0.352010582574777, 0.12454390634003121, 0.27771334828552485, 0.4332794216326237, 0.2663511060267221, 0.11161961001223064, 0.162436839027844, 0.24757599151565124, 0.11856109417141847, 0.17437150831184356, 0.15689781834551808, 0.1489175073159693, 0.14332893368860045, 0.1765130478320529, 0.12812151767537994, 0.11995542421277183, 0.08490042666480913, 9.999999999998899e-05, 0.0023151128990495096, 0.03387461717043405, 0.16858922172075874, 0.03336069035149869, 0.004336201534892115, 0.05620642047452984, 0.03577648251262511, 0.13929059721136905, 0.25165171803969655, 0.05985327742632385, 0.09348389287264103, 0.18442123165117186, 0.06584402947425916, 0.09170530433832713, 0.24760198379367282, 0.07965227924118512, 0.19607884451713398, 0.06185456291480784, 0.24187004936811884, 0.2166132801081707, 0.11084418237531057, 0.08375468072348558, 0.08922453738909097, 0.10525235190068727, 0.07579322104232955, 0.23252633407841417, 0.20201682090668072, 0.17627375939917378, 0.21541078234299826, 0.12927072056371292, 0.132073954654212, 0.1610311090470734, 0.24853183081209962, 0.24405077941420927, 0.5808949585669079, 0.6000652718895412, 0.5870804499686165, 0.567549894127191, 0.5436875693428709, 0.5830815229807425, 0.5833889775479997, 0.5752425964135253, 0.5759249140959088, 0.12138531634617122, 0.1361615884696339, 0.1320986285903225, 0.13191154973763186, 0.13732478402364978, 0.16096354515291678, 0.09919381437841934, 0.10764197167041334, 0.147561604389698, 0.14028554411651206, 0.21889613762466287, 0.23555534903630937, 0.16342243240887366, 0.1741977487900207, 0.1629326507608415, 0.19413884890693467, 0.167275720329218, 0.15474405238930233, 0.4003456806961122, 0.38327521369406536, 0.40414727389540084, 0.39135902274441003, 0.38186759592922714, 0.3817002950778263, 0.41256577625912727, 0.424870131818501, 0.4012637165177605, 0.2693419479370587, 0.29765821512531077, 0.3108314126859183, 0.2992267283550425, 0.3004471366211796, 0.30955037280862685, 0.332167068365786, 0.33894297341572943, 0.32192536617067113, 0.2261060526154577, 0.20989240551311172, 0.20364547508238162, 0.21303875206468603, 0.20090698060491374, 0.19274578480651594, 0.20784996298532354, 0.2334403701662695, 0.20270369643000663, 0.2104099973996938, 0.3883509713824247, 0.21220979417571917, 0.35906945566623805, 0.23815407007810818, 0.3069082118374328, 0.2242400717350701, 0.19940643430754534, 0.1965813088946624, 0.16845870816720598, 0.16973146711439802, 0.8388533869453191, 0.16735924078949516, 0.199205014203363, 0.3773809094798669, 0.17621990934776022, 0.16879453543304224, 0.8066958322346368, 0.7812354950239433, 0.16769610831354564, 0.7582664602790644, 0.7650297959750467, 0.19965004052611302, 0.1670436660189989, 0.16566282252430942, 0.23556023930624748, 0.7405204634400515, 0.19619093631040874, 0.17713133020753924, 0.20360684124826267, 0.17834590078055756, 0.1898029115471015, 0.17490435627751466, 0.18155366066922574, 0.1797316407142342, 0.19857990551266258, 0.09394962273394614, 0.09753786808340104, 0.08999536372270356, 0.08951657895935627, 0.08670619304237626, 0.0879503762305347, 0.09012357395797521, 0.09069074189292003, 0.08974316711586694]}, "mutation_prompt": null}
{"id": "5da59121-aecf-4609-9d67-2f5128c3b47e", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.9\n        self.crossover_probability = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.03 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.03 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.85\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a dynamic sinusoidal perturbation in the mutation factor and adaptive mutation factor scaling based on fitness variance.", "configspace": "", "generation": 69, "fitness": 0.3228988353212226, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7271616957270077, 0.7447150902149593, 0.7626159119589275, 0.7111007204546476, 0.7201852981570593, 0.7218530185435366, 0.7383271870185831, 0.7240576625851403, 0.7284918548106831, 0.5670001818643, 0.5813374115232232, 0.5651697504451022, 0.5676264683210221, 0.6250311644439163, 0.5811949579400002, 0.5824913361884987, 0.58640623389998, 0.6184508182284079, 0.1496268455004851, 0.2563333370313494, 0.40726448839043117, 0.15171203018824653, 0.2462295646749797, 0.1532136066633789, 0.23994995971652988, 0.2518435630861865, 0.32057501842391656, 0.12079577053595236, 0.1335898398540044, 0.14130183288881704, 0.11126210805461612, 0.10615034396698086, 0.14851983944611657, 0.12594603599123166, 0.12840424042168452, 0.1327057315119219, 0.9153965983931436, 0.923006952707152, 0.825250443560712, 0.9399247822940362, 0.950141540856656, 0.9277609475695503, 0.9042857832902964, 0.9418864426203685, 0.9379496678303904, 0.39451981910778167, 0.34282622467089463, 0.308501481172757, 0.3506592922253412, 0.3994361136630429, 0.33451331848882315, 0.3202421482549581, 0.33510892522929503, 0.35369833740599654, 0.7077209149274906, 0.712957315703726, 0.6935250374302555, 0.7350927541733339, 0.783472492886752, 0.2538425975393409, 0.7136377342112854, 0.7646260970182539, 0.7554576497293022, 0.14098129986044228, 0.1255651448952052, 0.12381190259899344, 0.17640603506840868, 0.13106607643084023, 0.2659631473301485, 0.24634559492958374, 0.1717397009471584, 0.16970861598155185, 0.13215986789733358, 0.11526236895945985, 0.1676966960891425, 0.12773078008121996, 0.196435075087094, 0.14270528663683413, 0.1195417137154352, 0.16717140244261042, 0.2897337507233553, 0.10841260621766846, 0.028794519301667654, 0.03378402417662074, 9.999999999998899e-05, 0.04256270764559089, 0.08370058909847045, 0.04273762064831421, 0.10116213508081306, 0.01887353212558862, 0.06521671932789819, 0.08120862525059969, 0.0686068134030533, 0.06229491721716274, 0.09837187536476799, 0.027404945788345736, 0.20561952820750284, 0.10093958300094041, 0.3861685724729408, 0.1871983801742464, 0.033827357626660115, 0.10323533662377449, 0.0656799220289096, 0.15414838485480153, 0.10449410022675443, 0.2082422802339191, 0.13975524768705838, 0.18831447372388732, 0.17677576393904293, 0.24707977568933925, 0.23159264826285275, 0.23823149623768025, 0.10258837576450497, 0.16402772419227007, 0.09161946358423334, 0.21493000494681824, 0.23485201397455036, 0.553351132921837, 0.5697659897341775, 0.5474879995134702, 0.5690948884968065, 0.5478441529078277, 0.5525740321910849, 0.5394638720325019, 0.5838173425363689, 0.54397161262257, 0.23382299653926264, 0.1464081455423869, 0.14747912814846253, 0.11346451008982583, 0.15631876844955273, 0.13769595702764925, 0.1556289860230834, 0.13617499475637052, 0.0675540731613884, 0.3065901126826498, 0.1423533889569749, 0.15766730234022286, 0.1593206582372948, 0.18493724476983975, 0.15228910503204585, 0.15953622635697517, 0.14639558736617742, 0.21060803086830326, 0.36661471020977343, 0.38022892092784855, 0.3805353253354088, 0.3735815310870616, 0.37139532688015087, 0.3933769477647908, 0.3859778530126158, 0.4117549009597957, 0.3908766055408449, 0.31772717501979464, 0.2871347734039966, 0.33140596159931024, 0.29073520561703436, 0.3146700444667826, 0.3062863507607877, 0.32124891426988966, 0.3250672067287621, 0.31894512886624127, 0.20701477016315906, 0.214322119644077, 0.20503270646558103, 0.21736046170991208, 0.19569503439713598, 0.2232174708775423, 0.22413171310133795, 0.1936305451889645, 0.2049941558405608, 0.2139343714960904, 0.2131511558270217, 0.21133160078240876, 0.22519100187074492, 0.3649803418235492, 0.19577666426530593, 0.2799445590693983, 0.21781863158983394, 0.19932925765736653, 0.18460268042139227, 0.18345320336117588, 0.7928156504274388, 0.826980095795444, 0.7303639187478494, 0.7759284070375028, 0.16739862265365968, 0.781475359245826, 0.8038670441013023, 0.7780421110490793, 0.20518354020980245, 0.6234084348003834, 0.6577709831611633, 0.164521461749365, 0.16528756864467264, 0.16741149794790455, 0.12353735738069938, 0.7398353789372556, 0.18799028340766366, 0.1723552690471173, 0.18695385659580965, 0.20178299468461747, 0.22101765774930815, 0.1876950759517375, 0.20916235932844052, 0.18661350108942043, 0.17302435815839579, 0.08493343701391076, 0.11016211238315843, 0.08461762731397471, 0.08798111398127462, 0.08221993968051189, 0.07859628278020736, 0.09056456631482779, 0.08740306502426232, 0.08849707427470421]}, "mutation_prompt": null}
{"id": "a94a1d33-01e5-4915-b9b4-040f79ba1b93", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Modified:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = -0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        mutant += self.levy_flight(self.dim) * (mutant - a)  # Introduce Lvy flight step\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Modified", "description": "Invert mutation factor sinusoidal perturbation and introduce a Lvy flight strategy for enhanced exploration and diversity.", "configspace": "", "generation": 70, "fitness": 0.27443319614124306, "feedback": "The algorithm ChaoticHADE_RMC_Modified got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.6566620772032519, 0.6313234658298414, 0.6252650516533582, 0.6404869094782522, 0.6381479246277043, 0.6497313278301333, 0.624974580732817, 0.6399701126890376, 0.6316283094129161, 0.5183686299024151, 0.5178936225900719, 0.4941848134127196, 0.5007097509042631, 0.5148981827461753, 0.51478789161125, 0.5167979882509339, 0.4963480720077841, 0.5358645878127717, 0.23630331816667316, 0.24198578509590174, 0.2556250179997318, 0.26931817405635494, 0.29455160591985985, 0.13685374913776682, 0.21889194801179968, 0.2627229728447482, 0.2709119690674968, 0.13148600273043154, 0.19903457791482748, 0.17625686946959962, 0.15204742066772636, 0.14891742885243442, 0.19119839678806527, 0.13349278124313202, 0.25317900809042526, 0.13915844629683127, 0.9379115276559319, 0.9304218792486093, 0.9200860374354581, 0.9350923872967486, 0.937780874910761, 0.9270043617873379, 0.962140999170465, 0.9140223573607549, 0.9313435973151202, 0.3166045340341076, 0.32831691813481234, 0.32260077444700497, 0.29476355573619817, 0.3182192272150324, 0.3040641024613674, 0.2939275649864542, 0.28809980283896763, 0.2983602465419083, 0.3713537956937837, 0.5440290326131142, 0.4917336705816847, 0.2543049514298781, 0.5545355332091204, 0.20555218661409547, 0.37535405870088046, 0.5450024043136884, 0.533415340377078, 0.15526118939560052, 0.1524218074879813, 0.16882170145782716, 0.11693987271905859, 0.14244368977032174, 0.16414477019920726, 0.38034699545782524, 0.14789381268581492, 0.20181032438845403, 0.13302502258633264, 0.17606373882729964, 0.12541916431155353, 0.14205168236918075, 0.13024976624032136, 0.12661229598035129, 0.12936728868159808, 0.15828948579068203, 0.190859235562452, 0.06005933440788014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019566662992678285, 9.999999999998899e-05, 9.999999999998899e-05, 0.021996034512602458, 0.0028492649806821646, 0.06717530124197746, 0.13358705855196162, 0.08763422447237734, 0.05570106914340012, 0.05433537502654051, 0.08085514141483252, 0.06536252177532009, 0.030924522796448417, 0.05548313340556743, 0.1170618397168186, 0.11047587509705459, 0.15475355225534626, 0.08749764322904119, 0.07204590552239132, 0.09408372054586944, 0.1035718745807126, 0.08252308794217111, 0.17404551316449324, 0.16763236877260312, 0.0803542845426386, 0.2175914902472076, 0.10610250081337491, 0.053854239358625655, 0.08930872256975997, 0.1476286468973369, 0.07788846397129745, 0.08225440041022414, 0.4378358709877407, 0.4335908627184587, 0.4318021270514594, 0.4291682340477103, 0.44065838847061545, 0.448485841505726, 0.4450428342511846, 0.43100801179141246, 0.44602372130560475, 0.10466509744068808, 0.11318120618424765, 0.11170349495175491, 0.14265539341726186, 0.10966676875628578, 0.11827135084665386, 0.1403749987793923, 0.09451663368284557, 0.13309859315738848, 0.14285053111502943, 0.18857052825088272, 0.1508300684043946, 0.17102624998963023, 0.14295602050128142, 0.17168883751887665, 0.30361984096359607, 0.1275736279503783, 0.1299173205691153, 0.31189729441288816, 0.3203083685820616, 0.33234505447331764, 0.316798320140661, 0.3013097826004144, 0.29963178721232675, 0.32494662098725247, 0.35368514673096374, 0.3147141914969337, 0.2658938902043919, 0.2615177931385837, 0.2812463477477468, 0.18178766281153125, 0.24788728436153218, 0.24465657605097302, 0.2560208911079602, 0.26435007137904054, 0.26136433849395035, 0.2021325244026605, 0.22462384376641564, 0.18525243395434754, 0.20513257038173383, 0.2031685127452615, 0.1963881796342043, 0.1969931542914859, 0.2027688097502106, 0.19455179193068595, 0.22849913968825375, 0.2320712539730082, 0.22868144098846566, 0.23030812395867006, 0.2741670743457155, 0.2111682718533694, 0.2422607479181068, 0.21687045175927777, 0.23476044484266279, 0.18321260745113066, 0.18381519611984243, 0.1778498701285567, 0.7334881094043834, 0.19633270724285334, 0.6855691013731564, 0.6029480977991031, 0.6345509156889231, 0.17686844373448096, 0.44129308292776137, 0.20099163292319944, 0.1968762748745485, 0.5179967273816307, 0.20504975065513553, 0.5129705755915863, 0.16549073772577594, 0.4228750151332078, 0.20191865375356033, 0.18454605830385706, 0.19117078898979611, 0.19819033587095314, 0.1805363989044274, 0.1897147585909985, 0.1849670819651602, 0.17831932154376862, 0.19832596792514, 0.19196405644087977, 0.08815789389053497, 0.08307621780306795, 0.08700117236773963, 0.09416198190555058, 0.07464503709232417, 0.08325446088753907, 0.09474065220804206, 0.08742586853706091, 0.08119605190858747]}, "mutation_prompt": null}
{"id": "680de063-ebd4-4f75-87cb-c7b3017070d3", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        # Dynamic perturbation in crossover probability\n        self.crossover_probability = 0.4 + 0.3 * self.logistic_map() + 0.3 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_Improved", "description": "Introduce a dynamic perturbation in the crossover probability to enhance balance between exploration and exploitation adaptively.", "configspace": "", "generation": 71, "fitness": 0.33030892249056265, "feedback": "The algorithm ChaoticHADE_RMC_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7471171424352597, 0.7325349042986098, 0.7294287999871276, 0.7536878189341921, 0.7413492181030461, 0.7394473208014789, 0.7382947356270231, 0.740477931659439, 0.742323273938722, 0.5910704315402495, 0.5836413687253675, 0.5893910347875326, 0.5800354412647273, 0.604168287669008, 0.645727640986961, 0.5833487588099713, 0.5650605396441626, 0.609492061039659, 0.2372810919894781, 0.16025048510851014, 0.15238900645803966, 0.1806883190314469, 0.13714127496749184, 0.1594819328083198, 0.14925956143035368, 0.14289443120422562, 0.15927986968451768, 0.12916178705250825, 0.17758646047694238, 0.14297731034994254, 0.14167447709704806, 0.13358388974651736, 0.12561877372514552, 0.13595328441153798, 0.10035514655089806, 0.12908504802131449, 0.9284075521297412, 0.9117377421376996, 0.853693048829155, 0.9450921909888274, 0.9134283084619556, 0.9063807246552291, 0.9640133194808952, 0.9431549061465476, 0.9209780083882542, 0.307445502405141, 0.3585110183480875, 0.3277297365448646, 0.3669068381417324, 0.32209848907540506, 0.3152043150824213, 0.293953511626046, 0.327144606562385, 0.37809150306948835, 0.7100546825343084, 0.712564945821565, 0.6822709060087387, 0.7399347245730238, 0.7603347443407955, 0.5144584823528399, 0.7542419178943709, 0.7140419879565081, 0.7314191297287702, 0.14174049005507527, 0.12538790918063658, 0.20372173106767855, 0.10093327791747175, 0.14495192216854758, 0.1983650643227517, 0.14811224421490876, 0.19066172760316336, 0.17302587503393174, 0.20601330959432107, 0.141185659962496, 0.2085683699286749, 0.19862717813764663, 0.1750586734377988, 0.15494424608755375, 0.14860569230900111, 0.12670164962532326, 0.12665537540626937, 0.03118989850481535, 0.05930825749772706, 0.07707178633991685, 9.999999999998899e-05, 0.1844492240980199, 9.999999999998899e-05, 0.0011466524932156608, 0.003760979753737792, 0.006320687160752625, 0.4447495453576431, 0.38818483694665906, 0.16185098353186367, 0.2347831829988688, 0.14551863572230594, 0.09217411888483562, 0.18109633124094948, 0.11083993545410453, 0.1785541871279971, 0.08822421876365283, 0.10355604853186051, 0.21216583468054573, 0.25536901473477625, 0.09518737072091188, 0.0646623957505208, 0.0854994793560514, 0.20186063477331595, 0.08369656530966618, 0.1728831367458632, 0.1215004056281136, 0.2513461526927143, 0.202545288743611, 0.1502548608896188, 0.1334474700330618, 0.16297391875039902, 0.12541994074262186, 0.14238594893697554, 0.568190178155171, 0.5876751921914087, 0.6045897668749038, 0.6142906160930767, 0.6070620068360654, 0.5984886332932449, 0.5959485700253937, 0.5951347873072936, 0.5895863404852554, 0.1309224568592734, 0.11557801628210307, 0.13860961753159573, 0.1388460259096217, 0.37263598945844745, 0.12242945588786902, 0.13009448063051954, 0.12201170831084018, 0.11187304488937555, 0.1492323396793379, 0.1356535536038409, 0.1666638616306806, 0.19413513314035036, 0.24218125899404108, 0.18869176567159884, 0.22193214666078187, 0.1793733201557266, 0.14964222767172886, 0.40461561566018234, 0.38491929620612064, 0.40400568599099496, 0.38958726181963166, 0.40804522195147197, 0.37971709209596016, 0.410291046462096, 0.4148804981787184, 0.3830711593462601, 0.3220189103187592, 0.30754963237374955, 0.34273232925838304, 0.23354515359118744, 0.3365360936394025, 0.3438208057437826, 0.35527511592624617, 0.3520606612633549, 0.3290109230269781, 0.24329034581905717, 0.22314092601700064, 0.21918669665365897, 0.20737702559960602, 0.2188134957680179, 0.2044861228068212, 0.19972773374400954, 0.20186372527241403, 0.19281785146663866, 0.22411804539585478, 0.21770510095053686, 0.19182718449135172, 0.1759581357879375, 0.3748306386586736, 0.397327950434445, 0.32485664108499146, 0.21002262582960063, 0.2140052797898414, 0.16536079526899283, 0.1688759675663175, 0.8153763025261315, 0.7860354118921073, 0.19780631651097103, 0.7893187596196838, 0.7570123776979429, 0.1680980382212558, 0.796795125439701, 0.7536385696846238, 0.7043706927785356, 0.7292005541673084, 0.753123695937384, 0.20439841895778277, 0.7820343769315693, 0.1674546825787132, 0.14626562100241391, 0.7395577171047163, 0.18596772213267287, 0.1867936044337548, 0.1752720483936271, 0.18264423560321308, 0.1807414711193145, 0.18020679936382966, 0.18624696886322223, 0.18140400978966786, 0.1809404907587029, 0.09155321459537369, 0.08684812623382643, 0.08697032878086397, 0.08581460266825502, 0.09325433555583618, 0.07695712587239945, 0.09316131946389794, 0.08389651327605863, 0.08683036591507975]}, "mutation_prompt": null}
{"id": "4b9ff59a-8881-4899-ab40-562059c2e1f0", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n        self.decay_rate = 0.98  # New decay rate for mutation factor\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor *= self.decay_rate  # Apply decay to mutation factor\n        self.crossover_probability = 0.4 + (0.6 * self.logistic_map() + diversity * 0.1)  # Adjust crossover probability with diversity factor\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Enhance adaptive mutation by incorporating exponential decay and diversity-driven crossover probability adjustment to improve convergence speed.", "configspace": "", "generation": 72, "fitness": 0.29199093182602426, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7789753743071699, 0.7767496024333378, 0.7637806988126928, 0.764285300745787, 0.7412230672532271, 0.7606618087357313, 0.7607964311404664, 0.7773074501104293, 0.7642265638744598, 9.999999999998899e-05, 9.999999999998899e-05, 0.1192975698773493, 0.15874862578998272, 0.6563574609743212, 0.021722014320977756, 0.04149867619508585, 0.08153817499173965, 0.6928136088272812, 0.3900079167116136, 0.33202134231765745, 0.14563067970376664, 0.16324981624338308, 0.24700796968020244, 0.39460844233727554, 0.17514416924397846, 0.5227556596418013, 0.3254473111084779, 0.121675105581593, 0.11277538820742261, 0.10862741883325255, 0.1261247553171979, 0.1135250227760245, 0.1457932867234677, 0.14481412458216414, 0.08633100742252664, 0.1286898604351372, 0.7791778911506848, 0.9253174814504238, 0.21837768227526722, 0.9222419590959898, 0.9023508176174765, 0.8631885465951349, 0.9495718256719663, 0.8793619288537071, 0.953238806928774, 0.2244875492755135, 0.08607860455951888, 0.27917862831178386, 0.12398328978101403, 0.18937959994073195, 0.30939735832492044, 0.20503570104909563, 0.10524054703122887, 0.2303859581175226, 0.8145773517933185, 0.7791505870854075, 0.30472882887339414, 0.7063760090319143, 0.8274087653035853, 0.20952442600520094, 0.8022967360901568, 0.8061151852827919, 0.22904335265128362, 0.12477823362286167, 0.12299939854289954, 0.12028688920661879, 0.091011094998248, 0.15353916420000346, 0.3535542996518991, 0.13760095423079488, 0.13665851644874438, 0.14108136189101572, 0.19571866807228577, 9.999999999998899e-05, 0.22065199559483084, 0.126838985870653, 0.12642922319363992, 0.12943623165118112, 0.13081171052250662, 0.1833596111853114, 0.120809948977457, 9.999999999998899e-05, 9.999999999998899e-05, 0.02894144161430323, 0.06603954628772735, 9.999999999998899e-05, 9.999999999998899e-05, 0.04035399458973277, 9.999999999998899e-05, 9.999999999998899e-05, 0.06404698464773262, 0.03455674363776706, 0.11003248520679776, 0.08281285227431001, 0.11431555496723866, 0.026399625112482283, 0.06786479680277757, 0.07946409266810228, 0.06731515187309856, 0.06630692517814951, 0.20104840403124413, 9.999999999998899e-05, 0.20850470356589756, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.21333165957087674, 9.999999999998899e-05, 0.17305498968248956, 0.050247902461101, 0.0982667775609416, 0.1651443622291454, 0.12072887517995146, 0.06674329072096896, 0.21556235355279862, 0.09862355294948522, 0.19001974385292364, 0.5909233587030986, 0.5663322147617653, 0.6160220897461589, 0.5581554024168816, 0.5466598017348712, 0.5793860194072071, 0.5728010756683918, 0.5998466732526185, 0.5822445627151458, 0.2650874530692541, 0.12384646129866017, 0.09682263363270138, 0.15146679703743116, 0.11893827337772822, 0.17029833428063645, 0.15668175791433603, 0.0948333271338272, 0.07407159973449107, 0.19746803746337083, 0.4559586856322294, 0.26070799590260885, 0.17317958386408794, 0.35543945052948067, 0.22974988535027563, 0.2538602342001809, 0.17697227190045195, 0.22068749046687686, 0.4431168878295727, 0.4176859598524556, 0.44732986326154667, 0.408316508936886, 0.4249638287459282, 0.40835822470735617, 0.4237533217506513, 0.44951769869621905, 0.4358142156213066, 0.2932998746593427, 0.3191373932130126, 0.2545060920146681, 0.3346262804436998, 0.32949626969830026, 0.31038835924393426, 0.3312168981457777, 0.3432816087625904, 0.3066940960423984, 0.19768644138794356, 0.21014456283619987, 0.20060310229061062, 0.24260857599624497, 0.21204240126021623, 0.226061196570417, 0.21431819515761097, 0.2100320049114992, 0.2049486215491867, 0.2192324961834513, 0.1992703840997364, 0.23030878914502184, 0.24202075192451178, 0.20280513416233237, 0.20083218227801714, 0.22992674190981477, 0.23136385176142005, 0.19667113902302447, 0.16757412577127218, 0.17127347268479864, 0.8351500928916255, 0.8508640970189337, 0.38095886051591366, 0.4128545009925163, 0.7843967231034674, 0.16901526223451924, 0.8421622143763726, 0.7577297895462419, 0.16850338788711283, 0.8021470321151585, 0.5397673534878034, 0.7487924331388582, 0.5604017076573975, 0.1663639191595666, 0.10429249230591209, 0.35699573263681417, 0.2157329338633699, 0.19628453310052474, 0.18353643438495326, 0.18989961740611594, 0.18974106749399344, 0.17983310804203123, 0.18719126807194675, 0.1980238529311128, 0.18387168934313158, 0.1021544047024816, 0.12701395425284046, 0.09072540780893268, 0.09737252274007335, 0.09109966776872913, 0.08028698287312397, 0.09458267952365385, 0.08624500792491596, 0.08026129791357584]}, "mutation_prompt": null}
{"id": "d6f80a61-fa3a-4183-9e84-f6cccee24a8b", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        \n        diversity_factor = np.std(population, axis=0).mean()\n        dynamic_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(diversity_factor))\n        \n        mutant = a + (dynamic_mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Incorporate a dynamic, non-linear scaling of the mutation factor based on population diversity to enhance convergence speed.", "configspace": "", "generation": 73, "fitness": 0.3293779895984467, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7296155224244784, 0.7336595362443796, 0.733642639330236, 0.7370327945686921, 0.7359799966799685, 0.7402892991397473, 0.7440987836133471, 0.7302209849575834, 0.739604355465119, 0.5973957864788022, 0.5600959769901663, 0.4219694269349288, 0.6072266365276704, 0.5859177046854465, 0.6284524640367206, 0.5640557649210463, 0.5844867939435234, 0.5933628220298219, 0.4691679205131962, 0.1658949161796912, 0.28884260576247667, 0.2290575895171193, 0.31136365612609906, 0.1614673071535042, 0.1559795794012736, 0.20796361483835946, 0.20398166828533493, 0.17816914320954835, 0.13039451779816758, 0.14253386379583022, 0.1273317806543155, 0.15122980759408455, 0.15655184294575486, 0.11508121377541392, 0.13973917459644614, 0.14280342298126603, 0.9002437528125773, 0.9368010764990612, 0.9176373048797267, 0.8809905353354495, 0.9282596423220363, 0.9625427632561503, 0.953500035911524, 0.881265616407167, 0.9312169453914526, 0.3024871279236273, 0.20422349315726995, 0.31787861858412647, 0.37303643841575873, 0.30034888663386805, 0.35447341637320473, 0.33220305826970364, 0.3614036875981803, 0.2893896561761349, 0.6950778250897083, 0.735309641232613, 0.6778841670631712, 0.7964504085896488, 0.742809926810081, 0.7282301539122205, 0.7538698466474982, 0.22970424877115325, 0.7136264483642035, 0.1678215644393929, 0.17321638152083219, 0.1070085423091095, 0.1640169255379107, 0.14815544619157006, 0.4352892529517851, 0.41850725316620363, 0.48652800241685723, 0.15422306016363108, 0.21440180679818566, 0.14420090112480866, 0.15478568957501426, 0.14462544158642054, 0.12925468137403895, 0.22587987051564073, 0.1692062077098262, 0.13120471089567454, 0.1338871856132966, 0.04133749640954398, 0.026799227680113447, 9.999999999998899e-05, 0.0004880945794507596, 0.28651714739409695, 0.0024690142569910867, 0.02389971084064091, 0.13692487504621786, 9.999999999998899e-05, 0.1665111394916854, 0.09691754087130633, 0.1378363628472904, 0.1922806862264108, 0.1140766298759388, 0.047693492467110965, 0.23478332117726175, 0.1204128176601571, 0.3605583155544768, 0.04461386240974752, 0.08929515804611854, 0.18561460299886778, 0.14691454256575232, 0.0951577181707054, 0.2239740535858652, 0.08453899896413097, 0.16610829751214728, 0.15615158908412796, 0.2617504064689259, 0.12131048600128902, 0.1357174698830217, 0.15182487162079394, 0.28914362480886424, 0.24750660330614316, 0.10543690259405425, 0.16736563394994775, 0.23705391276518784, 0.5655234878573386, 0.5621621461362756, 0.5552298107782598, 0.5649349030304857, 0.5632316006791942, 0.5788561136788397, 0.5394194286023853, 0.5409969570013919, 0.5593347594047753, 0.12182564753711744, 0.10698897434931753, 0.11844703091875364, 0.1321328358977758, 0.10481236410397066, 0.1426135420751058, 0.11427748156713746, 0.11688732468878571, 0.12269016770524288, 0.15483543566313507, 0.16351156603944073, 0.15366287927690847, 0.1813478389477866, 0.2638432301498739, 0.1525550797495684, 0.20117871309893887, 0.1404251971923104, 0.1409267655785541, 0.38330384141281193, 0.3772426257303483, 0.3826145465807912, 0.3832197765493238, 0.3770674098399842, 0.3835645259957754, 0.3986763076375498, 0.4070412844065089, 0.38353568056451404, 0.31806169938700846, 0.29501919059513215, 0.2390571481137892, 0.3128760697902925, 0.3216666152186507, 0.30168586718122425, 0.31457959562484805, 0.3237608380831962, 0.30976946507144776, 0.1980492317770307, 0.2074593024024184, 0.20387316515774223, 0.2261071605464312, 0.22248905297036514, 0.2238097418972116, 0.2199352355132591, 0.20747645008163562, 0.22856730035164052, 0.20107690807692846, 0.20965343334860176, 0.21288275474592, 0.32360201602184957, 0.3024772445235754, 0.3423513004444896, 0.2712684329835281, 0.32646579722195757, 0.19950803963301533, 0.7145072558044065, 0.18487929023112593, 0.8156114445374801, 0.7857722021817092, 0.19780476314231932, 0.7697804916077213, 0.6189873343291823, 0.1630636865169114, 0.7853264514558272, 0.7065708611223136, 0.20674822783330382, 0.7433780115618762, 0.20381509262983766, 0.6496016503914772, 0.7182964264732689, 0.16539949593678593, 0.15563009973879127, 0.7683919411351786, 0.17921922183403638, 0.18133705471592898, 0.18178063098534003, 0.2001845312228112, 0.18486223423479387, 0.19526953577936879, 0.18042979933621195, 0.20486611643415964, 0.19899813110121756, 0.09358294265731815, 0.11280679272905914, 0.0910951238175699, 0.0930739927456189, 0.09065590542127777, 0.08636922934346658, 0.0898970513575903, 0.08884022056305729, 0.08944300763521118]}, "mutation_prompt": null}
{"id": "14e19b02-82e0-4230-ba43-91e908280e67", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def sine_map(self, x):\n        return (np.sin(np.pi * x) + 1) / 2\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        chaotic_perturbation = self.sine_map(self.generation / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor + 0.01 * chaotic_perturbation) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Enhance the mutation strategy by introducing a chaotic perturbation using the Sine map to improve exploration diversity and convergence speed.", "configspace": "", "generation": 74, "fitness": 0.3261515054983773, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7322854519316545, 0.7275917358091809, 0.7297747154396024, 0.7424589211639062, 0.7165250756385618, 0.7255383018510809, 0.7309713809601015, 0.7377209202298354, 0.7326191405410336, 0.5607569240728127, 0.5398042560170788, 0.5927206268759004, 0.5765209101774111, 0.5307081601884005, 0.5368912578191556, 0.5382287845773233, 0.5689594496670052, 0.6186018879570738, 0.2818143465847993, 0.27455994224384606, 0.2535388840196926, 0.3189847690052756, 0.13692893530605743, 0.2925951784418903, 0.1993305213284461, 0.386900714847655, 0.4130702058773126, 0.13287306273393373, 0.12837739080119004, 0.14184952913147464, 0.13499414598755588, 0.113857372852878, 0.11409506109346224, 0.15691453255153553, 0.14012711473980566, 0.14298898052328057, 0.8901570179981008, 0.9475282885481483, 0.9472897892850073, 0.8849680663593703, 0.9235689263316407, 0.9481623827288106, 0.9196159489629259, 0.9251486192824973, 0.9315574489358122, 0.3487590756010265, 0.33589801316876133, 0.36241623947760127, 0.34412421305875296, 0.32084691439292934, 0.35374096288180223, 0.2865004108343441, 0.30402767815827925, 0.3736239512573183, 0.7169342849370709, 0.689144861426382, 0.7410373553856531, 0.6932233747183816, 0.7461205848481514, 0.7602826711129738, 0.7567479515079709, 0.7563149934894764, 0.7772090995433744, 0.1245994659653723, 0.15106559243713458, 0.16261534103488196, 0.13087355020803082, 0.15760159173092692, 0.2815863545886881, 0.32501994737706774, 0.17856268685260623, 0.22769512211770848, 0.1650101434593686, 0.1174174205685018, 0.18193551452342083, 0.1432499567425508, 0.17323421795016003, 0.12275237476176704, 0.2277039288139816, 0.14637967082441938, 0.1991009038245446, 0.08120889617071658, 0.05442371384331568, 0.07164566820873808, 0.0008350513014049321, 0.13189285549319119, 9.999999999998899e-05, 0.013683816267400783, 0.008662958662134401, 0.040588230765799205, 0.09000857534187001, 0.20163519299491928, 0.10685807559175087, 0.09745057533939039, 0.3556744043919091, 0.02545144835576718, 0.33284742832098924, 0.2368892063038872, 0.364263533889983, 0.03947438886333621, 0.2220875853143368, 0.24212449771341682, 0.16467758728620907, 0.08911306805556596, 0.06469849054755283, 0.09215920387891763, 0.09510690855450865, 0.11567695995217075, 0.1434980092147945, 0.22283363403013545, 0.22833755372588638, 0.14576311566833122, 0.2720054840378221, 0.0561899230138313, 0.11179158974837244, 0.2212181204409469, 0.15973128981244533, 0.568242201265164, 0.5817963649234095, 0.5730697432176106, 0.5700624141613801, 0.5640579232605147, 0.5648209488564073, 0.5648905660648919, 0.5657676009198269, 0.5717947947505535, 0.11764866808077457, 0.12860987183968298, 0.19944874832410997, 0.11733966265256202, 0.11313476886963836, 0.13598434439912066, 0.13555186402681374, 0.1399598626601375, 0.12960787722986733, 0.1688851442767102, 0.2109801141436014, 0.16375322672187853, 0.167893289115572, 0.17801806401299347, 0.23475477681414658, 0.2220302275764262, 0.21483009301170497, 0.1431339902210702, 0.3869108026525049, 0.3671906617734112, 0.39340361597132256, 0.38574149523731505, 0.38440440131553355, 0.3831499946134289, 0.3930208755766168, 0.4087707535073226, 0.4069216460801164, 0.2316787601005703, 0.29583687143359627, 0.2740663782564471, 0.23803160749724817, 0.32579853359552846, 0.2994914129856773, 0.30582856018973836, 0.33397961549988, 0.3009176927585372, 0.22332763361532992, 0.21406995727953715, 0.21372811519017354, 0.20965858430622497, 0.22138306487194626, 0.21300079284955475, 0.23838154434240355, 0.23509131259417504, 0.2405398656016441, 0.2718704341288589, 0.3959235723390274, 0.22570582801306116, 0.2317946598755417, 0.21875771999533644, 0.209808857075372, 0.19573159959123543, 0.20407275822621074, 0.20896770916314866, 0.16995984825846844, 0.19440941813066126, 0.831852180346734, 0.6824547412357094, 0.19816881145408083, 0.19632959946268025, 0.8017672859663031, 0.17280963870091348, 0.7873807757884115, 0.7435626860808091, 0.20845514815567345, 0.7611508496294409, 0.7449915274804161, 0.16451057555300264, 0.16509506398004903, 0.16713744131094732, 0.44434581340598756, 0.6882548928553509, 0.20080792696999716, 0.18711245026822165, 0.17875939788364392, 0.1992021543844128, 0.18394205617563075, 0.18430257436198572, 0.1832991874983977, 0.1736115563248919, 0.1774252548523334, 0.09036483549251262, 0.09429850635954284, 0.09841101901387861, 0.08856259798452304, 0.09300709253630468, 0.08875100693543758, 0.0808495009324941, 0.09068926606430339, 0.09522912821254159]}, "mutation_prompt": null}
{"id": "09b81286-973e-44ec-87be-effaca3a6ddb", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.4 * self.logistic_map() + 0.2 * np.sin(np.pi * generation / (self.budget / self.pop_size))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce a chaotic map-based adaptive crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.3253750269956119, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7500993649942063, 0.7435080003675041, 0.7351732053641649, 0.7466500949270345, 0.7512782081827787, 0.7416288414104455, 0.7397143003699649, 0.7401824171756085, 0.7434234819296817, 0.5764340722391739, 0.5755396090491998, 0.5959795646964934, 0.5920702022226468, 0.6120853290205729, 0.5791079260444965, 0.5878791431170545, 0.5856244444519947, 0.018391790343003978, 0.20977345092195854, 0.15220204661047032, 0.20080969842386098, 0.23320647622418555, 0.3447745838178352, 0.3216940032254483, 0.15783597700785246, 0.15207831004208805, 0.2400744482524887, 0.1380987084859251, 0.12292164879450318, 0.11884727062345612, 0.13592845474797866, 0.12841400546751325, 0.158338458636044, 0.11975260446102298, 0.12892849594300948, 0.13468413628998566, 0.9058611535475911, 0.9507372661578547, 0.8848710126615407, 0.9393059599489267, 0.8930081334423408, 0.8906878033323863, 0.9638562349347489, 0.9439641943062406, 0.9026093421454554, 0.3546848131150315, 0.22608018021186427, 0.37814211071867354, 0.34967228287558794, 0.3501439682888, 0.33670614658418474, 0.33426252030620784, 0.3188903586821621, 0.30654210136517457, 0.7110724444992192, 0.7311839605831534, 0.7108128989016629, 0.7165509088826758, 0.761117214583908, 0.7288217730375222, 0.6892553877126012, 0.68659152970202, 0.7639155313380546, 0.14568856460217716, 0.16237531686550266, 0.12250471434579835, 0.12097849711043018, 0.20546756174605496, 0.3172099945284059, 0.1455553953442894, 0.19779786441667457, 0.15588629383332087, 0.19887477179225754, 0.17023575649579348, 0.21117908719324918, 0.18456795320024222, 0.12394791075644263, 0.14287989973957904, 0.12471311866474166, 0.12079929635196951, 0.2133956277206721, 0.06355383584355645, 0.1757973800890733, 0.08218803051199886, 0.027804929291185165, 0.03574876296255569, 0.06636357746141053, 0.07704076722373154, 0.001257963325370981, 9.999999999998899e-05, 0.07906486879848307, 0.1541445489149459, 0.13134923770966855, 0.2580267008111857, 0.22340587599705541, 0.04228426675939012, 0.0871364333526653, 0.18722729729483722, 0.4252844789454764, 0.052988610100583866, 0.0911398628811878, 0.11879128358404523, 0.25239097921950127, 0.08773731428235043, 0.0836976017354224, 0.10804570978840056, 0.09052336296307695, 0.1605008115663642, 0.27106710180250826, 0.26067086954630525, 0.2007938294705348, 0.13775051014999173, 0.10568965837370248, 0.16359226625960632, 0.16007441828131397, 0.15297911268857756, 0.2543425458962896, 0.6106678425533181, 0.5702726073903928, 0.5986445850034606, 0.5723409852812054, 0.5821842778607551, 0.556645183529523, 0.576555595450553, 0.5747433709033214, 0.5747975890495799, 0.1857047943975365, 0.13376396225998055, 0.1349770635802675, 0.13043781920456732, 0.1143383942094317, 0.11751832939355777, 0.14016248821341326, 0.11089975292109489, 0.09523817894138298, 0.16077739624828424, 0.18765406915515792, 0.23251861077092428, 0.15011142984687742, 0.24652168975007038, 0.22201164178996224, 0.1633051402558232, 0.2081864640654636, 0.1439008807871096, 0.40068820234716773, 0.37318960868014794, 0.4126657070977039, 0.3899295002950999, 0.4015308393792655, 0.40512818444365317, 0.41932474605247594, 0.40405137928000023, 0.3977348854821263, 0.23065010697614707, 0.35345501724307127, 0.3226439008339146, 0.30904403244173806, 0.30144365014919805, 0.3177479525255731, 0.33739431524388463, 0.3280972534290526, 0.3036316270034247, 0.21830793312635566, 0.2156898890324246, 0.20455493107383294, 0.21419878694551575, 0.20228839658222286, 0.2023698457754043, 0.20830115297811347, 0.2099207851157342, 0.21619114851833976, 0.21845558559562994, 0.2183498053162034, 0.2168454570108208, 0.3212650335539523, 0.2427583421857793, 0.19748009460591331, 0.2098886235687868, 0.1895781826289309, 0.19242499196771246, 0.16838780415071997, 0.17013350580147746, 0.8002077965150494, 0.7378093412269338, 0.19927082660497986, 0.7843984826384351, 0.7308482992804529, 0.1650833556676976, 0.7851960344211754, 0.7593523836185223, 0.47958900914908753, 0.7443769992991747, 0.7533286298292097, 0.16434115877160804, 0.7346465787651788, 0.1656000131166957, 0.189563530215483, 0.5838526266064391, 0.2079427166150244, 0.19288634571094243, 0.18216017711757526, 0.17614376126929454, 0.17745397507527394, 0.16951839400096214, 0.18148659783787047, 0.20626520646878832, 0.18355909750040322, 0.08976320722661513, 0.09158332629436916, 0.08824171694011895, 0.08529630904105523, 0.09617375522398341, 0.08719772994518848, 0.08861947879800902, 0.0956717653825041, 0.08586342329035201]}, "mutation_prompt": null}
{"id": "2b15ac65-10cd-4ba9-92a0-07525201a097", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n        # Dynamic population size adjustment based on fitness variance\n        variance = np.var(fitness)\n        if variance < 0.1:\n            self.pop_size = max(20, int(self.pop_size * 0.9))\n        elif variance > 1.0:\n            self.pop_size = min(100, int(self.pop_size * 1.1))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC_V2", "description": "Introduce a dynamic population size adjustment mechanism based on fitness variance to enhance convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {}, "mutation_prompt": null}
{"id": "73f39a31-6bbf-4239-be82-50aa4badb38c", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant = a + (self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor) * combined * improvement_factor\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < (self.crossover_probability + 0.1 * self.logistic_map())\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        offspring = np.where(cross_points, mutant, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n        \n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n        \n        return population[best_idx]", "name": "ChaoticHADE_RMC", "description": "Introduce chaotic perturbation in crossover probability to enhance diversity and exploration.", "configspace": "", "generation": 77, "fitness": 0.3241200695921305, "feedback": "The algorithm ChaoticHADE_RMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.7442744430407642, 0.7424098444969287, 0.7304225803978647, 0.7365042473956895, 0.7364932297347897, 0.7366934522034926, 0.7364105410761187, 0.7332499732245115, 0.7266597899458909, 0.5480390497185741, 0.5568514266165155, 0.5419621230036178, 0.5721028609920568, 0.5554133449439376, 0.6095387124704279, 0.579682987229873, 0.5842437757830402, 0.6094732291536189, 0.40501937480039085, 0.20429032573859107, 0.2085808256715157, 0.42339186316720023, 0.3349556561544198, 0.1853149001652934, 0.13373699329840782, 0.31964670502064796, 0.2616883407858417, 0.1265164829742238, 0.128717805786415, 0.14405446755334428, 0.11594895647610559, 0.10662454949190037, 0.12691810809725268, 0.1519341800098415, 0.18367044362739715, 0.13565144293461395, 0.9125814238621579, 0.9393231258908026, 0.8899050656004395, 0.9449573919044378, 0.9376259230934535, 0.93594797748346, 0.9455993874836658, 0.9633101342967875, 0.9423131934710495, 0.36683932958939014, 0.34588538218677845, 0.35040284530080434, 0.3537671910174135, 0.3342947203476978, 0.34007980262186643, 0.3476737385267751, 0.3358074531525743, 0.32194208934696555, 0.7363252239305804, 0.7068368921966169, 0.71506119423808, 0.7523358226310686, 0.7061773796905685, 0.7198124949438167, 0.701456617272703, 0.7117083468226619, 0.7019360639082818, 0.21409193944308114, 0.16427272770930246, 0.16821335966695183, 0.20843180526799765, 0.17982927857374964, 0.1582114097230256, 0.17014926159171861, 0.14052951390805046, 0.16411415976272437, 0.22183370856685503, 0.1901704636349716, 0.20812381844120575, 0.16509829348274396, 0.13132423219973333, 0.14971177036727057, 0.17556600934684796, 0.14558293383042487, 0.13146742445265336, 0.0324851603650268, 9.999999999998899e-05, 0.15668910806996517, 0.015712189765574425, 0.04444651153045287, 9.999999999998899e-05, 0.06821810244045978, 9.999999999998899e-05, 0.0697112513628213, 0.2108127526527338, 0.049311339125272524, 0.12697047433660413, 0.1153549896081495, 0.06767700356832262, 0.025696768703908357, 0.08756910239396343, 0.12107447675479965, 0.04044036232285764, 0.041249047007616224, 0.07175628469628281, 0.23594549920799068, 0.08421488516003395, 0.11921314178512743, 0.0776711288581271, 0.08982782208838858, 0.21154637785787278, 0.07505587178721729, 0.15970966734996417, 0.23397847124843507, 0.19711629974368894, 0.03778052437804402, 0.20933476921195682, 0.08142972408559968, 0.08836702996602486, 0.13944751292640944, 0.06892201316342816, 0.5974569123156145, 0.5886717821471519, 0.6183917145231623, 0.6154187572120893, 0.5632073416464833, 0.6073663316864868, 0.6159654621802033, 0.5921624108271202, 0.5963256719386646, 0.12299779637459163, 0.22114496032080166, 0.11660380651535196, 0.12173104596178541, 0.1483863789401776, 0.13116965139681902, 0.12778769339193974, 0.1378740409414333, 0.1373927121322278, 0.17072205530159823, 0.1517721350712069, 0.21704856004483564, 0.17212476476817395, 0.22291995469167036, 0.18429109341685057, 0.251822843898573, 0.19518835196928086, 0.20369221139503624, 0.38708937086770223, 0.4029094829413773, 0.40316798258205855, 0.39384799657415526, 0.39295387494891965, 0.40202456483957794, 0.40994047016245283, 0.41534973038491885, 0.4006036336283689, 0.3195580912216389, 0.3447167555344518, 0.35692785835980156, 0.31181438282025686, 0.3329460105884954, 0.31732197811767937, 0.3188089602814065, 0.3429554495164776, 0.3110591593104507, 0.2001364079696888, 0.2124793045947102, 0.21957121963477244, 0.20189102797885672, 0.20775601465559745, 0.20175009765344076, 0.2174070992741436, 0.21824051479197104, 0.2158384914594631, 0.19592960424270123, 0.18916603942444876, 0.21357568667189697, 0.22936398190016338, 0.2104906121160155, 0.23061823923965208, 0.20548191833657514, 0.20864058289787624, 0.19338390832797325, 0.18218817577551116, 0.18481053723000263, 0.7133521978819521, 0.7959620953146116, 0.34544629093088974, 0.7366101879162408, 0.7459200609386931, 0.1631566188331568, 0.8191097774851102, 0.5839932900381095, 0.16812467081534144, 0.723079667563514, 0.7348901357772042, 0.733950622680513, 0.1673136154057696, 0.16517718184248975, 0.15380402800217052, 0.6752295043828606, 0.19147644216564108, 0.19426564085341946, 0.18228458941558534, 0.19560942333093356, 0.18520848541923207, 0.18177455783168706, 0.1796539305837639, 0.1855407617442042, 0.18933795856829339, 0.08416260957941335, 0.08040071902160795, 0.0796243868862363, 0.09031356632456022, 0.08340572520897527, 0.09197385474774566, 0.09143791024429482, 0.09595106308076251, 0.09129078573577631]}, "mutation_prompt": null}
{"id": "88d08f25-cb9f-418b-bedf-6940cac7e649", "solution": "import numpy as np\n\nclass ChaoticHADE_RMC_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(100, self.budget // self.dim)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.logistic_map_r = 3.99\n        self.z = 0.7\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def logistic_map(self):\n        self.z = self.logistic_map_r * self.z * (1 - self.z)\n        return self.z\n\n    def mutate(self, population, best_idx, fitness, i):\n        fitness_scaled = 1.0 / (1.0 + fitness - np.min(fitness))\n        idxs = np.random.choice(self.pop_size, 3, replace=False, p=fitness_scaled/fitness_scaled.sum())\n        a, b, c = population[idxs]\n        best = population[best_idx]\n        adaptive_factor = 0.2 + 0.3 * self.logistic_map()\n        combined = (1 - adaptive_factor) * (b - c) + adaptive_factor * (best - a)\n        improvement_factor = np.exp(-(fitness[i] - np.min(fitness)) / np.abs(np.mean(fitness)))\n        sinusoidal_factor = 0.02 * np.sin(self.generation * np.pi / (self.budget / self.pop_size))\n        mutant_factor = self.mutation_factor + 0.02 * (self.generation / (self.budget / self.pop_size)) + sinusoidal_factor\n        mutant = a + mutant_factor * combined * improvement_factor * (0.9 + 0.1 * (np.std(fitness) / np.abs(np.mean(fitness))))\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_probability\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        diversity_factor = 0.5 + 0.5 * (np.std(target) / np.abs(np.mean(target)))\n        offspring = np.where(cross_points, mutant * diversity_factor, target)\n        return offspring\n\n    def adaptive_strategy(self, generation, fitness):\n        diversity = np.std(fitness) / np.abs(np.mean(fitness))\n        self.mutation_factor = 0.5 + (0.5 * np.cos(np.pi * generation / (self.budget / self.pop_size)) + diversity) * 0.8\n        self.crossover_probability = 0.4 + 0.6 * self.logistic_map()\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.pop_size\n        best_idx = np.argmin(fitness)\n\n        self.generation = 0\n        while evaluations < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, best_idx, fitness, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n\n            population = new_population\n            self.generation += 1\n            self.adaptive_strategy(self.generation, fitness)\n\n        return population[best_idx]", "name": "ChaoticHADE_RMC_Improved", "description": "Enhance mutation and crossover strategies using dynamic parameters based on generation count and population diversity metrics.", "configspace": "", "generation": 78, "fitness": 0.14954004522050443, "feedback": "The algorithm ChaoticHADE_RMC_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "f39e6747-6fd7-4a72-8934-d99a0dd2d3ff", "metadata": {"aucs": [0.2308801832686208, 0.19498166899558722, 0.22178933017298164, 0.28186811740621887, 0.18081329912016608, 0.266175888747044, 0.2990003603283158, 0.3164668898343125, 0.3237912203752574, 0.011527718042485646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0742683861505562, 0.06649278924034374, 0.09514054197023047, 0.06700911537757837, 0.04977792687158622, 0.03561151285996034, 0.051649146665832646, 0.060731441104443507, 0.043226747058702, 0.055586518758257264, 0.05733594374054152, 0.0640865221770579, 0.08282849296936379, 0.048815682135014304, 0.07550591704514886, 0.04549289048664962, 0.051561764484458594, 0.05378496191901472, 0.9800164241288123, 0.9898920444876156, 0.9737517507854989, 0.9786904377214064, 0.9626905768743964, 0.9803596146152252, 0.9903914727779352, 0.979824336093753, 0.9778833125699393, 0.10591309781402836, 0.05531765722633375, 0.06987034340630449, 0.09155924920520797, 0.07670372491114319, 0.08398792225129947, 0.05331519362870607, 0.04221915666303522, 0.07055464156674773, 0.28203389719433625, 0.5010696982454884, 0.27609894569153515, 0.13044949503976844, 0.1732405768080103, 0.20257166989327802, 0.1519583901838203, 0.19663465087274612, 0.18126811334164827, 0.11440211319390126, 0.07924478739138108, 0.08280861193522138, 0.07704499899286532, 0.10997323198739828, 0.06181835072957653, 0.022889814206838666, 0.015134247582025306, 0.041817777138261625, 0.056475023193348184, 0.011696414288638324, 0.03589920637027322, 0.09421078299589969, 0.036268257754924704, 0.07487973091292244, 9.999999999998899e-05, 0.030444931257327723, 0.000135042344411751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04235424692154177, 0.02313951833375627, 0.04248452108169731, 0.025946922846763476, 0.00546145934269171, 9.999999999998899e-05, 0.015327171941925788, 0.009710907686051207, 0.01713301382086685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015101143214441226, 9.999999999998899e-05, 0.007434859725436449, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04006644440550722, 0.027035038436477032, 0.0061406935019228115, 0.184789180261834, 0.19411565897787486, 0.22195034423765714, 0.21764890728176212, 0.2365356436159476, 0.2358743304971327, 0.29459873279867055, 0.23881745375866903, 0.25382114686788604, 0.08982782098251951, 0.08565982861898225, 0.09174084096835, 0.09779854440416968, 0.11785536854772605, 0.1002066523933639, 0.08334257404268486, 0.06679829297171114, 0.06853505788383174, 0.1507539339933297, 0.11746245588037041, 0.1213851831670063, 0.13766266535167793, 0.14717171983703048, 0.11876316031372791, 0.14202456507457994, 0.11700293641409731, 0.125130926154718, 0.1481825659931637, 0.13647290533146572, 0.1738668123254432, 0.19672066242474084, 0.18806328520044446, 0.18809903188930088, 0.18221064162509182, 0.17679665528143373, 0.18146412744026352, 0.11566027704603088, 0.10346393234677376, 0.15881787041869788, 0.13562837286286722, 0.14937074263850625, 0.13925080826284808, 0.13145489510293717, 0.10738321281343266, 0.14861241000090708, 0.16091357190258493, 0.15213310050403528, 0.15652906713233117, 0.16649597663248983, 0.1796398586882788, 0.16597730179374193, 0.2099653231120756, 0.16828510648444173, 0.17511567831133812, 0.16551690842190148, 0.16236057295301143, 0.1666224136262634, 0.16194759707295103, 0.17794126426684564, 0.15395051208551414, 0.17333634200871606, 0.17128191824763594, 0.1663673481140684, 0.35021941838890713, 0.20161226529565746, 0.25860131530658814, 0.16468610811536744, 0.1944771036276428, 0.17607188949178776, 0.2568815826481474, 0.14168875325618668, 0.14460282873966157, 0.432115772000652, 0.13999198951718683, 0.11918469610196969, 0.2786654052886688, 0.15728137091174865, 0.16169357738898216, 0.12323274454428124, 0.40380838762329163, 0.3741737364870179, 0.1776369844925586, 0.16603005550568628, 0.18656144143415088, 0.18633270229036958, 0.1815256618166644, 0.17684495186977678, 0.17410465601097969, 0.17270733969135343, 0.20527765064765802, 0.05527240825673785, 0.05228693206635193, 0.059553301647236934, 0.05408153437741092, 0.05217646254495523, 0.06776377775265319, 0.07255130573507884, 0.06610088382565482, 0.07153314243199871]}, "mutation_prompt": null}
