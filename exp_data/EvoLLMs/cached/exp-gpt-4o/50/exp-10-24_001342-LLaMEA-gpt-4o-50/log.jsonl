{"id": "7c939e4b-252b-448c-843f-654801f25134", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.temperatures = np.linspace(1.0, 0.01, budget)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, current_index):\n        idxs = [idx for idx in range(self.population_size) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        mutant_vector = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        crossover = np.random.rand(self.dim) < 0.9\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        return trial_vector\n\n    def simulated_annealing(self, trial, current_fitness, index, current_temp):\n        trial_fitness = func(trial)\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                current_temp = self.temperatures[evals]\n                trial_vector = self.differential_evolution(i)\n                self.simulated_annealing(trial_vector, self.fitness[i], i, current_temp)\n                evals += 1\n\n        return self.best_solution, self.best_fitness", "name": "HybridDE_SA", "description": "A novel hybrid metaheuristic that integrates adaptive differential evolution with simulated annealing for enhanced exploration and exploitation in continuous optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\n  File \"<string>\", line 33, in simulated_annealing\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\n  File \"<string>\", line 33, in simulated_annealing\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "c86061a3-27dd-4d3a-91ce-da7491e9b45c", "solution": "import numpy as np\n\nclass HybridDE_SA_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.99 * evals / self.budget)\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, func, current_index, evals):\n        idxs = [idx for idx in range(self.population.shape[0]) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        mutant_vector = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        crossover = np.random.rand(self.dim) < 0.9\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        \n        trial_fitness = func(trial_vector)\n        if trial_fitness < self.fitness[current_index]:\n            self.population[current_index] = trial_vector\n            self.fitness[current_index] = trial_fitness\n\n        if trial_fitness < self.best_fitness:\n            self.best_fitness = trial_fitness\n            self.best_solution = trial_vector.copy()\n\n    def simulated_annealing(self, func, index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        idxs = np.random.choice(range(self.dim), self.dim // 2, replace=False)\n        trial = self.population[index].copy()\n        trial[idxs] += np.random.uniform(-1, 1, size=idxs.shape)\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        \n        trial_fitness = func(trial)\n        current_fitness = self.fitness[index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def resize_population(self, evals):\n        if evals > self.budget * 0.5 and self.population.shape[0] > 10:\n            reduced_size = max(10, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population = self.population[:reduced_size]\n            self.fitness = self.fitness[:reduced_size]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.differential_evolution(func, i, evals)\n                self.simulated_annealing(func, i, evals)\n                evals += 1\n            self.resize_population(evals)\n\n        return self.best_solution, self.best_fitness", "name": "HybridDE_SA_Dynamic", "description": "An advanced hybrid algorithm combining adaptive differential evolution with simulated annealing and dynamic population resizing for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.20399245977993846, "feedback": "The algorithm HybridDE_SA_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "7c939e4b-252b-448c-843f-654801f25134", "metadata": {"aucs": [0.3038540034360162, 0.3291833099209718, 0.30516482218469365, 0.31815060567005427, 0.31266699095078143, 0.3308763768991081, 0.34523038746591206, 0.3316049094693201, 0.3088805845968826, 0.19904515042737214, 0.19289951047625942, 0.20935667676146852, 0.19383020070885204, 0.1907352872829371, 0.19747361383026396, 0.18324396637998785, 0.16519368909477616, 0.19677885888725155, 0.11791086866384792, 0.12168036288770401, 0.11302294613464459, 0.10516250595849685, 0.10582256283095126, 0.12276256275629749, 0.1249310730909241, 0.10139906209534422, 0.10962263707513831, 0.0916304640773935, 0.09781932475423927, 0.10116392908960659, 0.10022004944024321, 0.10092734136911863, 0.11342298922204685, 0.10277284940269915, 0.09187261757386345, 0.09206905812035382, 0.9477553866176499, 0.9204938679602259, 0.9208558812105587, 0.9481302949843928, 0.8756803966197361, 0.9537778457879073, 0.9261665399697129, 0.9272709739114348, 0.9583723773985848, 0.2034586884722156, 0.20369906366302903, 0.19315696566599694, 0.2263094011239486, 0.2050520340173979, 0.19417209397865554, 0.20389418549241234, 0.21178701980175496, 0.19040998321514768, 0.26080336780585, 0.245861989534516, 0.22759652004013997, 0.2575155716090086, 0.25663741467920453, 0.2633453103099819, 0.23267611178449132, 0.2564340919385142, 0.26532935893485654, 0.1378653225337555, 0.11349275270303028, 0.14898500241785928, 0.15669157514594878, 0.13797135020922924, 0.1298197047238644, 0.1368695603303367, 0.12526613736826764, 0.14469203393100272, 0.1704681830241972, 0.1603758945416961, 0.11068679649235258, 0.13207140262944872, 0.16474557921216437, 0.14790506746160004, 0.1438271886590632, 0.11935954049871655, 0.12370954133555967, 0.06681040806433158, 0.03339031569492201, 0.03349185648773201, 0.05097755714349261, 0.044816743191320896, 0.04485134320025186, 0.05780066657606131, 0.029623597434293658, 0.05255397418248031, 0.1727353352064087, 0.2150950943371801, 0.1646262612385765, 0.1774148396862718, 0.13868808579673553, 0.16431363357279716, 0.18368141046429187, 0.17391650008036452, 0.18826994503050276, 0.010275134640545414, 0.010920605257243365, 9.999999999998899e-05, 0.006440284198739765, 0.008492399491010105, 0.008277134547515885, 0.0036460303008499784, 0.006348389085394368, 0.001504879715745644, 0.1118457930027571, 0.13473735329977155, 0.10539761060623865, 0.11768868317386916, 0.11217705963177393, 0.11494333928056644, 0.12073514235676797, 0.11598587281120931, 0.12026989639895036, 0.28402075844517416, 0.3158039552219216, 0.2916191214622812, 0.29396447697248107, 0.31065998213432167, 0.3196941318066049, 0.3137430727369791, 0.30196340538135313, 0.28516364330724864, 0.09251302340182921, 0.08585443234197887, 0.09005354335271365, 0.10785486622581353, 0.07767996814847644, 0.08013114868340909, 0.09011982053084755, 0.08896637735408641, 0.08728815568593795, 0.15951600805670674, 0.18275981103675687, 0.16381276010402113, 0.17861610067314593, 0.17852217889495225, 0.16567658187278922, 0.17158264463958983, 0.1832145970487833, 0.18192217680538303, 0.22404821742612846, 0.20491782544561943, 0.216447409276879, 0.22551907092366552, 0.2104333848676777, 0.22704375783912734, 0.21810930653684357, 0.22918019693319003, 0.22928519051707263, 0.17973010652251742, 0.18178864966716213, 0.17863243704577558, 0.1728331004286614, 0.18654049848748055, 0.17820290797031235, 0.1973330847654432, 0.1771703234569144, 0.19780793368777505, 0.20463411373236418, 0.18833968166143, 0.17862120907271217, 0.20371740380031955, 0.20014180193562991, 0.22752239080841086, 0.17719520525548327, 0.19717837705237873, 0.1949657867421235, 0.20472886020608372, 0.17487018347513872, 0.1762652084097336, 0.19019841601652065, 0.178872583342223, 0.18663058692056622, 0.18484131851609098, 0.18123600701451692, 0.17645016693340476, 0.3055111424266004, 0.3483444473685898, 0.3611992375090972, 0.30459714135295846, 0.2840801714511578, 0.3351813514321529, 0.21523169385365404, 0.17673662230731557, 0.2608749265761189, 0.2675856285323369, 0.33852038789208927, 0.2994798415194848, 0.29901902500053446, 0.26957512099087255, 0.18980428629800006, 0.21444608799053433, 0.1987190665797668, 0.2550051892879722, 0.18373273868264128, 0.1748655312534242, 0.1772812161996531, 0.19738133476293374, 0.19346911941367884, 0.18722758634467795, 0.19785291152563245, 0.1798238234821874, 0.19754505835061065, 0.06950338146844681, 0.07220756461986, 0.0765254861517467, 0.07778755037970697, 0.07084589266215002, 0.0667583985749336, 0.0807878399411871, 0.10895512156794362, 0.06908924977889042]}, "mutation_prompt": null}
{"id": "22f9594f-3b72-4876-ba8b-c73c09f31ad1", "solution": "import numpy as np\n\nclass RefinedHybridDE_SA_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.98 * evals / self.budget)  # Increased cooling rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, func, current_index, evals):\n        idxs = [idx for idx in range(self.population.shape[0]) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.6 + 0.3 * np.random.rand()  # Adaptive mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        crossover_rate = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover rate\n        crossover = np.random.rand(self.dim) < crossover_rate\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        \n        trial_fitness = func(trial_vector)\n        if trial_fitness < self.fitness[current_index]:\n            self.population[current_index] = trial_vector\n            self.fitness[current_index] = trial_fitness\n\n        if trial_fitness < self.best_fitness:\n            self.best_fitness = trial_fitness\n            self.best_solution = trial_vector.copy()\n\n    def simulated_annealing(self, func, index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        idxs = np.random.choice(range(self.dim), (self.dim + 1) // 3, replace=False)  # More dimensions perturbed\n        trial = self.population[index].copy()\n        trial[idxs] += np.random.normal(0, 0.5, size=idxs.shape)  # Gaussian perturbation\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        \n        trial_fitness = func(trial)\n        current_fitness = self.fitness[index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def resize_population(self, evals):\n        if evals > self.budget * 0.4 and self.population.shape[0] > 10:  # Earlier reduction\n            reduced_size = max(10, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population = self.population[:reduced_size]\n            self.fitness = self.fitness[:reduced_size]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.differential_evolution(func, i, evals)\n                self.simulated_annealing(func, i, evals)\n                evals += 1\n            self.resize_population(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridDE_SA_Dynamic", "description": "A refined hybrid algorithm enhancing exploration and exploitation through adaptive mutation strategies, simulated annealing, and gradual dynamic population reduction for black box optimization.", "configspace": "", "generation": 2, "fitness": 0.20740317742903575, "feedback": "The algorithm RefinedHybridDE_SA_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "c86061a3-27dd-4d3a-91ce-da7491e9b45c", "metadata": {"aucs": [0.30747124899860523, 0.31216115945452017, 0.31736966346368756, 0.30994095532072774, 0.3091536634152898, 0.32146737773361655, 0.3182076731552046, 0.3298236097851782, 0.3219241572469941, 0.2322876123489227, 0.2301034638491849, 0.21045116415190857, 0.21114840285740744, 0.22361989490879197, 0.22131586073089027, 0.21975351462348713, 0.2345340328307196, 0.24606780204054501, 0.10897724657489793, 0.1121381716844535, 0.10178425098221255, 0.1085921369760261, 0.11718069519533036, 0.10362708228356732, 0.10667833465214904, 0.1229727415681735, 0.11759435045333011, 0.1066868254613329, 0.09162144401921146, 0.10251406451206568, 0.09700164520213184, 0.09948937041526229, 0.10280818851863183, 0.1066108252290493, 0.11037741657987132, 0.09604643914409716, 0.9112985137063865, 0.9102419009581691, 0.9451911719581388, 0.9577965248839623, 0.9546429218646978, 0.8704590128197147, 0.923911833331403, 0.9206595343192236, 0.9839602140550378, 0.2098086957394426, 0.19907886105028394, 0.20250319189836463, 0.20058173043746408, 0.19951063772088262, 0.1994761628577345, 0.21731653636213144, 0.23134083895816948, 0.2140642204415698, 0.27731102758385073, 0.264346512373573, 0.25834346223985005, 0.284629076728945, 0.29328254722249114, 0.26421881923403934, 0.2607562357458162, 0.252740695052857, 0.27708894654856564, 0.16660625391675843, 0.13230939784244677, 0.15312214808246494, 0.12595202223558388, 0.1357884479064564, 0.15995364530765765, 0.14782567839613203, 0.15883094072877724, 0.14844715154674903, 0.1059152718656785, 0.12104345873658895, 0.13910589437501453, 0.13722465606307233, 0.13508222336968978, 0.15695603828211102, 0.16540054418152172, 0.14614422194935217, 0.1356686159398336, 0.05203649198821947, 0.026766249945051057, 0.041483508481586995, 0.04611750192442399, 0.06231982230873523, 0.03787991590048023, 0.06528560638826397, 0.06486257117822047, 0.039940544338284645, 0.15111001500014065, 0.1881163121826277, 0.16844836466558388, 0.14575990482604906, 0.14162282239436086, 0.16283393581631722, 0.1815288884903863, 0.2052433558391472, 0.16505803541345454, 0.01079790499732558, 0.002887706494154374, 0.004404437249901694, 0.0018274250171700368, 0.0005977665128642506, 0.0009602007955329395, 0.004345026087961168, 0.010705545097258629, 0.0012429625802886646, 0.1184829940211084, 0.10873384298279976, 0.09456063538238701, 0.1097988239169152, 0.11351896474050915, 0.1061638419588089, 0.10869928951072694, 0.1099413286607187, 0.10952874818072178, 0.2910710201853086, 0.30332446380230893, 0.30448344479284883, 0.3126056356589887, 0.30088044220701415, 0.3120111898546015, 0.3267778388030165, 0.3080203721638419, 0.30929188252923256, 0.09870306865053025, 0.09406516863048242, 0.09441314125240663, 0.10383737230620571, 0.08482615888516176, 0.08790863813550098, 0.08304139263395938, 0.08884437458865213, 0.09409823048170252, 0.1691590650437632, 0.16709573323334737, 0.173244238463637, 0.22433975288570118, 0.17724327118701788, 0.1751231558009354, 0.1894066610875581, 0.1662571999389445, 0.16259730474023248, 0.23113837224409595, 0.21633141739008976, 0.22608794361489482, 0.22716215922279048, 0.22399016886443912, 0.22667628839402998, 0.21432769082347614, 0.24260289465187657, 0.22265117603250772, 0.17293463363635275, 0.18948385777550725, 0.17836082928724573, 0.16589420436678537, 0.18540301959892735, 0.17499423858859953, 0.18246860135677556, 0.19630728597362712, 0.18434628302061218, 0.17381990699889416, 0.17911075199723658, 0.18348370074379838, 0.18503942175930765, 0.18495848100231482, 0.19717790676744662, 0.19635430257252617, 0.1868562809562352, 0.19292901924718664, 0.18262776776096146, 0.1813855496961434, 0.191607191843299, 0.1922703046577432, 0.19080152279252682, 0.1774693349431562, 0.17999159630991612, 0.19270548629826445, 0.18970683762723373, 0.2915800199709835, 0.19352299885244695, 0.3598988199886789, 0.18626675837811113, 0.31782446827013267, 0.34601458597313195, 0.283977293399331, 0.29156928370900126, 0.332622618768466, 0.3634667404715006, 0.31138600270868155, 0.3321575871296748, 0.31186944303191744, 0.2044216641110833, 0.28962377107005544, 0.20881149625062345, 0.37674839812588456, 0.2002630115604216, 0.1759781260902913, 0.19592580231650447, 0.18089902179103778, 0.1931088608752881, 0.19199193365564693, 0.1830185505199472, 0.19210056570341327, 0.1866497064147037, 0.1983766732400848, 0.06483103792816014, 0.08648617895505173, 0.07348977079581875, 0.08155043925789451, 0.07393046473528353, 0.07146329228543313, 0.07419128262194119, 0.07001670149625838, 0.07187609300449438]}, "mutation_prompt": null}
{"id": "b717e3e4-2df3-45d7-92de-55c59a5ba098", "solution": "import numpy as np\n\nclass AdvancedHybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Slightly larger initial population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.95 * evals / self.budget)  # More gradual cooling\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, func, current_index, evals):\n        idxs = [idx for idx in range(self.population.shape[0]) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + 0.2 * np.random.rand()  # Slightly reduced mutation factor variance\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        crossover_rate = 0.9  # Fixed higher crossover rate\n        crossover = np.random.rand(self.dim) < crossover_rate\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        \n        trial_fitness = func(trial_vector)\n        if trial_fitness < self.fitness[current_index]:\n            self.population[current_index] = trial_vector\n            self.fitness[current_index] = trial_fitness\n\n        if trial_fitness < self.best_fitness:\n            self.best_fitness = trial_fitness\n            self.best_solution = trial_vector.copy()\n\n    def simulated_annealing(self, func, index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        idxs = np.random.choice(range(self.dim), (self.dim // 2), replace=False)  # More dimensions perturbed\n        trial = self.population[index].copy()\n        trial[idxs] += np.random.normal(0, 0.3, size=idxs.shape)  # Reduced perturbation scale\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        \n        trial_fitness = func(trial)\n        current_fitness = self.fitness[index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def resize_population(self, evals):\n        if evals > self.budget * 0.3 and self.population.shape[0] > 15:  # Earlier and more drastic reduction\n            reduced_size = max(15, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population = self.population[:reduced_size]\n            self.fitness = self.fitness[:reduced_size]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.differential_evolution(func, i, evals)\n                self.simulated_annealing(func, i, evals)\n                evals += 1\n            self.resize_population(evals)\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedHybridDE_SA_Adaptive", "description": "An advanced hybrid algorithm combining adaptive mutation, enhanced annealing, and adaptive population dynamics for efficient black box optimization.", "configspace": "", "generation": 3, "fitness": 0.2253802476735729, "feedback": "The algorithm AdvancedHybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "22f9594f-3b72-4876-ba8b-c73c09f31ad1", "metadata": {"aucs": [0.3352525081420208, 0.33877875763757925, 0.31646646156067404, 0.35444515322545667, 0.3804147414061603, 0.35857372196133175, 0.3653085036910497, 0.35353011176474847, 0.32523398079377785, 0.30632086062879793, 0.276824424562218, 0.2938686421118355, 0.2668268192506613, 0.26310656204958094, 0.27553887034509084, 0.2801286609551694, 0.2732069700127666, 0.27179583549494424, 0.13175793905216449, 0.10148343258182901, 0.11054321630472319, 0.10487829263430926, 0.10920021332598828, 0.1139732871986977, 0.1117523739449302, 0.11584297964789603, 0.1188393241064385, 0.10818389761011804, 0.0997932722013104, 0.10394005541275897, 0.11908883394478509, 0.08929385652616217, 0.10467340892020816, 0.09127919450562605, 0.10595969130147809, 0.09496064143769056, 0.8464295219400452, 0.8462974223331595, 0.8507607373170278, 0.839770063630563, 0.9199842888329901, 0.8796302441404469, 0.8576438660802873, 0.9494197060030807, 0.9145198855074705, 0.23244022895072625, 0.2138527997608498, 0.21765190202173557, 0.2490388877341324, 0.2216765755351754, 0.22384337544280508, 0.23750826697138894, 0.23853699573571907, 0.2451904221016744, 0.3136313075705649, 0.30971615769865135, 0.286694576081876, 0.2894559131084462, 0.3108903592889435, 0.31231914063800204, 0.2804052447975719, 0.29125291730292, 0.2853893216035006, 0.18892609743689914, 0.1574046993061956, 0.14721457092724854, 0.15076125160221598, 0.1588903787685445, 0.1397722363238041, 0.1944445027572913, 0.16541605106169732, 0.18695833276957963, 0.18832540243160756, 0.1326613719124925, 0.15512117739957687, 0.14607083607816873, 0.1666335337073397, 0.18513550880852758, 0.1799011925473909, 0.1610892592276889, 0.15893280429920997, 0.124016157698294, 0.09292494066842683, 0.09669860096881788, 0.08067251096011163, 0.11812405363311085, 0.10180003090438428, 0.13545317583562533, 0.11873486541913625, 0.12864077577294863, 0.25519910475447505, 0.2134890198636764, 0.2805185434207469, 0.22995458004319358, 0.2460923405297164, 0.22621328784591344, 0.25251647476176053, 0.24230911100348806, 0.27551152718244354, 0.0259526513051187, 0.025106249531753222, 0.017077179078227145, 0.02946295091178186, 0.01750415579063125, 0.017030784060016013, 0.026594536672419955, 0.03111072449622243, 0.048367659300160404, 0.1492836557631837, 0.14446314187088405, 0.13653868075898246, 0.14540141985553778, 0.15191130614679627, 0.15276994227795637, 0.14506389908910355, 0.15090716870650955, 0.14286544518564748, 0.32581435875425124, 0.3158149390505175, 0.3257514997141686, 0.3411884330105127, 0.314448287466214, 0.3245688906752253, 0.3237337772939525, 0.30557684612232283, 0.32397001145642657, 0.10580149124153726, 0.09402342093149496, 0.09393056192666749, 0.09700870017125363, 0.10396323280552333, 0.09586209578935723, 0.08982959087503639, 0.09563405418836424, 0.11607903521061491, 0.21437241811018426, 0.2137333285347679, 0.17735723886154298, 0.22598303797712105, 0.1744603180167289, 0.17822353349740638, 0.17270510793098148, 0.1940486719941611, 0.16569117885340634, 0.23724749286331293, 0.23003918592334516, 0.23473684188297295, 0.2252034837510195, 0.233581285840202, 0.23841118426036123, 0.24410950039543444, 0.23849697137164738, 0.23517225453954949, 0.20158672896673502, 0.189433504063929, 0.2016022699290384, 0.19628390884270774, 0.1837402215097521, 0.19242917219445987, 0.21143025185546926, 0.2135436873759936, 0.20342092350418584, 0.20582938255285876, 0.1877893112937601, 0.18789761548176387, 0.19508856863628588, 0.20131276441135748, 0.18246685017057152, 0.18403689992790329, 0.1944064407751086, 0.18274656572210302, 0.1886467616086538, 0.19852053391652225, 0.18028052125668315, 0.19027245244344937, 0.19160597434580173, 0.18599485628934587, 0.19094574241954698, 0.18481828133003164, 0.18311506270818823, 0.2905291430936723, 0.3796510746516396, 0.2809447394567476, 0.3419670667590671, 0.2198294866064372, 0.23110508914785255, 0.31331736773975805, 0.33101256903842313, 0.3220888274282857, 0.4172441110505515, 0.40959784962182466, 0.3464659949972586, 0.31599202977410246, 0.25870430760188423, 0.23432638451358678, 0.34835097696475414, 0.3135705469620239, 0.20113059226729924, 0.18918495009964587, 0.18733680313765022, 0.18910394578802248, 0.1862131343648804, 0.1943433784640164, 0.18603119902418253, 0.18223004038214452, 0.18706600689055808, 0.17379266066590482, 0.07561253103381937, 0.07794708170826725, 0.06425449719581156, 0.06826091749533025, 0.07314235152095139, 0.0694184668922515, 0.072643625740057, 0.07078026631927148, 0.06817048446060925]}, "mutation_prompt": null}
{"id": "72df7b52-19f0-4371-b8bd-96e86c2f25c0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Slightly smaller initial population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Slightly faster cooling\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, func, current_index, evals):\n        idxs = [idx for idx in range(self.population.shape[0]) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.6 + 0.1 * np.random.rand()  # Reduced mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        crossover_rate = 0.8  # Adjusted crossover rate\n        crossover = np.random.rand(self.dim) < crossover_rate\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        \n        trial_fitness = func(trial_vector)\n        if trial_fitness < self.fitness[current_index]:\n            self.population[current_index] = trial_vector\n            self.fitness[current_index] = trial_fitness\n\n        if trial_fitness < self.best_fitness:\n            self.best_fitness = trial_fitness\n            self.best_solution = trial_vector.copy()\n\n    def simulated_annealing(self, func, index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        idxs = np.random.choice(range(self.dim), (self.dim // 3), replace=False)  # Fewer dimensions perturbed\n        trial = self.population[index].copy()\n        trial[idxs] += np.random.normal(0, 0.2, size=idxs.shape)  # Further reduced perturbation scale\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        \n        trial_fitness = func(trial)\n        current_fitness = self.fitness[index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def resize_population(self, evals):\n        if evals > self.budget * 0.25 and self.population.shape[0] > 20:  # Earlier and more gradual reduction\n            reduced_size = max(20, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population = self.population[:reduced_size]\n            self.fitness = self.fitness[:reduced_size]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.differential_evolution(func, i, evals)\n                self.simulated_annealing(func, i, evals)\n                evals += 1\n            self.resize_population(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveHybrid", "description": "An enhanced adaptive hybrid algorithm that integrates stochastic selection, dynamic perturbation, and gradual adaptation for effective black box optimization.", "configspace": "", "generation": 4, "fitness": 0.21519161620851424, "feedback": "The algorithm EnhancedAdaptiveHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_id": "b717e3e4-2df3-45d7-92de-55c59a5ba098", "metadata": {"aucs": [0.3641102089385012, 0.35093539466190116, 0.3465699845943391, 0.3568629819036311, 0.3597454560946104, 0.37334357344777314, 0.35839838973803295, 0.38034438289221617, 0.3910909107667363, 0.23252069490766702, 0.2576337902959205, 0.25528718475050316, 0.23993709955090559, 0.2614435237109479, 0.23332981887324455, 0.25312666453462074, 0.2615347900677717, 0.24651260913297068, 0.11757286215869556, 0.13544161974628732, 0.1366082765208395, 0.11209951083318137, 0.12176410445908536, 0.14305702208646176, 0.13700172359351326, 0.12801447101825236, 0.1188220697790795, 0.11065533976591668, 0.12622280222082571, 0.11022255717034057, 0.10920988116914743, 0.1294267031877554, 0.11472249691439251, 0.12192202983412115, 0.10650777942986711, 0.11042615979445292, 0.9181689810369439, 0.8732113350994772, 0.8800218571169083, 0.9264801723676936, 0.8517831114384719, 0.9142704580551981, 0.8927481807376942, 0.8717422284215022, 0.9055766727125178, 0.21116003030428276, 0.2106003210574815, 0.19797185336268586, 0.2050384055536567, 0.2071557978336377, 0.20622594668966, 0.21978576763822544, 0.21301308129895447, 0.22224303393051414, 0.3113796557193943, 0.2673000894840548, 0.25048779772797103, 0.28849665245181766, 0.27713151202706765, 0.2563343453901169, 0.27998745868488084, 0.2735925970995702, 0.26714681070781054, 0.17497254752693303, 0.1507846121374179, 0.19592312616526575, 0.15821454797942947, 0.15039285556076432, 0.1727388941182053, 0.16484631151372175, 0.17950402619199135, 0.15838654598072777, 0.14799192673004868, 0.14243018931052398, 0.12750437288039662, 0.17823695024370412, 0.16945646056845032, 0.15805110792819432, 0.1575499810020956, 0.15521986523827092, 0.16487760489666636, 0.06026197884595441, 0.06819303202032567, 0.05392248791727994, 0.06145551050345899, 0.0634475410452735, 0.056494419229487725, 0.0752055236430168, 0.08062565303545488, 0.0702806232328328, 0.16645465730972087, 0.18704972100881545, 0.20862213103100635, 0.16339282771972974, 0.1820252144471396, 0.17746254632161584, 0.1986796720605314, 0.21527025821023948, 0.1789190707155316, 0.02393290545574056, 0.013914910624073906, 0.012407127527599315, 0.03316576805232185, 0.03565134521031543, 0.026887097169170704, 0.02647625992531344, 0.02017267443118531, 0.016419188077803626, 0.1363536030065139, 0.11023874002606426, 0.12974633276530623, 0.1342382601184332, 0.13138816674063603, 0.13186886157260835, 0.11835877230132752, 0.12147085183825024, 0.13470940139747767, 0.32830492961685853, 0.33366906867376356, 0.36489232446349573, 0.347387811198562, 0.3366099606484393, 0.3405207873199604, 0.3448336763193044, 0.3296023702957277, 0.3232936153877769, 0.11878955793258561, 0.1081641679433436, 0.10905610306168256, 0.09731800356570675, 0.09411502347427503, 0.10226227551029587, 0.11362536381534505, 0.09889539302456318, 0.11116068833832582, 0.18963810515487545, 0.17849490034122228, 0.1619339831811829, 0.18232052278426225, 0.184166823031926, 0.1589393091748732, 0.17455503896222002, 0.1707678634249702, 0.21366815051883892, 0.24640114633446986, 0.2450713152154005, 0.2460839965020052, 0.2352852059303301, 0.2354112227024029, 0.24138699736771008, 0.24918812678494118, 0.2582999806651255, 0.25137197903848163, 0.1996080681221164, 0.19391104750110477, 0.1810606965899687, 0.19278722400292936, 0.17797531264791977, 0.18275709843339027, 0.19248875360065543, 0.19686523775999065, 0.190949040206838, 0.19848720362338768, 0.17734836190392889, 0.2034977433348768, 0.18692893197396365, 0.19984335510188123, 0.23380384155434686, 0.19966657837706003, 0.19416428356680826, 0.2165188188985473, 0.19048597797367461, 0.19159967415197487, 0.1983638377889656, 0.18350096554941187, 0.18526881105611515, 0.19186941208203023, 0.18214336295123779, 0.1876064018377498, 0.18798154550082768, 0.262005325322867, 0.1621017045383658, 0.2654642914654768, 0.3050106033026816, 0.17034189762724017, 0.3109332193109662, 0.20012606304236102, 0.17135652341134333, 0.16444210834692463, 0.2636262514535098, 0.1841987880052689, 0.3263884625344198, 0.3064741114576409, 0.17916198629630198, 0.2708647356809851, 0.20296360164798444, 0.3588062645435224, 0.20093675134784694, 0.18600569163582747, 0.18694546095641695, 0.20452910121110313, 0.19082558707361008, 0.19613262166393275, 0.1881528919345289, 0.19658144918689002, 0.20725552638706535, 0.2026021008958857, 0.07529432843042227, 0.0785350778966476, 0.0841388717370799, 0.08940008987356252, 0.09069318088768508, 0.0759178231248887, 0.08674218585658888, 0.07325179676844906, 0.07649116938277056]}, "mutation_prompt": null}
{"id": "99de2142-46a2-4681-a204-dcc3c8a69011", "solution": "import numpy as np\n\nclass RefinedHybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Moderately sized initial population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def differential_evolution(self, func, current_index, evals):\n        idxs = [idx for idx in range(self.population.shape[0]) if idx != current_index]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.3 + 0.4 * np.random.rand()  # Narrower mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        crossover_rate = 0.85  # Slightly reduced crossover rate\n        crossover = np.random.rand(self.dim) < crossover_rate\n        trial_vector = np.where(crossover, mutant_vector, self.population[current_index])\n        \n        trial_fitness = func(trial_vector)\n        if trial_fitness < self.fitness[current_index]:\n            self.population[current_index] = trial_vector\n            self.fitness[current_index] = trial_fitness\n\n        if trial_fitness < self.best_fitness:\n            self.best_fitness = trial_fitness\n            self.best_solution = trial_vector.copy()\n\n    def simulated_annealing(self, func, index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        idxs = np.random.choice(range(self.dim), (self.dim // 3), replace=False)  # Fewer dimensions perturbed\n        trial = self.population[index].copy()\n        trial[idxs] += np.random.normal(0, 0.2, size=idxs.shape)  # Slightly reduced perturbation scale\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        \n        trial_fitness = func(trial)\n        current_fitness = self.fitness[index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[index] = trial\n            self.fitness[index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def resize_population(self, evals):\n        if evals > self.budget * 0.4 and self.population.shape[0] > 20:  # Adjusted timing and size for reduction\n            reduced_size = max(20, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population = self.population[:reduced_size]\n            self.fitness = self.fitness[:reduced_size]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.differential_evolution(func, i, evals)\n                self.simulated_annealing(func, i, evals)\n                evals += 1\n            self.resize_population(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridDE_SA_Adaptive", "description": "A refined hybrid algorithm merging adaptive mutation, advanced annealing, and dynamic population scaling for effective black box optimization.", "configspace": "", "generation": 5, "fitness": 0.2453998945661569, "feedback": "The algorithm RefinedHybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.16.", "error": "", "parent_id": "b717e3e4-2df3-45d7-92de-55c59a5ba098", "metadata": {"aucs": [0.3863595717066449, 0.4013876984310881, 0.3710244683374416, 0.4171926256388053, 0.4147379881825919, 0.3923491425936195, 0.3815719981000668, 0.3898818766526174, 0.3732283140080451, 0.3222860484549396, 0.3092691108091533, 0.31195519440206243, 0.28756364770089593, 0.2965995990799174, 0.30179156904019533, 0.30224649204712317, 0.31199105571478747, 0.28088621474365083, 0.14775692816402497, 0.13001665857790445, 0.12993396433473514, 0.1318641878477036, 0.13532623872551508, 0.14321757779672173, 0.13560530216411482, 0.1362476627210899, 0.12928745884916337, 0.11765887354980809, 0.11525749965913257, 0.13517624833853847, 0.11625002348384095, 0.11915718308909395, 0.11533375918262212, 0.1213358245545314, 0.12898793324387947, 0.10279033332367393, 0.9085841065638538, 0.8686535860923, 0.8633594776793895, 0.8915168176720479, 0.8267995234443803, 0.8773040558941992, 0.9142129377173522, 0.8428841803432661, 0.849698015700989, 0.2728747203075417, 0.26741310138491503, 0.2509588347492173, 0.2742277743424908, 0.2376878169564104, 0.26842946099542386, 0.2573149287070907, 0.23624692894389399, 0.273320568084782, 0.3202291248578314, 0.2894668628686614, 0.3189211455277082, 0.3299872170504593, 0.31683829484946824, 0.3229355317409187, 0.31413294625035815, 0.30552184058974785, 0.3919782826240483, 0.20962314523651315, 0.17257782181313086, 0.15427578924348107, 0.18144525351514118, 0.20002939831051658, 0.19849739492175655, 0.17210914844947733, 0.18507422033773446, 0.14878739412927955, 0.16113400873999162, 0.15111791296430144, 0.17699632911485097, 0.20122716007121444, 0.20629280988001364, 0.18106294539108592, 0.2039837584962083, 0.16740071021277958, 0.1781726988784187, 0.1523949159868987, 0.16571346587908398, 0.16200564711381105, 0.15341568005188344, 0.15698303817380344, 0.10739266946234327, 0.15849218901175877, 0.13891767475791184, 0.15244533170226604, 0.27471054689441987, 0.26145103436149675, 0.28446156503192765, 0.256292912012112, 0.2794249737718225, 0.27393168988762295, 0.29012889302195943, 0.27944126287464055, 0.2595187225705399, 0.07201706453184431, 0.054664860457611764, 0.08460600897629722, 0.07777386774257034, 0.08270156030918552, 0.07565569396323013, 0.05140573149530914, 0.05202706477011021, 0.045121767346175345, 0.18296441468691027, 0.1616538143835312, 0.17163148092707925, 0.15213581896241135, 0.1837101026072958, 0.18083161613322818, 0.1771893832959318, 0.17592826741409007, 0.18030844312488115, 0.3708994624504559, 0.3676870105445067, 0.3712245453945745, 0.36906041058838934, 0.3660243230695218, 0.3682643787853903, 0.3757148230329752, 0.3521664735344012, 0.37411097388624837, 0.11559404570931253, 0.10892656451460958, 0.1232738353363857, 0.1273726594786635, 0.12972707748120083, 0.10879114993821914, 0.13939360826350877, 0.11687603908509503, 0.1173259933596017, 0.18225672253458847, 0.16615087922508298, 0.1690215963289402, 0.2084515856758209, 0.17409753028057073, 0.17525157921945234, 0.1817915549877137, 0.19336556209153088, 0.16000136611460525, 0.25486071575270675, 0.2688547864999751, 0.2661822249053122, 0.2711426208066524, 0.25627687880513894, 0.25542293806488725, 0.2744793048196713, 0.2704003678818423, 0.2633133660957453, 0.2085793339669284, 0.2017422734366603, 0.20236836361464972, 0.20494417421944044, 0.21627786769551471, 0.20876244834511226, 0.22014725839219085, 0.24124592296033387, 0.21782410764452664, 0.19560769394359334, 0.20041167648010605, 0.22025899770504598, 0.20544873276574882, 0.20288431687667863, 0.20830849923298045, 0.20133582208370537, 0.2181258300940584, 0.2497635954103543, 0.17844521138020408, 0.2365139471409332, 0.19646347183009838, 0.18609366699474317, 0.19508400024995076, 0.1795679673303242, 0.18709517861600167, 0.21576462676678398, 0.19171832076266326, 0.32024551105763477, 0.43834289252719205, 0.4783659754209846, 0.4114452985415228, 0.1976089356759151, 0.4594290577288016, 0.3640990043014354, 0.18093643255364533, 0.3097391915964838, 0.3370322881229647, 0.20168743578942783, 0.4546175156598442, 0.21441800457965943, 0.36873659732768727, 0.21931819553939336, 0.19768028727253273, 0.3157226524106329, 0.20250477966138625, 0.20002727626906325, 0.2050235087237935, 0.1818104121993439, 0.1958739180555361, 0.19532293792080868, 0.18891181518229105, 0.1904615610967153, 0.19674563076482177, 0.1899304578794958, 0.09620210227976145, 0.08086559025535933, 0.0913566477629536, 0.07973402753182912, 0.08823748798770781, 0.08189020239093625, 0.07402488946432184, 0.0749276870224811, 0.08428132866452054]}, "mutation_prompt": null}
{"id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 6, "fitness": 0.2832210278695564, "feedback": "The algorithm NovelHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.16.", "error": "", "parent_id": "99de2142-46a2-4681-a204-dcc3c8a69011", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "50334249-863b-428b-9daa-e673031a2ae1", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "d58324ad-a487-4dc8-8e5d-79f1a5570e69", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "51e6a70f-f3a5-4e1e-a639-6ce5cdbbc736", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "51094c8c-1ea2-43a4-aa1e-e62ce4a267fa", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Diversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.diversity_threshold = 0.1  # Diversity threshold for rejuvenation\n    \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.3, 0.7)  # Altered beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def maintain_diversity(self):\n        if np.std(self.population, axis=0).mean() < self.diversity_threshold:\n            rejuvenation_factor = np.random.uniform(0.8, 1.2)\n            self.population += rejuvenation_factor * np.random.normal(0, 0.1, self.population.shape)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n            self.fitness.fill(np.inf)  # Re-evaluate all individuals\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n            self.maintain_diversity()  # Invoke diversity maintenance\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Diversity", "description": "An enhanced hybrid algorithm incorporating adaptive chaotic mutation, stochastic tunneling, and dynamic population scaling with diversity maintenance for robust black box optimization.", "configspace": "", "generation": 10, "fitness": 0.20390058025932542, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Diversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35129888621098126, 0.3425062658152854, 0.3436543472364436, 0.33537774495322636, 0.24656075445336123, 0.37784639247079876, 0.2645365342333136, 0.36544624921476665, 0.255774813398572, 0.03196114091775237, 0.09577600414234477, 0.029163174617875653, 0.058711225261878996, 0.12101074383886845, 0.05773634708348874, 0.018412557501816473, 0.0530463903213475, 9.999999999998899e-05, 0.10988884858745784, 0.13190669924825793, 0.11831359337845193, 0.06688478526559904, 0.12182790701400203, 0.1269816047923198, 0.10134201925157926, 0.10031292530643499, 0.09526402210169527, 0.1035302345401633, 0.07549979783864069, 0.05204878772867083, 0.10508376809212627, 0.04101597831245396, 0.08200031317037626, 0.11101168598173083, 0.09488799208854592, 0.09644705146431898, 0.6533972829069874, 0.7595950318177771, 0.5126313543907814, 0.5058565659369225, 0.6123567729725898, 0.7753483239218019, 0.7533593882412053, 0.7105191030169156, 0.6175022304745978, 0.22832170587755074, 0.10517953362375099, 0.18775337363254174, 0.2501935055346737, 0.22731090099308693, 0.23287275984556888, 0.2179633551555964, 0.20833616424391344, 0.26881930701737966, 0.23985914723597423, 0.729073594106618, 0.1542431709791101, 0.35307736799481404, 0.2953555904430092, 0.29084146687989565, 0.1931286848630489, 0.28421045810431844, 0.5250084508190078, 0.1862905599432263, 0.12848992819478133, 0.14701750427733673, 0.22346494080883605, 0.18393568922713077, 0.13845749211379388, 0.17433712895251374, 0.11317111930527868, 0.1865261766394669, 0.16602113490714654, 0.177376102402532, 0.2166147488039606, 0.16239988119430948, 0.17272995485440112, 0.16046343867413393, 0.17064410805147834, 0.127314687187279, 0.11946677754677004, 0.012201782715996368, 0.04611994646858242, 9.999999999998899e-05, 0.018697783887028474, 0.06411643236135167, 0.11331852569855705, 0.018862339799863403, 9.999999999998899e-05, 0.06679483331866709, 0.21710017216199184, 0.25031003340394387, 0.3078159032828929, 0.25203096885058307, 0.24310393826402077, 0.30386016977723973, 0.1083394120067227, 0.18505155641450843, 0.2132838329352501, 0.0018705842772931414, 0.005950586866776408, 9.999999999998899e-05, 0.0404349367121315, 0.029686245203637607, 9.999999999998899e-05, 0.013821069905612382, 0.005961599987483357, 0.005968363120006481, 0.09552277248470487, 0.10153519986853732, 0.12774928242733818, 0.060584718828566975, 0.13823585144623285, 0.10234901603897995, 0.12114671726940518, 0.0875732423043899, 0.10906615387981689, 0.35577063002294773, 0.28383041420106625, 0.24528968384626426, 0.3090559807253076, 0.33049976724484387, 0.3844777986100023, 0.3504683557341075, 0.3387394563852446, 0.39992184461693703, 0.11422329835762612, 0.0572110304867367, 0.1571205013990984, 0.10563052134889805, 0.12237973449949857, 0.1100578798845947, 0.13186188478774452, 0.1459650981251963, 0.10207486781210395, 0.2569894643746966, 0.28943645780252214, 0.2144108484963635, 0.2662100136429756, 0.271592066918917, 0.23972459998434104, 0.17805316989494624, 0.16036312199455938, 0.20463460472955963, 0.2843658442405109, 0.265826978945477, 0.2805117584621658, 0.28169121368550165, 0.2628205357156945, 0.28266706599469293, 0.2990352132093903, 0.28441709162388407, 0.2109662048024218, 0.2497152648824772, 0.24261945354528858, 0.16332293964188338, 0.18278557997253309, 0.24322703782008426, 0.22103623929003546, 0.24510581947997778, 0.2569751532740119, 0.221057631204303, 0.25649377934269546, 0.205068896310598, 0.24944941572303692, 0.26711039614933463, 0.23333797604200113, 0.22475361864586907, 0.22825625681908646, 0.27146418058932265, 0.2761022399320896, 0.18945031570175053, 0.20555526401976387, 0.18674083438652822, 0.2058002919204106, 0.23530986688349254, 0.18832421562258927, 0.18764984041890453, 0.2064042245172557, 0.20299237622753563, 0.16685517230720814, 0.31624160043001026, 0.16558873752300496, 0.1698701986173239, 0.195953001152545, 0.16965510592601007, 0.1421573874911224, 0.16390444744062993, 0.41583912703044557, 0.4394829492923287, 0.20596318101602973, 0.2403350872057165, 0.36615096515514656, 0.15903401382950033, 0.16751789525570382, 0.11069745240247708, 0.20428796290223272, 0.4835038054534434, 0.19283300973823847, 0.21872858706856746, 0.22235632794677862, 0.21553120646933777, 0.21325189090996832, 0.21047394634333105, 0.19939213620062113, 0.20160609935853757, 0.2210508510794129, 0.09148065162426977, 0.10242569268646007, 0.09698036462863457, 0.09280932696941258, 0.09701310526678497, 0.08209642865530331, 0.10054376415201116, 0.08619767155799585, 0.09144455204118296]}, "mutation_prompt": null}
{"id": "a85973a7-3202-4290-8a74-6c873def29b5", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule for slower cooling\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Modified chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.45 + 0.55 * evals / self.budget  # Altered scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm combining chaotic mutation, adaptive stochastic tunneling, and dynamic population scaling for improved black box optimization.", "configspace": "", "generation": 11, "fitness": 0.2715028930505828, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.41535972006259914, 0.3906784063001444, 0.34706213224769067, 0.3678430492746586, 0.3799112303462038, 0.37467800519572314, 0.3796290776902169, 0.3812922227716584, 0.36302335375475525, 0.30156874161015534, 0.3169587377748563, 0.3269250643935234, 0.3103949908603255, 0.3378510054727554, 0.3105500296207432, 0.286526395140249, 0.3011177853445165, 0.3083239104841775, 0.10834495455553383, 0.11902239221758482, 0.1390978634031983, 0.14281638997168666, 0.1310564775591725, 0.2555646737715661, 0.1375501273136528, 0.15432723024460626, 0.13511728403233103, 0.09912477053390045, 0.10888182614532305, 0.13777033771319525, 0.09763872027343445, 0.07452603863737839, 0.12266231503698177, 0.11170376366086499, 0.09834778670204725, 0.12001919418031226, 0.6736383217790165, 0.9640974453300649, 0.823831865196653, 0.6729991145276168, 0.7850257868517518, 0.7610447946140868, 0.688562697641673, 0.9243476081621107, 0.609085183479825, 0.2458711430393209, 0.22180735537893137, 0.21591462135902273, 0.2897542550542962, 0.25366595940020487, 0.27309889777462293, 0.2558471562448371, 0.2766543558794714, 0.2588688663636254, 0.6089427819322373, 0.46387581940909806, 0.7216156812361676, 0.45371889562983336, 0.41969163146030875, 0.3852820257057863, 0.3496075942604895, 0.3479730634880257, 0.5838992599877286, 0.23441251902651206, 0.17956326440873605, 0.26956392158499054, 0.192987615916836, 0.19365288490822685, 0.2354798904404739, 0.27232604360099555, 0.20987235082956368, 0.22782650294563722, 0.32702122903977815, 0.13009856724265245, 0.2612345843064595, 0.18764828919407972, 0.22913465669622612, 0.2943103043521813, 0.1981122359154508, 0.15751033289423577, 0.23927463620574962, 0.3051912188092496, 0.2827483488314443, 0.287234458628557, 0.27929811408940897, 0.292158172125881, 0.26886066337755177, 0.3093504155701339, 0.3107399738447775, 0.3012018277588192, 0.3479829430694291, 0.33031498915160473, 0.33788237583169456, 0.33462937454954966, 0.358780292595831, 0.33315442993633937, 0.3503791458131774, 0.3429192427356612, 0.344439853022362, 0.21735660461078, 0.16809104318015577, 0.24663156125069685, 0.2535219227457619, 0.2373092909762935, 0.22774527718936055, 0.19299213879783828, 0.2303324354320122, 0.17561082644253, 0.23906147843395298, 0.24675611508291462, 0.24315852589942322, 0.23030757321555673, 0.2453049659063249, 0.23639834604932797, 0.2390266481344605, 0.24890061278947317, 0.242358288243799, 0.3608335019613622, 0.3415824249023359, 0.3492889630417889, 0.34819007554217785, 0.34098593345518124, 0.348738536472753, 0.3472233716675772, 0.34432312359853356, 0.3491454849118222, 0.12677044654568603, 0.17112934515175438, 0.13786265289632194, 0.11585011220397823, 0.1210506885306526, 0.14803469260029867, 0.17025697057404632, 0.13637852542873263, 0.153054494549835, 0.29644040787813297, 0.2327925395015079, 0.2618706177671112, 0.20512331321056432, 0.30350235102625933, 0.35919786641737894, 0.2288739116537014, 0.2534871647618605, 0.3323922164282014, 0.29595491279767283, 0.2925636249673548, 0.2977761133428031, 0.28861027604614486, 0.2723431116839149, 0.2870422918950639, 0.28102447128649943, 0.2820719981729145, 0.2933197329678643, 0.276329096685334, 0.27727879164868274, 0.2625981867183612, 0.26471370018127705, 0.2599914948385883, 0.25274856041594695, 0.27233107631670417, 0.2608619828501718, 0.23160490391089184, 0.22033940219590586, 0.21202838055746165, 0.2032630270376058, 0.23678951680161997, 0.20893364705228512, 0.21630231641286723, 0.23538652388153603, 0.23151904271602286, 0.2149700777275957, 0.18783714343432056, 0.22511402900107702, 0.2103795575635673, 0.2304186642442504, 0.2101254539757893, 0.1943870390654706, 0.20044322014050575, 0.23694328178024882, 0.23825531664570476, 0.16103336751067876, 0.1838175657545138, 0.20512441250308233, 0.16539927445432112, 0.1974713336218913, 0.18988374720741452, 0.5128058668400735, 0.16492723968061984, 0.16584011388241815, 0.20323456200365542, 0.2094480894033488, 0.5332138415296988, 0.4305644002514669, 0.20571356016391906, 0.15061586103494706, 0.2085104291470783, 0.2058923452878506, 0.22480075291226143, 0.1862015219924501, 0.1946338833147001, 0.1967403783858246, 0.19981483672515699, 0.2270328314953628, 0.20728723044987718, 0.21493885882974806, 0.20457851390663218, 0.22005230348508653, 0.08548170884098216, 0.10003668073008354, 0.08518063661239417, 0.09261917000560738, 0.09947577002788455, 0.08984714240630787, 0.09371834765503495, 0.09821300846852443, 0.08334810364994771]}, "mutation_prompt": null}
{"id": "3b6140ed-d95d-4ebd-876d-30793c1a99f8", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Altered cooling schedule for faster adaptation\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.4, 0.6)  # Modified to use uniform distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted growth factor for more rapid scaling\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm integrating adaptive chaos, stochastic tunneling, and dynamic population strategies to improve black box optimization.", "configspace": "", "generation": 12, "fitness": 0.2732101388317853, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3751259313335479, 0.3696076511256601, 0.379370696461959, 0.3670363925861536, 0.38377253837817893, 0.37004175378245385, 0.389818126745927, 0.3748762589761896, 0.3856513195032084, 0.3268833806706539, 0.31161182792695186, 0.31695851804966924, 0.3382694066422196, 0.31163641591251423, 0.3131408739387791, 0.27488907028900555, 0.3264456201291953, 0.40050992114622874, 0.12466054710439489, 0.10426051815574722, 0.1066374206961902, 0.11257569227368891, 0.11074473644187599, 0.10294727988920005, 0.0992996700759532, 0.08743574758061401, 0.10690025712441187, 0.09556339431283556, 0.10781744620509603, 0.09717765161678549, 0.09776114642344969, 0.09219692925426659, 0.11792271830222523, 0.09984236345827191, 0.1002773822318821, 0.10904297060647239, 0.43506473945233193, 0.5654613807874158, 0.8512355491893658, 0.7676150187979477, 0.07375159406892384, 0.5092805929447006, 0.8093542786779809, 0.6859066588983366, 0.6124884300186859, 0.271947254332749, 0.2596023801740982, 0.28818899557175615, 0.2733170585891245, 0.2756376454135886, 0.262833919785331, 0.27864392260931525, 0.28888821437408196, 0.2823821586671811, 0.6758985779898083, 0.33901401786171215, 0.7590597381896899, 0.7151203476113828, 0.47868781000949334, 0.7945638362883896, 0.6854596096442771, 0.361624339770396, 0.4027136649509385, 0.2567556178119599, 0.29261720609358133, 0.24966427378599332, 0.2426338353249028, 0.2607807521526272, 0.2683308784876762, 0.3358828775326522, 0.23671404623924286, 0.23923995356439576, 0.23357861118161438, 0.24730556205611698, 0.23573038166772387, 0.2742300181230014, 0.24268443376456106, 0.28050188620808725, 0.13022261579992322, 0.2960774365202343, 0.26866980448241884, 0.32847928187895103, 0.3292186644639993, 0.31050655824756335, 0.31737630566870156, 0.32650471096688993, 0.3066945764819875, 0.3332416279962759, 0.31167236785928165, 0.33096280952161883, 0.3513588925532801, 0.36579815056186393, 0.33355027841454643, 0.3408186689413619, 0.3357667390446085, 0.33302525574022324, 0.338231930124839, 0.342003092054469, 0.37339027007852854, 0.2609273998104441, 0.21198793722259146, 0.2715900788952481, 0.20970949786796722, 0.25341919462819784, 0.2744219471230003, 0.18090130741781862, 0.24372153829595622, 0.18791239289490347, 0.2513014879466404, 0.24256404513876273, 0.2492605652350569, 0.23646829932776336, 0.247982504209861, 0.2539215319403394, 0.23780978324512447, 0.2485576496952071, 0.2605672943280649, 0.3519042978576704, 0.3591678851800161, 0.3557951715283769, 0.3407224806702427, 0.35647546488158655, 0.33842690843307377, 0.34436500566816963, 0.3370427112478892, 0.35242818251584984, 0.11320857304097898, 0.10931303106470003, 0.10825573153964962, 0.13714095349306266, 0.12907804280035484, 0.11197192663818789, 0.10213899674131122, 0.12130906626022009, 0.12060357938405919, 0.20796006970697167, 0.1660772607681723, 0.1733103069205938, 0.15932814379998328, 0.15944119221540554, 0.15426114224819865, 0.17990655228904073, 0.2390431098318011, 0.1791363867896305, 0.2746258599417638, 0.26560752932077947, 0.28173169633396555, 0.28200635287435494, 0.2792417596375668, 0.2699913168998954, 0.2824489011167828, 0.2938148591668581, 0.2795463285531442, 0.2649006416204067, 0.25978554232279427, 0.262992494374543, 0.26071918935942895, 0.2642589047268441, 0.263106807967316, 0.26036271289584834, 0.2746887402011081, 0.2676991677616677, 0.19598727057925347, 0.18660448017703346, 0.219396232718848, 0.19833364212422977, 0.2011005394550942, 0.19441628705070402, 0.21496060424824714, 0.2519898897393327, 0.2030711059853837, 0.2278715502262929, 0.18307751236712744, 0.19903433755004774, 0.17390496753072215, 0.1874898345730942, 0.18737262704788304, 0.214875824062721, 0.1876440902435481, 0.1918213388024338, 0.18305955094901283, 0.1827682177750206, 0.16536734119702978, 0.5505513981883754, 0.1904362048079865, 0.4761891963095659, 0.4543838327732035, 0.47176867979492765, 0.475921128645737, 0.5428694560291152, 0.20803203969442663, 0.20601143383131337, 0.1628674011119492, 0.5013464538076884, 0.49728676589325715, 0.2091677977863584, 0.46674025865740487, 0.20865102329759722, 0.21160324970131028, 0.1933051639645167, 0.19277260642039462, 0.18672462595934713, 0.16667821490962742, 0.17881605719151084, 0.18695140629243168, 0.18805348654914522, 0.1949252290674116, 0.08188876024621372, 0.07899495994375871, 0.08788789652074136, 0.0849526529439747, 0.0827653345877496, 0.0767049296976916, 0.07179991910054395, 0.07687123507672622, 0.08828682923078468]}, "mutation_prompt": null}
{"id": "06e58e92-d4b6-479e-aa7c-e7e2f814847b", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Modified chaotic beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm using dynamic chaos mutation, energy tunneling, and adaptive population resizing for robust black box optimization.", "configspace": "", "generation": 13, "fitness": 0.2751204030009724, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3755776362187182, 0.371691647289045, 0.36816907070309657, 0.36186072750556053, 0.35903280795755266, 0.36979809997727997, 0.37596050741798315, 0.3730489849144859, 0.37540482567792277, 0.2925004117609932, 0.3040536353402695, 0.28536662403414126, 0.33973111914462184, 0.28064247356354166, 0.25030265831731857, 0.26533315300549654, 0.3054932949186163, 0.293668664346902, 0.1319264002204269, 0.1470018713450416, 0.1333669718703544, 0.1123376495226256, 0.11371645005985065, 0.14606181040690913, 0.11124406731862835, 0.1482322850981389, 0.13938103662725188, 0.09878414273026814, 0.1065559947133492, 0.09494226507788839, 0.16370330874923544, 0.07875554009434638, 0.11089209444707782, 0.1304244036636596, 0.11995159025427116, 0.12168279662658865, 0.9545078411101345, 0.6127223277567492, 0.9398747948734149, 0.7178589398834587, 0.7947648561584455, 0.7120117928954361, 0.8951307677119112, 0.6124243885529603, 0.7443347725152648, 0.2632823075786914, 0.24559805175429972, 0.26759757598323153, 0.2729228186323256, 0.2607634060948115, 0.23905861431573117, 0.25793807109091405, 0.28653666614329476, 0.28097019075205476, 0.3998428016460951, 0.5972768173904448, 0.3600420946064523, 0.3793039813636272, 0.58137035542396, 0.6447026352701337, 0.5578900301474311, 0.3639214402092791, 0.3543924387059493, 0.23503876276221058, 0.141468085530152, 0.2594244670404021, 0.28042200005581874, 0.23230219975231192, 0.23041662978532762, 0.24711210225943325, 0.3148365331192037, 0.2623484295147689, 0.27077805219373663, 0.2850023994552858, 0.2535786264918417, 0.17045209521483773, 0.24567985420890048, 0.12190441989811462, 0.16524994411290594, 0.20306050651106133, 0.2223372573312219, 0.2959321239086765, 0.29216729679198783, 0.2778536827021728, 0.22446153332579466, 0.3212349660895164, 0.27275882756252035, 0.3135813914112143, 0.3060286312999143, 0.29749168337697407, 0.3597882050453002, 0.34345582769707494, 0.35282034483372504, 0.32493100133145425, 0.3417595465271964, 0.32744362509697367, 0.3284986580729442, 0.3621957671736805, 0.2647275855782285, 0.25305612455111426, 0.12538609528280265, 0.09765193829451912, 0.2613942547618564, 0.17154877397427137, 0.2701595586301201, 0.26578727395804425, 0.17023321255156443, 0.2305567824861311, 0.23533213137661735, 0.24187329572884486, 0.23824102076527165, 0.23342466270323647, 0.25872002175731623, 0.24659881707814224, 0.2374531097125686, 0.23829646325890586, 0.23421878041070865, 0.3548671671514749, 0.33945056424115305, 0.3548534678374602, 0.3489157974219116, 0.3485668741731057, 0.3481650805067129, 0.3777175380826425, 0.3919987528604797, 0.3553655034947253, 0.16988267074340202, 0.1272887012975047, 0.1252194867451859, 0.11027193874324526, 0.12169769882478809, 0.12164004938637685, 0.15871616952333711, 0.11645304012964208, 0.12949299227814226, 0.31816940176322295, 0.2008352629207676, 0.27075496808481514, 0.3270659481626913, 0.2932968676216847, 0.3032443434937473, 0.23865139906018729, 0.3397701336388088, 0.20876139403262162, 0.2873597552393967, 0.297629405837617, 0.2908621531733786, 0.2839888453716276, 0.292859627463676, 0.2888384830588109, 0.2760799986592637, 0.284070218256559, 0.29173467599110636, 0.28468677028680545, 0.2591736439195227, 0.27713460382604904, 0.2609060680398294, 0.2730076765516777, 0.26882056107662977, 0.2714965300385994, 0.2728438787854973, 0.26627688802509153, 0.2161273024529331, 0.20103784106708056, 0.22601017383966893, 0.27896337347387146, 0.21650976609749206, 0.2017345182271889, 0.23058114487788894, 0.40570735444378825, 0.22683196591957389, 0.18634109579868963, 0.22617916368653246, 0.2384142169195872, 0.19451706230061105, 0.22030149236357766, 0.22251866369625772, 0.20961372071561923, 0.19313421393793673, 0.20468834236398736, 0.18262491375948253, 0.18535303555609783, 0.20878096934618784, 0.12202618121047248, 0.19560028753976122, 0.5016837641030497, 0.5081863136235762, 0.1665031995005838, 0.529517721308191, 0.4700747580421393, 0.2059272987024292, 0.4727594447565845, 0.5254495473545808, 0.1569533625965318, 0.1453156491259222, 0.12533084804952832, 0.20895322280807982, 0.20601603796514067, 0.20350610641654698, 0.2083331826297964, 0.18476317870426218, 0.21223807860576083, 0.22059695167793614, 0.22645864992281772, 0.23494576192750338, 0.22565224987498145, 0.1962666042920269, 0.08974110844260341, 0.09468979400453448, 0.09393947973800665, 0.0901705904471164, 0.09026214032853208, 0.09991053877124179, 0.09622154218981871, 0.10098507022107317, 0.10006187683300272]}, "mutation_prompt": null}
{"id": "5dbd9525-ec6b-4e1f-b9b7-c37ad45f5633", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Scaling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        beta_value = np.random.beta(0.7, 0.3)  # Modified beta distribution for chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + beta_value * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_prob = np.exp((current_fitness - trial_fitness) / current_temp)\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_prob:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor dynamics\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.dynamic_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Scaling", "description": "A refined hybrid algorithm leveraging chaotic mutations, adaptive tunneling, and dynamic population scaling to enhance black box optimization.", "configspace": "", "generation": 14, "fitness": 0.2600853728057345, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Scaling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3488727122408686, 0.35509054549837704, 0.3175298686050233, 0.3445582275307324, 0.3472602581014488, 0.33135427232269654, 0.3833194005354025, 0.35743956660913123, 0.3095998717706522, 0.2808926429405435, 0.26079422143326203, 0.25519581549921155, 0.2622058198565602, 0.2769039719078873, 0.26359257524047774, 0.2618368015258654, 0.286944745329512, 0.2602531141566825, 0.24433831945969997, 0.12489469481808846, 0.1197651727516923, 0.14282712295084843, 0.13129277501684777, 0.11691215194893667, 0.1323203663899567, 0.13119553028532938, 0.12801830202871756, 0.12718737638422895, 0.11295825231779688, 0.12168422545214741, 0.12669689616524937, 0.1209267159110794, 0.1092867497260972, 0.13456556345084425, 0.11336419419190347, 0.10565532090894159, 0.8065845479054149, 0.8680648879094326, 0.8181636324648325, 0.9536736746550951, 0.5891707676853388, 0.6254128546469435, 0.9483072198305573, 0.8702235057196698, 0.8793044547695815, 0.24639547893677805, 0.2299917789257253, 0.24065631591541792, 0.2514509118138649, 0.2485703775450946, 0.2509821216818936, 0.26849316471401496, 0.24572326448761905, 0.29262213148783256, 0.32564820416475304, 0.3455474373687165, 0.37763239109483815, 0.7265914909434446, 0.3590727023117145, 0.5166299403954215, 0.3060968273458391, 0.3218108766065355, 0.3693516082110606, 0.227463650632021, 0.2193515369798924, 0.22636736666279678, 0.21313456958665433, 0.21209493514158018, 0.16535337041404563, 0.27166896851835176, 0.2359946531769418, 0.24202109866555455, 0.246643090181902, 0.24288345883565532, 0.25386851521561105, 0.22767612531434644, 0.24404888720102225, 0.22901984677789777, 0.2526969379363172, 0.21891247066241848, 0.22174574679847825, 0.2543438625605732, 0.23058788116724105, 0.25665079546441916, 0.28390882548302565, 0.2532673126328733, 0.27169341465078867, 0.24672165282066594, 0.2628188773349507, 0.25266708263645665, 0.290349009874178, 0.2955623749271201, 0.29783684418311873, 0.28399165889049194, 0.30543999978454084, 0.32580273584503705, 0.30793053681755256, 0.3209617862856601, 0.31668674634537297, 0.10567914163258318, 0.10000792266278402, 0.17417267761181832, 0.21318763489442183, 0.19093832773778574, 0.17024265280948203, 0.13273679857172227, 0.11785124160240756, 0.1928012376088898, 0.1926096358109547, 0.2148814505225639, 0.19997223391337682, 0.20682062561611003, 0.20406458282239037, 0.19943241750868868, 0.20534715565880335, 0.21794030676538811, 0.20234146149075705, 0.3019172738261462, 0.3192095946433574, 0.3208922368551067, 0.308030937782534, 0.3151371196059305, 0.32261037106244195, 0.32838435000295296, 0.3332647028274649, 0.3121082880479774, 0.13080541724296968, 0.15189044121214978, 0.1551446332271702, 0.14087520149897392, 0.14039282827992572, 0.1685635840004437, 0.11647593025842329, 0.13836893134828554, 0.11916766872123441, 0.24100376724009953, 0.2694031901764047, 0.21559029668299212, 0.26753031109126857, 0.2785649292809176, 0.20307577286020273, 0.24158135648745005, 0.2409735756272926, 0.2861116003818027, 0.2587950712684931, 0.25141246111064797, 0.2570579450809518, 0.25453154140111645, 0.2581218973894679, 0.2463805272016637, 0.26381579400829425, 0.2621007584339431, 0.2595034533964641, 0.2427590852718009, 0.2320683955039804, 0.24450082392833727, 0.22245489893179193, 0.233986468768564, 0.227076361128852, 0.23603088011686035, 0.2732563893945025, 0.23176556744062615, 0.1818647951694614, 0.21806032232784023, 0.20469166311144305, 0.20220712145973463, 0.22424324531487572, 0.19520463874974947, 0.18510828007867575, 0.19708975351126812, 0.19408543898290298, 0.19976882662718032, 0.22217707461080205, 0.26220583397618136, 0.20152376356978097, 0.20729136440522544, 0.1942983358302106, 0.1946946527086434, 0.18879800377349176, 0.19659354199025447, 0.48873770574757924, 0.1605385260857729, 0.18811711883884408, 0.18176624781473216, 0.4147315946409209, 0.1595938449828478, 0.4014806198704918, 0.4412798705709564, 0.19840055974920967, 0.4623812406365657, 0.44229965010484307, 0.12351508523037136, 0.19572745647399603, 0.19729598981286722, 0.4299988275690726, 0.4321390978071282, 0.5019457219806907, 0.12431085821398813, 0.19389220376526395, 0.18091454606883262, 0.19030415189692973, 0.1786099859225294, 0.212117827786934, 0.19352525116069197, 0.21024854498111945, 0.21541237594557916, 0.1918301125453984, 0.07984030052684177, 0.09556733171347276, 0.1058666238139947, 0.08309147854328824, 0.08946961583536284, 0.0824175681486018, 0.09048914595066815, 0.0761383141568287, 0.09294498245279648]}, "mutation_prompt": null}
{"id": "401a5230-226f-4de9-a4d2-d5662b3f92a6", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "a33af59e-6fe1-4393-8a11-e123180d4c89", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_DynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Slightly tweaked cooling\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Adjusted beta distribution\n        a, b = self.population[np.random.choice(self.population.shape[0], 2, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - self.population[current_index]), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def dynamic_neighborhood_exploration(self):\n        for i in range(self.population.shape[0]):\n            if np.random.rand() < 0.3:  # Chance to explore neighborhood\n                neighbors = self.population + np.random.normal(0, 0.1, self.population.shape)\n                neighbors = np.clip(neighbors, self.lower_bound, self.upper_bound)\n                neighbor_fitness = np.array([func(neighbor) for neighbor in neighbors])\n                better_neighbors = neighbor_fitness < self.fitness\n                self.population[better_neighbors] = neighbors[better_neighbors]\n                self.fitness[better_neighbors] = neighbor_fitness[better_neighbors]\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n            self.dynamic_neighborhood_exploration()\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_DynamicNeighborhood", "description": "An enhanced hybrid algorithm utilizing adaptive chaos, stochastic tunneling, and dynamic neighborhood exploration for robust black box optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {}, "mutation_prompt": null}
{"id": "9e7ffab0-4b88-47a3-9354-d95a0a27e6dd", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Slightly increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def enhanced_chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 0.5)  # Changed to gamma distribution for chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def dynamic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.enhanced_chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        # Added dynamic tunneling acceptance probability\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / (current_temp * (0.5 + 0.5 * np.random.rand()))):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def adaptive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Slightly adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.dynamic_tunneling(func, i, evals)\n                evals += 1\n            self.adaptive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm utilizing enhanced chaos-based mutation and dynamic tunneling techniques with adaptive population control for optimized solution discovery.", "configspace": "", "generation": 17, "fitness": 0.24096211856979527, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3323045112600802, 0.33461345641264173, 0.32674494679263166, 0.35193811096063365, 0.3596692014746873, 0.3495548245913328, 0.37950826634883184, 0.34647577275189634, 0.3375790130349857, 0.2590389805981118, 0.27684994321434586, 0.2313367338299971, 0.2597147817926688, 0.2831407166416915, 0.26198918505268665, 0.2725257709032437, 0.2467885795482866, 0.2618098789083979, 0.10535644935101351, 0.1218731113760041, 0.09413657984224899, 0.09505105762013721, 0.11236173545356176, 0.08797695948555573, 0.11580939356817399, 0.11378171729605224, 0.09009388607465718, 0.08537033373474656, 0.09336493642018451, 0.08839951497962428, 0.07813185453074423, 0.09376525733639207, 0.07541468168707088, 0.0895264681203698, 0.09463566146626179, 0.0865130608739546, 0.8668523022560757, 0.7739443994021269, 0.9234631626265184, 0.8084180712312663, 0.8295992459482248, 0.8009216152071232, 0.8411540696302497, 0.9390203132542345, 0.9893665020340132, 0.25343396486195324, 0.24432353898593284, 0.2554234547169538, 0.24050755594002793, 0.25790720583114857, 0.25022267618258576, 0.254854207493719, 0.2329016280088182, 0.23530767866647095, 0.338085913682604, 0.3277553059402465, 0.3869226523149112, 0.32554951460957404, 0.3206766626095793, 0.48957147835699877, 0.33556024750066304, 0.318583685033097, 0.32387192187718306, 0.218950486778275, 0.16956900276626352, 0.2018947130179335, 0.2178662584527773, 0.24113378758823867, 0.2160342217682435, 0.21756417972566366, 0.20489919896709063, 0.23976071930458442, 0.22219375306082823, 0.16905014502368265, 0.21010934450838203, 0.23175834378149573, 0.19939119822003148, 0.1981690303237409, 0.22903891426302891, 0.2423810181144771, 0.20161262067292718, 0.24225292430771528, 0.23789969751686135, 0.2453056823732962, 0.22602027030740068, 0.24630106187260215, 0.2024988618371406, 0.23767679179876244, 0.21935867767019612, 0.22118248243904037, 0.3108282871759225, 0.2835057794989445, 0.31405105055999216, 0.30377155643958187, 0.31978729978718423, 0.3024158383652181, 0.3169389673351046, 0.2942659496233624, 0.3012634615919897, 0.07391948989682517, 0.09830339144791012, 0.08260424148920442, 0.12694251718480642, 0.16638415862040168, 0.1586602367707921, 0.1385262972970952, 0.12597330832846199, 0.12776786116063488, 0.21002563235977245, 0.1848901135012483, 0.19613969469026082, 0.19854984655473606, 0.18821269184755685, 0.19299638256583718, 0.20806381958599174, 0.20448391866381488, 0.18635307106865107, 0.31916164794132196, 0.3259642641349927, 0.3243565235593636, 0.3464794398698442, 0.34129268729856743, 0.3290280645751409, 0.3385569796186052, 0.3150221353414543, 0.3197061807550551, 0.10761158690297856, 0.12318482614432613, 0.09065917641341148, 0.11249260785781967, 0.10799267365924992, 0.09368254657394426, 0.1260042730840183, 0.10709958429892308, 0.08451782145718534, 0.19267345508824285, 0.1800514808468573, 0.17806883833169285, 0.2572133559578125, 0.2716414450477288, 0.20737347670895545, 0.19150277041024832, 0.15943918970899396, 0.20572363632277413, 0.25188069569683924, 0.2535139666093461, 0.26606191266960666, 0.2506530773010375, 0.25829080708130925, 0.2561120050891412, 0.25039003008590555, 0.26592965180099026, 0.26330750690321525, 0.2382684753580524, 0.23638610742730803, 0.22658715182553446, 0.21857769619519762, 0.22833214281449932, 0.22835400726036392, 0.2288242809566453, 0.2336145934599635, 0.21429956354777946, 0.19697430727540965, 0.18712472340518205, 0.19775963137469066, 0.1924062882013401, 0.19735616990178728, 0.17899075179963142, 0.18864651453567804, 0.19193360686938543, 0.17718026507323392, 0.2013605852258913, 0.1764679408456059, 0.17442907896705673, 0.17954207331135041, 0.18975707713577605, 0.17524442972768306, 0.18516103188145894, 0.18228439908959304, 0.189678155916009, 0.18534116324525107, 0.19652153562474606, 0.36776186872373484, 0.40552258482773884, 0.18787560799347636, 0.1759335344875923, 0.3672486298321005, 0.18327172878506803, 0.1680588082498118, 0.44848912013199527, 0.1972137841856928, 0.3871830295236727, 0.18724888160885977, 0.1936345360103423, 0.1601000101018617, 0.20781160010841315, 0.20495418138655963, 0.14693367841254845, 0.1870263715244177, 0.18221921853652345, 0.177231957520393, 0.173602266279837, 0.15096226887646824, 0.18704000239636553, 0.18536863728324193, 0.17178853920514225, 0.16296860105230448, 0.07507224957772829, 0.07707276122904405, 0.07789104281408421, 0.07910151881212946, 0.08451022304248912, 0.08750876996678414, 0.08266966465093772, 0.0783394335879728, 0.08531587354325842]}, "mutation_prompt": null}
{"id": "fe30f430-44eb-4a35-93e3-013784dbdd96", "solution": "import numpy as np\n\nclass EnhancedChaos_Tunneling_Scaling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: max(0.1, 1.0 - (0.8 * evals / self.budget))  # Altered cooling schedule for higher exploration\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.4, 0.9)  # More controlled chaos range\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp * 1.5):  # Enhanced acceptance probability\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Adjusted scaling factor for smoother growth\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedChaos_Tunneling_Scaling", "description": "An enhanced adaptive chaos-based algorithm that integrates dynamic tunneling and scalable population strategies with improved exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.2621201126230637, "feedback": "The algorithm EnhancedChaos_Tunneling_Scaling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3472280565103997, 0.3471829578472836, 0.348781706262165, 0.3492112743245559, 0.3394368049455804, 0.35826960954576925, 0.36127813345015947, 0.377888063279886, 0.35460381717053713, 0.29087063220825304, 0.3059587599574999, 0.30540727195675466, 0.30815623971282224, 0.31154594439693917, 0.3085727059346567, 0.27909432722912475, 0.3062237452444979, 0.32711914880821913, 0.09747338511989656, 0.10753436760978963, 0.08831306068311628, 0.09713953846578138, 0.10290408338815593, 0.09810986565184754, 0.10173577982130244, 0.10318236152725635, 0.09251951048438767, 0.07995041997270314, 0.08623610028887141, 0.09843825311449905, 0.10619890889571848, 0.09624848647722539, 0.09841595995150443, 0.08638315775227601, 0.09687506454722783, 0.08537676414306639, 0.8140980285257973, 0.7160627459708135, 0.8095111149287507, 0.863065142597422, 0.8718112353478343, 0.5753464258143283, 0.9483360765169352, 0.7787593043636041, 0.6226278145837365, 0.26737358123506183, 0.2805544914885072, 0.2534380972513952, 0.2764369765144331, 0.285819105955204, 0.262031850889739, 0.2662005400101154, 0.2714068224352959, 0.27996967485913093, 0.687926964555332, 0.41292658992803266, 0.3553417058004483, 0.3524509407416383, 0.3385097042484144, 0.3480732444558027, 0.3387958912477458, 0.37254864049887526, 0.3533290159604502, 0.25925890473660007, 0.24199878886848547, 0.24479611499900455, 0.24693203520034912, 0.21615439303327666, 0.27733295254529944, 0.2813625561915617, 0.26764113427165703, 0.26203997866789797, 0.24721127875994864, 0.28837339077245816, 0.28606906771592744, 0.23045029540946682, 0.2827922775472592, 0.2790553659126014, 0.2961941948672926, 0.22487860385071468, 0.25730322787492965, 0.3106945346258393, 0.2950893242871315, 0.2672498740659994, 0.28156735924074905, 0.26866722091591655, 0.2687782672092851, 0.2798000075982694, 0.27766916901829797, 0.26567905994687036, 0.32724218353833334, 0.31870347386795905, 0.3321581287391536, 0.3190987615051303, 0.3359748557164919, 0.3187817601772356, 0.34532176608983933, 0.33523449238238867, 0.3364877873035491, 0.1993392587269719, 0.20322586918886176, 0.18483714698305198, 0.19355459121341123, 0.21888698014032482, 0.20179349927485823, 0.213000934159162, 0.18391903305186075, 0.20750958072524817, 0.22144624150984482, 0.23499577170760988, 0.22996149661874177, 0.22373222315332586, 0.2305157040514455, 0.2303437034856758, 0.22550299353515402, 0.22863204626708367, 0.2289201215280321, 0.3453795067183666, 0.3436993298732318, 0.32850743468066457, 0.34435013269552694, 0.3517299839828404, 0.34552283582801313, 0.32592880150551806, 0.32650737323905865, 0.32479069808475747, 0.10229719266175619, 0.09133057046829673, 0.08696004233650112, 0.10478656068332803, 0.097819151996001, 0.10663967328538637, 0.10195986035504079, 0.09140147128825282, 0.09469396097278382, 0.13169158758644495, 0.14166977738573727, 0.16285607025053883, 0.21612171063457164, 0.192573214196481, 0.18110478311669653, 0.14561027446940333, 0.2532991819770778, 0.17648257047664806, 0.2600042149010011, 0.2599602389173997, 0.26875155828038033, 0.2594571549040049, 0.27467239152981104, 0.25954838982855444, 0.26820517729159543, 0.2644681693085338, 0.27126205221486355, 0.25643582059906345, 0.24641092680013876, 0.24558884600305442, 0.23807921189359382, 0.2466026174528717, 0.24046702096966532, 0.25047544101275576, 0.24812553019444405, 0.2474283508653886, 0.21226418573997985, 0.20430187093927765, 0.1896611868151964, 0.18346433670596551, 0.20083881623485444, 0.18147081871801718, 0.20577894873372893, 0.1872722233488754, 0.1866484687505363, 0.18207231377412847, 0.19959577917866478, 0.18510420283966245, 0.18061453252610227, 0.18881798637958436, 0.18436916623145827, 0.1920193206475227, 0.18382257416307635, 0.19001166678355075, 0.17966172695244498, 0.4436302595871312, 0.19381614088785115, 0.4897919646914962, 0.44166025927431685, 0.4505148625599028, 0.4364887037959748, 0.1640494375476994, 0.35660073127547953, 0.4609346839239433, 0.20261408986781537, 0.40784511272422475, 0.40512124070891653, 0.1905196406763695, 0.16135238008831287, 0.20904510949165866, 0.5498842829893218, 0.2084050638201851, 0.19067456320543996, 0.1884308587625767, 0.19020899993606577, 0.1777047242031411, 0.2053633635702371, 0.17931099465377243, 0.20551167999725617, 0.18740953300804486, 0.18899038727819129, 0.08327808919796609, 0.08276431683700047, 0.07628021859927414, 0.07563830896128454, 0.07439119394203186, 0.07767608020837213, 0.06906648201929888, 0.08657124492733037, 0.08017655800679113]}, "mutation_prompt": null}
{"id": "a3bd9483-a931-4dfc-b542-83a2ccce900b", "solution": "import numpy as np\n\nclass NovelHybridChaos_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        mutation_rate = np.random.rand() * 0.2 + 0.4  # Variable mutation rate\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + mutation_rate * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp**1.1):  # Slightly increased exploration\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Altered scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Improved", "description": "A novel hybrid algorithm enhancing adaptive chaos with improved stochastic tunneling and variable mutation rates for robust black box optimization.", "configspace": "", "generation": 19, "fitness": 0.26297820903380015, "feedback": "The algorithm NovelHybridChaos_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3542553829792101, 0.34834963195629864, 0.36428597455317135, 0.36964280239763125, 0.3649521357936244, 0.36855642364922603, 0.35855638003055523, 0.3801187088429233, 0.367156532742005, 0.3007946187205707, 0.3894130242323922, 0.30984819271534736, 0.3065945956835202, 0.32900948749834114, 0.30673988443369204, 0.31159101975803016, 0.32238618175067313, 0.30723171539627714, 0.09879832580013403, 0.10239900215057296, 0.10408179149399166, 0.11775358378629719, 0.10577194083152008, 0.10847391919284144, 0.11637011857624224, 0.09991324193655071, 0.10119584834105955, 0.10067042712921326, 0.0849039499789731, 0.09415376589229385, 0.09709979325627305, 0.08545539512078137, 0.09050840782112646, 0.10897963962175983, 0.11082585261978928, 0.10165874038023226, 0.37560900986454104, 0.5553755272207739, 0.5073500201969248, 0.9424883175072675, 0.5695197193551362, 0.5160175774509492, 0.7480717199960165, 0.5990259404304535, 0.669570650579476, 0.2797333698046427, 0.25539242450830413, 0.26309120801706376, 0.2743551381839958, 0.28125460295339866, 0.2858044189049159, 0.2792372981312091, 0.28572021090093536, 0.25344262211925284, 0.5460966671996458, 0.6550652087577866, 0.7853521530010239, 0.346516611196235, 0.7400849862455716, 0.7115556289339234, 0.7021616831771748, 0.3617473170797828, 0.35392597328126296, 0.25276658626456683, 0.2482884546894445, 0.22994873370890023, 0.28395904215095025, 0.20100608605836046, 0.2697694805447689, 0.25953453271278093, 0.2605292271977592, 0.23062685501337665, 0.26338958168096827, 0.2493133954851009, 0.22205315340517884, 0.1703145742411194, 0.30350418864501594, 0.2558985845534496, 0.3099335795185919, 0.26459823530489346, 0.25915245027759737, 0.28877642550043914, 0.296760020536294, 0.3245591829731741, 0.3069200984451319, 0.28830523058418234, 0.2901447614580801, 0.29905144386565075, 0.2907231739329875, 0.326027767034047, 0.3322758235651918, 0.34793394530772925, 0.36606347808059836, 0.3245221941795776, 0.3249114156986699, 0.3262657102079156, 0.33840182290808773, 0.334272552667746, 0.3545037765944159, 0.12743977270025753, 0.1615378558034215, 0.23190746204197332, 0.2511573642873012, 0.2688725703766218, 0.25538340208027044, 0.15425840889695397, 0.11992333260519028, 0.20563141314754962, 0.24663678776900555, 0.22961319826886806, 0.22891338217388868, 0.22916958945945076, 0.2383560564334728, 0.24149050608187994, 0.24309612357554033, 0.24859902774356246, 0.24362477431400809, 0.35980220113618866, 0.36394245734144626, 0.34743811825222026, 0.3721037284738077, 0.3369893527085053, 0.33784232769328004, 0.33518212784739476, 0.34169501855446016, 0.34611580558596977, 0.09151647306893396, 0.10702719089041568, 0.0998560040062243, 0.09604072288882548, 0.0898366183564745, 0.10041423858107013, 0.09767924581624954, 0.1059312694430058, 0.10620295974795646, 0.15188751204499662, 0.1605129506469637, 0.15023975889021945, 0.17165090952631856, 0.17819007937998144, 0.15927423338796776, 0.15799162513566567, 0.21528724232017116, 0.17650817123716278, 0.26986712898839293, 0.2782444048984605, 0.27102401096136797, 0.27650429346606764, 0.26830865267990656, 0.2828778000746438, 0.2692343915629386, 0.2752183776153554, 0.2896005572055885, 0.26595922698462904, 0.2561182704740731, 0.2568881768950265, 0.2593101446213977, 0.2589639431523859, 0.2502117837688883, 0.25593559427879087, 0.2628907884187943, 0.26698285896077023, 0.22217909417173987, 0.1909040352184117, 0.21610934990821284, 0.20601407845819586, 0.2053343948300118, 0.20167390774611793, 0.2034182147421859, 0.2240414329548286, 0.2303007888594204, 0.18560163558531462, 0.1872506044996951, 0.19450681270975934, 0.18634199806598262, 0.1965100167513174, 0.1859345784195381, 0.20988838659327158, 0.18706560830805963, 0.17723741689261807, 0.16969456657979987, 0.43227432442133884, 0.1500440302662489, 0.4409600201794126, 0.46081668988709945, 0.5144341300706698, 0.42195068676721015, 0.49765613018501265, 0.1660578617933386, 0.1968950860838311, 0.200597340098561, 0.20030876998272573, 0.20138532632720862, 0.19749526510613769, 0.21096808289849234, 0.20892907614536416, 0.20465652256221023, 0.20447055407457115, 0.2014619072446523, 0.18268635145377743, 0.1851178735089719, 0.19793220022182467, 0.19470845130753067, 0.17669426151613987, 0.18834680834520878, 0.163803463849039, 0.18131760304346822, 0.07678755727319364, 0.08269055481934462, 0.07848758626674512, 0.07374392922632522, 0.07977946408428394, 0.08225687269586046, 0.08829677584869966, 0.07659807785388473, 0.0786988118158568]}, "mutation_prompt": null}
{"id": "0820da6b-ff5a-4b88-b8ed-281cea1a10a5", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.logistic(0, 1)  # Using logistic distribution for chaos\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / max(1e-10, current_temp)):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm integrating chaotic mutation, stochastic tunneling, and dynamic population scaling for superior black box optimization performance.", "configspace": "", "generation": 20, "fitness": 0.24938349593160705, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3711481446648016, 0.3382266490753142, 0.3218933211611794, 0.40584525723410425, 0.3356369295829996, 0.3556269379002831, 0.3501084576589215, 0.33126776803955527, 0.34396182371190764, 0.25924491275398265, 0.2509510473474892, 0.25565112947996593, 0.2644026656398719, 0.25188312835131865, 0.24630823300114002, 0.27536534523896894, 0.24026368455455938, 0.21891088063244035, 0.11492303219446598, 0.12314457617462127, 0.12128703336399616, 0.10485908820856404, 0.13142512613257062, 0.10881108378191073, 0.0915344072336729, 0.12149578685406237, 0.15803232312709448, 0.07980229505168812, 0.10273364680711783, 0.09989069522301319, 0.10363821884517654, 0.09233764873591865, 0.10552225482325261, 0.08205299256436105, 0.10143399103587836, 0.10207954143436859, 0.9763883144547464, 0.9924573020699977, 0.9437684511736172, 0.9841912461721767, 0.8527686875915987, 0.9818798857400667, 0.9878497503085705, 0.8328413096657961, 0.9418380162781521, 0.25694429874695623, 0.219229755855755, 0.24369679531990818, 0.22539945420440555, 0.2626608125816967, 0.24183681578317706, 0.2362433981295644, 0.22684504302415975, 0.24336453981398076, 0.3420326144724082, 0.3243906598891103, 0.3174266707585597, 0.4162469290406199, 0.3293106165163361, 0.34458310071194753, 0.3245048801598216, 0.4442500053128713, 0.31875862527768695, 0.23096260929495283, 0.1491086038484538, 0.18847683709754182, 0.2124788596374213, 0.19318856357911096, 0.2525450762874323, 0.2718311066285449, 0.25734707603481444, 0.2737857583758707, 0.2917817347660906, 0.23504655533713104, 0.051786643217292094, 0.18583826014768645, 0.25750025446559544, 0.19620957204304645, 0.21960425077846368, 0.22753040161370175, 0.223331491958362, 0.2381978350062003, 0.23453702886897487, 0.2288651829026399, 0.2672190908963702, 0.24418882920735996, 0.3059127863863461, 0.23189766080936758, 0.21408819245056054, 0.22343596266944443, 0.29098099748467643, 0.28551281111875526, 0.31134055993369814, 0.29093998831411605, 0.272787376918059, 0.29630644581480414, 0.2866236201167942, 0.2920618622728227, 0.3374514075116454, 0.15009072372671672, 0.17038582745365605, 0.0902706146074046, 0.15482385108180063, 0.11787135916513869, 0.15566437206665773, 0.0922302704671627, 0.14904070430910143, 0.11226478587189448, 0.19982282401545493, 0.19279711796935672, 0.198228581314285, 0.1979770924164247, 0.1959692833127722, 0.1859735567668488, 0.1942094710444433, 0.18625575016433327, 0.1975533370255128, 0.31086775816609535, 0.33639536640735834, 0.3160282969400954, 0.3168038437255062, 0.29617950497119494, 0.3083078246248384, 0.3189363875589414, 0.3193422707959892, 0.31461460283230314, 0.10819760352555385, 0.12391313948510574, 0.11825442056781921, 0.18652159436573945, 0.11757219582439626, 0.13631430713153636, 0.13438709393586212, 0.11281023838838389, 0.11307801453031863, 0.301252231384895, 0.17559762292767267, 0.15241646693396904, 0.2974193168826822, 0.23544643201557525, 0.14245340848910437, 0.21808421456417038, 0.26619703822955665, 0.20583068157842122, 0.2691634846981732, 0.2515389854400317, 0.26015166892709884, 0.2691300161704878, 0.24898516455110686, 0.23765841447997804, 0.2501559746716372, 0.27066200474210256, 0.2675093297646508, 0.229615227910539, 0.23334568017992097, 0.24008183139563688, 0.2383503150968681, 0.22870737714848544, 0.21683726055205876, 0.23851075447073944, 0.2358890671131787, 0.2267293121226156, 0.17555605156408616, 0.18813959928409207, 0.1831750957265439, 0.20667855089139098, 0.19338680094037108, 0.21140640168637692, 0.19734022914950533, 0.18565502995070993, 0.199033848377697, 0.19348387624350194, 0.19877838327024955, 0.19268097149592134, 0.18682817549798514, 0.17982685464598236, 0.17928745161483362, 0.19438827549760018, 0.17592226563250257, 0.18042258244054976, 0.39198274774083053, 0.45619771876504733, 0.16465692488001438, 0.17365147154184524, 0.18789313823705345, 0.4468058086555652, 0.18262456089360657, 0.17685578415160141, 0.3804272458342054, 0.19693209209290308, 0.4200153491190127, 0.20736960171808627, 0.1952747558051423, 0.16169222169499264, 0.43511046724648506, 0.20757052245161123, 0.20532225674564863, 0.20336022811566978, 0.19719860452653515, 0.18948689970450427, 0.2111090276273866, 0.1679781497824806, 0.1573292317346734, 0.15112844610198717, 0.22364646319322934, 0.22326585764535134, 0.16517141214634556, 0.08067455775966159, 0.07406521192749149, 0.06805534038596361, 0.0736418854726204, 0.08150223078189078, 0.08074686866058023, 0.0778578438063352, 0.06906307048521043, 0.07739808041992258]}, "mutation_prompt": null}
{"id": "d11a07cd-7dd8-41f7-a1db-9837e8a12882", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "ac8b9f0a-7620-42e3-832c-e9b7328a5983", "solution": "import numpy as np\n\nclass ImprovedNovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Changed initial size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        self.mutation_probability = 0.8  # New mutation probability factor\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        if np.random.rand() < self.mutation_probability:  # Conditional mutation\n            chaotic_factor = np.random.beta(0.6, 0.4)  # Updated beta distribution\n            a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n            mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n            return mutant_vector\n        return self.population[current_index].copy()  # No mutation fallback\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedNovelHybridChaos_Tunneling_Adaptive", "description": "Enhanced adaptive chaos and stochastic tunneling with dynamic scaling and mutation strategies for robust optimization.", "configspace": "", "generation": 22, "fitness": 0.2468872293271642, "feedback": "The algorithm ImprovedNovelHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.13.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.32622520812946765, 0.32948277753601984, 0.33243527385849625, 0.37260630111939463, 0.3442981992898374, 0.3318190518694307, 0.3266688377204372, 0.35507342083600724, 0.3708667960555949, 0.2629608116427057, 0.2912435293208996, 0.27642094623133906, 0.22436332700607653, 0.2611193909858637, 0.2460613905790403, 0.1754401430388336, 0.24862598902419553, 0.2559388681158614, 0.12594130715450014, 0.11065021271445563, 0.10294280183877313, 0.12704230636532443, 0.10771005560744795, 0.1090472385126342, 0.1110583140837984, 0.12530384610593082, 0.1556515085408675, 0.10337077257330807, 0.10291954948513049, 0.10143322424799628, 0.10610700372093529, 0.11349875444456137, 0.09118743633507442, 0.11477397521404231, 0.124635765272338, 0.11275150019448688, 0.7070662310084571, 0.8213939910013861, 0.6932749668058877, 0.6641495275010614, 0.7768800591424597, 0.6302374533916346, 0.8335239600561363, 0.7582437178644076, 0.6863956998620788, 0.2784654622758096, 0.20652582227354332, 0.23072125867910775, 0.24095577721483918, 0.25165397242009524, 0.24864510320111077, 0.25314862157717555, 0.2573894056931877, 0.23737174239625314, 0.3385282112401241, 0.34244259454485126, 0.3244593585676264, 0.3238333830457687, 0.36669742154154694, 0.32438930509287345, 0.3259910109197677, 0.3744929059849079, 0.5875176415172151, 0.1872060522515807, 0.15915291453205005, 0.2187749077727571, 0.19300241129613094, 0.269676611556792, 0.22584845466363623, 0.12082994158381355, 0.2091713245807194, 0.23883612010354538, 0.22453951079817103, 0.2466906272364402, 0.15810794814969287, 0.22805681970138525, 0.15662714749737738, 0.2386166204901098, 0.2780736183420611, 0.29704538684159765, 0.24040515223266856, 0.256973098679508, 0.2542561540384106, 0.2408665626142028, 0.26062963359480784, 0.2730959299425342, 0.24779957774544759, 0.27120978742731094, 0.2504248043751721, 0.237810273618969, 0.3396856472210279, 0.29438327300919565, 0.33154132946569714, 0.2825056468819921, 0.29892115898430527, 0.2867165378548383, 0.28523646156579374, 0.31447747765365375, 0.314872728150837, 0.13003005095254616, 0.09181565304693518, 0.17029849916850948, 0.20003046135535385, 0.1217743749661, 0.15543092270813974, 0.11702688191323452, 0.10139364129287898, 0.14595896801565122, 0.20291179175400553, 0.20802239700062541, 0.2165373398203162, 0.2051218266377286, 0.18382158896477674, 0.183392725274644, 0.19945383549869788, 0.20173493989876767, 0.199430955690724, 0.3147822297884192, 0.32838604113948233, 0.3158706809029509, 0.3217949679363912, 0.3146900590498837, 0.32310980854214333, 0.3340285602115646, 0.31278831070692925, 0.31681416761633074, 0.15463522498530202, 0.1319831672312699, 0.09864412708998371, 0.09691772496213469, 0.10268894527986594, 0.1219609348849775, 0.1151052396765041, 0.119796287650759, 0.1177659890584224, 0.15014361719755998, 0.2824443451469888, 0.2519007985550906, 0.20972980791675355, 0.2772152773690616, 0.27636930898960765, 0.22181751543026662, 0.17189892106522275, 0.18167818486620002, 0.25411744454689755, 0.2648908050178338, 0.26827198388527296, 0.26096065120231693, 0.2629037185691441, 0.25231965485831853, 0.2591524992691465, 0.2720052341245337, 0.2759724817040269, 0.24000161680241838, 0.24100269557318055, 0.24127889780591982, 0.2349639149530537, 0.23236735077145398, 0.24714145386059128, 0.2355580331520517, 0.2467157624251466, 0.2431199670283245, 0.20642825939533282, 0.23879092363930532, 0.18555254347916517, 0.19574706350463178, 0.19193852724695604, 0.20766179706622345, 0.18906967933305852, 0.2284391514734535, 0.20197194259865414, 0.19990807446280756, 0.17492017363725643, 0.27360753984133634, 0.1917303208317549, 0.20458420245092224, 0.2736441676760948, 0.19634844018310404, 0.190751900204017, 0.19031718255355068, 0.16777782867887325, 0.20216668436306306, 0.16860821358459233, 0.4629445709669471, 0.18261136248706888, 0.4434903430547984, 0.44711613175660836, 0.16025997208244602, 0.14975586687214104, 0.4276936933421456, 0.4509270119732458, 0.4073766388815355, 0.2391130788285155, 0.3855123531050293, 0.20166592816825202, 0.1966166841799969, 0.20920563673723558, 0.20004207699144694, 0.17600056574887823, 0.19906517591606565, 0.18843685321375092, 0.1840253335873111, 0.19578920334734629, 0.19344011431524666, 0.1900512180792815, 0.20381860804518415, 0.19949851114552242, 0.09761062691507727, 0.10384462910644776, 0.09930078285345412, 0.08489627913721343, 0.09152538462940829, 0.08223554595911753, 0.09176758526567397, 0.07917174059037368, 0.09683805637655585]}, "mutation_prompt": null}
{"id": "55d44099-974b-47a3-a397-3a90ba635668", "solution": "import numpy as np\n\nclass ImprovedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 0.95 * (1.0 - (0.9 * evals / self.budget))  # Adjusted cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.4, 0.6)  # Altered beta distribution for mutation\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_probability = np.exp(-np.abs(trial_fitness - current_fitness) / current_temp)  # Temperature-dependent acceptance\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm using chaotic mutations, stochastic tunneling, and adaptive population scaling with temperature-dependant acceptance probability for improved black box optimization.", "configspace": "", "generation": 23, "fitness": 0.265654969285143, "feedback": "The algorithm ImprovedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.39835508034683087, 0.3979907255847167, 0.40602619988050404, 0.3981347832554557, 0.37847190705245626, 0.40299036140612554, 0.37785838118533566, 0.37751462720268314, 0.39084688900145415, 0.3358005093526537, 0.23373035168694367, 0.3207076515849929, 0.014143270024639443, 0.2867071989498128, 0.2623001458436637, 0.31550924561204385, 0.34253239181075423, 0.2955319061730831, 0.10709249930928122, 0.11206286977850355, 0.15363919774413648, 0.14678294934491387, 0.15454951919704218, 0.10177798444346464, 0.13555756081935721, 0.14388796118300218, 0.11227923753893632, 0.10600926260749688, 0.08920713789867418, 0.09434677040420758, 0.10102994146861333, 0.10770442325770524, 0.09083447465129413, 0.08992160444299102, 0.08278491988004189, 0.1112782300110704, 0.6755505088717668, 0.9363942092667967, 0.7865050202349512, 0.7537496103914005, 0.7876437074614175, 0.1810347270374122, 0.8306320508085289, 0.7044208128896634, 0.6474390236209486, 0.2625678553660743, 0.32268053001045205, 0.17954405112960825, 0.21969640582579375, 0.2046116152152394, 0.2033013379716041, 0.22909726774766215, 0.32196283057089137, 0.25852749228932703, 0.5545478094714676, 0.6844022653051367, 0.625054533972837, 0.5317050098310128, 0.36002757596689794, 0.6281945373717681, 0.23564685072297964, 0.6691826709534382, 0.33962638960519853, 0.19663007533914956, 0.18892538592365327, 0.12717817901899164, 0.3013723641270679, 0.29529458803879616, 0.11952004458777865, 0.14284618644941927, 0.35937365518006614, 0.3364468724744183, 0.11418927792914635, 0.16621729858278178, 0.09764304974859861, 0.16004845012451063, 0.1863562204685989, 0.3026507297005372, 0.21809867543859196, 0.20149286837787128, 0.14751987190587335, 9.999999999998899e-05, 0.32034298941794737, 0.08485795673986629, 0.32152380284259097, 0.26467767422616184, 0.2845793824486905, 0.10405569297270889, 0.29183067402650553, 0.14775302128502021, 0.3526416969078169, 0.32763451534661703, 0.3565368654711918, 0.30399583498145544, 0.3300316032387367, 0.3566052636857777, 0.37096425780377273, 0.2942409596816449, 0.3669696991218597, 0.05144212525954006, 0.17428439097712745, 0.1649460146874715, 0.2100524353287323, 0.09599808681883915, 0.136443886318252, 0.17918113579902328, 0.14609625530732884, 0.1725227540801919, 0.13188068609152248, 0.17489023200074916, 0.2532890081631215, 0.2176075107282992, 0.26178471896034694, 0.27347853035618286, 0.24430410917642753, 0.25925612965919953, 0.1421626153255231, 0.3798688526651254, 0.3752877460818679, 0.3417065319641648, 0.37818404737704103, 0.3616246319507145, 0.3681847317492245, 0.36991625598209, 0.3556321704662795, 0.3431026188503554, 0.09670992563200032, 0.1329747417488243, 0.15118074796285796, 0.15124818046429556, 0.14712527970373923, 0.135799287138742, 0.08935865470461068, 0.14460810386030898, 0.11483861851090804, 0.23446012964734742, 0.35416464285343874, 0.3488845647724249, 0.28715981921550937, 0.2958942669736172, 0.3292555655211499, 0.2938530718154372, 0.21239891875625638, 0.308242464634759, 0.2566243512340348, 0.2746431352469907, 0.3090632611410771, 0.3241625848385953, 0.2981637394475716, 0.3080003797371895, 0.30486405795770366, 0.2840748988685349, 0.2856042061577312, 0.20676253707593728, 0.19090468853586273, 0.27292566295404297, 0.21478308561639592, 0.2796299534275576, 0.27781741996291065, 0.28856377841339576, 0.22392050821777854, 0.25801002485165625, 0.2270292262247966, 0.2511771892555902, 0.23177639844732856, 0.26298229511981996, 0.2117461355630207, 0.23666701627121767, 0.2722825538357958, 0.22303627357735756, 0.27001573832934567, 0.187516580496351, 0.20442398999414912, 0.17772359404289728, 0.20560031801427026, 0.21658617469156582, 0.1997238915681383, 0.19355959132593592, 0.24069851006783816, 0.1686804434501371, 0.1671594359172004, 0.515496398420496, 0.18371703008239582, 0.49618385102966545, 0.19112752976505654, 0.19216711750019644, 0.16120803679823492, 0.17065867659621292, 0.4982056463314751, 0.4594808398672826, 0.20380378688118939, 0.5146099061650897, 0.3855327334009706, 0.20182666274919137, 0.16139990371408042, 0.2052640865437716, 0.1998585310746458, 0.5662976882253448, 0.2734661783404394, 0.2521837553810926, 0.22319640149139974, 0.23414461220395777, 0.25668690056183996, 0.2648879523393217, 0.21049777161063843, 0.21341432376481495, 0.24466986381600675, 0.08344809894791738, 0.10314951922212967, 0.10527436272090085, 0.08225831670532802, 0.09437023176682746, 0.09625134952366443, 0.10394971066283665, 0.09219320117516361, 0.09161301083324302]}, "mutation_prompt": null}
{"id": "2023aca5-8c62-467f-bbd9-1f7f6cd3713b", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "640931e3-ea0d-4b19-af27-7494b72bf84c", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "e028727c-f3a5-4cda-8565-6f3fc40aebfd", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * (evals / self.budget)**1.5)  # Changed to nonlinear cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.4)  # Adjusted beta distribution for mutation\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_probability = np.exp((current_fitness - trial_fitness) / current_temp)\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Slightly modified scaling dynamics\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined adaptive hybrid algorithm incorporating nonlinear stochastic tunneling, chaotic mutation, and adaptive population dynamics for robust black box optimization.", "configspace": "", "generation": 26, "fitness": 0.26519328087581284, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.34239076498646304, 0.3335430407575385, 0.3394951095435689, 0.39382261828174947, 0.35142848156053064, 0.34802335566877507, 0.3388357771544871, 0.3387774310142395, 0.370740765568212, 0.2928249114552044, 0.26214888602342057, 0.2909811376070365, 0.27386376205054463, 0.28608400235145526, 0.28346825731484815, 0.2658556616346235, 0.28439447917988414, 0.2721719782201427, 0.1133017820507648, 0.16071110617457385, 0.10813889356271322, 0.14632079461031722, 0.1398362248876509, 0.108624151065425, 0.13508054632571898, 0.11230457627680279, 0.13603120970703986, 0.07620755105625554, 0.09985131426397098, 0.10136818627282496, 0.0993094882968808, 0.08953806720137725, 0.1264189132083402, 0.11480729124270783, 0.1005930944180714, 0.12011124960097674, 0.8115438901745389, 0.877065401998818, 0.9163265339493697, 0.7970820314097564, 0.4921674645105659, 0.9344315481807348, 0.7835449676977235, 0.8625623985763246, 0.811702756285206, 0.2734376948822155, 0.23844529635291, 0.24942748679009052, 0.25401656849527166, 0.2993939268749872, 0.24825488864856415, 0.26590209801249487, 0.2710062773032266, 0.2671039513801281, 0.35490492350956915, 0.5068570964677639, 0.3436104663258316, 0.3637754343743268, 0.3432167841072722, 0.6477891657185129, 0.4202540751181505, 0.3570913925767589, 0.344188131043485, 0.2872720273933329, 0.24663707679008862, 0.2443357757200697, 0.21629842867345506, 0.17477177694954948, 0.20059165780979538, 0.28327902634004354, 0.3067371458900501, 0.2604837833779472, 0.12786319908139887, 0.22753265421559687, 0.22581210710735933, 0.2087608684142379, 0.16284032419863892, 0.26576658432121103, 0.23344442536753196, 0.18579551920371506, 0.2736108116668552, 0.264502103916321, 0.2884301161926258, 0.28485582656528563, 0.2801377339210146, 0.2745212783467662, 0.2623863931650525, 0.3023669546015675, 0.2534514956985545, 0.26188689859392067, 0.30720748092135297, 0.2972451816592864, 0.3253153533468569, 0.33079879631317644, 0.37055231692627943, 0.30159758352143495, 0.32138768741574664, 0.3214490125308488, 0.3112025877358182, 0.1954085476542876, 0.1531612391027629, 0.207916964596236, 0.22785339982072572, 0.14154346758108038, 0.24023929369995045, 0.2056837352821803, 0.1472312208698553, 0.13762695431582228, 0.22939939135678156, 0.2295051583356571, 0.2193848075231255, 0.2127033643023295, 0.22355626873134893, 0.2218493096007904, 0.21314331526697283, 0.22745949856572212, 0.21339703161278045, 0.32385240616951505, 0.3433114187706702, 0.32413177139138005, 0.3199323155613796, 0.33468909272261305, 0.36038555722664234, 0.3315545569604329, 0.32743726767555714, 0.33425302907484844, 0.10572708982510415, 0.09861597385767495, 0.11892584896368574, 0.11832374851029581, 0.13224178081290083, 0.13402166108264524, 0.11652295312907845, 0.1312279503249303, 0.14005747038480043, 0.29184716302232316, 0.34376051906041294, 0.2811340199084261, 0.3515504009119713, 0.2666222220396077, 0.238958295927986, 0.2214233073989067, 0.2468389908811529, 0.3034564799644419, 0.25890389235912203, 0.2647379969843707, 0.2682736582551507, 0.2723664094551135, 0.2732407229788597, 0.2568603858694639, 0.25888243532273325, 0.25714115193163867, 0.2564049058571952, 0.24576552870082602, 0.2535602718052239, 0.2511926204510204, 0.25053138809917774, 0.24318316484610103, 0.24151056804611815, 0.26070656771866574, 0.25415929152406047, 0.24225542746764117, 0.23417519440159318, 0.22231770733582845, 0.20143468728213898, 0.1873016236022772, 0.22442321336080384, 0.18920806066760887, 0.19908783275382458, 0.22407729286086364, 0.21084603986328032, 0.242065816285582, 0.20687290537550695, 0.1990509224675101, 0.2096871429749101, 0.19390434141182045, 0.18928615985521402, 0.2523544710507316, 0.19670070366238357, 0.1877609233478037, 0.19218767157127026, 0.2046171401763346, 0.5009936440897587, 0.17984392161648466, 0.1905200463754605, 0.17191028803649355, 0.1627512096900129, 0.45709412526293747, 0.4334512515380534, 0.4924548074360108, 0.44964256054010376, 0.4244921198717103, 0.16542091691511507, 0.21684168235030743, 0.16631595397358356, 0.207754859324775, 0.4845997620732341, 0.20581728561464774, 0.20924317193408615, 0.2115800927913627, 0.18686000793892754, 0.2022070426600907, 0.22526326195287316, 0.2053311636558981, 0.199545651833679, 0.223138632856425, 0.20250324384939533, 0.1122584153442675, 0.0909572903007585, 0.09836491101669831, 0.08941235928468905, 0.10214841673653663, 0.09278048685060947, 0.09534677230308775, 0.08429644775287448, 0.09206886239454892]}, "mutation_prompt": null}
{"id": "4ccfbbd5-3635-45c7-acb6-353c4977f25f", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 0.8 - (0.7 * evals / self.budget)  # Modified cooling schedule for faster temperature decrease\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.3)  # Adjusted beta distribution for a different mutation pattern\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Altered scaling factor for more aggressive scaling\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm with adaptive chaotic mutation and dynamic tunneling for improved exploration and exploitation in black box optimization.", "configspace": "", "generation": 27, "fitness": 0.26524517071674586, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.36550887615897587, 0.33647219566047404, 0.3465363389526953, 0.3758250114612771, 0.3514364998224203, 0.35126422752493114, 0.3723737215666493, 0.3484120176388795, 0.3511191573697314, 0.2944331415349484, 0.27351859805343615, 0.28341127428979673, 0.2672432321906537, 0.2804925491778003, 0.2628932989705083, 0.25343515396417204, 0.2739593592313804, 0.2640428196208019, 0.13442642881970046, 0.13754506663042487, 0.1023467592399484, 0.11349751330603175, 0.10418692126118478, 0.14798390765993374, 0.10658491765602851, 0.12036137109288647, 0.12801900485724238, 0.1132506840080989, 0.1115142202547812, 0.1230509422042192, 0.10368566234130772, 0.09932822451453727, 0.11207557960088721, 0.11562664979094295, 0.1102576865743391, 0.1170593399165255, 0.817400982118197, 0.874799770371, 0.7100238397326204, 0.9536736746550951, 0.6365885214509431, 0.6715645352145074, 0.709048281510934, 0.9290488516092706, 0.833528219531311, 0.26290972859459794, 0.27916040692248645, 0.2589825028894369, 0.25357939223370096, 0.2416860610797923, 0.2350908267270615, 0.26182891872065295, 0.2498415835356529, 0.2643846355409145, 0.5617177917723366, 0.33882450467548786, 0.35075066272402666, 0.48287675150400866, 0.31322001373898956, 0.4193085385662698, 0.3994052987067924, 0.32591715085789297, 0.34131592868452, 0.2537049273934574, 0.22654327095158, 0.24087834041496703, 0.22495199388125797, 0.18270801681557158, 0.19469559279919768, 0.2506217032463044, 0.2612794906542747, 0.23957130433436624, 0.2877038337683131, 0.20785371345687964, 0.2855970639315091, 0.23685233838881448, 0.23302217861512275, 0.21269856438009938, 0.26388968165641746, 0.23962423525354137, 0.2562823110279562, 0.2582300086138729, 0.27820056544393135, 0.2675240433623157, 0.2776245226372944, 0.24987666393223118, 0.2637810183089726, 0.23332138009139225, 0.2555207870124795, 0.2413049910919034, 0.3292455284369513, 0.3012415881123075, 0.315277312592239, 0.30003036680807005, 0.33464949692436086, 0.3503441115498874, 0.31862417551618794, 0.3177483209317207, 0.3116879598476813, 0.1013325743460255, 0.09489590181264151, 0.18137721864066303, 0.23320360162935116, 0.20113304948998245, 0.16762942675876125, 0.1439713724500301, 0.1255814519762185, 0.1944556606832537, 0.20434488718084964, 0.22811224261116736, 0.20546360477290027, 0.2040871262519075, 0.2282149128992863, 0.21677970203855668, 0.20627532944409144, 0.21822205214385526, 0.219380801337692, 0.3328010548788931, 0.36366619908727227, 0.32625441447529036, 0.34054998972596406, 0.3954645724704072, 0.3227957018141844, 0.3432458520370083, 0.33658769532049304, 0.32001051810925574, 0.12215558635368728, 0.12123331832691653, 0.12504201778200819, 0.13638609437421623, 0.2055239365670728, 0.1684410814155033, 0.12539124560423076, 0.11238374641001869, 0.21873237093074083, 0.2137086851771347, 0.2761236120103022, 0.22750399023903878, 0.27741642149208834, 0.2551596307677849, 0.22525401463599248, 0.29387451159337163, 0.22047540996813952, 0.3066457056737083, 0.2654546261560168, 0.24924805785577486, 0.28084411957786015, 0.2643136222263993, 0.2656377677189081, 0.254668486075165, 0.2866889169439064, 0.2734338040561858, 0.2619357074573859, 0.24261643611394756, 0.2352574375335671, 0.261204303767233, 0.24169694928627872, 0.2374670686199204, 0.24087296974007955, 0.24942789039241842, 0.2516018072997719, 0.24358645561697345, 0.2038451573892912, 0.19911460419252702, 0.1852712277660019, 0.2112479403742208, 0.1847369989133788, 0.1898380898433466, 0.21784933879476875, 0.19025557706661966, 0.19304786751620295, 0.19580560035036187, 0.20249496355700236, 0.2610546436284038, 0.20232590643883364, 0.27847455037107816, 0.2028553141419558, 0.20247826376297595, 0.19742361402585662, 0.21306459961212354, 0.17915240067603733, 0.20146577221785156, 0.16287038402172715, 0.18071269934875656, 0.20070585651241213, 0.19267894333207713, 0.4554780289226277, 0.4120752575444038, 0.4622108364241513, 0.5295696057536579, 0.41154115196948005, 0.4591191280527208, 0.4400695179190445, 0.1973807115090075, 0.4391592630002692, 0.48132228349811657, 0.5049034962319099, 0.12392488155579373, 0.20363482761601048, 0.188147504976942, 0.2065698177175992, 0.1879507748571725, 0.1933033274044279, 0.19087059229971015, 0.21714191025605634, 0.21751958770625135, 0.21107800247326147, 0.08428891128059002, 0.08501788481618, 0.08699456896457103, 0.10016107999022683, 0.09006192277840785, 0.09351124162572377, 0.08474359919276919, 0.08545944845694464, 0.0753655472530369]}, "mutation_prompt": null}
{"id": "33e163fd-73ef-45af-a3ab-53bedfc7e1cc", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 100  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Altered cooling schedule for faster cooling\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.8, 0.8)  # Altered distribution for chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = a + chaotic_factor * (b - c)\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.3 + 0.7 * evals / self.budget  # Altered scaling factor range for dynamic growth\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Dynamic", "description": "An enhanced hybrid algorithm utilizing chaotic mutation, adaptive tunneling, and dynamic population growth for robust black box optimization.", "configspace": "", "generation": 28, "fitness": 0.24440825705099464, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.13.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3496486897789861, 0.3404116542387723, 0.35953427469178034, 0.3474972382297291, 0.35305586757123664, 0.3492050731410532, 0.34446545816691376, 0.330425951368138, 0.3419222811096352, 0.2542221731598454, 0.22799741683180186, 0.2765168591588111, 0.23920671140025174, 0.23950713800142998, 0.23930701609865856, 0.2600737552516791, 0.2455170109565208, 0.2533095735374389, 0.11407129988006914, 0.12338839036918925, 0.14879713658592297, 0.09303371429498986, 0.10662878414207899, 0.10768802814745482, 0.1186450709919018, 0.11850521161835481, 0.13809096045681069, 0.11445591356144014, 0.1099293176107583, 0.11033442671016325, 0.11033056853458201, 0.09753856796301352, 0.11849593844415163, 0.10528445744135495, 0.09380901311201728, 0.11039816951965675, 0.6292437182027594, 0.930401170212869, 0.5706995530166125, 0.7154112822627676, 0.5317946527354058, 0.7109273186444901, 0.6766973609157614, 0.600870179379269, 0.4911586139219396, 0.2623916138771193, 0.2466382561268674, 0.2155401408901798, 0.2354470424743299, 0.24607935317069052, 0.2549510093915295, 0.2433492257283344, 0.20096049147480344, 0.23371315249815072, 0.4905954859649232, 0.33222952823329954, 0.4537014694100533, 0.3446045091006328, 0.5307508462886744, 0.5919955127197423, 0.6151312254546963, 0.3297949698904795, 0.3625819544953318, 0.24447546485017624, 0.2098179693692801, 0.2584381600716884, 0.1633234444187085, 0.21275304400083195, 0.214087474229971, 0.16244106659760038, 0.11403843558611881, 0.26204184034721834, 0.15435612301765067, 0.15134269164874148, 0.2185798088677695, 0.22473994792141716, 0.1564098402593731, 0.17822646021073374, 0.19797191535763736, 0.18866861549493696, 0.25373571399919304, 0.2398417741626797, 0.2357953555360327, 0.2490702524168933, 0.2409599483814434, 0.24205794517145474, 0.22005574576440246, 0.24972283864045175, 0.22841223624023155, 0.2578909973707171, 0.3123829030150278, 0.3029793487904636, 0.29055003043413064, 0.29158579690188835, 0.30809210244760377, 0.30654912470596796, 0.31628920496923096, 0.31887355854761046, 0.31306069225734834, 0.14419165891250452, 0.1598456886237627, 0.07765942501268641, 0.17480676290945918, 0.1395753439499149, 0.19009290557362912, 0.17215996145160117, 0.1754512837697867, 0.12596628608480986, 0.1990118115276106, 0.2145029737254911, 0.21447641141148, 0.1895051822078786, 0.195887456369075, 0.21445411179986185, 0.19630804892763376, 0.18955575394667246, 0.21537422391773287, 0.3396371038067637, 0.3210376346731807, 0.3241071319116886, 0.3194735593083088, 0.3591792659709897, 0.3545031240699972, 0.334477114004355, 0.3205341526014944, 0.34019263232321184, 0.1364820092601824, 0.1193386252775972, 0.12792128537816316, 0.12648538875315374, 0.10805950302809564, 0.11439149140628269, 0.11125713628974876, 0.11753025331308675, 0.14829321608890422, 0.27628608392541365, 0.19328114855313716, 0.17804827367085085, 0.24312190380100784, 0.26575917422615336, 0.242044789956827, 0.26632335101031845, 0.15395141040616434, 0.24368428432403932, 0.2690085346988671, 0.24834138874288125, 0.2642610937107599, 0.26140436438269776, 0.25708963477297087, 0.26332729324787685, 0.26186143371568227, 0.2720395597573011, 0.26884515880477655, 0.24105490217217496, 0.23301071279992225, 0.2379891364265745, 0.2444175463466145, 0.248734195912781, 0.25239156178140876, 0.23557534063150387, 0.24380704268758224, 0.24802533242089964, 0.2133661276692176, 0.19221673040079812, 0.20090173456716343, 0.20502335991105325, 0.21064042344429612, 0.18229753679141047, 0.1920562777044733, 0.19212673864721175, 0.20885644362727485, 0.19072014535883552, 0.18489231290156316, 0.1863624097036063, 0.19194075079302442, 0.1995771328470889, 0.19276206530377138, 0.19558848974215293, 0.20338002719836112, 0.21731627386021668, 0.16940343845180328, 0.18778601169711373, 0.44034357362850496, 0.4605341212971099, 0.19005289519085056, 0.18801371387129606, 0.18109106634701233, 0.16653289918336045, 0.43409827445920013, 0.16626026973721308, 0.16281035354483242, 0.19760096542900696, 0.5351819572557706, 0.15683123173370872, 0.42693052887533867, 0.20152000518092705, 0.1577865750996421, 0.4646676433447394, 0.19770617787551592, 0.1900360605131397, 0.19346078017723944, 0.18569839824521894, 0.18896640737513548, 0.2005229282533324, 0.19505826064167364, 0.18131590492585514, 0.19657171007164664, 0.08870650460201579, 0.07902799719956233, 0.09017602886924947, 0.08312718990470835, 0.08328006077957362, 0.08331151137586401, 0.08624579749102101, 0.08621863773438221, 0.08134547114584345]}, "mutation_prompt": null}
{"id": "2cd072ec-2a92-46ed-abed-7a0a9f032857", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "cd45b187-1f0f-43f0-93f3-02f0a5fb05c0", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: max(0.1, 1.0 - (0.8 * evals / self.budget))  # Modified cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 1.0)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def adaptive_archiving(self):\n        archive_size = int(0.1 * self.population.shape[0])\n        archive_indices = np.argsort(self.fitness)[:archive_size]\n        for idx in archive_indices:\n            self.population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.fitness[idx] = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n            self.adaptive_archiving()\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm utilizing chaotic mutation, stochastic tunneling, and dynamic scaling with adaptive archiving for robust black box optimization.", "configspace": "", "generation": 30, "fitness": 0.11207626615205792, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.1568423431898298, 0.12005202632670642, 0.13926206328715673, 0.1695247792671053, 0.18280714416092303, 0.19630527954846522, 0.17162167390670147, 0.1586731126589097, 0.15031996027115946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02867134145537531, 0.031241360466942703, 0.05662683821956138, 0.035014899313024594, 0.03935230848947435, 0.039045820592220504, 0.03010299763523927, 0.03398160032615638, 0.029653609581201223, 0.02262386553891016, 0.008854854539929735, 0.009828013064898888, 0.019950269646540564, 0.0031980925506024382, 0.019136430835880125, 0.014763392921912755, 0.016973928761161328, 0.007840221911818657, 0.9902271892556314, 0.8374434752679624, 0.8124309670713818, 0.8577939662916477, 0.8888462446193957, 0.6965696907562129, 0.9924127780097867, 0.8816866273779642, 0.9732308907257209, 0.06274794416174423, 0.058519384802914964, 0.01854324137141561, 0.05845295212502111, 0.03391764908231254, 0.041279874613144085, 0.06978011532836703, 0.04722643874847143, 0.055877320212726955, 0.13189782154213459, 0.09649245955651387, 0.10820484810665143, 0.0929292677551603, 0.0929911098163757, 0.11002051067213492, 0.11333268344715797, 0.12118072160067805, 0.10443760137363334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007571462539302631, 0.03954618640244012, 0.011014777037560042, 0.025834130647019116, 0.023426363721922083, 9.999999999998899e-05, 0.0142271540565172, 0.039023298432157016, 0.04262565891148895, 0.03455994360271797, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049508673284763605, 0.03379490494555104, 0.0610294771730443, 0.0443075057761545, 0.05079086926389487, 0.10786028527737013, 0.05023837943546372, 0.04336447026461443, 0.010233881007564949, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019009158527322212, 9.999999999998899e-05, 9.999999999998899e-05, 0.17412068198422237, 0.18413608046430008, 0.16795095982208608, 0.17984218780684647, 0.15581862163927396, 0.13931350577402446, 0.17149518115898188, 0.2113866545780373, 0.16591301389338586, 0.04914446045484, 0.05748697489191945, 0.03913487675283178, 0.044797645472912206, 0.03928971704802875, 0.03535526018345769, 0.030286444860237904, 0.02937062134522217, 0.0321196422376121, 0.15381457162530987, 0.14713577066795736, 0.12398173790754552, 0.13766266535167793, 0.12522902449621454, 0.1478488179550017, 0.12246937907722899, 0.1101806395583591, 0.16173822909161262, 0.1414005771643726, 0.16537281301498552, 0.1613932299901244, 0.17445245898525552, 0.18363175154289757, 0.1667776712099709, 0.14454317024265895, 0.17377774300845283, 0.14881056396794268, 0.0868035564036983, 0.09296030403766309, 0.09198129050798909, 0.08692446415873178, 0.10964780287225606, 0.09102038255327571, 0.09398279249942476, 0.0997711199450243, 0.09009610770616605, 0.15658862548797337, 0.15596362813881737, 0.1626111783012789, 0.14768623715560336, 0.1339280256657034, 0.14075014386342377, 0.14042487245472712, 0.14294176566115535, 0.15561811961318872, 0.1289226687283075, 0.12190467037582042, 0.11223106215733447, 0.08308295349850126, 0.14625467861860975, 0.09441514877075186, 0.0927890898034529, 0.09526551065624533, 0.11637276458233059, 0.11467329423815376, 0.122381544880929, 0.13864321591654516, 0.13338359240462228, 0.1276252919800922, 0.15011894216014188, 0.11145505696700164, 0.12337636194622248, 0.1328075494198483, 0.12215211451746832, 0.10790888035051416, 0.2557377023677947, 0.17858105679482683, 0.14955714192628, 0.11161853309351277, 0.21108796726007317, 0.1677561005930045, 0.14155580711200433, 0.16681543129995102, 0.1736448830155377, 0.16791155799694757, 0.17745476649003522, 0.16917576016183333, 0.15884049968958625, 0.18200592631038148, 0.16077799786147295, 0.16445841941240846, 0.046080244017271066, 0.044489083808103125, 0.05103523126182574, 0.04038631493998435, 0.03425093938292756, 0.040824094258907095, 0.05291363117832937, 0.039577964044913094, 0.03328794054947071]}, "mutation_prompt": null}
{"id": "aa9f9d8e-c078-41f2-8895-36204c6b4316", "solution": "import numpy as np\n\nclass AdvancedHybridChaos_Tunneling_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule for better exploration\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 1.0)  # Changed distribution for chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling mechanism\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedHybridChaos_Tunneling_Dynamic", "description": "An advanced hybrid algorithm using adaptive chaotic mutation, stochastic tunneling, and dynamic population growth to optimize black box functions.", "configspace": "", "generation": 31, "fitness": 0.18208477116919503, "feedback": "The algorithm AdvancedHybridChaos_Tunneling_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.27033860010257293, 0.29109157366009664, 0.28946038895001236, 0.2848871208728, 0.2922284407572744, 0.3024990857667813, 0.2997343598044465, 0.2849630703669638, 0.2869052213470502, 0.10809379300004696, 0.1383900454756435, 0.13104393313260732, 0.09522903074138012, 0.1072831061830537, 0.08919313639344506, 0.11087992774712607, 0.12376729522120222, 0.11527016820302649, 0.07292903265076334, 0.0827953833494035, 0.07130309164009763, 0.07189324212752035, 0.06105460110857819, 0.06408694500278211, 0.07512607572526775, 0.06706068661421871, 0.07015961699062356, 0.059512961738985126, 0.06233311748932979, 0.06275392032352467, 0.07429077554527486, 0.06270804085177328, 0.05178370377138164, 0.06751159322463796, 0.06546855236664784, 0.05825650237218449, 0.9902271892556314, 0.9559596585306371, 0.9823791063278982, 0.9713299112019892, 0.9718935245408494, 0.9483045110898427, 0.9924127780097867, 0.9682751702206511, 0.9871780878271232, 0.1672963466121853, 0.1459550425784475, 0.16734102841241805, 0.16416016962657742, 0.13861087201679223, 0.1968745833442923, 0.18691010339217995, 0.1569380015787063, 0.1740772641342071, 0.20872629628649142, 0.24748819250843113, 0.23860962492339377, 0.23887570250602852, 0.24182691559069935, 0.25825603770431116, 0.23653329332936535, 0.2503279086771413, 0.24063777491077765, 0.06657882094069756, 0.0938168294058267, 0.07717125991133011, 0.0804158953059626, 0.08946285831416168, 0.09472196284175549, 0.09175684171756071, 0.09353617180079254, 0.106902225212273, 0.17422151951063136, 0.1406830680469051, 0.10668084260415234, 0.10829426338632275, 0.1371422163749343, 0.08622714526932918, 0.11644931380830825, 0.09547282467477403, 0.11032276967023336, 0.0777854722578264, 0.061577951753988946, 0.07032990680528761, 0.06791866248241674, 0.08763738803353482, 0.07542391762368239, 0.08159278439747342, 0.07979067262743522, 0.06389713463522928, 0.17130696048664962, 0.1726491493435377, 0.17160720375031946, 0.159888314393821, 0.17504230075776528, 0.18612516582128202, 0.19442227262422307, 0.1761412986938825, 0.14852658480453595, 0.006753790290777717, 0.016276850442921598, 0.0008310381798690702, 0.00046114626289750493, 0.014104486334173494, 0.0010274395809865, 0.00794815526651671, 0.01303706820410555, 0.0077038868625075585, 0.09099569845229127, 0.06830168119609648, 0.07438444132243782, 0.07785713343665102, 0.0893349204988364, 0.07900512130479076, 0.08664866042794406, 0.08785956549640361, 0.10520771814771979, 0.26236463708157876, 0.27165655077245987, 0.2863796727171084, 0.26113014216019415, 0.24659977147546697, 0.266874845148373, 0.28795748662491083, 0.2700353123155441, 0.2411881956336851, 0.08383066222883684, 0.07924372108217181, 0.06774247810754419, 0.07733975327622156, 0.06595991451344907, 0.08032687976587316, 0.08372489022922514, 0.07440656933756451, 0.07011533832916306, 0.1739650747468604, 0.13969209788394765, 0.16538236860687316, 0.20610826485374523, 0.1740722977330792, 0.11978438010801962, 0.22642524074304216, 0.17072440061396943, 0.16429811665061878, 0.21053909571894114, 0.21642917219789093, 0.2221730654814842, 0.22204814370953596, 0.20701868200691664, 0.1984506080779933, 0.21631698900624075, 0.21096653226284712, 0.23830447574206848, 0.17160260862205579, 0.16573741091842242, 0.17385799457099493, 0.16981457712086323, 0.16765150367429504, 0.16047963315448321, 0.17856234118941505, 0.17618382118181086, 0.16618551831937423, 0.16806195503941912, 0.16363827163807565, 0.16086478298704965, 0.1788182873960914, 0.1671517237153748, 0.16991503884999715, 0.17807561044608977, 0.1849322534657264, 0.15878538282967636, 0.15506349972514366, 0.15512188871318433, 0.1594245631477359, 0.15011326875490272, 0.16992743973789293, 0.15834375719702498, 0.16904127062051322, 0.16617358125621684, 0.14887969115589073, 0.36861484079580875, 0.17956748617105878, 0.33841719585585694, 0.17683361721904312, 0.19402555140906064, 0.17781255682661434, 0.16944819502492559, 0.17151193258518127, 0.16970581502741477, 0.2773911440486432, 0.18123498143563366, 0.24168402369836017, 0.22120498134694566, 0.21006975765291414, 0.24069016215385697, 0.19947553855958045, 0.24823341348732508, 0.19783950793868021, 0.19981375422942016, 0.1750258650011841, 0.18480083112855428, 0.16062012273459836, 0.19032766151858027, 0.16513012235643687, 0.17425922261597482, 0.16609316727079526, 0.16935978747225022, 0.055622389178725085, 0.06646848747331391, 0.06060138424886041, 0.06437210429664553, 0.06344274520833426, 0.06147542274431417, 0.05773955546092946, 0.05420139207868202, 0.07626234636831086]}, "mutation_prompt": null}
{"id": "f4d428b1-fcf6-4aff-9360-ff31f9602412", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "e0de4031-6ebd-4546-b4b2-090e7c9c61c2", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 / (1.0 + 0.9 * evals / self.budget)  # Adjusted cooling schedule for more gradual cooling\n    \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.8, 0.8)  # Changed distribution for chaotically motivated exploration\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.7 + 0.3 * evals / self.budget  # Adjusted scaling factor for better exploration in early stages\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An innovative blend of adaptive chaotic dynamics, enhanced stochastic tunneling, and dynamic population scaling to improve multi-modal black box optimization.", "configspace": "", "generation": 33, "fitness": 0.2790904625529605, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.16.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.38265375744831487, 0.3807300656215449, 0.3758166439905105, 0.3627653970138627, 0.3618817037968802, 0.38247736161900525, 0.3734596369054999, 0.3572401754460488, 0.37198387559934165, 0.3164265382960876, 0.3263990430388999, 0.3105345851663095, 0.24669601004454667, 0.32779479857775473, 0.2938833199663864, 0.3257077392575477, 0.3239933921805007, 0.3065223844288164, 0.13447993816227666, 0.1508615365636573, 0.10919149424229235, 0.14704657170014346, 0.13848490742281627, 0.16034822388440984, 0.12607478897645874, 0.2986208245379699, 0.13313553496097574, 0.12648402304809292, 0.12889030787009492, 0.09291965356770493, 0.12333746011626734, 0.1115425963457688, 0.08804668091528511, 0.09349313932537917, 0.09213854111991548, 0.14579325225745454, 0.7055876711678345, 0.6770738422996992, 0.7342559516733982, 0.8399310067255011, 0.6565781340871831, 0.8723034116364239, 0.7003340434395784, 0.756525145517269, 0.9272836630064324, 0.3005707712701984, 0.28178859404681866, 0.2529352109027917, 0.28151838419332775, 0.23250257388181805, 0.26664922411054925, 0.23220080274441035, 0.2523321178516237, 0.2864115594788442, 0.811365038670608, 0.6674170903717618, 0.407567414820482, 0.8964953893423288, 0.3229024864681451, 0.7214796343896809, 0.6730312460175731, 0.4716185288849284, 0.34307427215399633, 0.21028261003460325, 0.26703531280347337, 0.13154536860184873, 0.12759908344022008, 0.2881021571965796, 0.12407361131980366, 0.23828506911192726, 0.2333881120143354, 0.33085182380709655, 0.199356391538556, 0.1521446023359886, 0.25251808037815093, 0.3309218940493788, 0.22300155225881868, 0.2772036840496611, 0.27556233571896593, 0.1918717198513279, 0.13506790603539243, 0.3195553253051364, 0.3092172502099775, 0.3172018716048277, 0.33471895168440136, 0.2978897026857994, 0.3079912409895982, 0.29141454974010417, 0.30881067319167665, 0.32648786255828743, 0.33563551031162064, 0.3343840700513867, 0.33080825833998817, 0.364847656594526, 0.3733063154670545, 0.32067777313320023, 0.34695102251899934, 0.3384573220382895, 0.35738849335846057, 0.1776992680256959, 0.16324699544758337, 0.09499054732600964, 0.23745596127054325, 0.25924002227371334, 0.22041044085169603, 0.2724220748714986, 0.18965828539334162, 0.12822142788663315, 0.25338544574629207, 0.2434243409300576, 0.09175688622087819, 0.25048482346904843, 0.19875868626626447, 0.2547640129471104, 0.24979119246035975, 0.2402442115057274, 0.25122655516958303, 0.3859462270302687, 0.37679284872646, 0.35887687968538917, 0.3293946747492541, 0.36114081754474747, 0.3379424728443702, 0.3274182143137824, 0.3494472340088469, 0.3499050997866283, 0.13446132391943555, 0.1234446486754508, 0.13466034545629935, 0.10792486542903879, 0.17022826428561344, 0.14754408444510192, 0.15598285362037168, 0.17305595154838627, 0.12170216005160128, 0.2966054720037222, 0.1762059078405528, 0.19460423234532986, 0.3161071541331464, 0.29894772797932123, 0.1826409064457054, 0.2710670972221938, 0.23460160974263156, 0.34819058107823486, 0.27769328986727504, 0.28437947682654807, 0.27792707510957915, 0.2736399945290159, 0.27384252629566297, 0.2683556939817676, 0.2788618082187472, 0.28309820851219236, 0.2712934934687181, 0.2679235958092602, 0.27893272405120617, 0.27947101300564503, 0.26357923612978884, 0.2602335204605011, 0.25399670140016206, 0.27597995793458774, 0.270495217031387, 0.2763652610354337, 0.21771983645998183, 0.21022466301493936, 0.24930457279570584, 0.23378032822654837, 0.23957807339380732, 0.19330759231031203, 0.22131976671911957, 0.21320058306933976, 0.23457367686723085, 0.19702434666394497, 0.21115744117814106, 0.2083941839131792, 0.2717224149275447, 0.30191125482319103, 0.21510593564179015, 0.186608557590922, 0.19240462351459275, 0.3139463098812493, 0.5083799860816337, 0.16315060359663225, 0.20321642043535781, 0.1710679367352581, 0.18530967580768487, 0.45566335914930656, 0.48735435168261343, 0.471116129988427, 0.48488540841695194, 0.4668507582676048, 0.2087134711928681, 0.15383923254836063, 0.16132039924916441, 0.160882908860022, 0.16523860923219802, 0.20496111214204094, 0.20756393392589667, 0.20887708262044258, 0.20719104345427253, 0.20623035370503362, 0.21932088491690027, 0.18347735500440698, 0.18479945782974205, 0.19379115866868746, 0.1856170864497101, 0.18656488787569725, 0.20388806857328934, 0.0987402002232024, 0.09729322229442228, 0.09285549106214952, 0.1074863222927741, 0.08982213930184813, 0.1027014303448126, 0.09212186504262887, 0.10222038430826685, 0.08750911562872021]}, "mutation_prompt": null}
{"id": "722e3666-7e9b-4a20-85a6-7757e405a53b", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "1349431e-a0a9-4470-a91f-ea31cee406a6", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "45c9c26c-5e42-4610-9fd2-0084b88a3849", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "21be9792-54e1-48b2-bd3c-56ee6188e2f4", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_AdaptiveScaling_Elitist:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Altered cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Modified beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def adaptive_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def elitist_selection_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            best_indices = np.argsort(self.fitness)[:additional]\n            new_individuals = self.population[best_indices] + np.random.uniform(-0.1, 0.1, (additional, self.dim))\n            new_individuals = np.clip(new_individuals, self.lower_bound, self.upper_bound)\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.adaptive_tunneling(func, i, evals)\n                evals += 1\n            self.elitist_selection_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_AdaptiveScaling_Elitist", "description": "An enhanced hybrid approach using chaotic perturbation, adaptive tunneling, and scalable elitist selection for robust global optimization.", "configspace": "", "generation": 37, "fitness": 0.27405375887195876, "feedback": "The algorithm EnhancedHybridChaos_AdaptiveScaling_Elitist got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.4021246865881831, 0.35924794174387886, 0.37614520012420816, 0.39495686666029783, 0.367843520301705, 0.3608954799364974, 0.37290573051023834, 0.3775012589716161, 0.34541838511650347, 0.3166349603090912, 0.27861634265612234, 0.32262068649929176, 0.3277179188925039, 0.32421685466950856, 0.3250971846426358, 0.28102958514202936, 0.3147745689193423, 0.3358901211828583, 0.1366836723919792, 0.13643600640841946, 0.10244558609176224, 0.10149215235167719, 0.1328976373646661, 0.12665451870072775, 0.12833967942362834, 0.1294139588794495, 0.13303259446569282, 0.08379643789799351, 0.08474323377685089, 0.07300475997436973, 0.11674537553620667, 0.09118677931809815, 0.10609555300990836, 0.10161101693818453, 0.14267465595875506, 0.08849503183025231, 0.7631834666067079, 0.7318874835636935, 0.5793025077117857, 0.7065575659238492, 0.978834492218271, 0.9325708183094306, 0.7905969078698357, 0.5925226233803321, 0.9861484542345129, 0.2471123573093249, 0.21324595777791922, 0.3127195957951111, 0.2253786966752055, 0.2814499898344013, 0.2483138631843087, 0.2738327158785261, 0.2680046530635096, 0.23210797620812396, 0.7384625856720872, 0.42192404365521763, 0.35404447242804804, 0.7268265591208591, 0.2323552931558852, 0.6537382511266431, 0.662642037202682, 0.42909235712844074, 0.4186281870466906, 0.2783093413256307, 0.29830677102029923, 0.299677516597622, 0.128233368928936, 0.2735114774081914, 0.17158360432171083, 0.26975079822299075, 0.12827662030812603, 0.2828841030692649, 0.2389949712249132, 0.2511488711272277, 0.1616241164244917, 0.24714330054159228, 0.3291027627656883, 0.12995135298795446, 0.35939221639530583, 0.20120142760770554, 0.2612928733125738, 0.30884895361466147, 0.3103745040330146, 0.28624778701411757, 0.3056921595555835, 0.2782199182872872, 0.30278130975893813, 0.3193711703445964, 0.3607390563531483, 0.33199367437459315, 0.3459899032462236, 0.3595521714758837, 0.3580611031486942, 0.3568043256658049, 0.3064635206176941, 0.34910837054129296, 0.3406511271267747, 0.3278157453733711, 0.34809463280482733, 0.09538590600864716, 0.24835214705534747, 0.2428549744301275, 0.16905044193180307, 0.1536898472382422, 0.21585054706305395, 0.1776462283187249, 0.12241123916082175, 0.265490655471762, 0.2463588815551182, 0.24950245343019128, 0.2586770100953346, 0.2483051309123191, 0.25377301121473717, 0.24927588046714588, 0.2679461644001562, 0.22751158058014376, 0.27593033952284673, 0.32756402831965037, 0.34516934948732514, 0.36705673110703085, 0.3579871373328847, 0.3661349478018585, 0.345872994781669, 0.3562593031085738, 0.3498805450493373, 0.3367893349036376, 0.16115220723506885, 0.14959228845517958, 0.14899180454324434, 0.1528708016013618, 0.17460727713241375, 0.14089645788300986, 0.14441311051713523, 0.1327179721843793, 0.10974239640693217, 0.31705922148162313, 0.33749857038324327, 0.1541078182853054, 0.2334030804904409, 0.2049177761539408, 0.2747709249603364, 0.31943944521402134, 0.34741912912646844, 0.20233398848868955, 0.27920617524504354, 0.29011391633617445, 0.28268139573228557, 0.2908083897555911, 0.2797478691928086, 0.28116884939967035, 0.2877452763040462, 0.28904609737731335, 0.29252200553407215, 0.28393551935171124, 0.2815919751634117, 0.2613219048598706, 0.2650785108757081, 0.2684508109165751, 0.25747737224545664, 0.26721285727781274, 0.2693697260034972, 0.26774635507360367, 0.2064946964693536, 0.2114855455432234, 0.21484684039863877, 0.26009362960602045, 0.22049786348347922, 0.22693021055990126, 0.20574993488747872, 0.21644781203862817, 0.24892466891291432, 0.22334943292066078, 0.19772806112994012, 0.22749025039693416, 0.29344981395652425, 0.1928221283026642, 0.22699293952062738, 0.22335229157810133, 0.2219597328527435, 0.20516343097908818, 0.17002310720669433, 0.19755345959260173, 0.1460265952994767, 0.1670498062900364, 0.20058749155212652, 0.1571136403112514, 0.16420530255202814, 0.16735798864086082, 0.1612872191284661, 0.4797602014097957, 0.20824691483217972, 0.4880158015505096, 0.16469663153202818, 0.16423044103707218, 0.5380240166485688, 0.21090132860707878, 0.15512232984733487, 0.20448299091162525, 0.22237396637956375, 0.21708628025347165, 0.18728274644927967, 0.20974181443138218, 0.19804104132085198, 0.2095782259004978, 0.19642341259875973, 0.23105847117849188, 0.2004897396349562, 0.09454378031552879, 0.10591020444259414, 0.10690252112298637, 0.10714840228747813, 0.10125587654263402, 0.11007581699480617, 0.11512366258252738, 0.09775295479617685, 0.08640757849524638]}, "mutation_prompt": null}
{"id": "518d2d7a-7d7b-4439-85e7-4d6415057966", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - 0.95 * (evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.3, 0.7)  # Altered beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * (evals / self.budget)  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid optimizer using adaptive chaotic dynamics, stochastic tunneling, and dynamic population scaling for robust black box optimization.", "configspace": "", "generation": 38, "fitness": 0.2768444756325406, "feedback": "The algorithm NovelHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.41190071712070364, 0.38537052057283894, 0.39695694791108405, 0.38574919816802566, 0.38275588513970327, 0.3720600284657136, 0.36997513746565114, 0.38164027780180776, 0.4056903870639892, 0.325508409629365, 0.3282740626483577, 0.32026645258900455, 0.33178647878916234, 0.3691257395106834, 0.3376872751166805, 0.3339525171265364, 0.3254756881068671, 0.3243535837417859, 0.09482520004215289, 0.1047869432880898, 0.12745274662007144, 0.12806004908725177, 0.11844078987906959, 0.11347148868858092, 0.11406987042012406, 0.11182671694046908, 0.09356781407750092, 0.12026132410068513, 0.1115719090826065, 0.10787332261322369, 0.10763091417153281, 0.11148599852887331, 0.08902859516228978, 0.1208322315080046, 0.11456163414391818, 0.10658442951517388, 0.69918466420883, 0.5492843666375242, 0.9262865785007058, 0.7283871596397405, 0.4078567395637156, 0.6763806829206659, 0.6908495814866658, 0.6220632867602348, 0.48107846776907504, 0.27120273006700046, 0.28425042232665443, 0.28156098086268033, 0.2587001482394661, 0.29296021982974196, 0.28289448683324037, 0.29075385837871215, 0.3088323971327055, 0.2871623033748876, 0.7768887084618825, 0.585069892040722, 0.6091789702331392, 0.5022888866188742, 0.4560268380345568, 0.5763240978108823, 0.4327622426406489, 0.369234517084291, 0.4642314851071, 0.24782050204339368, 0.2764789966967991, 0.29734192338164067, 0.2727946150613495, 0.30990928003648055, 0.30439332464264446, 0.315390301386938, 0.3075361865274826, 0.28916555642934505, 0.23201757123293354, 0.06800975279333432, 0.2857911817979679, 0.31600262328359474, 0.29738750004348036, 0.31920054890170146, 0.2265345880589904, 0.28657300161147414, 0.25711364734913233, 0.3463372842221093, 0.3289262612151064, 0.32377743320398245, 0.3502431786771705, 0.3056374401218709, 0.3270347659924163, 0.32878646016978896, 0.3224778522185706, 0.328323945343614, 0.3541216425313741, 0.3744275713382188, 0.3650295102966332, 0.3488631168083596, 0.3399209837893262, 0.35009967378194584, 0.3498009550757615, 0.3504826663338638, 0.3632819305246937, 0.15644885110168127, 0.26767571066170115, 0.25849660236572514, 0.26383974297789925, 0.27782740253725924, 0.2935165047456779, 0.16117231325014725, 0.17570364308551722, 0.28205497621218933, 0.2615579526868018, 0.26280450793668375, 0.2629286908829278, 0.24401549573844294, 0.2578656385716628, 0.24761689361198713, 0.2566312092649179, 0.25639733647058005, 0.25798857516859863, 0.343979828988633, 0.3473750558637626, 0.3560836912584938, 0.35457083271091117, 0.3519875799450577, 0.35317108092417926, 0.3581316202573894, 0.34459266884026196, 0.36548001401026764, 0.09899466997640416, 0.12006677110556652, 0.09340087814406528, 0.12851108743673922, 0.10707604889052713, 0.09426530321840221, 0.13062810079316678, 0.10295882230678621, 0.09769170515805503, 0.23186595043630187, 0.2965379964050999, 0.14819331086655874, 0.1799855121315781, 0.3199195856387341, 0.16311541287307396, 0.3218479985096596, 0.20033054025362274, 0.1796360305891188, 0.2837931421633071, 0.2967578816874472, 0.29162103864699385, 0.2882127847915056, 0.2926347401025118, 0.2797477971902508, 0.29207580522388876, 0.29087580502724364, 0.28607862687216035, 0.27104284624305963, 0.26541797445126336, 0.27733972818910935, 0.2733609961939787, 0.2683122205156515, 0.2737739704537616, 0.2777496173039794, 0.2792256481101848, 0.2742835578227437, 0.20431490003295327, 0.1973380242319075, 0.19197490756614166, 0.20465987442366407, 0.2030318947914178, 0.20047549074501536, 0.19818411275375358, 0.21745125591354153, 0.19759918767008255, 0.17997627584105835, 0.2630858806494406, 0.21526314024717663, 0.20370889769138145, 0.24850561640526825, 0.21419219045046467, 0.20715129994429315, 0.17959278755828267, 0.19923119873322614, 0.1834443349493493, 0.18367417303446942, 0.5158947882855764, 0.5035025485183457, 0.18437428687751412, 0.4690093982059118, 0.4892895144854197, 0.16660646777834576, 0.4877580901887577, 0.5501963527664828, 0.20209661531249112, 0.19972291876994297, 0.20020859974726413, 0.1663182712155542, 0.2003380354133566, 0.20894406985403347, 0.20843175387563673, 0.15791547157025776, 0.18306213760912593, 0.1924954170771207, 0.18570962638203936, 0.17220043163208243, 0.19119305425608013, 0.178634258712575, 0.18290204765153162, 0.20844717123322687, 0.19718973293073683, 0.07415099270595116, 0.07589644592968414, 0.08709190289877822, 0.07761306457032457, 0.08726304930414353, 0.07496673479463023, 0.10425214774866176, 0.08009202527005543, 0.0809497733069684]}, "mutation_prompt": null}
{"id": "1ac6fffa-6aa2-4ab1-8f68-31a17d42d412", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.3, 0.7)  # Tuned chaotic factor range\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / (current_temp + 1e-8)):  # Avoid division by zero\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Slightly adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm combining adaptive chaos, dynamic exploration-exploitation balance, and stochastic tunneling for improved black box function optimization.", "configspace": "", "generation": 39, "fitness": 0.2732438140267786, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35870167808081876, 0.3474888617424028, 0.37722931584280284, 0.37531894868856575, 0.37296673904794075, 0.3844377156858261, 0.3752151427926843, 0.3602017438277644, 0.35473138698969164, 0.3330744810695686, 0.31191718950447433, 0.3057290121523708, 0.3329631114032465, 0.340196660894596, 0.32996462028907836, 0.32786500247365447, 0.31307799845266615, 0.3201633249494106, 0.10053953298093654, 0.10676099771628345, 0.12766958567922815, 0.11512887563106555, 0.13409781984355418, 0.11251066071154547, 0.11046550284919798, 0.11286900546242029, 0.09406200708553913, 0.10923083298382319, 0.11313901933091475, 0.1007582465758402, 0.10759706531460889, 0.11258268841946284, 0.09236727620548868, 0.1133014049432075, 0.10848742206788398, 0.11699227150758762, 0.5856279061181511, 0.7632029237655281, 0.8788289116085558, 0.8128016270778977, 0.6328951625807446, 0.5554101063088233, 0.7014247109143805, 0.5886379039776019, 0.6134842646271521, 0.24253791908133926, 0.2690966331299801, 0.28001625528581, 0.24754213677936643, 0.3120387257492174, 0.2638077154940447, 0.25610782250753505, 0.2992347060012135, 0.2701990948929285, 0.5354557702708909, 0.36658694794498603, 0.362229179530286, 0.396272738865735, 0.36996400219176984, 0.7571497560144173, 0.3472853627343171, 0.5078120935449619, 0.7181012984259347, 0.2912733275118242, 0.2960332952931387, 0.2905510722068987, 0.2243918929837565, 0.30592470448813114, 0.31363490913193104, 0.29879228365949706, 0.32554423116961584, 0.28429275421102074, 0.23145686782918085, 0.06823315291290788, 0.2845692873262329, 0.3137344227308425, 0.3290123046961576, 0.32441925100313207, 0.2285318173694022, 0.2919852709916214, 0.27110235615331135, 0.321733455131875, 0.30582791566653755, 0.3438699457856722, 0.31243652351045725, 0.32308501609630635, 0.30440952400123333, 0.34002758965018853, 0.32150793735233196, 0.3083410798924179, 0.3544098426720572, 0.35138406248800025, 0.33862936189199677, 0.32727356038456235, 0.3296551778991955, 0.40086542439143447, 0.3534497335529494, 0.3378125220152315, 0.33977540038954, 0.16307346747094176, 0.25841326401803355, 0.2684148285061213, 0.26315790242752135, 0.2735304615197963, 0.27403868153382227, 0.18146443001415624, 0.19073039938881098, 0.262457830597973, 0.25281910204297897, 0.24706913504047945, 0.25971113663671686, 0.23517632059011961, 0.25204269955981684, 0.24818146494985827, 0.25292794192172474, 0.2509516594056673, 0.25236871395509486, 0.3435671875146773, 0.342910179220279, 0.3650389517647834, 0.341839972156197, 0.3610120517030958, 0.33996410294441604, 0.3451066119432321, 0.34710896397256374, 0.33823492702822344, 0.09937293513895507, 0.11992577493303236, 0.09035716086859591, 0.12571246625022237, 0.11469053485748859, 0.09426530321840221, 0.1102928199665677, 0.10295882230678621, 0.09695560496089761, 0.22101383976764566, 0.29464504155422966, 0.16427392319824263, 0.16814735426462135, 0.30957654515055333, 0.1602283592449849, 0.30738675352636236, 0.22496025652089735, 0.1990351601122634, 0.2776396474195215, 0.28964610005124203, 0.29142239229698286, 0.2779561458323103, 0.275985946938611, 0.2784590311201237, 0.2880166033691215, 0.27790944807352336, 0.2876615072035261, 0.27262498372072785, 0.26106369061479595, 0.26548113273730867, 0.258952546791112, 0.2690563603005277, 0.2694373388516358, 0.2721590027364841, 0.26096405508395837, 0.2659145666308138, 0.20285922286757874, 0.1999523328269257, 0.19765696220277396, 0.20053074834329132, 0.20025668933410856, 0.2035450106695369, 0.1993396373597074, 0.20437045679651777, 0.19730200694222522, 0.25364377602346655, 0.20403905018894097, 0.1992333790377162, 0.19314428450213927, 0.23382650893336887, 0.18713552812450562, 0.19227074500322217, 0.17925831657278046, 0.1974965700437672, 0.1831983583961223, 0.18347237106435887, 0.5417970562537406, 0.48460385857097543, 0.1847903183057541, 0.5120543336236831, 0.47675145999098967, 0.1667254587312773, 0.4705171764658632, 0.5240237175459629, 0.2017017577989254, 0.19977722280465748, 0.21872331114775256, 0.16628366560148677, 0.2005135739197068, 0.2091069843662572, 0.20830772655621344, 0.16497370996649985, 0.19532527775817243, 0.19507909489160613, 0.1963925325848208, 0.16887020473561787, 0.19225180102894923, 0.208966957841897, 0.17987370088134136, 0.20750815660181354, 0.19701817537952815, 0.07415099270595116, 0.07589644592968414, 0.08709190289877822, 0.07761306457032457, 0.08726304930414353, 0.08518426603374973, 0.10425214774866176, 0.07679935619888778, 0.0809497733069684]}, "mutation_prompt": null}
{"id": "515a865c-0dc9-4f92-97b1-8b97ea332637", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "6993fd0e-e474-4d9e-ac10-b811beefef3a", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule for faster convergence\n    \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Changed beta distribution for more variance\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Slightly altered scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm using adaptive chaos, stochastic tunneling, and dynamic scaling with enhanced selection pressure for black box optimization.", "configspace": "", "generation": 41, "fitness": 0.2715028930505828, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.14.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.41535972006259914, 0.3906784063001444, 0.34706213224769067, 0.3678430492746586, 0.3799112303462038, 0.37467800519572314, 0.3796290776902169, 0.3812922227716584, 0.36302335375475525, 0.30156874161015534, 0.3169587377748563, 0.3269250643935234, 0.3103949908603255, 0.3378510054727554, 0.3105500296207432, 0.286526395140249, 0.3011177853445165, 0.3083239104841775, 0.10834495455553383, 0.11902239221758482, 0.1390978634031983, 0.14281638997168666, 0.1310564775591725, 0.2555646737715661, 0.1375501273136528, 0.15432723024460626, 0.13511728403233103, 0.09912477053390045, 0.10888182614532305, 0.13777033771319525, 0.09763872027343445, 0.07452603863737839, 0.12266231503698177, 0.11170376366086499, 0.09834778670204725, 0.12001919418031226, 0.6736383217790165, 0.9640974453300649, 0.823831865196653, 0.6729991145276168, 0.7850257868517518, 0.7610447946140868, 0.688562697641673, 0.9243476081621107, 0.609085183479825, 0.2458711430393209, 0.22180735537893137, 0.21591462135902273, 0.2897542550542962, 0.25366595940020487, 0.27309889777462293, 0.2558471562448371, 0.2766543558794714, 0.2588688663636254, 0.6089427819322373, 0.46387581940909806, 0.7216156812361676, 0.45371889562983336, 0.41969163146030875, 0.3852820257057863, 0.3496075942604895, 0.3479730634880257, 0.5838992599877286, 0.23441251902651206, 0.17956326440873605, 0.26956392158499054, 0.192987615916836, 0.19365288490822685, 0.2354798904404739, 0.27232604360099555, 0.20987235082956368, 0.22782650294563722, 0.32702122903977815, 0.13009856724265245, 0.2612345843064595, 0.18764828919407972, 0.22913465669622612, 0.2943103043521813, 0.1981122359154508, 0.15751033289423577, 0.23927463620574962, 0.3051912188092496, 0.2827483488314443, 0.287234458628557, 0.27929811408940897, 0.292158172125881, 0.26886066337755177, 0.3093504155701339, 0.3107399738447775, 0.3012018277588192, 0.3479829430694291, 0.33031498915160473, 0.33788237583169456, 0.33462937454954966, 0.358780292595831, 0.33315442993633937, 0.3503791458131774, 0.3429192427356612, 0.344439853022362, 0.21735660461078, 0.16809104318015577, 0.24663156125069685, 0.2535219227457619, 0.2373092909762935, 0.22774527718936055, 0.19299213879783828, 0.2303324354320122, 0.17561082644253, 0.23906147843395298, 0.24675611508291462, 0.24315852589942322, 0.23030757321555673, 0.2453049659063249, 0.23639834604932797, 0.2390266481344605, 0.24890061278947317, 0.242358288243799, 0.3608335019613622, 0.3415824249023359, 0.3492889630417889, 0.34819007554217785, 0.34098593345518124, 0.348738536472753, 0.3472233716675772, 0.34432312359853356, 0.3491454849118222, 0.12677044654568603, 0.17112934515175438, 0.13786265289632194, 0.11585011220397823, 0.1210506885306526, 0.14803469260029867, 0.17025697057404632, 0.13637852542873263, 0.153054494549835, 0.29644040787813297, 0.2327925395015079, 0.2618706177671112, 0.20512331321056432, 0.30350235102625933, 0.35919786641737894, 0.2288739116537014, 0.2534871647618605, 0.3323922164282014, 0.29595491279767283, 0.2925636249673548, 0.2977761133428031, 0.28861027604614486, 0.2723431116839149, 0.2870422918950639, 0.28102447128649943, 0.2820719981729145, 0.2933197329678643, 0.276329096685334, 0.27727879164868274, 0.2625981867183612, 0.26471370018127705, 0.2599914948385883, 0.25274856041594695, 0.27233107631670417, 0.2608619828501718, 0.23160490391089184, 0.22033940219590586, 0.21202838055746165, 0.2032630270376058, 0.23678951680161997, 0.20893364705228512, 0.21630231641286723, 0.23538652388153603, 0.23151904271602286, 0.2149700777275957, 0.18783714343432056, 0.22511402900107702, 0.2103795575635673, 0.2304186642442504, 0.2101254539757893, 0.1943870390654706, 0.20044322014050575, 0.23694328178024882, 0.23825531664570476, 0.16103336751067876, 0.1838175657545138, 0.20512441250308233, 0.16539927445432112, 0.1974713336218913, 0.18988374720741452, 0.5128058668400735, 0.16492723968061984, 0.16584011388241815, 0.20323456200365542, 0.2094480894033488, 0.5332138415296988, 0.4305644002514669, 0.20571356016391906, 0.15061586103494706, 0.2085104291470783, 0.2058923452878506, 0.22480075291226143, 0.1862015219924501, 0.1946338833147001, 0.1967403783858246, 0.19981483672515699, 0.2270328314953628, 0.20728723044987718, 0.21493885882974806, 0.20457851390663218, 0.22005230348508653, 0.08548170884098216, 0.10003668073008354, 0.08518063661239417, 0.09261917000560738, 0.09947577002788455, 0.08984714240630787, 0.09371834765503495, 0.09821300846852443, 0.08334810364994771]}, "mutation_prompt": null}
{"id": "1f1d613c-7836-4ae1-929b-b43f4b05b190", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Adjusted beta distribution parameters\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.7 + 0.3 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm using adaptive chaos, stochastic tunneling, and dynamic population scaling for superior black box optimization.", "configspace": "", "generation": 42, "fitness": 0.2750104009823509, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.36506439547576974, 0.33764937900736725, 0.3647092231563651, 0.36617184402108816, 0.35449260076327127, 0.3689863015460709, 0.4018425907900248, 0.36534173407730774, 0.35715433185406675, 0.32024722164295494, 0.3082682966349174, 0.3105521096132161, 0.2938526760463235, 0.2958361535531403, 0.24505003041630102, 0.2812678728295277, 0.2912942037776912, 0.31883669487466315, 0.13121670261150487, 0.14866877979831028, 0.13335196713435638, 0.11225052276428782, 0.13398719440567508, 0.14602528282430682, 0.10669603106076497, 0.14810054993006616, 0.1389896280916908, 0.09874119798406045, 0.1108235234658621, 0.09496988397147776, 0.1639872967587035, 0.07471430156111858, 0.11117896293773133, 0.1315254288034381, 0.11992276989953843, 0.12165809467809108, 0.9545078411101345, 0.70510752708303, 0.9398747948734149, 0.5828338334580876, 0.7632664147159675, 0.6195706236511904, 0.8951307677119112, 0.7488177911071427, 0.6659942896798459, 0.2729003804026078, 0.26943464969502984, 0.2809717898808173, 0.28226322410150095, 0.26316344370981204, 0.24205662862531852, 0.24584864891402858, 0.29977566929205335, 0.2804288548955064, 0.4856128460667316, 0.5003761889409581, 0.34429186251476507, 0.569632571330057, 0.6826444085874446, 0.5390127873316221, 0.4930376334384574, 0.660198416212626, 0.4329223238061638, 0.23601536740231865, 0.12106542637938766, 0.2436255146778844, 0.2877758078813566, 0.2134391281568272, 0.2652518834438321, 0.18998138175698942, 0.3427990716931948, 0.2799444675700814, 0.1985331093261492, 0.2646748360760127, 0.28137758947266656, 0.18205716925616244, 0.24235594144511108, 0.12222201221429119, 0.16995735903294773, 0.19194393300664092, 0.2197361660306023, 0.3147375183681501, 0.285826517601512, 0.30901559054156924, 0.23538251839700874, 0.3066203711894858, 0.3000750887940914, 0.33892546881410857, 0.29615074727896396, 0.3136327785232067, 0.3520555967102035, 0.3416332894996572, 0.3396288139029775, 0.3234383576659917, 0.3338378563133826, 0.3580979720996872, 0.33191358601238263, 0.35202195318439, 0.26316196370175016, 0.25648371695275196, 0.13998659346502662, 0.09694030989142488, 0.23806544595315582, 0.16703369734960483, 0.2649806058984976, 0.2562616748952713, 0.18995978574150685, 0.21154452419153658, 0.2383628786123767, 0.24197951191173817, 0.23193834850120598, 0.23579620182127314, 0.25075340143363267, 0.2236364195228181, 0.24599102650382088, 0.23443503897894835, 0.2696383777949998, 0.3658454745257086, 0.33969824769969625, 0.37123690494529804, 0.36935637562483936, 0.36534222089526536, 0.314627542807163, 0.36369784004025973, 0.34543371853013183, 0.3442064651809891, 0.1708971810428357, 0.12559310381193334, 0.12523939529693728, 0.11022531216204046, 0.12159261405215405, 0.12162977133785735, 0.14910394694863394, 0.11669223727548084, 0.1295590896130645, 0.34407572549297105, 0.20894882451707386, 0.24392652440544993, 0.30072716599952354, 0.28975065417207, 0.2732807138792068, 0.23028610460844035, 0.31011582918822034, 0.29868502726347723, 0.27707455195444386, 0.29109995579730985, 0.28967433901832507, 0.28164296588940285, 0.2812885327509378, 0.2843951127057368, 0.27439394902210956, 0.28375730059856163, 0.2861763922080238, 0.27329247266390166, 0.27140832451907027, 0.28150409266620846, 0.2567933272084775, 0.2645106100232554, 0.2715923887607735, 0.277441093715487, 0.26671796761518884, 0.25872521171935514, 0.21964325096777582, 0.25196974150957696, 0.21560654594513795, 0.2752881779751881, 0.2419889819516332, 0.1985681807101497, 0.23694015025183457, 0.3948941735803313, 0.21085550915279505, 0.19707922132168043, 0.22726652884500953, 0.2393685305027683, 0.18929735233834788, 0.2306438886515878, 0.21417264089996346, 0.2165853935363743, 0.20847070425933611, 0.20631588817727864, 0.18319056382936805, 0.18524738445515254, 0.20893163070994814, 0.12198155168808023, 0.19557703685351424, 0.4654334571897366, 0.4926685913725327, 0.16651417675822944, 0.5420826891309256, 0.4905508867896178, 0.20585831082397732, 0.15046913653960114, 0.4973067559473934, 0.1568613753022895, 0.14243144908840144, 0.12526025960626208, 0.20898504138544238, 0.2057219091288015, 0.19912774355379814, 0.19570676310819923, 0.18470307416162834, 0.19271079435455962, 0.2159710586896041, 0.24669373230596225, 0.2079445452813653, 0.22608884754644676, 0.1991868925527941, 0.08955390108293049, 0.09469340273547955, 0.09404830704413891, 0.09626175595755815, 0.0903988965265784, 0.09986843538061696, 0.09531606006849436, 0.0968835595179216, 0.09999747225255373]}, "mutation_prompt": null}
{"id": "6e5cd5ba-ff2d-4205-a21e-9c2773dc6d59", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "0eb7db1f-9aee-418a-8fb7-e60f543b3259", "solution": "import numpy as np\n\nclass EnhancedHybrid_ChaosAnnealing_Topology:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 / (1.0 + (0.9 * evals / self.budget))  # Changed to annealing schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.3, 0.7)  # Adjusted beta distribution parameters\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_annealing(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_topology_adjustment(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_annealing(func, i, evals)\n                evals += 1\n            self.dynamic_topology_adjustment(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybrid_ChaosAnnealing_Topology", "description": "An enhanced hybrid algorithm integrating adaptive chaos, annealed tunneling, and dynamic topology adjustment for robust black box optimization.", "configspace": "", "generation": 44, "fitness": 0.16643015066433212, "feedback": "The algorithm EnhancedHybrid_ChaosAnnealing_Topology got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.13.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.2456240625579983, 0.3232358449075279, 0.2988807170133496, 0.35031645812478085, 0.1862401066901852, 0.35464454911553445, 0.2552066643059868, 0.37525587340688815, 0.18082354938080392, 9.999999999998899e-05, 0.0787310705364378, 0.002055074033036397, 9.999999999998899e-05, 0.10328152091880072, 9.999999999998899e-05, 9.999999999998899e-05, 0.0645940531235406, 9.999999999998899e-05, 0.09505303251531427, 0.0950595542895537, 0.0849948355059511, 0.06354799381020981, 0.12024142904565083, 0.11787488309122751, 0.05883420859161126, 0.08611669306424008, 0.07180135450709435, 0.09191319684111077, 0.06233733031863398, 0.04696452678088758, 0.10977597799168248, 0.04213108611598837, 0.07493155671504848, 0.08418365676095341, 0.06544379872934403, 0.07937418884724923, 0.5844278414811179, 0.5645719937690663, 0.4111322459792529, 0.27537039474810454, 0.5685576523327658, 0.6699978110759959, 0.7198552563792615, 0.6865957075633511, 0.4928505637108249, 0.11565403903794835, 0.06718629207002291, 0.09119097269606591, 0.15054364019012934, 0.11521638860970873, 0.1779588472364796, 0.14240735083093714, 0.12020934736071542, 0.30111949150557715, 0.20839500122657906, 0.3539752408618282, 0.1397063034376217, 0.16039591712534695, 0.19462915344585985, 0.3139159021868493, 0.17102595412152133, 0.19011836898408752, 0.23126256985935956, 0.06891383462467571, 0.1277657456926603, 0.12323757397279356, 0.03345022992111557, 0.1589742796463839, 9.999999999998899e-05, 0.12375360049172801, 0.0770184397445064, 0.09136184965682392, 0.13317151937529248, 0.07761812903973986, 9.999999999998899e-05, 0.06784998464233927, 0.15361436265782524, 0.09545816772362214, 0.10377886016058857, 9.999999999998899e-05, 0.12231315854597524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029410601791678204, 0.09350599531717108, 0.0007266682556784643, 9.999999999998899e-05, 0.06089177546101732, 0.12510998801261863, 0.15004781407889878, 0.27386270746810837, 0.13236506579156326, 0.17785392691314172, 0.22431068447612745, 0.09641439867791501, 0.10942719810952817, 0.15558367172466192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11825996527459648, 9.999999999998899e-05, 9.999999999998899e-05, 0.07553080410730961, 0.09396194167215921, 0.017062226794542057, 0.009050691068713923, 0.09210568876747405, 9.999999999998899e-05, 0.13853587137847012, 0.010898535612202997, 0.0003033699973098436, 9.999999999998899e-05, 9.999999999998899e-05, 0.3524485379814367, 0.26975031000206984, 0.1903287482082091, 0.27001001829144144, 0.3135827634914905, 0.3920656750822631, 0.358434359064715, 0.34512192437458467, 0.37689230427447395, 0.09149506927445761, 0.035682918176342726, 0.09376751067285638, 0.08193776354742044, 0.09714610942112523, 0.09136177605948159, 0.11785825411229711, 0.12751670696766326, 0.0895370442424619, 0.18311537473882777, 0.20774042836329665, 0.22694050968184531, 0.15851413769688083, 0.19657910783898203, 0.19839379221762488, 0.1626444430818088, 0.15412987176223358, 0.17864526726030616, 0.27927317868708657, 0.21365933240835044, 0.23359101251622338, 0.24223969145003954, 0.196731691429893, 0.27555170290293574, 0.24907344217812077, 0.2515527676123267, 0.16327716446891027, 0.2111128880777724, 0.19566118383645192, 0.15691453400827815, 0.18660749567435297, 0.18029375260276626, 0.1704999269612859, 0.2593231728081121, 0.30611139693195377, 0.18698505593831838, 0.24721716508189995, 0.23166195117343413, 0.27701814196777297, 0.25260006292646053, 0.22523039088419927, 0.20617617172855807, 0.22430610605176515, 0.2607721679672289, 0.26830073224165774, 0.1922066447030143, 0.18551571561939384, 0.16722696627530964, 0.1839317500153811, 0.18221929850432084, 0.17420126352401344, 0.1738557819609554, 0.20573377139404636, 0.18818123224046945, 0.16584820069770745, 0.3178332031054757, 0.16501275124506487, 0.17003937558755533, 0.19194108379377461, 0.16704935983187919, 0.14184851341159443, 0.16233101417939577, 0.41583912703044557, 0.33554081438525873, 0.19751721926231625, 0.19736375524814065, 0.25191732068112926, 0.1382544597572658, 0.1668576025028442, 0.11028749031490448, 0.20634492088569678, 0.2980724150369154, 0.2037560209711985, 0.24524254901407205, 0.22868846758479267, 0.24680518544115448, 0.22457142365784355, 0.20936710243478818, 0.2139241110044905, 0.20944828015873695, 0.24448511781745097, 0.06725126689109806, 0.07210215513139884, 0.06757893511253954, 0.08408173957692266, 0.0944895913610857, 0.08632991223936137, 0.09409006965012379, 0.08216084764542231, 0.07474728809628506]}, "mutation_prompt": null}
{"id": "4b83c51c-06f1-40bd-bbf9-82fa240e1a04", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.4)  # Changed beta distribution parameters\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm using chaos-induced mutation, stochastic tunneling, and adaptive population dynamics for improved black box optimization.", "configspace": "", "generation": 45, "fitness": 0.2699996605042736, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35529281830007986, 0.35043003417739205, 0.3435374803860398, 0.34824865024212437, 0.34001799480357997, 0.35464606852053693, 0.354398228562259, 0.34227321326107407, 0.34786539444553577, 0.27566374176690855, 0.2807286697184671, 0.28175974085190614, 0.2837445579516884, 0.29580206883693905, 0.2813562619353597, 0.2656102076470671, 0.29814717177562644, 0.2722711017064001, 0.1161835312261339, 0.15267874324467157, 0.12966114805390205, 0.12205455510352636, 0.16424505843761728, 0.10864723217015781, 0.10413337726525784, 0.1267012961426104, 0.11205123993071897, 0.07620384473016095, 0.1185301863560051, 0.09651167123907922, 0.11749367985343429, 0.08936175641550304, 0.12571151076772435, 0.11574382315513254, 0.10268139017901246, 0.12319604494981029, 0.8322379087857942, 0.8359687047100445, 0.9083768336429943, 0.8776086812022458, 0.42064246993271426, 0.9344315481807348, 0.8319671545369164, 0.8407626050110718, 0.7599318237856046, 0.26365506245021697, 0.2580426465146989, 0.24626182293083276, 0.2575790752423063, 0.2834945018115548, 0.25252278483587565, 0.2685487303246251, 0.2962270294709033, 0.24943449928605865, 0.47154503768792444, 0.3586659525338761, 0.3590517380597197, 0.33350292860110764, 0.33475689070269576, 0.43163769119813444, 0.44493764552078485, 0.5846312379123636, 0.638031687464856, 0.29848336299665257, 0.24503549057869645, 0.24670990415223482, 0.23218444027109597, 0.23990450034670796, 0.2683854449002957, 0.2763128630512556, 0.3159511111211747, 0.27987366171582995, 0.12797877833097504, 0.2387651974608076, 0.2173160175005432, 0.23394031538630577, 0.19980024498211502, 0.25566826624901406, 0.26497078537531416, 0.20433459208480131, 0.2615425327260962, 0.28040310277211444, 0.28456317747057447, 0.28152875464495797, 0.26590234113818867, 0.2829179206746839, 0.26681410215001444, 0.262653432534805, 0.2663290756824712, 0.2655094747790988, 0.29916425722971085, 0.3139012794608025, 0.33027004087253675, 0.32054205793280066, 0.3453678877529299, 0.30987572704281874, 0.3310363465573598, 0.31700569519518895, 0.3094122232622015, 0.1933204769514989, 0.15104631386149592, 0.22086271656480372, 0.2198776319735689, 0.1474779270381903, 0.22951912691042442, 0.19195624008105538, 0.15020113269228108, 0.14002460799907823, 0.22907931666285053, 0.22794783025283816, 0.21560314488321952, 0.21224354792633016, 0.22550931964456566, 0.2407722871806227, 0.22587533748838773, 0.2346620756340272, 0.2068289733645674, 0.33151950332746083, 0.35975568073481956, 0.34290181181588053, 0.31235325948106285, 0.3313384713959965, 0.32994474146693287, 0.3475789967944546, 0.36170749652939016, 0.32824514158665286, 0.1059023426161586, 0.13428738557022812, 0.11862653164694748, 0.16277062248611385, 0.09953388567803445, 0.1261090863656278, 0.11789596742124064, 0.13127132595011604, 0.1377584863570135, 0.3068176307190452, 0.3188674494469337, 0.280635909619781, 0.348825215040821, 0.2743272849065175, 0.24373655738903277, 0.25293663281682, 0.2742189156357777, 0.29826514044686014, 0.26534097728608663, 0.2683153392688902, 0.2707329248104242, 0.27368786964428027, 0.2735866675138421, 0.2653376197586992, 0.2542416972040501, 0.28044497682107294, 0.2602482332395517, 0.24959857341121028, 0.26355546466766366, 0.2612364191352634, 0.2608940479546682, 0.2586129628125544, 0.2639253475884953, 0.2565274146401324, 0.2616955243848168, 0.2541933814500261, 0.20524302060705912, 0.2279006852330263, 0.2035473155395534, 0.20948952670556686, 0.19148779055546972, 0.21149489089400153, 0.21503626753959715, 0.21849215890398976, 0.21347600639487285, 0.22086517338082778, 0.20869942962521748, 0.20366897230751502, 0.18803787135479133, 0.2684675933498566, 0.21930692086791248, 0.21625101967956462, 0.20408705486487178, 0.20030193591890788, 0.19168944717464798, 0.2045874696816703, 0.49255643083739764, 0.17951893289033127, 0.1911603913539036, 0.17177137150921584, 0.16036454339656792, 0.4800429976922216, 0.4804776237701165, 0.48528629968271264, 0.4473217452753375, 0.38990104927079505, 0.1652591134187953, 0.4670165949724826, 0.166225566249801, 0.20756317393858148, 0.4734299291975613, 0.2200729086075367, 0.22178170194186242, 0.21260342444604807, 0.18759781168612322, 0.18370799420635353, 0.1927299272764319, 0.22612604929969726, 0.18344235194725822, 0.1998281512597878, 0.21108318747834165, 0.10932605833136821, 0.08223635059602874, 0.08878503429035278, 0.08508766106145671, 0.1019735419465494, 0.09439209565249984, 0.09819809806134328, 0.08211881573521695, 0.08730167628758168]}, "mutation_prompt": null}
{"id": "695661c8-b4e9-4681-93d8-256d61eef67f", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "f18578cd-bd25-43a3-a4ec-b685d03ee73f", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "cd53d6bf-174d-44a7-8d54-0f156bcedd1a", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "3516cf29-7cda-4fe6-ac77-a3d07e128f52", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "3f03a254-eed2-43bf-96d4-13d29c67c3ef", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "a52093dc-a28d-4a08-87f0-8119e75d1056", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Slightly adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Adjusted beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm leveraging enhanced chaos dynamics, dynamic tunneling, and adaptive population scaling for improved black box optimization.", "configspace": "", "generation": 51, "fitness": 0.2789603289428318, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.16.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3896925620682018, 0.37064534844553254, 0.3666377553140182, 0.4130941147525594, 0.38412595789307347, 0.3929891107063964, 0.3816190169094149, 0.38272262212181574, 0.3660866506355829, 0.3306999297259454, 0.35388922511302656, 0.2997957911185678, 0.3075534566137713, 0.3196271028971879, 0.3308272621286211, 0.31571050653470056, 0.31263483829599015, 0.20183378739019375, 0.11270070106511798, 0.17423169238124114, 0.10205404781628935, 0.11119313452309432, 0.3247007255482438, 0.13765261460460965, 0.11743795248421396, 0.12475047828341812, 0.12719535041148888, 0.08711361036596899, 0.10375438222752476, 0.08952644958155254, 0.10709712719804809, 0.10370382248790133, 0.10241495952478386, 0.0913969069311803, 0.11688721388170176, 0.08995285292292066, 0.7818394879362247, 0.8423247776070448, 0.9737066969466339, 0.7452464678611388, 0.8494158403391463, 0.7206060586539469, 0.7167863342589186, 0.6422905737488127, 0.8930678971522965, 0.27140092982366837, 0.2574846937672014, 0.28570425210982364, 0.3044972295913565, 0.2987652938190555, 0.2533498727823167, 0.24822236628270944, 0.2544329393045792, 0.25718931717702687, 0.6149249875963043, 0.7369477619227995, 0.7485618707508994, 0.6529380557749196, 0.5166017751109592, 0.39265173488760685, 0.3971511473713176, 0.46062911571266907, 0.5930130545511652, 0.27666127427782117, 0.22100640244479797, 0.2313727938079937, 0.12877260230958232, 0.3061734131453855, 0.21391463507646769, 0.28495699543411357, 0.3200166784663355, 0.1262676992805305, 0.15200659862277788, 0.24376670262510347, 0.14426495236675307, 0.31626742385561235, 0.24121002714309725, 0.12767585606655807, 0.17668271160500104, 0.30299769434246504, 0.3124665592621102, 0.34280576816637953, 0.31766445551123623, 0.3102125435746169, 0.3388751941895045, 0.3300998385955217, 0.18072877517841157, 0.33445062687147364, 0.31560288891087673, 0.33553105474936795, 0.34336128661892384, 0.33938434893252367, 0.40562995726274087, 0.3607610815032377, 0.32982138648863035, 0.37702634339349983, 0.374362603335069, 0.33525634238521884, 0.3181383892673524, 0.10206781301037882, 0.10451200952943795, 0.10384390052679682, 0.28789002379771844, 0.25364036456725847, 0.17709605968712205, 0.14760597591974, 0.14230679254773315, 0.2586080414289261, 0.25437677045456597, 0.24547504596407121, 0.2931577682837767, 0.17967634833410717, 0.262633977347118, 0.22866137282286325, 0.24665269163434367, 0.23229796541929792, 0.26470831497121194, 0.3532558520378756, 0.3571789865455556, 0.3506661936203923, 0.38246054387763473, 0.36155643399346693, 0.3484079763646317, 0.3761368212131493, 0.38570092879032536, 0.3338053814339994, 0.306629202906502, 0.14112400750492327, 0.13549085585926335, 0.12641868005102386, 0.171281844244777, 0.10739090662562323, 0.1344230897949361, 0.08879469762094305, 0.10522759172463192, 0.23439160131267334, 0.3024111489374355, 0.19453811420753175, 0.2206286938210561, 0.30255730221081956, 0.2425537306449782, 0.20961175380466646, 0.21025029588229927, 0.3209093618066018, 0.27799195867766535, 0.28906660821591146, 0.2908828171467128, 0.29044195044201704, 0.2888316777384504, 0.28167329702009203, 0.3091732992535049, 0.2915372338259764, 0.2900459910681006, 0.27048396498405924, 0.2818198982247333, 0.2763081618495059, 0.2852088944785389, 0.2443562199618523, 0.26002241782079094, 0.28607313562068615, 0.2828283658254107, 0.267678434600805, 0.2448436402664913, 0.2236510827382735, 0.2410054884585432, 0.22160538760102078, 0.2321952979856977, 0.23864375378107805, 0.2626148182139688, 0.2389651944137836, 0.21936165430335963, 0.1955944696511659, 0.20860059961708755, 0.19071626972781996, 0.18895672648366424, 0.2078977676348599, 0.1941890247958432, 0.18510348093184514, 0.19398843563131374, 0.20215030565329095, 0.1691414489119576, 0.16719579665202877, 0.15201779192673925, 0.19401674863227902, 0.18404905186019793, 0.19285214150739427, 0.16779063853098164, 0.5218026140811527, 0.20094102793067858, 0.4616614576456589, 0.20286574709687866, 0.5276896983561303, 0.16137405079870337, 0.4887727458736395, 0.1625143791531788, 0.20997883513007576, 0.20755406853438885, 0.2067702899740218, 0.20869771623368372, 0.21381934203761566, 0.20125655464555026, 0.2378556516094089, 0.1998520854246234, 0.21289426916528364, 0.21607952079283366, 0.247456737932919, 0.23350716040150066, 0.1064853803087179, 0.13319153834149888, 0.09622333167691, 0.08335733408807466, 0.09629284492644308, 0.11665156330915283, 0.08176446981167718, 0.08961914577022945, 0.08802341603981934]}, "mutation_prompt": null}
{"id": "8c5d63bc-b06e-41e9-bb86-57c8e42db3c5", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule for sharper early search\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.4)  # Adjusted beta distribution for mutation\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_population_control(self, evals):\n        factor = 0.5 + 0.4 * evals / self.budget  # Modified scaling factor for gradual expansion\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.dynamic_population_control(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Dynamic", "description": "A refined hybrid algorithm integrating adaptive chaos, stochastic tunneling, and dynamic population control for robust black box optimization.", "configspace": "", "generation": 52, "fitness": 0.2729312713584847, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3829707417007032, 0.3493823952520615, 0.38205144855842965, 0.3697805607383834, 0.3785128918334958, 0.35847747058236223, 0.3679288050004318, 0.352879385263847, 0.35612719492094547, 0.31611444088410334, 0.3136684168311151, 0.2981950582821311, 0.3272647943539988, 0.30911426554286514, 0.31182537036572844, 0.3202376043766457, 0.3035921570868001, 0.29618964859872776, 0.16744680767579612, 0.15428223396055651, 0.13153595464382994, 0.10749758918298613, 0.14337747087122443, 0.12621362725160512, 0.13241530211393238, 0.14747952325856184, 0.14300610617502574, 0.099200100301153, 0.1053972556066537, 0.09766805409699686, 0.08843828020698041, 0.08802789576637515, 0.11538018394738969, 0.146543076785568, 0.0793350636142448, 0.09891776474828695, 0.8881662160735835, 0.9053438836392421, 0.7602864319500103, 0.8435755347824123, 0.9188031419700855, 0.5417220037180666, 0.8909546371692695, 0.6924402503762719, 0.6996618051029857, 0.2733479722874764, 0.262539892399852, 0.2653099288679992, 0.2734225746984139, 0.26681516779571546, 0.2793464947940435, 0.2758088624635605, 0.2710759809032841, 0.2950171868344773, 0.4533648870209932, 0.5844024574175516, 0.45794312558370087, 0.36861114642459103, 0.37326200895759, 0.36843594652058487, 0.3436639453487781, 0.3507145199527495, 0.4772266325211105, 0.15708147681198592, 0.2999783119234156, 0.24884411915834181, 0.22353925028884503, 0.29557881259046803, 0.24245774104826845, 0.20591315012331757, 0.1251668015548888, 0.28277649135089333, 0.2726014802865405, 0.2047874333478481, 0.3299044934164369, 0.28620759763645787, 0.26613903272359873, 0.2553061388128578, 0.30244835609328624, 0.23793022504392547, 0.12295429836973948, 0.2651926947079749, 0.29249297348244785, 0.29132078429461183, 0.31076420776727587, 0.31066390545864575, 0.29485701743266735, 0.28866084909976997, 0.3028427201053592, 0.2648745456532795, 0.3723266427726243, 0.34560047159879326, 0.3305189950363583, 0.32774805421252406, 0.34161271612746014, 0.3324775689953734, 0.32189487753677515, 0.3442795454464679, 0.3305391916704147, 0.1697879452735006, 0.2037902634301566, 0.1381190246486198, 0.2402036025307538, 0.1894989200121292, 0.19811758272191105, 0.2541477022442623, 0.12306206166539013, 0.2190234718317684, 0.2339458635415106, 0.2280158983606736, 0.22843153796806925, 0.2283737213919882, 0.22804192697490966, 0.23736141179026782, 0.21895500514106625, 0.24217690545427517, 0.24922998173785504, 0.3416667458176367, 0.34746196773857985, 0.3398756322156876, 0.34638640246292274, 0.32493998546787395, 0.3134329011682193, 0.3570748551489128, 0.3430257984718318, 0.35928286609251014, 0.13457335534535064, 0.09865309915484088, 0.14760026232952006, 0.1351797998563583, 0.1581717315601212, 0.11884343276736509, 0.1717201438321012, 0.10855898106844675, 0.09507622022587969, 0.2591134058940624, 0.32450587334011916, 0.1705284160698064, 0.32337793663488246, 0.3095523269933822, 0.27888774844890396, 0.3069468588353952, 0.314873142864019, 0.2916987905957644, 0.2708222290287827, 0.2817526180908779, 0.27653337475152007, 0.2668722225193708, 0.27242084888619933, 0.2560144844262001, 0.2755580102881785, 0.288759907989922, 0.2697685094035973, 0.2619856672687846, 0.2686645179970837, 0.269877711876119, 0.2615772153400543, 0.26101024714876375, 0.25620631482027434, 0.2523197789280597, 0.26099610930843264, 0.2573046153980997, 0.19837344367194465, 0.2231723104577894, 0.1921390440215387, 0.26554836946650084, 0.2366041138347469, 0.2007834824890632, 0.22108489345056082, 0.250310545653477, 0.204082009386366, 0.22605590491783456, 0.21464765413297704, 0.20496426038509963, 0.22224349857356984, 0.21238040008891756, 0.20300357674925973, 0.19831465638835466, 0.20006621459846197, 0.26281352273896863, 0.49979640929641234, 0.19697170950332143, 0.4798925272788991, 0.5417055523137209, 0.1866054619141062, 0.15409259700063327, 0.16569427522899127, 0.16450332779755572, 0.200602219200251, 0.47121621791106694, 0.2074120646999671, 0.49450521118491675, 0.20389589675565056, 0.19498268902233074, 0.16592234220045154, 0.15065510688619466, 0.20601350859847567, 0.4885666620658248, 0.21153345489363584, 0.21885908461128156, 0.1986739517015973, 0.22516723905190128, 0.22353412034582898, 0.20818859741751383, 0.20704796948125148, 0.1974969708936286, 0.18308186083129974, 0.09855833683247073, 0.09879192866878006, 0.08544212048150457, 0.09552130931614722, 0.08763773451998191, 0.10376820651141605, 0.0897762436850349, 0.07785147764118883, 0.09684588815983186]}, "mutation_prompt": null}
{"id": "688cee0b-af81-4875-9b64-672ab9b3655e", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "2ae87e1a-c93d-40cc-87f2-51424bb9b737", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "a82a8fe5-fac2-4894-9b89-d9cd241d5ec8", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.exponential(0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm integrating chaotic mutation, adaptive tunneling, and dynamic population scaling for robust black box optimization.", "configspace": "", "generation": 55, "fitness": 0.2696510715050395, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.17.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.37039453494626884, 0.34636704306154065, 0.3870648981479471, 0.392742512189753, 0.42047248616818, 0.3891659689099529, 0.3588908342586856, 0.39944162749789125, 0.40900835333957486, 0.07448879634187311, 0.23351526143997958, 0.14273567078404936, 0.3092573860686997, 0.3015818737667618, 0.2536125795558005, 0.10455937447198027, 0.0950481602760812, 0.24971218255599292, 0.13571838467982011, 0.12808114618346367, 0.1071932563805067, 0.15136920115081154, 0.34459475713003784, 0.16483618289704227, 0.09949457787189553, 0.1559877150779545, 0.1696006621392424, 0.10030439902939814, 0.12581538499437372, 0.11191719525824306, 0.11441426632618534, 0.07135541751360741, 0.10329906400582944, 0.07347335959911983, 0.09177250916410629, 0.11453222960280995, 0.8363120975935049, 0.8093045985367299, 0.6798950747066297, 0.8364914218964848, 0.7112120655420027, 0.8637132057466774, 0.9488708061411842, 0.5750982840379193, 0.6037726267379091, 0.17263520600703453, 0.1576981689438295, 0.30581078954128305, 0.15092109248747165, 0.2743264197038898, 0.2583085500928074, 0.18296284171121513, 0.13217886386674693, 0.29396656674483357, 0.22576630280281107, 0.4606525426917175, 0.47413949784449916, 0.6245318888917866, 0.7156777317190226, 0.6352046055098475, 0.7074857098414089, 0.6625201169537012, 0.7039473129881971, 0.2562991661621167, 0.12678333543821152, 0.1298545972790196, 0.22224055745108628, 0.1445667639189715, 0.14445121362701452, 0.19331929625201816, 0.21085279771704468, 0.3584630477854448, 0.11008162197140048, 0.20165889858047625, 0.15725926690139314, 0.1829194236608347, 0.18547267140367507, 0.2568199130499452, 0.3118229077828838, 0.10815198395394798, 0.1293874164850597, 0.29614991555261483, 0.2301538332462285, 9.999999999998899e-05, 0.36008088823222095, 0.25648570210848887, 0.3421596306764837, 0.32752012432582034, 0.29880874679849145, 0.31808447117662564, 0.37254175838834913, 0.34201253245657837, 0.36741867746287815, 0.28459631480369196, 0.36599971700516276, 0.25128421699831716, 0.35533650354832635, 0.2888573424402342, 0.36652241816831943, 0.1616670693792719, 0.1037331590240328, 0.08450748104437467, 0.20681374144550313, 0.23396884982206534, 0.22760430214997518, 0.1210532179140471, 0.07204415953573551, 0.10385827685872062, 0.24696199242313333, 0.2542388943980862, 0.12591814361697795, 0.025308596058587485, 0.2093899769168841, 0.2601369713616257, 0.26185991986604784, 0.2522149648359725, 0.24985591091719128, 0.34699703876780996, 0.3365508061086926, 0.367963975652695, 0.3596392522521469, 0.35070195230974777, 0.35948000922457235, 0.35776589513246904, 0.3703881192967815, 0.3495426491349344, 0.08503302537760249, 0.11265523398664568, 0.11471865369856493, 0.11548322929035526, 0.10601788382353317, 0.1287000586045317, 0.17730291122550024, 0.10605385522867239, 0.17793945004355427, 0.2420960697948803, 0.1939553500432477, 0.26469361591425256, 0.19480621817645571, 0.3428841210341539, 0.2475688554048312, 0.1901574961337229, 0.20032267157720207, 0.3080880392382068, 0.26977735371753353, 0.28381897211641793, 0.2933402949544923, 0.25058740974033844, 0.28309126234289594, 0.31408946325430653, 0.28780773395691583, 0.26922487832114483, 0.29219668759996564, 0.27711060042183033, 0.27503006176418865, 0.284114843338407, 0.2800873275936112, 0.22136263144376866, 0.19762026868563787, 0.23374632965547493, 0.3102032179312314, 0.26395764597997895, 0.2728009793435454, 0.27051050035805924, 0.218358320431859, 0.21018388145574995, 0.20127703204697833, 0.19924283393350262, 0.2444975847300589, 0.22769433381443838, 0.24060705246392888, 0.21788740573998866, 0.23969466353195246, 0.2192107314934234, 0.1969192794268021, 0.18198125441236157, 0.19333045770387958, 0.18971876340826588, 0.23953487419440367, 0.19754306770780072, 0.17818318951787748, 0.17395885969183678, 0.49005107032896245, 0.18331005039472292, 0.19898033745667976, 0.5534843925134264, 0.5035696323845837, 0.16626726411819037, 0.48512460222082276, 0.5759860500631879, 0.1562157354085726, 0.12331515875855026, 0.4806415638667494, 0.1603673410644515, 0.4893251705234254, 0.47589068416122016, 0.5419666591950968, 0.3854662017743382, 0.17956665237156721, 0.20788925909069234, 0.2566099039125197, 0.2037962848500703, 0.1981500742000073, 0.19508651781380726, 0.18468866292143016, 0.20334327060747726, 0.2781176530130328, 0.13954997683745918, 0.09566569619183374, 0.10420475045043853, 0.09749325685814125, 0.10191219630466841, 0.09565106594343309, 0.14582884860284362, 0.12895872313371237, 0.08947131060758695]}, "mutation_prompt": null}
{"id": "971bd8ab-967e-41da-994f-ba56ee8599f6", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "c506a73d-41ab-4dea-9085-b487871ef2c7", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 2.0)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Adaptive", "description": "A refined hybrid algorithm utilizing dynamic chaotic mutation, probabilistic tunneling, and adaptive population expansion for superior black box optimization.", "configspace": "", "generation": 57, "fitness": 0.14115781452783244, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.2048106320192603, 0.19804813329564097, 0.19198791955984362, 0.2632195856629933, 0.2532694921192006, 0.28909192588855703, 0.2286201850385533, 0.22132924047522196, 0.22181591015418733, 0.028731966179104895, 0.015183965223697693, 0.0050468370208917035, 0.009109014941145133, 0.012356325862960094, 0.03361688225848847, 0.013823962063383988, 0.01312800542438286, 0.015328645920370976, 0.042079566987141326, 0.05669174035586677, 0.04017147251188036, 0.048393212641486216, 0.06372689350312033, 0.05145054916536551, 0.060002898975712204, 0.06417229481772102, 0.0628670490231178, 0.03600744491798524, 0.03212476951302812, 0.030818254632956288, 0.030962206208975496, 0.04826189989249907, 0.04332012974794308, 0.04079507752050393, 0.03927455494413157, 0.03037886960958036, 0.9923547253301882, 0.9715586657491118, 0.989066832770877, 0.9720583413604567, 0.9792737866866665, 0.9919521314299077, 0.978299869642855, 0.986292720173435, 0.9917233609472358, 0.09464049225654558, 0.08596164638884207, 0.08880649051135248, 0.08083828356965628, 0.07657844723584162, 0.110686609023535, 0.07753585875832358, 0.10029602816846439, 0.07400423538677803, 0.16583690472311519, 0.16628139320487556, 0.16068623391834358, 0.1752686442359065, 0.18930977584562048, 0.16542642124939833, 0.18254466001398872, 0.1799395540521347, 0.16030863874709322, 0.03488815812154844, 0.02928640093474444, 0.018602171510000653, 0.07538094084008895, 0.02031430136999368, 0.022210675183547246, 0.020474099471569196, 0.04558023491347318, 0.03708187497691995, 0.051155849110269824, 0.03964304887226067, 0.021267877488318265, 0.03366050431965173, 0.01620138382484948, 0.014767826574113352, 0.050329926332806973, 0.05396839689443422, 0.07827244699421532, 0.05261095597556009, 0.004044804071867469, 0.03984730268515979, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005476113510443081, 0.004151059325487982, 0.01001007044620894, 0.0010306703081046642, 0.1000764357943581, 0.10230783646476249, 0.0884874817394129, 0.118709376867559, 0.10121471269571936, 0.1141981171167743, 0.10321150023734593, 0.16890680763850618, 0.11314759943834929, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03147584743099219, 0.022331402195051808, 0.019984821636110928, 0.020344899219563728, 0.03047941058710535, 0.030560628651413624, 0.03878095291216521, 0.03739166052159093, 0.05692037878829137, 0.23175825809840767, 0.22500614492424043, 0.20685613110155632, 0.22907721990579588, 0.23093125682125004, 0.22018441047755455, 0.2312796226197158, 0.22510515959440935, 0.21972280998373017, 0.06157287218957774, 0.06310969431884572, 0.05802115373686478, 0.0676049743264504, 0.049391213428687686, 0.044531050771754566, 0.04444783311571643, 0.04907191057454896, 0.06806996261262799, 0.14210196063921288, 0.14091161383234285, 0.1336294245131212, 0.14130110043870336, 0.11884095110909676, 0.11562496115352261, 0.13666988742448016, 0.15378081385923392, 0.1776827166451883, 0.15723859940842944, 0.16864920714801357, 0.17695695952763657, 0.1802523981454065, 0.164888851390652, 0.18279473078839814, 0.19079094370855054, 0.18953060806457656, 0.18219090956946915, 0.11336889061557487, 0.07234018342906456, 0.11346978759462145, 0.13462386200490561, 0.151899066580245, 0.15500832756594485, 0.13103046294222243, 0.1538196374881975, 0.1120955488470674, 0.15415806343369653, 0.16488726624592887, 0.16080934895257593, 0.16675899678898454, 0.14656923764195484, 0.15220735264408436, 0.1476590782768129, 0.13911199293858523, 0.16479379165241503, 0.1264570418019071, 0.1339442356417121, 0.12765215560962173, 0.12403179405367715, 0.1340954866494607, 0.13216676011882877, 0.1518773745227041, 0.13291378572513746, 0.1294414795162282, 0.14461630459621833, 0.11179521836786155, 0.11213262127484669, 0.31001625018914947, 0.1656219528267886, 0.1703851234592324, 0.1556196001811937, 0.2220211484079717, 0.14784864657405483, 0.20105181038824493, 0.17279115396121414, 0.16132298458903005, 0.10078421566031026, 0.15072942231963116, 0.2427679695287558, 0.18638286215162647, 0.18825955411082373, 0.17471994189610107, 0.17143418886711093, 0.17536127256238143, 0.17826758397498865, 0.16363599526487216, 0.17293095697079608, 0.17426530176976973, 0.17914349067358326, 0.15684790308453544, 0.15674755364619775, 0.048195682058622125, 0.04797973013468293, 0.04649900843673427, 0.04928775776606453, 0.05942962426085685, 0.045985420020149825, 0.04347003096756674, 0.04939481820270719, 0.04306878632844169]}, "mutation_prompt": null}
{"id": "3990536b-6790-4555-92c0-e332d59c96eb", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Elitism_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Adjusted parameters for chaos\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_elitism(self):\n        elite_size = max(1, int(0.1 * self.population.shape[0]))\n        elite_idx = np.argsort(self.fitness)[:elite_size]\n        self.population = self.population[elite_idx]\n        self.fitness = self.fitness[elite_idx]\n    \n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            self.dynamic_elitism()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Elitism_Adaptive", "description": "A refined hybrid algorithm using adaptive chaos, dynamic elitism, and gradual population expansion for improved black box optimization.", "configspace": "", "generation": 58, "fitness": 0.06593619082147967, "feedback": "The algorithm RefinedHybridChaos_Elitism_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.12419322406946665, 0.1432763043373405, 0.16657843465633992, 0.14094870913832658, 0.11493298956875897, 0.12494813914022451, 0.10278481354495339, 0.1551098903597682, 0.10785823256533167, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017672924784088218, 0.028623933400939716, 0.044203198558794066, 0.016185925788393285, 0.02113425624531795, 0.06220954328574002, 0.02191389846263847, 0.030709756735462168, 0.0431008759603585, 0.023989211565211055, 9.999999999998899e-05, 0.016649238843107206, 0.03213094840647501, 0.022802123217512738, 0.0016906751946942356, 0.025348896595304038, 0.0001780508352825505, 0.009640687040145868, 0.06112106606416945, 0.06393024618621568, 0.11378807996101181, 0.0803901109527595, 0.06310970811696681, 0.06374661426355566, 0.09424928286256795, 0.12283713088203352, 0.061578569945134554, 0.06285383642971498, 0.02753040255463224, 9.999999999998899e-05, 0.016322184640732873, 0.014725150286537647, 9.999999999998899e-05, 9.999999999998899e-05, 0.04533844257964614, 9.999999999998899e-05, 0.10027683525177622, 0.13131592333317854, 0.07675956372094983, 0.11861457974722256, 0.10032077376687698, 0.1098478205169986, 0.05301016764830513, 0.09926773297163649, 0.10685048484273629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06411792629998836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005732607957461555, 0.027057426022233266, 9.999999999998899e-05, 9.999999999998899e-05, 0.06197677803571955, 0.011630643771372018, 0.010078190650269825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1353505167224235, 0.1826592937413425, 0.1783149899108516, 0.1253176384754503, 0.11226970225574406, 0.11589248782965911, 0.16767789371352393, 0.13702411807797432, 0.18181780186700858, 0.01987893946583552, 0.00898788190807065, 0.0455141053969077, 0.04281248914997193, 0.012353624750148673, 0.03147188683393598, 0.0206544519590125, 0.016729744178381578, 0.03277651270418103, 0.0914505361703799, 0.1463404234312764, 0.1405537820844487, 0.14065436440811296, 0.15336058426956645, 0.13803058473558139, 0.1109239464938706, 0.09052627573626693, 0.09571251452434737, 0.1568394923032762, 0.14630189952285655, 0.18164186003746852, 0.14818418157832225, 0.13851574562463842, 0.11219249845760237, 0.16312311523472, 0.17877295598833987, 0.16155990603890968, 0.06001801140465146, 0.10738162321891831, 0.11674784351088496, 0.09124738987765357, 0.0848820230734516, 0.0811688352334764, 0.08695376095501506, 0.15179167236922364, 0.11903277167479576, 0.1739650299365807, 0.15037770873829592, 0.17233818955367475, 0.15962175182614302, 0.13624496602505443, 0.17938332558790737, 0.1422855913081199, 0.1520338178087146, 0.17461865845167468, 9.999999999998899e-05, 0.02453831044663779, 0.15462090562042685, 0.011944289771322447, 0.15604600120510093, 0.1303165855326599, 9.999999999998899e-05, 0.14010847890565725, 9.999999999998899e-05, 0.061746414397801375, 0.11197188882106313, 0.09764594402989535, 0.1112466654439419, 0.12984303072795023, 0.08429166852626935, 0.1116980053506631, 0.11007849427547212, 0.0971500311259903, 0.15741720602795672, 0.1346413011483959, 0.07159522680819952, 0.07220170273000937, 0.03950252159926626, 0.07187850020963538, 0.05412676668797234, 0.09189782149382353, 0.05654839578746684, 0.1621527590548134, 0.14151318862842932, 0.1703148196720372, 0.19952167326564751, 0.1641476797604724, 0.18078936972681892, 0.17916848299959676, 0.1959377427612149, 0.17629906517895855, 0.036060953791052786, 0.033942547357529884, 0.03903014372034741, 0.03982030858036323, 0.0584316434998422, 0.06074267303241032, 0.03229009659841253, 0.06812599455443502, 0.04489703988662519]}, "mutation_prompt": null}
{"id": "4c7ba50a-51d7-48a4-a2d9-9214f0e316c8", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.95 * evals / self.budget)  # Updated cooling schedule\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.4)  # Modified beta distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "An enhanced hybrid algorithm integrating chaotic mutation, adaptive tunneling, and dynamic population scaling for robust optimization.", "configspace": "", "generation": 59, "fitness": 0.275692381689077, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.15.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.3802122517589319, 0.3758031390858313, 0.3606823416232553, 0.379937705290769, 0.36593677027656235, 0.36797201666350865, 0.3819045970931193, 0.3618553536401322, 0.35831168361103405, 0.3237559370091795, 0.28587714108548856, 0.31677451262826617, 0.2999318390239428, 0.30737296244486634, 0.33209439829831355, 0.3022065948490057, 0.31137068751805996, 0.25599324101056264, 0.1328807303734606, 0.15462610985021752, 0.1324743035379734, 0.10768124920492794, 0.1424537898305076, 0.12481787393674826, 0.1327551034911283, 0.14720511378787327, 0.1451305004639638, 0.08637404745407529, 0.10657107471491745, 0.1015185998599396, 0.08836676515751585, 0.08804678757354945, 0.10902724106237693, 0.14648499145550564, 0.07934633320913731, 0.09885017222073478, 0.851360774425694, 0.8143305948978404, 0.6164999746342037, 0.805104894194944, 0.9188031419700855, 0.6337577424123224, 0.7872593751013357, 0.7476946931722346, 0.7669853776173157, 0.2895118817208754, 0.27129141775871635, 0.27100913335510235, 0.27154374956290195, 0.2598370640242368, 0.285495392362093, 0.26977301997533554, 0.24631341005684693, 0.2823860470462899, 0.46832508248224725, 0.36227232861892367, 0.6839545252911344, 0.5127989863612463, 0.4527966667726133, 0.4687855405111886, 0.6004995239947972, 0.3686702304797297, 0.3652827702718541, 0.14497339701129208, 0.3060031345770232, 0.2291698312112186, 0.2177630742031088, 0.2840634341409106, 0.259142625642263, 0.2335555591168068, 0.12523753787162328, 0.28386716820325186, 0.2498467493222829, 0.19159395858603878, 0.3040424990445415, 0.2494860167475449, 0.24820918868186825, 0.2776636726547662, 0.2650341989184841, 0.2151212426887319, 0.12301547981367345, 0.3161255257070833, 0.3147638944919354, 0.29652355115963613, 0.3142863100676436, 0.3329648944762289, 0.30902177221115357, 0.2950499852877779, 0.3161051505004815, 0.2948949384461774, 0.3427066398297939, 0.3530754376400045, 0.33474576288757807, 0.3380101905125057, 0.33461616236944536, 0.35812869698094596, 0.3184629192396071, 0.3241839356099184, 0.3387519656029966, 0.1866912000171176, 0.23050229670233868, 0.16541825409031952, 0.2631905995061813, 0.18826170689727562, 0.201553653533881, 0.2442220095974863, 0.1301825245103042, 0.23763673812170338, 0.24916789146510732, 0.2436511797917521, 0.24304583641850208, 0.24282807565376818, 0.23479420916922322, 0.24596405097743324, 0.23513946511630257, 0.2417500709623399, 0.24309885264583997, 0.34537130749366685, 0.3318527687098617, 0.355122048813596, 0.3655847543622589, 0.33225002371087275, 0.33879249435768444, 0.33943631379885064, 0.35120882013356924, 0.3439777997660304, 0.14404812367890885, 0.09862296559194894, 0.14757570863350522, 0.1351941764233563, 0.14034898598233025, 0.11908885216354015, 0.17115748435947353, 0.10868221622403873, 0.0950613467274849, 0.15262502394541955, 0.33007669242007587, 0.17181731180089477, 0.34855376172721797, 0.2937613117809217, 0.23368440800071044, 0.29647160650900173, 0.3225596658555514, 0.2922353427116623, 0.2794946513701301, 0.2888255165407905, 0.29443021807155023, 0.2818732626349272, 0.2779854643968972, 0.2667019761543574, 0.2843257298836932, 0.28703924240943024, 0.2821548331721131, 0.27319554913411725, 0.2635140781097316, 0.2671311361908718, 0.26977449110784935, 0.25736487709267053, 0.2651461662534804, 0.2590496092033706, 0.2674581871463362, 0.2720106484851984, 0.20985935227050423, 0.22640494542642764, 0.2001859505781025, 0.233940123476593, 0.2483062136025409, 0.18984658000792953, 0.24669084331926683, 0.2486779347139625, 0.18570361929932366, 0.2767078891768079, 0.2099913089279688, 0.22193433762776205, 0.2350456368006585, 0.23389168518552117, 0.20326230805009415, 0.21876256269052674, 0.2868750502168197, 0.1917052905395188, 0.5455288573153587, 0.19749933141181397, 0.4622740052866209, 0.488479083895754, 0.1866121920379885, 0.1540188378592776, 0.16343241910073325, 0.16467029599131688, 0.2007858515960972, 0.45575461971611864, 0.20740428790145538, 0.5297108834720126, 0.2037990515999787, 0.19454503707507298, 0.16595225825451876, 0.15077653712273897, 0.20618961534442304, 0.46988809376039953, 0.22492761977337983, 0.21963589186847443, 0.20924128644934126, 0.230423772632959, 0.2228487867162957, 0.2073928987919298, 0.19875605437997756, 0.2189206282166709, 0.1829480875513445, 0.0952355391078249, 0.09884607144844848, 0.08239347313187229, 0.09545882970833519, 0.08793095351692315, 0.10627034047979156, 0.09625515145358787, 0.07823384902630592, 0.10383295109449608]}, "mutation_prompt": null}
{"id": "8876f74f-b85a-4ac0-8eb0-db0f536b9783", "solution": "import numpy as np\n\nclass NovelHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly altered cooling schedule\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.5, 0.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "NovelHybridChaos_Tunneling_Adaptive", "description": "A novel hybrid algorithm leveraging adaptive chaos, stochastic tunneling, and progressive population scaling for enhanced black box optimization.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.35090714298608283, 0.36756902032554983, 0.37092620814233923, 0.3754529223879107, 0.38100158412394636, 0.3731786652603045, 0.3715130910851535, 0.38263865185695856, 0.3671917126418136, 0.28838741536759704, 0.32368951263738366, 0.3301957009430243, 0.29010745575944985, 0.3067528005603214, 0.32673765819560263, 0.14601087123222956, 0.34477306635013816, 0.2053070154079114, 0.144056107474115, 0.15451668639454874, 0.13427862609358054, 0.11564633784269918, 0.1362763022390271, 0.11461566777348486, 0.147882179881222, 0.10645518295828404, 0.13782688697616663, 0.11064355014864469, 0.10479047552793908, 0.08692613880821076, 0.17178780521195858, 0.0977567104727548, 0.10790305793772514, 0.10406341318953494, 0.09012502472446982, 0.1116186296485947, 0.5829596213490729, 0.9860070725648876, 0.6850148587651257, 0.7695420971968924, 0.48604785598792544, 0.6509504376139739, 0.8835002544355977, 0.8472993956510141, 0.7904756673000285, 0.2681723186618701, 0.29358584097550733, 0.28320303820515946, 0.1835911072478641, 0.2889802815688215, 0.28222022217146314, 0.20035747061939224, 0.24449118659070823, 0.2992414692887292, 0.4184720131630931, 0.6021437015611191, 0.720436775433997, 0.48126202936188844, 0.7420132518589084, 0.5984793850507237, 0.5411372732449757, 0.6871163019729492, 0.516528381796822, 0.29700521723444917, 0.17214239637742612, 0.24717588241671362, 0.21945230076497402, 0.3453352607440522, 0.2299843460206047, 0.26206301138914045, 0.1271203636605842, 0.24676772858428642, 0.24519927742345682, 0.0661931453902258, 0.12693452213887702, 0.2456872389880248, 0.27654375264947284, 0.3170921229969892, 0.23745271033414628, 0.28192388491876785, 0.23133209483895345, 0.33270546368221265, 0.21569263235206104, 0.2993591918721976, 0.0021294723771717594, 0.3412980244838365, 0.3150692917681349, 0.136009661709676, 0.29783292913116377, 0.33592702802318875, 0.3400948065582008, 0.3282365469548769, 0.3022049572419815, 0.33658044502897866, 0.3540483830836495, 0.34900153734260164, 0.3673235332851966, 0.34391332878827663, 0.33160804243029496, 0.17864546506940837, 0.272052570694847, 0.1137812772623844, 0.20024914594406196, 0.28103139285433165, 0.17407617028363165, 0.2440078077608906, 0.19204204811630265, 0.21437022037791664, 0.2408247274965465, 0.2569132414808404, 0.2389194155466996, 0.173416686156043, 0.240376309041341, 0.2409864985364104, 0.24995748663119488, 0.25229087708214826, 0.25540629252072555, 0.34497668334196085, 0.3532321297913018, 0.35602636438993807, 0.3473314081191673, 0.33280347176450586, 0.358921771081571, 0.3592085459523795, 0.36641818465195486, 0.3456759244568076, 0.11554968479856975, 0.08683848854916343, 0.11021781250167328, 0.1385088592642727, 0.1402216300499196, 0.11008467953749335, 0.15061575935893357, 0.10370384311858127, 0.17696577443560524, 0.36351918284960694, 0.17713991480975488, 0.3153220840513037, 0.36207400722026073, 0.1948573292282788, 0.34404245637980346, 0.29469586268863956, 0.2970750699418969, 0.3260015681455575, 0.27894073523965257, 0.29058057618865873, 0.2849889332121597, 0.2838682436190928, 0.27780757547235313, 0.2844833318549984, 0.2881298512064312, 0.29217508684542515, 0.2873910805461951, 0.2749142502628893, 0.2663180912237715, 0.275496196209177, 0.18968445987274907, 0.28310494094597605, 0.26697153770398874, 0.28914335388249324, 0.28805900893590874, 0.28438586916786657, 0.25142865351716737, 0.23984815040429752, 0.23434596707319588, 0.21950638563137437, 0.2391706122239613, 0.22928661223847357, 0.2830986064693357, 0.2222349457558087, 0.2295331386150008, 0.19436494698787465, 0.22080979114436028, 0.20504933059108044, 0.1839736944958308, 0.23392194017297607, 0.21662093253026993, 0.2124553845673648, 0.3105816551698499, 0.18253389719707236, 0.18060426022602327, 0.594534866785158, 0.20604861843027955, 0.1604381730174016, 0.5501607294256374, 0.19542817152467518, 0.1652722656362393, 0.16879419485639158, 0.20693805374623564, 0.5105180583077598, 0.4406258135667732, 0.520900307834502, 0.202461066315053, 0.46462015205691587, 0.5132132998992067, 0.49134255154748474, 0.485186948315958, 0.209146115211446, 0.22150393199331708, 0.23356024092254368, 0.22471795591520527, 0.21733334277350747, 0.2342610711932389, 0.22242492996176255, 0.22732395315206544, 0.21843229273830156, 0.24158725309671747, 0.08575841278435714, 0.10027100844601389, 0.10415435777670679, 0.08583468578362696, 0.10183397165767183, 0.08154845097554697, 0.10143933456520193, 0.10772202945285425, 0.0960381382326706]}, "mutation_prompt": null}
{"id": "a91bc9a7-18c2-44eb-98e5-3973c23f49e5", "solution": "import numpy as np\n\nclass EnhancedHybridLevy_AdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)\n        \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def levy_flight_mutation(self, current_index):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / abs(v) ** (1 / beta)\n        mutant_vector = np.clip(self.population[current_index] + 0.01 * step, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.levy_flight_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.6 + 0.4 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridLevy_AdaptiveCrossover", "description": "Enhanced hybrid algorithm incorporating Lvy flights, adaptive temperature, and dynamic population crossover for robust black box optimization.", "configspace": "", "generation": 61, "fitness": 0.0685545475370853, "feedback": "The algorithm EnhancedHybridLevy_AdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.13311552333138643, 0.08959413547867956, 0.10008972313670184, 0.11002152709883029, 0.12088659505932386, 0.12258640655179243, 0.10830844358169889, 0.08112182110826383, 0.0863277025821868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026744640193507085, 0.030629553504121, 0.043601952300390434, 0.049992565068789574, 0.025699494384063826, 0.03088600419878762, 0.033177107774376435, 0.07409190778934693, 0.047161563242018034, 0.027054673794223327, 0.003339250747605882, 0.012836864161994477, 0.0504688756409738, 0.02479712113675081, 0.011122834587594999, 0.0366771550624575, 0.020090534691059703, 0.0040842635430863306, 0.05477230322695814, 0.0492894830931504, 0.05140286054891863, 0.05977539627987516, 0.05150522303712024, 0.04544925828023494, 0.06876775345318908, 0.05485257155522738, 0.04658348628439757, 0.07172119747833405, 0.005514117905191962, 0.010822997528675327, 0.0320947998536909, 0.006999223118714704, 0.03818617616137743, 9.999999999998899e-05, 0.02834231414640931, 0.012141327459980533, 0.10836585113369179, 0.14099214004280147, 0.06600908112660797, 0.14381772581296615, 0.0963666717058339, 0.012402149820489594, 0.06301906399351687, 0.08438509401319183, 0.06169441660499653, 0.010275388521864937, 0.0365438949685567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002894106549028441, 9.999999999998899e-05, 0.0006206310588008357, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019553360760347083, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008678518944575941, 9.999999999998899e-05, 0.003966811926066516, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08615038385658558, 0.06664967590113624, 0.09179888888888776, 0.06814604157628024, 0.0437796719928063, 0.06116766428809717, 0.11213796908133988, 0.060268615418497706, 0.04385875776017534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0071471839268720805, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028251422060180387, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012553661865100096, 0.113647289839101, 0.16462328543945537, 0.15925455301055935, 0.11791824121577721, 0.11626009490186695, 0.10205267927587136, 0.16691348597049604, 0.10924588600243024, 0.1291226043221102, 0.05304718880031356, 0.02193070891348925, 0.03922269301236425, 0.03903101352883809, 0.017474906106786925, 0.05193825999695978, 0.014875760944593086, 0.016024262752927676, 0.0656248385365178, 0.13750902349782268, 0.1498788769098126, 0.15888544104546765, 0.1627420678572864, 0.14387730541401966, 0.14097327424700468, 0.15839064161450445, 0.14075556390619348, 0.11242068581958087, 0.12348566702510966, 0.11493927584233932, 0.16654901237795128, 0.14190572642960764, 0.1273374967406884, 0.12605631961423547, 0.14587469368844885, 0.19784544876330368, 0.14546904366597502, 0.06445604743735422, 0.05947290017511664, 0.13626153696303167, 0.07946614654479567, 0.07554310446450585, 0.07956637391963362, 0.09415545633656197, 0.12568963068784578, 0.09175239094581233, 0.16286152263209985, 0.13123395271648786, 0.15637287355349472, 0.19044009807582463, 0.14566840575512507, 0.15381237208476595, 0.15836768188992845, 0.13211027180406787, 0.14327008248261153, 0.09425595191959257, 0.07135710917801463, 0.07832618168059413, 0.03934015247209577, 0.03494787325066895, 0.08128565022481793, 0.0507844264252344, 0.0003170169462795025, 0.0011547659613228012, 0.09977787646651581, 0.10729007504761123, 0.13427722740121495, 0.10872041526228038, 0.1521014745676248, 0.09743341625107893, 0.1141071053313768, 0.11240776762395599, 0.10642602068765661, 0.24828576890061282, 0.11695169027427177, 0.08425799273513546, 0.09521129297762398, 0.06290669120736003, 0.08948922511848012, 0.06659929766943606, 0.12486031293900779, 0.12978355469627023, 0.1980629627153473, 0.20596785252958372, 0.20631891458448393, 0.20869192976706108, 0.23302887919477722, 0.20029455190004442, 0.20668894490892864, 0.2127389496985459, 0.21914879060395254, 0.0362058663435213, 0.043813201891352405, 0.05783268495980576, 0.045264898104568796, 0.06806377994840584, 0.06235746743280923, 0.04518263910416298, 0.06611825576580554, 0.042885419810674064]}, "mutation_prompt": null}
{"id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Altered cooling schedule\n        self.elite_fraction = 0.1  # Preserve a fraction of the best solutions\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Adjusted chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.3 + 0.7 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "A refined hybrid algorithm enhancing adaptive chaos and stochastic tunneling, now incorporating dynamic dimensionality reduction and elite preservation for robust black box optimization.", "configspace": "", "generation": 62, "fitness": 0.30742483074144655, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.19.", "error": "", "parent_id": "3fa04809-77e2-4e6a-a608-d3c1e5e8f010", "metadata": {"aucs": [0.43611076357809875, 0.4832654697207216, 0.45579358869149944, 0.47476831193308766, 0.4545690064987933, 0.41848391698710885, 0.42167110109252925, 0.4630222548335807, 0.44444733489187915, 0.32965802603411765, 0.39394317928910316, 0.31861240273882296, 9.999999999998899e-05, 0.37271905912275405, 0.08324953950622582, 0.13981941322896896, 0.3056561500552193, 0.25140332548315014, 0.1028097356074471, 0.136951408311341, 0.11052618986108187, 0.17271921858951578, 0.15014328391272558, 0.12660147564887902, 0.08673799873052834, 0.10566230434959456, 0.11363412112028015, 0.11090087751709454, 0.09255834236285332, 0.07098675908686469, 0.1147269831740908, 0.09972625993927231, 0.052696898529614566, 0.09898702003274829, 0.09503530583300579, 0.09341150611009164, 0.96624157619594, 0.7783314723268273, 0.860204952050662, 0.7920145040360623, 0.9021154222926061, 0.8949684012000904, 0.7590771058508503, 0.8007097337923609, 0.946892173557221, 0.29594473811797384, 0.3687622527677179, 0.3532669217000599, 0.18907295064393237, 0.3474780540246485, 0.30053165015351724, 0.29627368283811384, 0.2719858545421865, 0.3551989198875637, 0.5607748816948395, 0.5226102586763168, 0.7954289564925645, 0.8385365985854003, 0.696132404129852, 0.7889405499230371, 0.758423815394489, 0.6127750141135593, 0.7911982000042092, 0.3456994893728337, 0.22067970074275023, 0.026408839164590248, 0.22563387010427927, 0.2865748863802382, 0.2664590098719458, 0.31284832342953794, 0.1240810220896752, 0.2523186407499842, 0.2690131286184302, 0.11170391431302162, 0.1723459349070332, 0.13195970165548498, 0.25874686237601907, 0.28038802546950414, 0.2932802769047417, 0.2972319962406582, 0.13095967335797964, 0.3322501317671871, 0.31961429434334165, 0.369216740930868, 0.23425250998009528, 0.16680806364182177, 0.40631292051102996, 0.37459616076361535, 0.32521154550543663, 0.3787910928015149, 0.39546260653399135, 0.2957011035501461, 0.3842242440493312, 0.3508353884047296, 0.35785174408482967, 0.3983120283886602, 0.34576314754643867, 0.41850975611314956, 0.38822310798163373, 0.04668861906601818, 0.0908965242939963, 0.3130442369365084, 0.34280563100636885, 0.3545140312751617, 0.1808140100110992, 0.17357435025004975, 0.18776809900556113, 0.28803447302885576, 0.2742533547873759, 0.28004590788156014, 0.22804124016309757, 0.2389627314208449, 0.2592046674696965, 0.30337432183612634, 0.16885199828722364, 0.2766669443588373, 0.29822934363953957, 0.3777039000168062, 0.37375156666095133, 0.40883845439865285, 0.38899991600083383, 0.37245469635247785, 0.3984872017828699, 0.374371863019326, 0.394219027330844, 0.39053961887646305, 0.0846915555096448, 0.10806192981488238, 0.141342918094442, 0.18006155358856812, 0.10644964500339771, 0.15275842047033783, 0.15206481552796414, 0.11340268857130664, 0.1017117730507785, 0.18059561336943042, 0.37444778503322795, 0.2561084922716226, 0.17034637538307051, 0.4100220109260535, 0.3828337095091565, 0.3032421023567714, 0.38131503091012764, 0.2587581054229042, 0.28829993903946993, 0.30898423767068994, 0.3203787668561431, 0.3299332701648543, 0.30057235695693507, 0.28885786199134855, 0.3090061612931474, 0.3504925846962049, 0.31766590775459036, 0.23512493426453007, 0.2958802560969691, 0.27671338008448443, 0.3293650250249789, 0.2881607745987741, 0.31052625777996856, 0.3180821906569037, 0.31169247524061927, 0.29562584300961836, 0.2665602145767956, 0.24851571354465618, 0.21385237361369314, 0.2757342545443642, 0.22411971298730726, 0.25294499065778486, 0.22732856657462885, 0.2537950636153189, 0.24811308723363168, 0.20865193857266406, 0.24809746955681522, 0.22309395551606137, 0.22162416347396618, 0.36625157061826374, 0.25156287277757894, 0.1883929286790762, 0.21528872863720916, 0.20350368513485373, 0.6427080784420014, 0.2069758777163737, 0.15230521159469212, 0.6967898649336879, 0.19784098415407647, 0.15676471156015193, 0.1669237089256359, 0.6656072862001036, 0.7141195697283019, 0.6755403686702929, 0.6164256097999647, 0.583298719501294, 0.20737971196203886, 0.2087622344063782, 0.16711589475580257, 0.2092440894337524, 0.1266805349726161, 0.15397724685483338, 0.24495436012172056, 0.2804602463325555, 0.19834951040353932, 0.27133595673089206, 0.25127364634383653, 0.2912024449631888, 0.2120588451292471, 0.29763668522555053, 0.22539830467534716, 0.0995654715063804, 0.10844413024157462, 0.10982014497446924, 0.09720428644760815, 0.10180223728335891, 0.08785983197989067, 0.07961483329960195, 0.07964384767033517, 0.08826472570381172]}, "mutation_prompt": null}
{"id": "8ce1c8f6-ccdc-4c5a-a38a-dd1f817ea0c7", "solution": "import numpy as np\n\nclass AdvancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Slightly increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Updated cooling schedule\n        self.elite_fraction = 0.15  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 1.0)  # Changed to gamma distribution for chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Updated scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedHybridChaos_Tunneling_Elite", "description": "An advanced hybrid algorithm that intensifies chaos-based exploration with enhanced tunneling and adaptive elite strategies for improved black box optimization.", "configspace": "", "generation": 63, "fitness": 0.2211952496261429, "feedback": "The algorithm AdvancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.3266300068188417, 0.32830852045174663, 0.3285147137355471, 0.3374357781757551, 0.34154187450020534, 0.3589552448321489, 0.31319813379305816, 0.3312557900688383, 0.3232675259912069, 0.20690796383480192, 0.18384148455907012, 0.17333140620036813, 0.1810144414261512, 0.21903189853574323, 0.20859780590045407, 0.18456543955804194, 0.23399604525325624, 0.18862110429720158, 0.07512194528572402, 0.08503785684211285, 0.09158562067859288, 0.07766216668153791, 0.09437051963092358, 0.09689320887648378, 0.06837826369669986, 0.07866921460839094, 0.09090766070680234, 0.08317592306823607, 0.10581241584101786, 0.10453527560736275, 0.08624385853984529, 0.08422959626789706, 0.09320606789263797, 0.09067718986091655, 0.05190840145023412, 0.06380669554563301, 0.9902271892556314, 0.9712954122896418, 0.9823719999669397, 0.9790180822470749, 0.9797123591082493, 0.9650363697786704, 0.9924127780097867, 0.9663479092500062, 0.9871780878271232, 0.23881911942293998, 0.2363928156349966, 0.1918039015227292, 0.22003424968955265, 0.200487723508043, 0.229651235032462, 0.08607445146625214, 0.17863275443123017, 0.21629577994598337, 0.2978225959174092, 0.30556442484747803, 0.3148923458965177, 0.40080866119527625, 0.3434083560269795, 0.31047899003098156, 0.28949967107325314, 0.37637730704946926, 0.3127427801834274, 0.12331547055798908, 0.13626801630028418, 0.16997826082514844, 0.1510152782515083, 0.14120963454491942, 0.10320901335155253, 0.15882347361523985, 0.21472304273303267, 0.16573322787600664, 0.086648842095991, 0.02111866030702947, 0.009448280729368541, 0.13152895707192924, 0.24741712637782143, 0.13019564605838663, 0.20409809128246426, 0.1346136168331915, 0.18236076023464232, 0.2049407785267603, 0.055704804258651874, 0.15265862264099483, 0.1625121467136147, 0.2006702660720896, 0.19418062918021062, 0.1504831819589839, 0.18511163944077103, 0.17117303111035476, 0.27279328250163504, 0.258367441708246, 0.27001304912006663, 0.2846421010603636, 0.2900417548725194, 0.30702552039606745, 0.30447904342005594, 0.26970362861537656, 0.2728399579959623, 0.0749918576909, 0.031829886163995846, 0.07105176056999085, 0.07207883983087959, 0.10321561757476716, 0.0900017680903451, 0.08103608744727664, 0.11390002797846843, 0.08234273815652104, 0.16064076115578063, 0.16428927728040377, 0.1517634541057591, 0.17245713292337073, 0.16266732076685475, 0.15123670924471877, 0.14201224134317758, 0.17882112755827673, 0.16957217464028784, 0.3035862587533241, 0.3274579420380923, 0.300213920580078, 0.30674150836591985, 0.3315789607044004, 0.31473982342830165, 0.3332592812871821, 0.31927326368965037, 0.3233551566753503, 0.10514594995386561, 0.07490546663711994, 0.11148827452694421, 0.11528040792473115, 0.0733888575543109, 0.07993009867346113, 0.07903407511818772, 0.11481916599667585, 0.07291511560492125, 0.1891341738571678, 0.11634266720554065, 0.162507423107358, 0.16683797488882024, 0.19985016514959209, 0.1350689040285874, 0.25967843596004847, 0.1780264502194122, 0.16789914389274785, 0.22232545383278213, 0.25018980426715154, 0.2664909162894409, 0.2350466635515024, 0.23960581785742352, 0.22271939256008022, 0.23590949811516615, 0.24214397122728049, 0.23882617575507947, 0.19871537221997293, 0.19472967431074317, 0.20326611848101883, 0.22907785631781674, 0.21911056396824147, 0.18001946462043705, 0.21919630995608919, 0.23542477589637423, 0.21666017062715004, 0.17376563098909226, 0.17429394324998682, 0.19830561169676564, 0.1652643053804832, 0.19853129046727747, 0.20481161142313886, 0.17664121780154074, 0.22291225138319937, 0.18185283782650818, 0.17456780029255536, 0.19153463419894734, 0.17955289478064607, 0.20421632022484737, 0.17502022894621272, 0.1768981044213087, 0.17086786083257588, 0.1789041587124095, 0.1571348851689065, 0.1585123780360127, 0.1778222258854888, 0.4284067310931128, 0.42599819170319353, 0.1866826795130988, 0.4068921728616387, 0.1735735815840308, 0.16786367553931048, 0.1730796715501277, 0.19526409346982687, 0.19120771596277686, 0.38042035823793885, 0.1978552936025464, 0.19507233171426153, 0.14937535819256464, 0.201833490070781, 0.2047543756335839, 0.4425615645160299, 0.19143510833559463, 0.1827117531446968, 0.17664555649340108, 0.17206795373631012, 0.16734451599143774, 0.16887971407596414, 0.17425922261597482, 0.21102303872700023, 0.15859570057638994, 0.07877472167600896, 0.06455278634714645, 0.06684281483472498, 0.053296067497138555, 0.06442944955313812, 0.04622848003788427, 0.0610830503655756, 0.07320273342368222, 0.045053438393932055]}, "mutation_prompt": null}
{"id": "190421ad-4a1e-4490-ae94-8d983b8860f4", "solution": "import numpy as np\n\nclass AdvancedChaoticProgressive_Elites:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.7 * evals / self.budget)  # Reinvented cooling schedule\n        self.elite_fraction = 0.15  # Increased elite preservation rate\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Modified chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Revised scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedChaoticProgressive_Elites", "description": "A novel blend of chaotic search and progressive elite integration, heightened by adaptive dynamic scaling and temperature modulation for superior convergence in complex landscapes.", "configspace": "", "generation": 64, "fitness": 0.29602391925645605, "feedback": "The algorithm AdvancedChaoticProgressive_Elites got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.18.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.43019604117938326, 0.42608892011598065, 0.43461468101387324, 0.42651576065001073, 0.4372900685772001, 0.5031119705617844, 0.434593985597859, 0.4559382947961923, 0.41463293775819987, 0.3988420364518086, 0.41656230654979165, 0.33974632449042064, 0.366294407173983, 0.3692732657118297, 0.3917041790439537, 0.3459131433772683, 0.3268207613216856, 0.11282827569407405, 0.11404150843545269, 0.11757026539671078, 0.12641736532516357, 0.08438434795111749, 0.12865714004055484, 0.10715787407180999, 0.1392809893236867, 0.1355979912484685, 0.08913084177608466, 0.09134132074041557, 0.06917401282854951, 0.11093556709419172, 0.10409736912239409, 0.09141503712745158, 0.08214497560137912, 0.1026390402978613, 0.1062672702274533, 0.10266753880076251, 0.8124805729320527, 0.9009172163693726, 0.9605967927519842, 0.7892214154637683, 0.7313428248316128, 0.6638219416289819, 0.8477080431103698, 0.8607362582453636, 0.8368062557718492, 0.3714429347885503, 0.27083397479237725, 0.37645139951930007, 0.35542649411223937, 0.3074971693870707, 0.29694904561637814, 0.31949052146267687, 0.2701597249702864, 0.34479544714417065, 0.726493767190853, 0.7605141411505875, 0.7241770953239388, 0.6667406586597568, 0.6568835053947994, 0.6334683721663599, 0.4477974542958686, 0.5732216730887938, 0.679288554802603, 0.35110724316265507, 0.25853774232311766, 0.12792768112560826, 0.17193015452726557, 0.2613960343944636, 0.12852033630614823, 0.23870483826914501, 0.36141954072306304, 0.3047439172875811, 0.1479019206418608, 0.12712725468688402, 0.12853993115444973, 0.12590000539189405, 0.3181080387031462, 0.2026372812456224, 0.3314657205841952, 0.27870470388253754, 0.23312926128764178, 0.3269676965939723, 0.266182479099105, 0.2419912731699959, 0.06991141065412998, 0.27282444688702046, 9.999999999998899e-05, 0.20319817495782588, 0.2228058343481507, 0.33451909815704306, 0.4272550134032803, 0.3586878734033815, 0.34739297158280147, 0.2764481577631899, 0.41348165497672096, 0.3863028214208093, 0.3673407458223321, 0.4169377661785312, 0.3938553115129293, 0.05179099573739765, 0.03461467192893508, 0.1157562169943267, 0.29248811002409225, 0.18657922045064956, 0.10769273670798174, 0.23087451941515702, 0.12492530154327364, 0.18599830640558013, 0.26859105606712985, 0.2991803708455253, 0.2385979195861785, 0.2806751655412687, 0.19972441205142077, 0.2720055216873355, 0.2633268991943456, 0.22749468229054404, 0.28865671228573353, 0.40740723438902304, 0.4218482449209434, 0.42098137977153083, 0.4240129288503688, 0.4013522881704146, 0.44524143109447845, 0.4062104473533288, 0.3808856481550481, 0.4319049227137417, 0.1522985981216829, 0.14864282106217908, 0.07637709000581949, 0.1275517307808548, 0.13140765016220635, 0.11071061869642107, 0.14728304957781369, 0.08504022320087457, 0.09710431478577097, 0.17053088107093006, 0.2229345982905765, 0.22770003295699615, 0.22595897670763831, 0.32753402445068713, 0.16920490090057105, 0.21278025618938634, 0.3251290277132679, 0.2431999690935741, 0.329882588040626, 0.32110952930455217, 0.33422567333152353, 0.3198232025071226, 0.21712395621502767, 0.32830863341841665, 0.313912007517545, 0.3122659269006832, 0.30581775980751735, 0.298250363087877, 0.15320047476046206, 0.2993460689873658, 0.29742570890059294, 0.30734370982801884, 0.28761291917394816, 0.29471645485764086, 0.32973319178304605, 0.22172327935679548, 0.2906248656243532, 0.21040358648936297, 0.22085156328011268, 0.22463412144208883, 0.2034870807137369, 0.2266599351297084, 0.28113334081704255, 0.21024527217464106, 0.21737713051689134, 0.18625099322224314, 0.21372635974092213, 0.21708210086990698, 0.37115152786266037, 0.18866203374176882, 0.19180682911328473, 0.19238767146511626, 0.20575078891558218, 0.2113816341920164, 0.16696020055364047, 0.1828598662807035, 0.5659800798968471, 0.1698988827238569, 0.19881887945345011, 0.6055762933712803, 0.5856596270060452, 0.16630522705159434, 0.6458760485081732, 0.6624227755842648, 0.20989841421103994, 0.19909051408089629, 0.16645968777064735, 0.20476112169195326, 0.20445807032954033, 0.6321060030529512, 0.21002120785822664, 0.6533979732960024, 0.24271168453805225, 0.21839222948770354, 0.22130801454277094, 0.261403488455735, 0.22057811869225008, 0.22661597161953828, 0.2624932209579992, 0.2748384362594445, 0.22414708583394327, 0.09245211165633338, 0.09818560875219118, 0.09340408815971735, 0.08171373535131154, 0.10610600626902433, 0.08992814874459387, 0.10477761471934988, 0.10281745294669131, 0.09994287257826617]}, "mutation_prompt": null}
{"id": "61d86d3e-1cc6-47a2-a8c3-1524826a4650", "solution": "import numpy as np\n\nclass HybridChaosStochastic_MultiScale_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Increased initial population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Slightly different cooling schedule\n        self.elite_fraction = 0.15  # Preserve a greater fraction of the best solutions\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.8)  # Adjusted chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def multi_scale_mutation(self, vector):\n        scale_factors = np.random.uniform(0.1, 1.0, self.dim)  # New multi-scale mutation strategy\n        perturbation = scale_factors * (np.random.rand(self.dim) - 0.5) * 2.0\n        return np.clip(vector + perturbation, self.lower_bound, self.upper_bound)\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial = self.multi_scale_mutation(trial)  # Apply multi-scale mutation\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "HybridChaosStochastic_MultiScale_Elite", "description": "A novel hybrid evolutionary algorithm combining adaptive chaos, stochastic tunneling, and multi-scale mutation strategies with elite retention to improve exploration and exploitation balance in black box optimization.", "configspace": "", "generation": 65, "fitness": 0.1962573113341032, "feedback": "The algorithm HybridChaosStochastic_MultiScale_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.32987980319833354, 0.3244322222817312, 0.34329416949705815, 0.34395510060539936, 0.33945955879110024, 0.33871124186078627, 0.32732829070738645, 0.3281665375168712, 0.3313481247218518, 0.0001520440817903701, 0.027318209759973455, 9.999999999998899e-05, 9.999999999998899e-05, 0.014697529174039436, 0.024591566122397657, 0.006553137529633379, 9.999999999998899e-05, 0.00010012773323941904, 0.09117032934962466, 0.11203327291409282, 0.11199348766346562, 0.09146579435241298, 0.08652546598147415, 0.09310717458669349, 0.08693132529923953, 0.10640780353723445, 0.09690005074551866, 0.08495125032937845, 0.08292602383934422, 0.08448366146271635, 0.10326946232891987, 0.08125978788044363, 0.08586312697305443, 0.09461865309564421, 0.08714083394861749, 0.09747077520168879, 0.8348006592936813, 0.842144557935901, 0.8811897027463806, 0.9043675009234929, 0.8734361224358005, 0.8818581127656266, 0.8928025940512103, 0.8812955912332657, 0.9369900821658912, 0.2378698005316684, 0.2211735241554016, 0.2239933646768293, 0.2030574003699941, 0.21437858499492657, 0.21580538866316024, 0.2215457407886321, 0.21399340053470572, 0.21873750285164428, 0.29350171469915143, 0.2802845455457402, 0.2681041120675153, 0.2724528022004593, 0.26112070067158566, 0.2753993789383069, 0.28517497450778584, 0.2616402022457276, 0.31546801445727546, 0.1510440872369765, 0.13714304787259968, 0.14284123655714376, 0.13860488925810877, 0.14870819531612, 0.13725301504177823, 0.12946945601232696, 0.1251360830203555, 0.15286284734939348, 0.15375186316499534, 0.13175380065286613, 0.13137085431423112, 0.12397017724861947, 0.12722971123739457, 0.13923547469571207, 0.1295063541345871, 0.13518768160705041, 0.13279726472537168, 9.999999999998899e-05, 0.006624531489379248, 0.07310196117013679, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030074279573273355, 9.999999999998899e-05, 9.999999999998899e-05, 0.00989662330835761, 0.09678573036033244, 0.10384577974013887, 0.11304502690080154, 0.06807297833487702, 0.0895037850705247, 0.06589073499270381, 0.07773964229818686, 0.0950967321560956, 0.10667360897692557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002670566131360852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07117974527839543, 0.06833448204983983, 0.08084125368443074, 0.06345249581933021, 0.07637666601302862, 0.06928433509913046, 0.07390139994691947, 0.06547850115942999, 0.07990709168282828, 0.39675340969713235, 0.3440000679474733, 0.326210669947813, 0.32618493138244486, 0.3233246810793675, 0.32974882985990484, 0.3185403271209283, 0.32912527739697994, 0.33053337992282894, 0.11036667835576686, 0.10176109553036772, 0.10536353288866163, 0.09010291904007006, 0.09978410221911505, 0.1100592638684248, 0.09304347111890221, 0.10186396544036846, 0.10043234024240466, 0.15114799313407545, 0.195073903568167, 0.1541067465172915, 0.1819446846084405, 0.19312358838371102, 0.20106127204940416, 0.1930333383823819, 0.2138111248555581, 0.1836635782598941, 0.23655749181324004, 0.24397323043469876, 0.24356003756676725, 0.25123256459580223, 0.2460211972203128, 0.26994702719262564, 0.26057059364836344, 0.256738952415677, 0.25617432426173137, 0.19029907937790747, 0.1848177081178487, 0.19171271104783316, 0.19265525188219224, 0.205647260071662, 0.2021652762800603, 0.19416714658688627, 0.2074885833609067, 0.1907064698101646, 0.21911757136637666, 0.21591813548173533, 0.2019157903242641, 0.20715798262707552, 0.19881029429872632, 0.2225685156845454, 0.2042986925904765, 0.20497549680644656, 0.1937827916820274, 0.18425281858617915, 0.18665583758371695, 0.1716592912235153, 0.19868575293414148, 0.1964318286161093, 0.19910196631873867, 0.18110373779099986, 0.17748472209650412, 0.19535653548061604, 0.47376733383777114, 0.18320834131528252, 0.5041821336602551, 0.4459601442667678, 0.19254402408013016, 0.1918638473956401, 0.1828308935466464, 0.16567570159282896, 0.18312780739975965, 0.4246276301146088, 0.4192537956375715, 0.20248275452117304, 0.39481591142067074, 0.16487781294114523, 0.16717985772631416, 0.47498897579147936, 0.4012126864282234, 0.4138498183440149, 0.17687494242123014, 0.1832975248564065, 0.17732727927814107, 0.19018105641608385, 0.1683504289501796, 0.17515819532291754, 0.17763612782882288, 0.18793703674297713, 0.1943544568653499, 0.09115295382851729, 0.08784804427305448, 0.09088718365567405, 0.08583366916297475, 0.08700904621896532, 0.0887885973680228, 0.08350483684492971, 0.0813972824869914, 0.08844411704099298]}, "mutation_prompt": null}
{"id": "dcca3292-c909-46d3-8ecf-bd952988a68b", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Adjusted cooling schedule for smoother decay\n        self.elite_fraction = 0.15  # Increased fraction of elite preservation\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.8, 0.8)  # Increased chaotic factor for broader exploration\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor for more balanced growth rate\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite_V2", "description": "A modified hybrid algorithm leveraging adaptive chaos, stochastic tunneling, dynamic scaling, and elite reinforcement to enhance black box optimization.", "configspace": "", "generation": 66, "fitness": 0.30590114640271876, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.18.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.4284540266393949, 0.4055031247270664, 0.4365553810408207, 0.43558052741206443, 0.4632777408726141, 0.4620414963999627, 0.4362600375216579, 0.4455198771621883, 0.43808550976595895, 0.3770321089394907, 0.34093815071520983, 0.39726297790100384, 0.3548953531122431, 0.37315856197118835, 0.4244590457344116, 0.38374263953622445, 0.2880473064801523, 0.37183554976977307, 0.12678158856071076, 0.1720674878917704, 0.13654839392096385, 0.1481146296071042, 0.12617010217945912, 0.10485989412949714, 0.1131995122776519, 0.1250109869002568, 0.12881285575340262, 0.09974683497850456, 0.10168986440475292, 0.1266941695956635, 0.11820753117848148, 0.08872191760540593, 0.10517813561567468, 0.12573049100936495, 0.12348777352188423, 0.0939781347918861, 0.7433649175371915, 0.8806926935696329, 0.7989204493205013, 0.6952418644166837, 0.9343411039779012, 0.8964167458067909, 0.8941189630006576, 0.8397664260567739, 0.9098881701832726, 0.3635469790060599, 0.3131522551555447, 0.2949057281651448, 0.34006247936988043, 0.3257587213309311, 0.2958199638459147, 0.3599826561628455, 0.3477846957502261, 0.3734477804287629, 0.660474114618248, 0.721212010045968, 0.6269557078996474, 0.7307659321020958, 0.6721485094754733, 0.7244236302678652, 0.5067244323167943, 0.7017286049116057, 0.7811769298533898, 0.3944747002530584, 0.1250492171676526, 0.12584438272820064, 0.2397461575908374, 0.12860399673928824, 0.24472091000972662, 0.2933796889991135, 0.2687143721643268, 0.11594974347141507, 0.08898642807263601, 0.31047808850687153, 0.2804851562851225, 0.3479430144072919, 0.2876215664992333, 0.15028371517454653, 0.21758938112066095, 0.20416114636107618, 0.44159974499432497, 0.25189932438694906, 0.36145378833350983, 0.3421945877159178, 0.27456932185029326, 0.3745424388597628, 0.3675186503251351, 0.3145044220685115, 0.39409242927022325, 0.3311098450975778, 0.4076033516288259, 0.38459498927663294, 0.3997898803390635, 0.3702061129410643, 0.42181978867671777, 0.38867412276721425, 0.3494900785478686, 0.4100274327571042, 0.38204025527961827, 0.16190325135613548, 0.10697945978878254, 0.12117843001853768, 0.20907156520716386, 0.08229615758392173, 0.17706666851680875, 0.1398430555096578, 0.16380112302039984, 0.1264165519554452, 0.2836707766680616, 0.29156467098162797, 0.23541735876843128, 0.2850842341091244, 0.292604437444257, 0.2907158654401052, 0.2595509188089109, 0.2964791032136088, 0.29055581272380493, 0.41413048840440125, 0.4025509848979647, 0.4024591764005364, 0.42455015261418994, 0.38680575052434396, 0.3957541561462543, 0.3813371269742587, 0.42191248339763665, 0.40654328771575743, 0.12576253860390607, 0.14539444723996786, 0.10074048139524361, 0.15003908330001892, 0.12124064730586792, 0.10354223053915734, 0.10241069248455081, 0.11471381630461963, 0.09398474228265608, 0.3907125126731116, 0.188423022393581, 0.18696498039736753, 0.22205044885666114, 0.27746289011112146, 0.18261022035132846, 0.22774271641344424, 0.2778281075164134, 0.2183974566323411, 0.32485399577905816, 0.30029923596732055, 0.3115661325897615, 0.316547325412163, 0.3430233256098285, 0.3056731500454397, 0.3145671797194878, 0.3275651327655039, 0.32231269908989113, 0.28580313608644525, 0.3101840222274257, 0.2959421242839637, 0.3082795302141037, 0.28837719978551, 0.29477979322532344, 0.3146080293997977, 0.3232586940667028, 0.2212542807898623, 0.2524066206277411, 0.20917165702442442, 0.20544329378459592, 0.2583780498870415, 0.19354205439432148, 0.19302160487793996, 0.20154399442279913, 0.23311680620979325, 0.23385960785408544, 0.23021623856302265, 0.1862554102688172, 0.21501674116253677, 0.1915316123657841, 0.2018371625704224, 0.1945914884238945, 0.2136452214540484, 0.226425916952966, 0.19383570952910578, 0.4982682588689259, 0.6382450364604293, 0.540816365887093, 0.1687822559317943, 0.1858470624369415, 0.16573454109591879, 0.16355494042859842, 0.16677553260234823, 0.6578845743084027, 0.6238228540428734, 0.20810843798009304, 0.20027851544816677, 0.513181714129007, 0.20477597549071758, 0.20207305541032416, 0.20711584325358845, 0.20848779085769753, 0.6483497949459517, 0.2474859555932697, 0.1911227219274768, 0.19024200470358776, 0.23020126113931139, 0.17638280848279742, 0.2653215238511013, 0.24048796610690293, 0.20975421985767473, 0.2637927789832294, 0.12671870423820308, 0.09521119403411016, 0.0739296889474943, 0.10216746916349762, 0.09555802039009342, 0.08346530185398637, 0.11184224338304216, 0.09559873393665497, 0.09802980152649776]}, "mutation_prompt": null}
{"id": "43dc8317-3927-44c2-95d5-60416a862b51", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Altered cooling schedule\n        self.elite_fraction = 0.1  # Preserve a fraction of the best solutions\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.7, 0.7)  # Adjusted chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.3 + 0.7 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "A refined hybrid algorithm enhancing adaptive chaos and stochastic tunneling, now incorporating dynamic dimensionality reduction and elite preservation for robust black box optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.43611076357809875, 0.4832654697207216, 0.45579358869149944, 0.47476831193308766, 0.4545690064987933, 0.41848391698710885, 0.42167110109252925, 0.4630222548335807, 0.44444733489187915, 0.32965802603411765, 0.39394317928910316, 0.31861240273882296, 9.999999999998899e-05, 0.37271905912275405, 0.08324953950622582, 0.13981941322896896, 0.3056561500552193, 0.25140332548315014, 0.1028097356074471, 0.136951408311341, 0.11052618986108187, 0.17271921858951578, 0.15014328391272558, 0.12660147564887902, 0.08673799873052834, 0.10566230434959456, 0.11363412112028015, 0.11090087751709454, 0.09255834236285332, 0.07098675908686469, 0.1147269831740908, 0.09972625993927231, 0.052696898529614566, 0.09898702003274829, 0.09503530583300579, 0.09341150611009164, 0.96624157619594, 0.7783314723268273, 0.860204952050662, 0.7920145040360623, 0.9021154222926061, 0.8949684012000904, 0.7590771058508503, 0.8007097337923609, 0.946892173557221, 0.29594473811797384, 0.3687622527677179, 0.3532669217000599, 0.18907295064393237, 0.3474780540246485, 0.30053165015351724, 0.29627368283811384, 0.2719858545421865, 0.3551989198875637, 0.5607748816948395, 0.5226102586763168, 0.7954289564925645, 0.8385365985854003, 0.696132404129852, 0.7889405499230371, 0.758423815394489, 0.6127750141135593, 0.7911982000042092, 0.3456994893728337, 0.22067970074275023, 0.026408839164590248, 0.22563387010427927, 0.2865748863802382, 0.2664590098719458, 0.31284832342953794, 0.1240810220896752, 0.2523186407499842, 0.2690131286184302, 0.11170391431302162, 0.1723459349070332, 0.13195970165548498, 0.25874686237601907, 0.28038802546950414, 0.2932802769047417, 0.2972319962406582, 0.13095967335797964, 0.3322501317671871, 0.31961429434334165, 0.369216740930868, 0.23425250998009528, 0.16680806364182177, 0.40631292051102996, 0.37459616076361535, 0.32521154550543663, 0.3787910928015149, 0.39546260653399135, 0.2957011035501461, 0.3842242440493312, 0.3508353884047296, 0.35785174408482967, 0.3983120283886602, 0.34576314754643867, 0.41850975611314956, 0.38822310798163373, 0.04668861906601818, 0.0908965242939963, 0.3130442369365084, 0.34280563100636885, 0.3545140312751617, 0.1808140100110992, 0.17357435025004975, 0.18776809900556113, 0.28803447302885576, 0.2742533547873759, 0.28004590788156014, 0.22804124016309757, 0.2389627314208449, 0.2592046674696965, 0.30337432183612634, 0.16885199828722364, 0.2766669443588373, 0.29822934363953957, 0.3777039000168062, 0.37375156666095133, 0.40883845439865285, 0.38899991600083383, 0.37245469635247785, 0.3984872017828699, 0.374371863019326, 0.394219027330844, 0.39053961887646305, 0.0846915555096448, 0.10806192981488238, 0.141342918094442, 0.18006155358856812, 0.10644964500339771, 0.15275842047033783, 0.15206481552796414, 0.11340268857130664, 0.1017117730507785, 0.18059561336943042, 0.37444778503322795, 0.2561084922716226, 0.17034637538307051, 0.4100220109260535, 0.3828337095091565, 0.3032421023567714, 0.38131503091012764, 0.2587581054229042, 0.28829993903946993, 0.30898423767068994, 0.3203787668561431, 0.3299332701648543, 0.30057235695693507, 0.28885786199134855, 0.3090061612931474, 0.3504925846962049, 0.31766590775459036, 0.23512493426453007, 0.2958802560969691, 0.27671338008448443, 0.3293650250249789, 0.2881607745987741, 0.31052625777996856, 0.3180821906569037, 0.31169247524061927, 0.29562584300961836, 0.2665602145767956, 0.24851571354465618, 0.21385237361369314, 0.2757342545443642, 0.22411971298730726, 0.25294499065778486, 0.22732856657462885, 0.2537950636153189, 0.24811308723363168, 0.20865193857266406, 0.24809746955681522, 0.22309395551606137, 0.22162416347396618, 0.36625157061826374, 0.25156287277757894, 0.1883929286790762, 0.21528872863720916, 0.20350368513485373, 0.6427080784420014, 0.2069758777163737, 0.15230521159469212, 0.6967898649336879, 0.19784098415407647, 0.15676471156015193, 0.1669237089256359, 0.6656072862001036, 0.7141195697283019, 0.6755403686702929, 0.6164256097999647, 0.583298719501294, 0.20737971196203886, 0.2087622344063782, 0.16711589475580257, 0.2092440894337524, 0.1266805349726161, 0.15397724685483338, 0.24495436012172056, 0.2804602463325555, 0.19834951040353932, 0.27133595673089206, 0.25127364634383653, 0.2912024449631888, 0.2120588451292471, 0.29763668522555053, 0.22539830467534716, 0.0995654715063804, 0.10844413024157462, 0.10982014497446924, 0.09720428644760815, 0.10180223728335891, 0.08785983197989067, 0.07961483329960195, 0.07964384767033517, 0.08826472570381172]}, "mutation_prompt": null}
{"id": "5b573503-6ba1-43ec-9aa4-83cb1814e3f9", "solution": "import numpy as np\n\nclass EnhancedFocusedChaos_AdaptiveElite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.15  # Adjusted elite fraction\n        self.focus_factor = 0.5  # New focus factor for chaos mutation\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.8, 0.8)  # Adjusted chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutability = self.focus_factor * (b - c)  # New focus on mutation direction\n        mutant_vector = np.clip(a + chaotic_factor * mutability, self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedFocusedChaos_AdaptiveElite", "description": "A novel algorithm integrating focused chaos mutation and adaptive elite reinforcement to improve convergence in diverse optimization landscapes.", "configspace": "", "generation": 68, "fitness": 0.16685347166815678, "feedback": "The algorithm EnhancedFocusedChaos_AdaptiveElite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.14.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.5185283221945185, 0.38754592921829256, 0.2772308751073921, 0.500679903364215, 0.2782686958719942, 0.3431176986585991, 0.297119949280763, 0.26091364838388853, 0.1589696945740845, 9.999999999998899e-05, 0.1495916398599798, 9.999999999998899e-05, 9.999999999998899e-05, 0.03149144875614551, 9.999999999998899e-05, 9.999999999998899e-05, 0.12296875585906786, 9.999999999998899e-05, 0.10256006090787506, 0.10309048831300538, 0.08343829284065307, 0.11970533731235433, 0.10044935061119209, 0.09375157735593909, 0.1565281058107526, 0.081776302435286, 0.10597735523875085, 0.03822224406014263, 0.08318492979596759, 0.0468019522276345, 0.11284517386387194, 0.05955953842391315, 0.049608104598323544, 0.10984478283881804, 0.1051900277051544, 0.030704683406243882, 0.12041069030652851, 0.11043946771387148, 0.08756243687502574, 0.0811220390829207, 0.10163037755716486, 0.07575796402771429, 0.1320139137094054, 0.9374816859920492, 0.06566936250964339, 0.10369917312808086, 0.048718266594977466, 9.999999999998899e-05, 0.06434171934369937, 0.1433642997307939, 0.04624984240971808, 0.12396136731755536, 0.08690121577332777, 0.148812996553622, 0.7624686587652815, 0.22686111410001575, 0.20540745216679657, 0.2720252925941691, 0.17274778280878478, 0.22870814904908143, 0.17558749800088957, 0.7627585718140838, 0.23612171651927893, 0.08817839207952693, 0.12540432865350193, 0.1227700764345252, 0.05382404827130571, 0.3651263031530483, 9.999999999998899e-05, 0.16087767744021308, 0.32189239445118234, 0.023433087782175566, 0.16162161647021456, 0.1136770372774345, 0.11980552466686645, 0.12340636085184364, 0.0652994348259861, 0.19245270197690978, 0.1557205799278385, 0.23415333519638293, 0.12817882744690245, 9.999999999998899e-05, 0.051704616042084095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005701538076085533, 9.999999999998899e-05, 9.999999999998899e-05, 0.018626833423995626, 0.3853189256561831, 0.09180422179584313, 0.1909911698548401, 0.09299437969218638, 0.14377559617256208, 0.11990842596099283, 0.27434177029605755, 0.22492099536249166, 0.16948961433959342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007034520138870848, 0.02949125792002727, 0.002779419413278972, 9.999999999998899e-05, 9.999999999998899e-05, 0.04577123697479113, 0.07745572382966037, 0.00922735252104745, 0.027984083059099274, 0.3475878845512853, 0.3318312635067243, 0.3543429838873632, 0.1757118764987987, 0.35135271177210314, 0.2669319724330633, 0.40887798962783406, 0.36405883895586866, 0.420766466392123, 0.0654540755431352, 0.05831452024240136, 0.1243528840999919, 0.12824986176869224, 0.09581445731626659, 0.14572263496890625, 0.10394287322702422, 0.1033978965407294, 0.09337426389285552, 0.17158045927087673, 0.23025812421595093, 0.20984026557621505, 0.18740704826119858, 0.18853169988459006, 0.22366085035411576, 0.248826019618144, 0.17439167100570652, 0.21020362601941422, 0.35402230755577935, 0.3265806193738582, 0.25852024176136856, 0.3315371814413107, 0.2491530964909402, 0.19703125685360756, 0.2658240789398282, 0.36073953794238833, 0.22737146125671492, 0.26138659552303456, 0.17966170126122438, 0.17464575704131535, 0.3718750418786506, 0.2712757289075145, 0.23792749653194945, 0.20421550232869246, 0.13588131370774226, 0.18773059486673205, 0.20850054143220642, 0.25450705328374024, 0.20928185393581333, 0.22109754321672914, 0.24269275998905393, 0.24820764000532802, 0.3079113460229794, 0.2766193847720786, 0.2598901638172908, 0.17666222537358878, 0.19587047140469194, 0.17332826551807123, 0.1922376776558622, 0.19089399946049534, 0.17370320539861372, 0.24183472238167736, 0.18097448030784524, 0.2087216925201565, 0.17958534693143902, 0.1474787401850779, 0.15305392932148976, 0.16994859351924785, 0.199109114494877, 0.19418617867505672, 0.1476824212556297, 0.15681194875517812, 0.38871748041569365, 0.23417786667101925, 0.20573539211841418, 0.24697490269702993, 0.11652711424394568, 0.23170104153002102, 0.1902146278280128, 0.16282473484599247, 0.3107116334014801, 0.49207656631007135, 0.26496114919578684, 0.2965924350306396, 0.20620411805533867, 0.18432273661048015, 0.24844157122357569, 0.19487040540376133, 0.1971694858689671, 0.186258900065847, 0.21485582594221608, 0.0862483900027542, 0.09053307401144106, 0.08750151874264067, 0.08061966563846978, 0.10629266825458639, 0.08238466418378576, 0.08877490808900224, 0.09900683758193085, 0.09656280287586227]}, "mutation_prompt": null}
{"id": "71895074-6d60-4f89-9a80-5088c1a1b698", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.15  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.9, 0.9)  # More pronounced chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.3 + 0.8 * evals / self.budget  # Further adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Shuffle elites to encourage diversity\n            np.random.shuffle(elites)\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "A refined hybrid algorithm with enhanced chaos dynamics, adaptive tunneling, variable population scaling, and elite diversity preservation for efficient black box optimization.", "configspace": "", "generation": 69, "fitness": 0.29835391580813786, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.19.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.47638592316532435, 0.41057880573606587, 0.38884808402866666, 0.42017333906764165, 0.427322903132917, 0.4594545128736016, 0.4103139569665587, 0.4512535192233187, 0.3690516613774302, 0.2754944278746544, 0.35166298674727414, 0.3719058108648725, 0.41580400598597755, 0.3603810430045796, 0.35484045868776704, 0.3527818330245597, 0.33418646582290645, 9.999999999998899e-05, 0.12008831177125123, 0.10508050350601439, 0.09836586260436675, 0.14913512593570943, 0.15170645335683242, 0.12711949012189927, 0.15199955795118203, 0.1196166728129694, 0.14872427468609473, 0.0851974613450831, 0.1083491067687663, 0.09257184978992139, 0.08949447721334969, 0.09273175590433202, 0.10448998638122353, 0.1293064453545696, 0.08064338534360105, 0.07458761501758293, 0.8113855278694535, 0.7641510717606912, 0.817848602689919, 0.8611794824947059, 0.7498491582702553, 0.941766944776331, 0.8673614384572187, 0.7788689167312562, 0.8893929500736655, 0.34363764282214704, 0.35341437757868777, 0.24984914876486342, 0.3666753160144779, 0.33216052821765707, 0.36181888784210436, 0.2791255712242806, 0.3087339523682956, 0.3227766180962668, 0.777462442845081, 0.7073057694284408, 0.7825621696164452, 0.6950204422406338, 0.43737785973808874, 0.7609354138308706, 0.8119595854592025, 0.5536215868804013, 0.7462869308518267, 0.12175517641743627, 0.12691179624521087, 0.3955500333727794, 0.3537253421479225, 0.34977124383988834, 0.014382122550454679, 0.23097000680576074, 0.2782486538955161, 0.19333422906128306, 0.24309151010637575, 0.19158101877889389, 0.12663857427125735, 0.2754722536782954, 0.33201097160977866, 0.18403599074468224, 0.1296840878472405, 0.1293558752058539, 0.13058691851686632, 0.3447835624232807, 0.3579460867445893, 9.999999999998899e-05, 0.29827826877672925, 0.3328468250655441, 0.32929184251008714, 0.3185888254637511, 0.3545060136549064, 0.3715566816525582, 0.4175516483903341, 0.4205148600576707, 0.3332961510244301, 0.2919217114654872, 0.36993804348574577, 0.4228796160612063, 0.3696237111192274, 0.4386578538918958, 0.4071387099953546, 0.08590149659230106, 0.08663448662218876, 0.23631466956984237, 0.3361992143300079, 0.3055595631468636, 0.13931264062271187, 0.13113208736918425, 0.24366899140217824, 0.14883677684053587, 0.2875285941583332, 0.2902983023772411, 0.22631500440168373, 0.2840137043519777, 0.2808832629204888, 0.2875046881553881, 0.3007612447911646, 0.23874331965695195, 0.27956980533775455, 0.38791743776068366, 0.4031807433926542, 0.37107580858263434, 0.3581356586574549, 0.41133512946854767, 0.36022830236939996, 0.3968087898431897, 0.4284071130182723, 0.4285382783350389, 0.13837160496928214, 0.09638513459116749, 0.1302559670396879, 0.38617051855825124, 0.09335698961245231, 0.10846782883689088, 0.11888955361611353, 0.13699494861316908, 0.15166670206530874, 0.21368328176054685, 0.21803003835374957, 0.20186068708203397, 0.19160090365630478, 0.3831442244847394, 0.19224364319076048, 0.21608433107440794, 0.2689972230570724, 0.2667481997926435, 0.3173091247349097, 0.3488365875542223, 0.3204145222757141, 0.3145458527161209, 0.30970663926868225, 0.32628267011571466, 0.3087237552860398, 0.31764552951630365, 0.32068111980451264, 0.3255140542597641, 0.285855725633838, 0.3057770223611679, 0.3004755750623833, 0.29179166021306036, 0.3137467269699179, 0.31666531942870346, 0.2912268910258856, 0.22292090173421664, 0.22920051685170195, 0.22965825626037117, 0.21117806003119333, 0.24159350790190293, 0.20530106891178967, 0.19720563396112478, 0.29092848028396956, 0.1680867192379999, 0.24456295362305314, 0.17875829765991524, 0.18687974917818573, 0.1858798570859692, 0.1904971424544728, 0.1818597484585045, 0.19486586126759953, 0.21351243590883873, 0.19179301762268164, 0.19789448839468582, 0.602759370569532, 0.14803217578898298, 0.21005001632591846, 0.6266110133815327, 0.1692383291337941, 0.19626911936042923, 0.1699655403849456, 0.16864322151069677, 0.64762875494671, 0.6287317535671617, 0.15665060977831746, 0.6598392626124749, 0.5965440126599103, 0.16477934267344285, 0.12231360582695283, 0.20436725945573508, 0.15304753386775705, 0.15542059022697208, 0.20162644474975444, 0.21854573755094586, 0.22426796358935375, 0.22907414881931443, 0.20081111274246233, 0.20963410097742086, 0.16720407579175478, 0.2570250215003843, 0.2259050993400289, 0.1069180412871672, 0.08444806049485343, 0.10015411679191111, 0.10243729896182685, 0.10570697779701355, 0.10037767116956364, 0.09685553652554024, 0.1001989157308486, 0.08802898391156666]}, "mutation_prompt": null}
{"id": "adad818e-20eb-4d08-930e-354c46e6398a", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite_2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.7 * evals / self.budget)  # Altered cooling schedule\n        self.elite_fraction = 0.15  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(0.6, 0.6)  # Adjusted chaotic factor\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite_2", "description": "An enhanced hybrid algorithm combining chaotic mutations and stochastic tunneling with adaptive elite preservation and dynamic strategy adaptation for effective black box optimization.", "configspace": "", "generation": 70, "fitness": 0.29602391925645605, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite_2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.18.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.43019604117938326, 0.42608892011598065, 0.43461468101387324, 0.42651576065001073, 0.4372900685772001, 0.5031119705617844, 0.434593985597859, 0.4559382947961923, 0.41463293775819987, 0.3988420364518086, 0.41656230654979165, 0.33974632449042064, 0.366294407173983, 0.3692732657118297, 0.3917041790439537, 0.3459131433772683, 0.3268207613216856, 0.11282827569407405, 0.11404150843545269, 0.11757026539671078, 0.12641736532516357, 0.08438434795111749, 0.12865714004055484, 0.10715787407180999, 0.1392809893236867, 0.1355979912484685, 0.08913084177608466, 0.09134132074041557, 0.06917401282854951, 0.11093556709419172, 0.10409736912239409, 0.09141503712745158, 0.08214497560137912, 0.1026390402978613, 0.1062672702274533, 0.10266753880076251, 0.8124805729320527, 0.9009172163693726, 0.9605967927519842, 0.7892214154637683, 0.7313428248316128, 0.6638219416289819, 0.8477080431103698, 0.8607362582453636, 0.8368062557718492, 0.3714429347885503, 0.27083397479237725, 0.37645139951930007, 0.35542649411223937, 0.3074971693870707, 0.29694904561637814, 0.31949052146267687, 0.2701597249702864, 0.34479544714417065, 0.726493767190853, 0.7605141411505875, 0.7241770953239388, 0.6667406586597568, 0.6568835053947994, 0.6334683721663599, 0.4477974542958686, 0.5732216730887938, 0.679288554802603, 0.35110724316265507, 0.25853774232311766, 0.12792768112560826, 0.17193015452726557, 0.2613960343944636, 0.12852033630614823, 0.23870483826914501, 0.36141954072306304, 0.3047439172875811, 0.1479019206418608, 0.12712725468688402, 0.12853993115444973, 0.12590000539189405, 0.3181080387031462, 0.2026372812456224, 0.3314657205841952, 0.27870470388253754, 0.23312926128764178, 0.3269676965939723, 0.266182479099105, 0.2419912731699959, 0.06991141065412998, 0.27282444688702046, 9.999999999998899e-05, 0.20319817495782588, 0.2228058343481507, 0.33451909815704306, 0.4272550134032803, 0.3586878734033815, 0.34739297158280147, 0.2764481577631899, 0.41348165497672096, 0.3863028214208093, 0.3673407458223321, 0.4169377661785312, 0.3938553115129293, 0.05179099573739765, 0.03461467192893508, 0.1157562169943267, 0.29248811002409225, 0.18657922045064956, 0.10769273670798174, 0.23087451941515702, 0.12492530154327364, 0.18599830640558013, 0.26859105606712985, 0.2991803708455253, 0.2385979195861785, 0.2806751655412687, 0.19972441205142077, 0.2720055216873355, 0.2633268991943456, 0.22749468229054404, 0.28865671228573353, 0.40740723438902304, 0.4218482449209434, 0.42098137977153083, 0.4240129288503688, 0.4013522881704146, 0.44524143109447845, 0.4062104473533288, 0.3808856481550481, 0.4319049227137417, 0.1522985981216829, 0.14864282106217908, 0.07637709000581949, 0.1275517307808548, 0.13140765016220635, 0.11071061869642107, 0.14728304957781369, 0.08504022320087457, 0.09710431478577097, 0.17053088107093006, 0.2229345982905765, 0.22770003295699615, 0.22595897670763831, 0.32753402445068713, 0.16920490090057105, 0.21278025618938634, 0.3251290277132679, 0.2431999690935741, 0.329882588040626, 0.32110952930455217, 0.33422567333152353, 0.3198232025071226, 0.21712395621502767, 0.32830863341841665, 0.313912007517545, 0.3122659269006832, 0.30581775980751735, 0.298250363087877, 0.15320047476046206, 0.2993460689873658, 0.29742570890059294, 0.30734370982801884, 0.28761291917394816, 0.29471645485764086, 0.32973319178304605, 0.22172327935679548, 0.2906248656243532, 0.21040358648936297, 0.22085156328011268, 0.22463412144208883, 0.2034870807137369, 0.2266599351297084, 0.28113334081704255, 0.21024527217464106, 0.21737713051689134, 0.18625099322224314, 0.21372635974092213, 0.21708210086990698, 0.37115152786266037, 0.18866203374176882, 0.19180682911328473, 0.19238767146511626, 0.20575078891558218, 0.2113816341920164, 0.16696020055364047, 0.1828598662807035, 0.5659800798968471, 0.1698988827238569, 0.19881887945345011, 0.6055762933712803, 0.5856596270060452, 0.16630522705159434, 0.6458760485081732, 0.6624227755842648, 0.20989841421103994, 0.19909051408089629, 0.16645968777064735, 0.20476112169195326, 0.20445807032954033, 0.6321060030529512, 0.21002120785822664, 0.6533979732960024, 0.24271168453805225, 0.21839222948770354, 0.22130801454277094, 0.261403488455735, 0.22057811869225008, 0.22661597161953828, 0.2624932209579992, 0.2748384362594445, 0.22414708583394327, 0.09245211165633338, 0.09818560875219118, 0.09340408815971735, 0.08171373535131154, 0.10610600626902433, 0.08992814874459387, 0.10477761471934988, 0.10281745294669131, 0.09994287257826617]}, "mutation_prompt": null}
{"id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 71, "fitness": 0.3148596808726621, "feedback": "The algorithm RevampedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "19a3ce08-7d30-4b1f-b468-571c8c3844d0", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "e60f3e6b-e5b6-4666-a204-f759258b32bd", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "50cf07fa-03a4-4457-9365-17d1a333d90b", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(1.5, 1.0)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid algorithm utilizing chaotic dynamics, adaptive tunneling, elite preservation, and dynamic scaling to balance exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.2773158262935333, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.37746734100414236, 0.38083857485830375, 0.42170887969176507, 0.37351945498356676, 0.39817287418787184, 0.4362094647080199, 0.39378987002308063, 0.40374787950799473, 0.40254221364758, 0.31977650329508633, 0.3067176470327131, 0.312674930447293, 0.2993023256287617, 0.3457427358747781, 0.3303615896475173, 0.28946833959268603, 0.3081498673108768, 0.27783754945066863, 0.13317376235870393, 0.10397351628459073, 0.10210656138372542, 0.12742583541517383, 0.0933510059677799, 0.130760314386679, 0.09296236568570071, 0.09149484390780616, 0.12497483604320347, 0.09212441407095762, 0.09532844240774485, 0.13499195610658976, 0.1106065051794709, 0.08026991721876564, 0.08253857926173058, 0.09889642057060377, 0.12992558419657307, 0.11652146941909558, 0.992050520289452, 0.9855922761382804, 0.9524382933656272, 0.9606697657980596, 0.9258647280077005, 0.9848163867365343, 0.934747310737069, 0.9266484170946561, 0.9831683812279634, 0.29570381134311896, 0.2865723692613463, 0.2549339998748762, 0.3027598549523235, 0.31606319450149556, 0.2892593321198834, 0.29880308272692857, 0.23811283523482973, 0.2827225557142993, 0.5936861792703636, 0.7866135232491889, 0.7362701284586115, 0.1998140443379116, 0.6336369515053668, 0.7026267572287734, 0.7270445908659535, 0.5428948759251023, 0.3388395459616297, 0.11742225528273242, 0.23965026684376733, 0.20399186907534395, 0.34264259979007605, 0.30802180870705365, 0.2935286994713123, 0.3379526631415116, 0.3315474469062688, 0.2080668278743255, 0.009918580579546643, 0.20771922906731666, 0.1191620606634739, 0.29374374669957615, 0.21885906871866945, 0.22620449971053425, 0.21834638307264687, 0.3160590614263521, 0.24547386119373282, 0.3021230948630007, 0.3234520838162538, 0.31084138339278167, 0.2835502025426475, 0.356048811649995, 0.2778259567147261, 0.3011428499187718, 0.29202997120607266, 0.31996277425685316, 0.3603215764697867, 0.35766896518998115, 0.3335231651456916, 0.39052305117680375, 0.3330896436192069, 0.29458983341019207, 0.3599972903801485, 0.33443190238787146, 0.3481156187042689, 0.07901940717017863, 0.06920802269024828, 0.141729617959638, 0.18427456910212048, 0.17542441139843046, 0.24125194679821815, 0.21400154390831871, 0.24161897648657282, 0.11271204047647188, 0.22735777558028025, 0.22199318570930304, 0.24123237620189963, 0.2395742793558382, 0.2238229745049093, 0.24037238209527523, 0.2566648863777975, 0.23118568273884654, 0.2141932705252686, 0.3450306359531179, 0.37214269057809035, 0.3616441124574027, 0.4201824609233782, 0.37503598129792304, 0.391574129994368, 0.3662251023345804, 0.42756257847712753, 0.35719433230719067, 0.12105973762432332, 0.08715175216815585, 0.10928576140006696, 0.10516737770744766, 0.10464379645947064, 0.12658183513455623, 0.12738192664433845, 0.08335314092392687, 0.10340005046446898, 0.1255521782496739, 0.14283099347534967, 0.19442247998141016, 0.10826420539482806, 0.3023563085658324, 0.20574266690003928, 0.18870375727285682, 0.13156054439297205, 0.1771255579822708, 0.2819044865718573, 0.27720699393749515, 0.30380774774225805, 0.2763552731926031, 0.27248002030837726, 0.2770720803704442, 0.2772434687296521, 0.2971708491747376, 0.29799722393046135, 0.2730199230968904, 0.21793910863210642, 0.24767909572594016, 0.2759866749819112, 0.27374135749045303, 0.2688110601224438, 0.2638689516517654, 0.29910226091365255, 0.2535352401847003, 0.18284191839454955, 0.17471577036586383, 0.16370124010500842, 0.15567843049442398, 0.1947170293348789, 0.18004787440096148, 0.17690441661620138, 0.18073498373898744, 0.21882681698142636, 0.23145190481273947, 0.2032779584972786, 0.20986233552488098, 0.18316628696460435, 0.20071288043400226, 0.22817436975859862, 0.22055841358321082, 0.27999875876232017, 0.23793201027541677, 0.17051570132470173, 0.1501190192946057, 0.15145207949306716, 0.18404906012288125, 0.16340888750467253, 0.18331852395475212, 0.16021796873791916, 0.16075231900039455, 0.5580055712341621, 0.60511192740926, 0.20265601488935403, 0.5464104191954833, 0.640445881353195, 0.15014860491884918, 0.12508479383046012, 0.2063734855298096, 0.20688664954806346, 0.1121234116026173, 0.18531912617551982, 0.18997597706055558, 0.18356462355544434, 0.16584990204091987, 0.16961829866337208, 0.14984107574452732, 0.20228889075595957, 0.1559056077538189, 0.1600994461687405, 0.0848720037343137, 0.060834929402888704, 0.08086318784315316, 0.07828509881562185, 0.05980876150595471, 0.08265525306690291, 0.08327459532215631, 0.07636357741098143, 0.06932195973598809]}, "mutation_prompt": null}
{"id": "b72fedbb-6c9f-48b8-9e06-cf435c82228a", "solution": "import numpy as np\n\nclass HybridChaosTunnelingEliteAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 80  # Adjusted initial population size to increase exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.10  # Adjusted elite fraction to reduce premature convergence\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Modified chaotic factor distribution for more variability\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor for gradual adjustment\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "HybridChaosTunnelingEliteAdaptive", "description": "A hybrid metaheuristic using chaotic dynamics, stochastic tunneling, elite enforcement, and adaptive parameters for optimized search and convergence.", "configspace": "", "generation": 74, "fitness": 0.2997687425823767, "feedback": "The algorithm HybridChaosTunnelingEliteAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.17.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.39182646778416363, 0.39437829990645046, 0.38466886012158397, 0.42092345041361445, 0.3922937791777876, 0.4110808116705874, 0.4029402779390814, 0.409594543481139, 0.397784924529235, 0.3272319949056286, 0.3522410862150267, 0.3258073269821068, 0.3296157500494883, 0.3101251024846341, 0.2485501508680228, 0.3238626114879726, 0.31988024510508495, 0.20872613614562596, 0.11114649121755005, 0.13442000317594904, 0.129560689073835, 0.17349331998881556, 0.1270990146012898, 0.15997690253244423, 0.15717444835934224, 0.1268127588948178, 0.11005416302987636, 0.10658919221244978, 0.1011528486841895, 0.10849503689595297, 0.120211182183532, 0.12150549391499355, 0.11265533594387378, 0.1360755383362905, 0.10012950901518358, 0.10072067596044088, 0.8432187057210307, 0.7239443607950558, 0.9640703320463618, 0.8249160288440461, 0.945278184962478, 0.7292418443354456, 0.876598537229934, 0.8679035347451238, 0.8060651314141198, 0.2984651643602917, 0.2771566051830552, 0.273381293615076, 0.2938161893045813, 0.31128210306778614, 0.2857138784909643, 0.2713696667068414, 0.30710345771623193, 0.32885196261671856, 0.8001127232154588, 0.6272249196700457, 0.7454959886693779, 0.667569923719993, 0.5497557501702149, 0.6580999848678438, 0.38625303152221846, 0.7197232733065081, 0.573469922228391, 0.2249232052538006, 0.2738408770945131, 0.20883865394762002, 0.29052494989912614, 0.31001436602746313, 0.18781505798741782, 0.3247238899796576, 0.2668872733103813, 0.2793560986191882, 0.07254115885989088, 0.3359318325436702, 0.20587325595821582, 0.24338244758466876, 0.1567236805984341, 0.3148741996518948, 0.16600116488411842, 0.2861013425817246, 0.2825385300778769, 0.33296163003833357, 0.31126065706742834, 0.31183895120952265, 0.3229895451312924, 0.3448889480385363, 0.3302395222630705, 0.34558014534960535, 0.3250023600255938, 0.3313616772349779, 0.37485478613463397, 0.39021633162880087, 0.35652326642215415, 0.34785096993829534, 0.38350392122683585, 0.374624572344723, 0.36379002213666933, 0.35875200627996506, 0.39774301147801394, 0.29275374257861053, 0.21320856840140945, 0.22506415406975344, 0.26267864176990263, 0.25349958382926885, 0.27538337597582185, 0.1841444821710123, 0.10734508553246214, 0.25045014270200094, 0.25708190398221664, 0.2592098450569692, 0.2506370893764748, 0.24255205508563094, 0.24620742618909186, 0.22941849124402525, 0.25495052639753624, 0.257484087729813, 0.2581828873895452, 0.3792302707384352, 0.3772496770485082, 0.368091053052243, 0.381594821606425, 0.36822740802723397, 0.3605359597000338, 0.35991883006503367, 0.37390391886994323, 0.3650725214140663, 0.1338165985837344, 0.1296112604870654, 0.11890768916488126, 0.1273129643653259, 0.13271863459915023, 0.15515620508559536, 0.254480637890076, 0.1268568377377325, 0.11565942163505205, 0.3129814028563048, 0.16727811792871106, 0.28739897862434594, 0.24367546439930632, 0.27327945545069166, 0.36684755459495666, 0.33058417523062555, 0.29771599570757157, 0.22851365069991214, 0.30375514461106756, 0.30063798733917246, 0.2954480696787255, 0.29914107489662434, 0.2936668720578134, 0.28448863406100877, 0.29347215237049207, 0.3034706311958314, 0.30050766321769395, 0.28247023517338476, 0.2665696428686968, 0.29694854252989056, 0.2923285473260344, 0.2567797396774385, 0.2912280146062326, 0.27777325033463685, 0.28881760625429476, 0.2774861955963698, 0.20938982576709164, 0.19712604487929264, 0.20477394107992275, 0.2149234761088955, 0.20173875460920654, 0.2015650705022951, 0.212366606396856, 0.21408833339116096, 0.21186705416443485, 0.23028862261474237, 0.1862555633512819, 0.19146118222195885, 0.21929189041052044, 0.19887520896681732, 0.18826847094890853, 0.20952368041404956, 0.20705630457109014, 0.2050641323061615, 0.5192001196396092, 0.20773552262456874, 0.571122116299388, 0.16852224765862067, 0.537878003249189, 0.20098417371157373, 0.5290777326380289, 0.5158358222162998, 0.5392437160522343, 0.5630230335270159, 0.20546698646136674, 0.20467357008728382, 0.19970639066350193, 0.5076282587020534, 0.19791951926311402, 0.2055240013099967, 0.5106459184054593, 0.2071207171590208, 0.20387419065790824, 0.19058989851443386, 0.17978326633067698, 0.18589005444922968, 0.18479134189984592, 0.17246745793794926, 0.18539877396559656, 0.19415078419512788, 0.19226987642511317, 0.0894268307479007, 0.07438347340263496, 0.09695267741073899, 0.07931669487277537, 0.09429063299706808, 0.08378565395007886, 0.09236302738753899, 0.09779809597011768, 0.1156608248443255]}, "mutation_prompt": null}
{"id": "c78f71b5-a9af-47e6-b7fd-5a3b8afea1cd", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "73c8d455-94ff-4f58-8250-0e232bbaf414", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 0.5 + 0.5 * np.cos(np.pi * evals / self.budget)\n        self.elite_fraction = 0.2\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * np.sin(np.pi * evals / self.budget)\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                non_elite_start = self.population.shape[0] - elites.shape[0]\n                self.population[non_elite_start:] = elites\n                self.fitness[non_elite_start:] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid metaheuristic utilizing chaotic dynamics, adaptive tunneling, elite reinforcement, and dynamic diversity control for optimized convergence.", "configspace": "", "generation": 76, "fitness": 0.31080011280131675, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.46823987911594445, 0.5340449584767808, 0.501357489954321, 0.5548216371050754, 0.4772220019315323, 0.5310532620804969, 0.5082195954676889, 0.5238880984354678, 0.47406053919577307, 0.31932145534915257, 0.3144535657057832, 0.377834537117942, 0.4586046997446136, 0.44433849545547965, 0.43874569357308535, 0.30755654988446735, 0.44152203782460153, 9.999999999998899e-05, 0.11517520712192708, 0.12759086773047423, 0.14733132510672298, 0.15069995241927991, 0.1272811367619, 0.1105100553965338, 0.12306260097780031, 0.1368454722352258, 0.12885818506501723, 0.07579770797942254, 0.1237426333914784, 0.11462741523948916, 0.08236092898489078, 0.10109247155808332, 0.07515806268321434, 0.183138266927942, 0.10420844014522668, 0.10394182270677288, 0.9566990046637415, 0.6710565507504703, 0.6097657825859804, 0.8540904716954746, 0.8677221411156919, 0.40271220468938373, 0.9778202210236705, 0.7555161263527983, 0.5791797676973676, 0.402330873024044, 0.2925200112950832, 0.2941966139759076, 0.16634005023425757, 0.2777306938829739, 0.4011998369243701, 0.3487602865204845, 0.15106137645205797, 0.3371295536684168, 0.860690917965473, 0.7791854144452347, 0.5705514730714245, 0.6802853715112103, 0.7592816331295463, 0.815075627272076, 0.768775839791256, 0.6533188062226569, 0.7904286880337207, 0.3091353274258435, 0.12462057357009093, 0.32203396020319586, 0.12410489895484056, 0.2373987837850623, 0.17130650748426746, 0.18783536776310272, 0.1279358770054143, 0.2030980497108913, 0.14398094273562623, 0.17952510628789464, 0.27736051630490133, 0.19013351584616311, 0.34707329118475305, 0.22618171634162088, 0.33233082461589614, 0.3791761440122956, 0.1825528411061148, 0.21416525218312854, 0.3652537408447084, 0.4699669225271643, 0.47810917356052796, 0.16565267081385626, 0.3838452911103193, 0.4012997574986411, 0.24317629384019324, 0.3577884495340916, 0.4454615292589318, 0.4742588032990228, 0.48240444632382984, 0.493506896909765, 0.47499674821561766, 0.44652939638473943, 0.5153319060319086, 0.4407454754821092, 0.4814812755954967, 0.1615816178684223, 0.10654949882894671, 0.17331043313318606, 0.22928695095921214, 0.19687771525881337, 0.09708420541975371, 0.16578243256300307, 0.1646627412670134, 0.273208663575779, 0.2743688510132142, 0.3415992271817798, 0.07185654896685079, 0.3287781958860051, 0.34251848106036564, 0.332508842680181, 0.3176677304781531, 0.3160311612062683, 0.33972216337568484, 0.4717371450599108, 0.4724756348515504, 0.48043464372724787, 0.43440327627095887, 0.45288430411775493, 0.4818483826947899, 0.49927896865471066, 0.4383851515736886, 0.4483301766710569, 0.10457517508978653, 0.10100318196151659, 0.09737097530328265, 0.1390780061589636, 0.09853730251959969, 0.12808088851093102, 0.13704751355196787, 0.09004957913909262, 0.1033097095988742, 0.2902789764277788, 0.2508731810703848, 0.1821328018411491, 0.23601190787763648, 0.3149131655449129, 0.26527442105786825, 0.2379642500207868, 0.25817860864604847, 0.26936498797014374, 0.35221283676130455, 0.3443536781835892, 0.35497002660511134, 0.37693890247631523, 0.3605423074326526, 0.3146009029247706, 0.34448319299729724, 0.35955698959310467, 0.3828273689700614, 0.2968623140539578, 0.3087118805835848, 0.3611316171831891, 0.335425042131395, 0.3457536083695768, 0.345618107337088, 0.34818297828296296, 0.3218084494548964, 0.3388125866596112, 0.20437368147557922, 0.19389589446354805, 0.19296660690226786, 0.180648743702434, 0.16970932365438807, 0.21624669621100034, 0.1989060751886902, 0.19375394563338977, 0.21714226252307256, 0.1939946599386826, 0.18222056081869276, 0.19294158488690483, 0.19378550451951282, 0.20613340171616357, 0.1883913613244116, 0.19034725814834186, 0.24290042295817982, 0.21443649024661227, 0.18436102200567384, 0.16273343760829517, 0.1515969181842245, 0.7138875071700861, 0.19862556934042908, 0.19559690895287696, 0.14127954240270046, 0.1383029521017426, 0.8050985189468584, 0.826732240758684, 0.6409776385510323, 0.7906714905383723, 0.19982580522254345, 0.1633530404433543, 0.20589898619176783, 0.15322271122690723, 0.20465695978118614, 0.2089164429772321, 0.15902981517994763, 0.17652675759874803, 0.1786704790206891, 0.16885135070890012, 0.1973755011379701, 0.1819030301199227, 0.17575389052594614, 0.19025965550567348, 0.18414718672829944, 0.08222268403868471, 0.07230720588132078, 0.07332352977470069, 0.08407819548428963, 0.0944951018245036, 0.09127718092450832, 0.06772658346466287, 0.07752780560245787, 0.07881501761545262]}, "mutation_prompt": null}
{"id": "2ce6c6c2-5a29-4b95-bd9d-8969ab6e4c40", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "30f44f1c-eb82-4c12-93a1-ed3050b8efc4", "solution": "import numpy as np\n\nclass AdaptiveHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 / (1 + 0.5 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.1  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def adaptive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.adaptive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridChaos_Tunneling_Elite", "description": "An adaptive hybrid metaheuristic integrating chaotic dynamics, randomized tunneling, and elite reinforcement with dynamic population scaling and diversity-convergence balancing.", "configspace": "", "generation": 78, "fitness": 0.3036865608020303, "feedback": "The algorithm AdaptiveHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4251726482559085, 0.4408659200160471, 0.41146988738746726, 0.42238899032259347, 0.43667106806251965, 0.4086027469034921, 0.42163967744331043, 0.4659085795813961, 0.4068365144935149, 0.31004475973387235, 0.3847181397427816, 0.3784208106629513, 0.39110427910653855, 0.2402382023827928, 0.3521179505961276, 0.36761913144049063, 0.3591147834569465, 0.31090853854712597, 0.14826728524856192, 0.1083849161101369, 0.17651036245809848, 0.12833405630238992, 0.11488563806753704, 0.1564512597432044, 0.11324930995233007, 0.1334977055367581, 0.1196425310207695, 0.09783556367787227, 0.10109702434257017, 0.0956067368208372, 0.134490473571113, 0.14199634012382045, 0.09262385132117146, 0.06933166953832626, 0.12324449568377271, 0.10825999906680372, 0.9618046868288105, 0.8311345279484922, 0.8727406998907754, 0.8254400063333276, 0.7169826604588385, 0.8414167436933603, 0.902374083763618, 0.7275669629470954, 0.8523561399071509, 0.352964994068923, 0.3111100811097104, 0.333268181526705, 0.3289229734386119, 0.32813578026938295, 0.3155508765662737, 0.310487449479141, 0.31605099694000227, 0.3445021101079875, 0.906362453938665, 0.38235126324322544, 0.5790855566205036, 0.8317959321319592, 0.849376660330678, 0.8485234532909117, 0.7803984214585236, 0.5528152983153458, 0.780144782708402, 0.4576497949013525, 0.1967405741260272, 0.21207052537473903, 0.29129742782466794, 0.3469716398722671, 0.12630308017855874, 0.32985387498499763, 0.3027340363046511, 0.2842357941532119, 0.3159181713643058, 0.31101586301454054, 0.37632827300065996, 0.2778424992242384, 0.2923124249576903, 0.3031931856231461, 0.2970121245936601, 0.24616470270754964, 0.23926532357803243, 0.32389069397518433, 0.33867316030746375, 0.31828000402102796, 0.3682662186037523, 0.2926349668435194, 9.999999999998899e-05, 0.24600820716933125, 0.295726318663979, 0.3194392175259252, 0.37558226084767143, 0.36315813837067323, 0.39413897237876094, 0.39309026436703987, 0.280195788219606, 0.36170570686721515, 0.3675032401799081, 0.40267430986996755, 0.38822139683779344, 0.19980188153755607, 0.11324848609119342, 0.05465741592229201, 0.28622602925914586, 0.182564819711864, 0.3022688537105179, 0.2677387796761376, 0.24416049455806965, 0.21904216388246578, 0.28018532919727757, 0.27390133625224944, 0.2568396172971462, 0.28721245679548324, 0.17769894989856116, 0.17631485352149756, 0.25565902136312113, 0.24558197789012426, 0.24432318217374915, 0.4121842161019946, 0.37832068524271967, 0.392761920008752, 0.3645492626859047, 0.37399457982193196, 0.38001081160023586, 0.4007546175237743, 0.3638598772231917, 0.39932319884634837, 0.15279603183460855, 0.06216888256194675, 0.13286879155235165, 0.1642683984205925, 0.08854519332620836, 0.11606141094032596, 0.11673783703234475, 0.08425090208310104, 0.17509976049241993, 0.23322609844449227, 0.16090513153155483, 0.178162628314794, 0.3457299010170618, 0.16365875443775335, 0.27122041175400824, 0.26090325737071085, 0.19852794007415242, 0.3229022421226778, 0.2874011342269265, 0.2865757719876164, 0.309781998193447, 0.3140932798490642, 0.30505389190707144, 0.3081193240571599, 0.31253211391099134, 0.31336056763133135, 0.29392977984727786, 0.2249799622017239, 0.28512462488754897, 0.3026600194642126, 0.3034851161180451, 0.23478888822543065, 0.29258068299461615, 0.2995168050395276, 0.21352376529341055, 0.28495081938610745, 0.22696537317429633, 0.22691216625043942, 0.21794805525871752, 0.20393165780531508, 0.21754105566302928, 0.20104454276320438, 0.2003007189426298, 0.20148404763820116, 0.21642143411406145, 0.2060558580038493, 0.18485997537751797, 0.35422396054977967, 0.20895516645134704, 0.214338057302361, 0.18940048276928945, 0.20827715508695777, 0.205136259367661, 0.20350942349942347, 0.5967783602295578, 0.1764507369966244, 0.15587777137737702, 0.17579164447240114, 0.614927960726628, 0.6219546513109688, 0.1807527746761407, 0.16753829290558586, 0.168763513070185, 0.5994505550862248, 0.5250037336686146, 0.6014385404538896, 0.5786058061971671, 0.1655258520224544, 0.15240667982102185, 0.2097967257484452, 0.20939719624375053, 0.1550656412376169, 0.17582576722806698, 0.1790480572862242, 0.17112511151827126, 0.18139131723878643, 0.2030071649562527, 0.18172702671231422, 0.1841743738251569, 0.21165767650785428, 0.1964271647376653, 0.09244440060434422, 0.13334905301209965, 0.11272336496316826, 0.0850129367072966, 0.07942633135097221, 0.11701721814934696, 0.09969221809964346, 0.10429586440829519, 0.0940295184726525]}, "mutation_prompt": null}
{"id": "6a830b0e-5c7e-45f2-8cbd-99c4369edbae", "solution": "import numpy as np\n\nclass RefinedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 70  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Further modified cooling schedule\n        self.elite_fraction = 0.2  # Adjusted elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Further altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n\n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Improved scaling factor calculation\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_Tunneling_Elite", "description": "A refined hybrid metaheuristic integrating chaotic dynamics, adaptive tunneling, and elite reinforcement with enhanced dynamic population control and mutation.", "configspace": "", "generation": 79, "fitness": 0.30605314770486075, "feedback": "The algorithm RefinedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4201771015510445, 0.42177278076947033, 0.41961517543189064, 0.44813205135427203, 0.45387284489165036, 0.4160205152569517, 0.4327053198632925, 0.42670854907226563, 0.4180149594575009, 0.36185606367474155, 0.26881656678828136, 0.36093459440246023, 0.3280357469237447, 0.34532482890079164, 0.35967312734169066, 0.3363677339112995, 0.33847905436082004, 0.33651932709890675, 0.17281285128112234, 0.16400561601778663, 0.13074997427623714, 0.1684843700633697, 0.14611963042655807, 0.11293561467683977, 0.11322762836763922, 0.14780143512645683, 0.12656144814040016, 0.10009666474498025, 0.0894252215417084, 0.08824775734466472, 0.13039515751115338, 0.08379080600643252, 0.09036044929994891, 0.10999561846373929, 0.06325579277458893, 0.12824612062439789, 0.7588024051937757, 0.9814661834403152, 0.7346829252049996, 0.7312431400226249, 0.8546048023288175, 0.6689418911472838, 0.9148359567975013, 0.8755546329116257, 0.7967931474926688, 0.3555739596256905, 0.3373544943122959, 0.3169160306081682, 0.3198049414238813, 0.33899549462835654, 0.2835403358463233, 0.36046029891218434, 0.3260720601393514, 0.3282426820442821, 0.5235733331605836, 0.7802559843179928, 0.7313680491093383, 0.6273797391335019, 0.8534041599269749, 0.6534171948711167, 0.7532702759898717, 0.7717043407748042, 0.8108526951901756, 0.3466640127007702, 0.25300491958032967, 0.2487980134663238, 0.16441308262954157, 0.3203460858889078, 0.12199705692917073, 0.2730373112830169, 0.2254470419520207, 0.2150092579880215, 0.3034732160125555, 0.12323292018872867, 0.1671915825268797, 0.3266074560093528, 0.19461025930570963, 0.2305371036353907, 0.3752019694313916, 0.19106837095102003, 0.23452916504584287, 0.33872130166375547, 0.3551816498643563, 0.3131211561113414, 0.3353782618897816, 0.29078805091510584, 0.33885150109676887, 0.3630005330509839, 0.3444840128857799, 0.35403187343701037, 0.36347574181418696, 0.3710149055948304, 0.34710052830105387, 0.39630374452327966, 0.41372359394382774, 0.37920908304066725, 0.3754311769101232, 0.3868221533529602, 0.381116083169625, 0.10711754963711939, 0.20227516173004711, 0.15676559804077428, 0.17385509684268163, 0.34417738755266036, 0.33479260300144864, 0.15265206693215383, 0.29560827080570173, 0.1012824952444824, 0.24338895194004895, 0.26907076967330945, 0.27410853501538557, 0.2593867989725449, 0.2886931272919864, 0.2916897103967018, 0.2657707308369215, 0.2685946193592771, 0.28110557305392536, 0.39715608713210726, 0.3829557826328287, 0.3741362101874537, 0.39416937459171963, 0.41616616672091244, 0.38796826086950076, 0.40222756706166773, 0.38276933106548894, 0.3823046744115042, 0.1428770406328349, 0.14700260651602493, 0.08742558502238862, 0.13399250207577296, 0.13466550219337603, 0.13644194070629545, 0.15124146698699803, 0.12295142050530572, 0.1253758062326349, 0.31334232348861835, 0.20980304704858754, 0.17256076018381228, 0.3173272834267066, 0.31577248425877025, 0.16955741834529958, 0.2778596750012816, 0.25259354963902736, 0.1849792653267931, 0.3167288563938744, 0.3107032925694736, 0.3285327954760704, 0.30878764207580955, 0.31743505769607494, 0.3135543131240054, 0.3133280262642294, 0.3086526320649253, 0.30127099653364875, 0.28185225607977404, 0.29332742980189297, 0.30958007484240524, 0.3029002091471088, 0.2883129387125385, 0.29640217890738696, 0.320189910324608, 0.3017989732214966, 0.297146362894943, 0.18642228729896926, 0.24133992422226302, 0.2059461281292414, 0.239841663883673, 0.20658727548414524, 0.1829600829407768, 0.1822860851201723, 0.2103564645602819, 0.21996693659193112, 0.21397056847657903, 0.19426676766009943, 0.3397362353540555, 0.21192993392459647, 0.20980427509785382, 0.1929787586349747, 0.20839313735718923, 0.2341075549338808, 0.21603010287260926, 0.2073481169561664, 0.666327152511001, 0.15119649524661072, 0.5107315286444893, 0.19769335993294035, 0.19506348916344163, 0.5309356072223004, 0.16352374929614433, 0.6411646844459065, 0.6546594854807544, 0.20926860876629017, 0.4419808694243863, 0.20192416161054882, 0.5046528287226297, 0.5065809967223449, 0.1623050258971953, 0.20910349744659262, 0.2074081978568495, 0.18281511268741957, 0.18094061240737402, 0.1812134795610899, 0.2062498272575929, 0.1656240117669684, 0.20468234496637794, 0.20391374939563056, 0.18049800286325557, 0.19568632275719045, 0.08627967911926593, 0.11532732463038087, 0.09416294320538132, 0.08390238543010875, 0.06692083300617235, 0.09265436447752562, 0.08332071586039869, 0.08782374380746005, 0.08863645905528705]}, "mutation_prompt": null}
{"id": "c7709f8f-ac4e-4ec3-92ea-c1b937f12e2a", "solution": "import numpy as np\n\nclass RefinedHybridChaos_EliteAdapt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_EliteAdapt", "description": "A refined hybrid metaheuristic leveraging chaotic dynamics and elite preservation with enhanced adaptive scaling and convergence strategies for robust optimization.", "configspace": "", "generation": 80, "fitness": 0.3093277194116394, "feedback": "The algorithm RefinedHybridChaos_EliteAdapt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4778213343648168, 0.4349279280268934, 0.45682369715456705, 0.4379276217347924, 0.464981898641577, 0.42732141087788567, 0.4307995730937547, 0.43437808285838664, 0.41577615337837803, 0.08309617641554745, 0.389644632514221, 0.38488816008816007, 0.33743110845186797, 0.37428528268233496, 0.3694035794452346, 0.1659178280301703, 0.3609107155582386, 0.16781043582424604, 0.10706406845980487, 0.10092960097555514, 0.07004231195915323, 0.15404295600131623, 0.13654539655383846, 0.13570529376577178, 0.34511760267339564, 0.15188157714984007, 0.1309959004174459, 0.1128431119865434, 0.09631246413603056, 0.06753676892644, 0.08803331575578699, 0.09177061356102167, 0.11175428861274028, 0.09314345780002276, 0.08834236945020513, 0.09051957190157245, 0.8585190902428599, 0.7843191792989487, 0.7477994227830906, 0.7883788336230793, 0.8175376195644648, 0.7726830476278242, 0.8940437669091682, 0.830779277770605, 0.9813900198569281, 0.3734614671412081, 0.3391171824350754, 0.30874475291893755, 0.2764126973550225, 0.3088737899764694, 0.3738250911288815, 0.23046460366951105, 0.30989166054578055, 0.38197618346471407, 0.7986697316386473, 0.8950448401161661, 0.8566681511399745, 0.7715778405053595, 0.8601776536446306, 0.8051096890624846, 0.7567712435627858, 0.6976100467760467, 0.8536943761722721, 0.4224833410746638, 0.18468581382369897, 0.38229428856808656, 0.25066108941501575, 0.12838830471796736, 0.23343784393845746, 0.1619860939558323, 0.3756281477717658, 0.21393343477247284, 0.3199101519631603, 0.24226378934860004, 0.36868085115822125, 0.24013447986381298, 0.23730633238526644, 0.31500562945704824, 0.1333489068135948, 0.2131963054461793, 0.23992495769155475, 0.35419182932243953, 0.2743246340857476, 0.39366197639676404, 0.10414072492560522, 0.2963390128266231, 0.3261359782623837, 0.22609479199371352, 0.10145678411431014, 0.3703306652897643, 0.4349203474679948, 0.3926878118966908, 0.4099064204910867, 0.360640410106825, 0.3953947167664512, 0.295797153434721, 0.3184482043780229, 0.3953719101686032, 0.41858065757984664, 0.13002788333631665, 0.18189158091061997, 0.2571441115198144, 0.3360503688091583, 0.36201064542592465, 0.30455105284555806, 0.35511915578897146, 0.3431155087874642, 0.23485553538485104, 0.29615428277484757, 0.21167376027053486, 0.2965952937569699, 0.03615094430415133, 0.28520427489215205, 0.27860582776220166, 0.29909732922130194, 0.30014828861249776, 0.2162574757979956, 0.39960899353100243, 0.41170375579504237, 0.4118621108027981, 0.3985490003934252, 0.4024848395014192, 0.39818131888642505, 0.3942771000802978, 0.4014511922699705, 0.40304923929662495, 0.11470705888427513, 0.06578539853934073, 0.09383692604335392, 0.10162209808574973, 0.12108541413343865, 0.11793413920965634, 0.11309695029768374, 0.11488686062927866, 0.13369739806816305, 0.15697252770385495, 0.21801532389489875, 0.20894492218484717, 0.3607523174149505, 0.3523105687400615, 0.25445671266051084, 0.2879614714589971, 0.20948902184059703, 0.13980012203879155, 0.3182987191178308, 0.3128159785057556, 0.328338005832731, 0.3302813907524351, 0.2918726850292135, 0.318039917848007, 0.32676521394921587, 0.3493901671268028, 0.325355291922927, 0.29902593733580085, 0.29090344226739107, 0.30538313036509457, 0.3185579048439072, 0.28514992779379167, 0.29406242722204756, 0.24586760386301654, 0.31816670872341124, 0.3231525006074192, 0.1758320492998735, 0.23947103117537105, 0.18973981666864725, 0.19789909715199816, 0.24496426532989013, 0.1927103628567577, 0.19652199238629364, 0.22994829582468435, 0.20184042909568212, 0.217749365658932, 0.22278792085791876, 0.18389551206922616, 0.1958660523400767, 0.2092232704583844, 0.1987743122175044, 0.24310917686429578, 0.20484306339897107, 0.18169489296918984, 0.17173855979962027, 0.16372443292451522, 0.15697187200483764, 0.6418947844551417, 0.1992356860084642, 0.6821050773320456, 0.16099877507502225, 0.16829206336507774, 0.6458474277888386, 0.5687547715046493, 0.15526779280841274, 0.6491330531411265, 0.5254198296179549, 0.16550076170357875, 0.5900074423669079, 0.20711260781171703, 0.5914191144701473, 0.15374412193005516, 0.18459162480757518, 0.18832357943114597, 0.18638208960000857, 0.17728476980087104, 0.15640905585989517, 0.17244815864391805, 0.1657178109114591, 0.17078499302125782, 0.2004062262252705, 0.10279125773283615, 0.08822035308576448, 0.11202399371109828, 0.08128047937059346, 0.0815563004961537, 0.07619790864022236, 0.06664142428216036, 0.08516693211715942, 0.10995695891984991]}, "mutation_prompt": null}
{"id": "67345469-d7b1-4f1c-b6fe-308a39a260db", "solution": "import numpy as np\n\nclass RefashionedHybridChaos_AdaptiveTunneling_EliteRetention:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.1  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 0.5)  # Changed chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def adaptive_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_prob = np.exp((current_fitness - trial_fitness) / current_temp)\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_prob:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_retention(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_retention()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.adaptive_tunneling(func, i, evals)\n                evals += 1\n            self.dynamic_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RefashionedHybridChaos_AdaptiveTunneling_EliteRetention", "description": "A refashioned hybrid metaheuristic utilizing chaotic perturbations, adaptive tunneling, and elite retention with dynamic scaling to enhance exploration and exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.28441528333251237, "feedback": "The algorithm RefashionedHybridChaos_AdaptiveTunneling_EliteRetention got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4027648686737121, 0.3795329477859437, 0.42874271948302134, 0.38955561636213676, 0.41009453999629575, 0.3906192854476134, 0.42848067941143964, 0.42626517881499804, 0.3895214816529412, 0.3311731169502836, 0.3377514545407838, 0.36042763092039753, 0.28662347218032025, 0.3216853001972835, 0.3325016021249557, 0.3191336983287051, 0.30069675958321385, 0.28949983221460784, 0.09917634606042991, 0.11787498665375984, 0.14726031110287718, 0.15208318938639076, 0.13327240842557586, 0.29050281748949547, 0.13320595493746878, 0.10608470774603485, 0.07523532384258125, 0.1359955307702312, 0.11631226191278077, 0.10167775126896084, 0.11151002841115931, 0.0861440669553587, 0.08444982843500182, 0.08568564190549843, 0.10136566854554163, 0.1289565187313143, 0.976433766903599, 0.9807180040900276, 0.9632168681908924, 0.9020432889525208, 0.9543085109022859, 0.9452087803730199, 0.964753536806275, 0.9352830680261741, 0.9631873768650705, 0.34348485360921466, 0.2923579701754624, 0.18564304049808666, 0.29859514197306214, 0.29183831706481944, 0.31985077487946634, 0.3069190314205713, 0.29754572002010604, 0.34305815735770406, 0.6331728775186718, 0.5777805762570063, 0.5415370125624304, 0.737059470250764, 0.7670700181539348, 0.49166208227318375, 0.6204526768773011, 0.4944791194497512, 0.35383766572857633, 0.23047320589754616, 0.2954617796353649, 0.30893244336969516, 0.2761435538978658, 0.29010285738742125, 0.2666849472536055, 0.2855317627888141, 0.3196493359412801, 0.29990817996037045, 0.28074188132454125, 0.016363225216742827, 0.2275830176686272, 0.23780851689414162, 0.27229917112808555, 0.12686583633227166, 0.24743881875141227, 0.3310439466955555, 0.28762221584936043, 0.3061287482998336, 0.3267100799368353, 0.327739402662961, 0.31353130257690887, 0.31396634166668413, 0.3140256015402628, 0.31020302360134544, 0.32049509124986053, 0.29057191357159384, 0.3565280905884388, 0.35352955556911747, 0.3441836177295974, 0.36722258065971913, 0.36372844099877943, 0.33705503439312356, 0.35897379545044983, 0.35882009144110616, 0.3225474720178494, 0.15545253711866647, 0.16875331633363, 0.15950807089449504, 0.2686391455460313, 0.23893756823855627, 0.20696450279186174, 0.16695472701322922, 0.10352661389652817, 0.13808516057185627, 0.22950696336785203, 0.2494232391612643, 0.23713366844860506, 0.2510224549167086, 0.2447739565790108, 0.2633010445282844, 0.23749336791225628, 0.2320410071989627, 0.2593975328937529, 0.343699033330768, 0.3555155913106962, 0.3603881216390621, 0.34683751887915815, 0.34387640154428145, 0.35467453418520867, 0.39185898359208093, 0.36861221187225257, 0.3558488107681619, 0.13688979478612984, 0.12225803848433148, 0.1267428871276436, 0.13299009017555186, 0.10316168879947085, 0.13543564216114223, 0.12807030651562512, 0.11707646033731312, 0.11642322721276122, 0.2322278227071316, 0.14699456956631218, 0.13097514446713665, 0.3096898794425822, 0.17412049532575324, 0.16635340996229186, 0.20938043954596797, 0.20852112271688128, 0.2999079322774758, 0.2707169274876191, 0.29403385549858096, 0.2905678888802741, 0.2866033297769889, 0.27749575030154916, 0.2729624360307915, 0.28306959951188515, 0.2860897540326499, 0.2788763463031909, 0.271698203821907, 0.2684662287292259, 0.26113168521066876, 0.27373136840375945, 0.2542594709850504, 0.262101354686057, 0.261814547092585, 0.2587838632769577, 0.2601894437990767, 0.18986133833668695, 0.18608725227748568, 0.1926744055048224, 0.21520126716267796, 0.18122678377058776, 0.19675854357059164, 0.20888332171692425, 0.19565987127495488, 0.20666742949181105, 0.18732428434951864, 0.19293108373181234, 0.21405526741757208, 0.2217849175452392, 0.2127783552213366, 0.20347184562688814, 0.19876726127873467, 0.19587878008771353, 0.19146748548543202, 0.16849864813492, 0.14940462742495852, 0.15299114970918748, 0.1969583736254894, 0.18019268481622153, 0.192308249051108, 0.604076664242556, 0.1637073808497007, 0.2000838141062582, 0.4932529806281737, 0.20470012186376452, 0.54609485665825, 0.5355419362472147, 0.16259113014657856, 0.1665235643069165, 0.20700104251805584, 0.20651940767530952, 0.12663538008759312, 0.2515199901239893, 0.16827903353051166, 0.1951882440987872, 0.18656547186799877, 0.15927517904045763, 0.16284169075696742, 0.17763914406606474, 0.1886085832805754, 0.1928796411619904, 0.09511593967594256, 0.08145055877130036, 0.0868286008165674, 0.0704102078180151, 0.0817704658882481, 0.07845243609001651, 0.08977365347914512, 0.09141940187956221, 0.08510824718368681]}, "mutation_prompt": null}
{"id": "f186afc7-4db6-4fff-aad4-d498afb967b0", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "e9430d2f-1847-4590-9c57-b56fead43747", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 80  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 0.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def competitive_collaboration(self):\n        subpop_size = self.population.shape[0] // 3\n        for _ in range(3):\n            selected_indices = np.random.choice(self.population.shape[0], subpop_size, replace=False)\n            subpop = self.population[selected_indices]\n            subpop_fitness = self.fitness[selected_indices]\n            \n            best_idx = np.argmin(subpop_fitness)\n            for idx in selected_indices:\n                if np.random.rand() < 0.3 and subpop_fitness[idx] > subpop_fitness[best_idx]:\n                    self.population[idx] = self.population[best_idx] + 0.5 * np.random.randn(self.dim)\n                    self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n                    self.fitness[idx] = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n            self.competitive_collaboration()\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid metaheuristic integrating chaotic dynamics, stochastic tunneling, elite reinforcement, adaptive population diversity, and competitive collaboration mechanisms.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 26').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 26')", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {}, "mutation_prompt": null}
{"id": "e47427dc-48b7-46f8-b1de-023358654ff0", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid algorithm integrating adaptive chaotic mutation, stochastic tunneling with progressive tuning, and elite reinforcement to balance exploitation and exploration in high-dimensional search spaces.", "configspace": "", "generation": 84, "fitness": 0.3093277194116394, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4778213343648168, 0.4349279280268934, 0.45682369715456705, 0.4379276217347924, 0.464981898641577, 0.42732141087788567, 0.4307995730937547, 0.43437808285838664, 0.41577615337837803, 0.08309617641554745, 0.389644632514221, 0.38488816008816007, 0.33743110845186797, 0.37428528268233496, 0.3694035794452346, 0.1659178280301703, 0.3609107155582386, 0.16781043582424604, 0.10706406845980487, 0.10092960097555514, 0.07004231195915323, 0.15404295600131623, 0.13654539655383846, 0.13570529376577178, 0.34511760267339564, 0.15188157714984007, 0.1309959004174459, 0.1128431119865434, 0.09631246413603056, 0.06753676892644, 0.08803331575578699, 0.09177061356102167, 0.11175428861274028, 0.09314345780002276, 0.08834236945020513, 0.09051957190157245, 0.8585190902428599, 0.7843191792989487, 0.7477994227830906, 0.7883788336230793, 0.8175376195644648, 0.7726830476278242, 0.8940437669091682, 0.830779277770605, 0.9813900198569281, 0.3734614671412081, 0.3391171824350754, 0.30874475291893755, 0.2764126973550225, 0.3088737899764694, 0.3738250911288815, 0.23046460366951105, 0.30989166054578055, 0.38197618346471407, 0.7986697316386473, 0.8950448401161661, 0.8566681511399745, 0.7715778405053595, 0.8601776536446306, 0.8051096890624846, 0.7567712435627858, 0.6976100467760467, 0.8536943761722721, 0.4224833410746638, 0.18468581382369897, 0.38229428856808656, 0.25066108941501575, 0.12838830471796736, 0.23343784393845746, 0.1619860939558323, 0.3756281477717658, 0.21393343477247284, 0.3199101519631603, 0.24226378934860004, 0.36868085115822125, 0.24013447986381298, 0.23730633238526644, 0.31500562945704824, 0.1333489068135948, 0.2131963054461793, 0.23992495769155475, 0.35419182932243953, 0.2743246340857476, 0.39366197639676404, 0.10414072492560522, 0.2963390128266231, 0.3261359782623837, 0.22609479199371352, 0.10145678411431014, 0.3703306652897643, 0.4349203474679948, 0.3926878118966908, 0.4099064204910867, 0.360640410106825, 0.3953947167664512, 0.295797153434721, 0.3184482043780229, 0.3953719101686032, 0.41858065757984664, 0.13002788333631665, 0.18189158091061997, 0.2571441115198144, 0.3360503688091583, 0.36201064542592465, 0.30455105284555806, 0.35511915578897146, 0.3431155087874642, 0.23485553538485104, 0.29615428277484757, 0.21167376027053486, 0.2965952937569699, 0.03615094430415133, 0.28520427489215205, 0.27860582776220166, 0.29909732922130194, 0.30014828861249776, 0.2162574757979956, 0.39960899353100243, 0.41170375579504237, 0.4118621108027981, 0.3985490003934252, 0.4024848395014192, 0.39818131888642505, 0.3942771000802978, 0.4014511922699705, 0.40304923929662495, 0.11470705888427513, 0.06578539853934073, 0.09383692604335392, 0.10162209808574973, 0.12108541413343865, 0.11793413920965634, 0.11309695029768374, 0.11488686062927866, 0.13369739806816305, 0.15697252770385495, 0.21801532389489875, 0.20894492218484717, 0.3607523174149505, 0.3523105687400615, 0.25445671266051084, 0.2879614714589971, 0.20948902184059703, 0.13980012203879155, 0.3182987191178308, 0.3128159785057556, 0.328338005832731, 0.3302813907524351, 0.2918726850292135, 0.318039917848007, 0.32676521394921587, 0.3493901671268028, 0.325355291922927, 0.29902593733580085, 0.29090344226739107, 0.30538313036509457, 0.3185579048439072, 0.28514992779379167, 0.29406242722204756, 0.24586760386301654, 0.31816670872341124, 0.3231525006074192, 0.1758320492998735, 0.23947103117537105, 0.18973981666864725, 0.19789909715199816, 0.24496426532989013, 0.1927103628567577, 0.19652199238629364, 0.22994829582468435, 0.20184042909568212, 0.217749365658932, 0.22278792085791876, 0.18389551206922616, 0.1958660523400767, 0.2092232704583844, 0.1987743122175044, 0.24310917686429578, 0.20484306339897107, 0.18169489296918984, 0.17173855979962027, 0.16372443292451522, 0.15697187200483764, 0.6418947844551417, 0.1992356860084642, 0.6821050773320456, 0.16099877507502225, 0.16829206336507774, 0.6458474277888386, 0.5687547715046493, 0.15526779280841274, 0.6491330531411265, 0.5254198296179549, 0.16550076170357875, 0.5900074423669079, 0.20711260781171703, 0.5914191144701473, 0.15374412193005516, 0.18459162480757518, 0.18832357943114597, 0.18638208960000857, 0.17728476980087104, 0.15640905585989517, 0.17244815864391805, 0.1657178109114591, 0.17078499302125782, 0.2004062262252705, 0.10279125773283615, 0.08822035308576448, 0.11202399371109828, 0.08128047937059346, 0.0815563004961537, 0.07619790864022236, 0.06664142428216036, 0.08516693211715942, 0.10995695891984991]}, "mutation_prompt": null}
{"id": "fc2ad8d2-8c83-4a16-8b54-f67cadf8f9ad", "solution": "import numpy as np\n\nclass EnhancedDynamicChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: max(0.1, 1.0 - (0.8 * evals / self.budget))  # Adjusted cooling\n        self.elite_fraction = 0.2  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Different chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def adaptive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.adaptive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDynamicChaos_Tunneling_Elite", "description": "Enhanced dynamic strategy combining chaotic mutation, probabilistic tunneling, and elite preservation with adaptive population scaling and adaptive inertia.", "configspace": "", "generation": 85, "fitness": 0.3093277194116394, "feedback": "The algorithm EnhancedDynamicChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4778213343648168, 0.4349279280268934, 0.45682369715456705, 0.4379276217347924, 0.464981898641577, 0.42732141087788567, 0.4307995730937547, 0.43437808285838664, 0.41577615337837803, 0.08309617641554745, 0.389644632514221, 0.38488816008816007, 0.33743110845186797, 0.37428528268233496, 0.3694035794452346, 0.1659178280301703, 0.3609107155582386, 0.16781043582424604, 0.10706406845980487, 0.10092960097555514, 0.07004231195915323, 0.15404295600131623, 0.13654539655383846, 0.13570529376577178, 0.34511760267339564, 0.15188157714984007, 0.1309959004174459, 0.1128431119865434, 0.09631246413603056, 0.06753676892644, 0.08803331575578699, 0.09177061356102167, 0.11175428861274028, 0.09314345780002276, 0.08834236945020513, 0.09051957190157245, 0.8585190902428599, 0.7843191792989487, 0.7477994227830906, 0.7883788336230793, 0.8175376195644648, 0.7726830476278242, 0.8940437669091682, 0.830779277770605, 0.9813900198569281, 0.3734614671412081, 0.3391171824350754, 0.30874475291893755, 0.2764126973550225, 0.3088737899764694, 0.3738250911288815, 0.23046460366951105, 0.30989166054578055, 0.38197618346471407, 0.7986697316386473, 0.8950448401161661, 0.8566681511399745, 0.7715778405053595, 0.8601776536446306, 0.8051096890624846, 0.7567712435627858, 0.6976100467760467, 0.8536943761722721, 0.4224833410746638, 0.18468581382369897, 0.38229428856808656, 0.25066108941501575, 0.12838830471796736, 0.23343784393845746, 0.1619860939558323, 0.3756281477717658, 0.21393343477247284, 0.3199101519631603, 0.24226378934860004, 0.36868085115822125, 0.24013447986381298, 0.23730633238526644, 0.31500562945704824, 0.1333489068135948, 0.2131963054461793, 0.23992495769155475, 0.35419182932243953, 0.2743246340857476, 0.39366197639676404, 0.10414072492560522, 0.2963390128266231, 0.3261359782623837, 0.22609479199371352, 0.10145678411431014, 0.3703306652897643, 0.4349203474679948, 0.3926878118966908, 0.4099064204910867, 0.360640410106825, 0.3953947167664512, 0.295797153434721, 0.3184482043780229, 0.3953719101686032, 0.41858065757984664, 0.13002788333631665, 0.18189158091061997, 0.2571441115198144, 0.3360503688091583, 0.36201064542592465, 0.30455105284555806, 0.35511915578897146, 0.3431155087874642, 0.23485553538485104, 0.29615428277484757, 0.21167376027053486, 0.2965952937569699, 0.03615094430415133, 0.28520427489215205, 0.27860582776220166, 0.29909732922130194, 0.30014828861249776, 0.2162574757979956, 0.39960899353100243, 0.41170375579504237, 0.4118621108027981, 0.3985490003934252, 0.4024848395014192, 0.39818131888642505, 0.3942771000802978, 0.4014511922699705, 0.40304923929662495, 0.11470705888427513, 0.06578539853934073, 0.09383692604335392, 0.10162209808574973, 0.12108541413343865, 0.11793413920965634, 0.11309695029768374, 0.11488686062927866, 0.13369739806816305, 0.15697252770385495, 0.21801532389489875, 0.20894492218484717, 0.3607523174149505, 0.3523105687400615, 0.25445671266051084, 0.2879614714589971, 0.20948902184059703, 0.13980012203879155, 0.3182987191178308, 0.3128159785057556, 0.328338005832731, 0.3302813907524351, 0.2918726850292135, 0.318039917848007, 0.32676521394921587, 0.3493901671268028, 0.325355291922927, 0.29902593733580085, 0.29090344226739107, 0.30538313036509457, 0.3185579048439072, 0.28514992779379167, 0.29406242722204756, 0.24586760386301654, 0.31816670872341124, 0.3231525006074192, 0.1758320492998735, 0.23947103117537105, 0.18973981666864725, 0.19789909715199816, 0.24496426532989013, 0.1927103628567577, 0.19652199238629364, 0.22994829582468435, 0.20184042909568212, 0.217749365658932, 0.22278792085791876, 0.18389551206922616, 0.1958660523400767, 0.2092232704583844, 0.1987743122175044, 0.24310917686429578, 0.20484306339897107, 0.18169489296918984, 0.17173855979962027, 0.16372443292451522, 0.15697187200483764, 0.6418947844551417, 0.1992356860084642, 0.6821050773320456, 0.16099877507502225, 0.16829206336507774, 0.6458474277888386, 0.5687547715046493, 0.15526779280841274, 0.6491330531411265, 0.5254198296179549, 0.16550076170357875, 0.5900074423669079, 0.20711260781171703, 0.5914191144701473, 0.15374412193005516, 0.18459162480757518, 0.18832357943114597, 0.18638208960000857, 0.17728476980087104, 0.15640905585989517, 0.17244815864391805, 0.1657178109114591, 0.17078499302125782, 0.2004062262252705, 0.10279125773283615, 0.08822035308576448, 0.11202399371109828, 0.08128047937059346, 0.0815563004961537, 0.07619790864022236, 0.06664142428216036, 0.08516693211715942, 0.10995695891984991]}, "mutation_prompt": null}
{"id": "1a912029-ef65-46aa-bd20-124e55689877", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_AdaptiveTunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.2  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.normal(0, 1)  # Changed chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_probability = np.exp((current_fitness - trial_fitness) / max(current_temp, 1e-10))\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Altered scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_AdaptiveTunneling_Elite", "description": "An enhanced hybrid metaheuristic utilizing chaos-driven mutations, adaptive stochastic tunneling, and elite reinforcement to optimize diverse black-box functions with dynamic adaptation.", "configspace": "", "generation": 86, "fitness": 0.30539996900893474, "feedback": "The algorithm EnhancedHybridChaos_AdaptiveTunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.41602233180475323, 0.4543849978135239, 0.42082688762920806, 0.45509034261395465, 0.4013447138587718, 0.424521150474617, 0.43646182368364683, 0.41347655331613686, 0.46017657896922637, 0.3730187664618835, 0.3163857607713064, 0.3561310800759019, 0.30880404000861394, 0.32785348281215454, 0.3299731069063955, 0.365977969671462, 0.32531762573395817, 0.29224337158449976, 0.13208217840178182, 0.1060279566630159, 0.17392109153300483, 0.13455550035707908, 0.10795152791005624, 0.10562228900971182, 0.11016360806765546, 0.10888640257947646, 0.14828246979351134, 0.1428977072195885, 0.10397448895680683, 0.10256978324996979, 0.06776686889613137, 0.07609332801296043, 0.10151797400040252, 0.09099646810818562, 0.09791259621296955, 0.08572138905701121, 0.8941476524477227, 0.9638443612615614, 0.814828589426593, 0.8931405662296686, 0.9767073060955016, 0.8044187314404316, 0.9518066085472723, 0.9494026547635684, 0.8899564511236744, 0.37695222082766244, 0.30739999232478976, 0.3618015658679107, 0.3179001229326458, 0.33231874005420814, 0.3115682406036385, 0.29678431465417754, 0.2912846644873831, 0.30402503862054886, 0.5684754688717182, 0.821602106221273, 0.8253842853749577, 0.6843296083013551, 0.5836383641952411, 0.7097164110979186, 0.6045891804260535, 0.6875922159545794, 0.7340612956973382, 0.2958746526535422, 0.3019045074877824, 0.3299716447159189, 0.2535071594725319, 0.23527841813283878, 0.2371207513471003, 0.28466689063594985, 0.25863421561521927, 0.274972126356652, 0.293882653192587, 0.2698639413038957, 0.20362796949032924, 0.4471690005380863, 0.24736117481096076, 0.28352311691158216, 0.329721569198939, 0.33350233019606945, 0.22346423971530716, 0.3762259706516283, 0.3973064333383479, 0.339369476767862, 0.3449495503066312, 0.3749428339974311, 0.36535184440480994, 0.3444339430306148, 0.34275168218312846, 0.3121334490292934, 0.3790905682006651, 0.38435322618155676, 0.42159190325190543, 0.36706733790490575, 0.4101931517276728, 0.3889255468949667, 0.3576596052739237, 0.40950052407583826, 0.4039696562131213, 0.09052077139256487, 0.1199272527703894, 0.25671787509392396, 0.2377673827268315, 0.3090588406034157, 0.10033462205128474, 0.11119848413182876, 0.15629920158067867, 0.1556120981135849, 0.2808054594423889, 0.25952033838203825, 0.2584078651880277, 0.27433973209983975, 0.26199542095276995, 0.26946400947302696, 0.24612121614435145, 0.26219919114803913, 0.2850413651283037, 0.39188011148304536, 0.40799727263575913, 0.3979810064209053, 0.41007448166091376, 0.4113408953784051, 0.3924778808920061, 0.40736967716380734, 0.38932708271716765, 0.38631356278105644, 0.10669098791425435, 0.1258281223555665, 0.09570465688007712, 0.10045712465280121, 0.12409030952245537, 0.14893458943469173, 0.14145282618361654, 0.1258437650054417, 0.13179989712710538, 0.2063126595571977, 0.19120680214329033, 0.30539027016797804, 0.4134747698846871, 0.3341044052718741, 0.2003739401795751, 0.36419210110386013, 0.1693720757597037, 0.3600825552949912, 0.2954007715131737, 0.28569141050010727, 0.3291442909513942, 0.301419079428185, 0.3052280567785025, 0.30532951638031103, 0.3294927898584392, 0.31845932011634837, 0.29344287608660524, 0.2818174188435929, 0.2770055970258941, 0.2606357422029939, 0.22681538615422936, 0.20274175394014005, 0.2690944495752684, 0.2761290259812821, 0.2947462564474782, 0.27400887574803934, 0.1971288806143342, 0.18938663617973595, 0.2328557086158065, 0.21118459431908254, 0.16649983199283924, 0.20131807893827558, 0.23551610966240566, 0.24026616904020737, 0.2353353700797013, 0.19620095041831487, 0.17952687988814364, 0.19840810662373531, 0.19783396414130416, 0.17670391084061665, 0.23472239078930923, 0.1817911694690526, 0.21145001798451035, 0.17259971582993872, 0.170227967744641, 0.16948081501505552, 0.6230535508304191, 0.6267259322663621, 0.1954238870660302, 0.18694260760388448, 0.5652946746105274, 0.167287950732941, 0.1675213994325695, 0.6170851533119113, 0.20742949753199846, 0.21029442492309325, 0.6418581806172969, 0.1639777223502955, 0.15212826534128088, 0.21090514358089418, 0.20595279655055942, 0.2102062276698805, 0.184671934548315, 0.16876925923640174, 0.18542180501897587, 0.17361501214168706, 0.25695784525645193, 0.21696839697921755, 0.19948936981622178, 0.2065364068905643, 0.17319451864385316, 0.10523443760561346, 0.09715767306605883, 0.07292972284930888, 0.08692835637550111, 0.08715260996958263, 0.07648802867229809, 0.08131805053939622, 0.09956268658300327, 0.08497090032466736]}, "mutation_prompt": null}
{"id": "c54f2994-fba5-461c-8ff7-66232f6d7859", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Modified chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Adjusted scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid optimization algorithm integrating chaotic dynamics, adaptive tunneling, and elite preservation, dynamically adjusting population and mutation strategies to maintain diversity and convergence.", "configspace": "", "generation": 87, "fitness": 0.3093277194116394, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4778213343648168, 0.4349279280268934, 0.45682369715456705, 0.4379276217347924, 0.464981898641577, 0.42732141087788567, 0.4307995730937547, 0.43437808285838664, 0.41577615337837803, 0.08309617641554745, 0.389644632514221, 0.38488816008816007, 0.33743110845186797, 0.37428528268233496, 0.3694035794452346, 0.1659178280301703, 0.3609107155582386, 0.16781043582424604, 0.10706406845980487, 0.10092960097555514, 0.07004231195915323, 0.15404295600131623, 0.13654539655383846, 0.13570529376577178, 0.34511760267339564, 0.15188157714984007, 0.1309959004174459, 0.1128431119865434, 0.09631246413603056, 0.06753676892644, 0.08803331575578699, 0.09177061356102167, 0.11175428861274028, 0.09314345780002276, 0.08834236945020513, 0.09051957190157245, 0.8585190902428599, 0.7843191792989487, 0.7477994227830906, 0.7883788336230793, 0.8175376195644648, 0.7726830476278242, 0.8940437669091682, 0.830779277770605, 0.9813900198569281, 0.3734614671412081, 0.3391171824350754, 0.30874475291893755, 0.2764126973550225, 0.3088737899764694, 0.3738250911288815, 0.23046460366951105, 0.30989166054578055, 0.38197618346471407, 0.7986697316386473, 0.8950448401161661, 0.8566681511399745, 0.7715778405053595, 0.8601776536446306, 0.8051096890624846, 0.7567712435627858, 0.6976100467760467, 0.8536943761722721, 0.4224833410746638, 0.18468581382369897, 0.38229428856808656, 0.25066108941501575, 0.12838830471796736, 0.23343784393845746, 0.1619860939558323, 0.3756281477717658, 0.21393343477247284, 0.3199101519631603, 0.24226378934860004, 0.36868085115822125, 0.24013447986381298, 0.23730633238526644, 0.31500562945704824, 0.1333489068135948, 0.2131963054461793, 0.23992495769155475, 0.35419182932243953, 0.2743246340857476, 0.39366197639676404, 0.10414072492560522, 0.2963390128266231, 0.3261359782623837, 0.22609479199371352, 0.10145678411431014, 0.3703306652897643, 0.4349203474679948, 0.3926878118966908, 0.4099064204910867, 0.360640410106825, 0.3953947167664512, 0.295797153434721, 0.3184482043780229, 0.3953719101686032, 0.41858065757984664, 0.13002788333631665, 0.18189158091061997, 0.2571441115198144, 0.3360503688091583, 0.36201064542592465, 0.30455105284555806, 0.35511915578897146, 0.3431155087874642, 0.23485553538485104, 0.29615428277484757, 0.21167376027053486, 0.2965952937569699, 0.03615094430415133, 0.28520427489215205, 0.27860582776220166, 0.29909732922130194, 0.30014828861249776, 0.2162574757979956, 0.39960899353100243, 0.41170375579504237, 0.4118621108027981, 0.3985490003934252, 0.4024848395014192, 0.39818131888642505, 0.3942771000802978, 0.4014511922699705, 0.40304923929662495, 0.11470705888427513, 0.06578539853934073, 0.09383692604335392, 0.10162209808574973, 0.12108541413343865, 0.11793413920965634, 0.11309695029768374, 0.11488686062927866, 0.13369739806816305, 0.15697252770385495, 0.21801532389489875, 0.20894492218484717, 0.3607523174149505, 0.3523105687400615, 0.25445671266051084, 0.2879614714589971, 0.20948902184059703, 0.13980012203879155, 0.3182987191178308, 0.3128159785057556, 0.328338005832731, 0.3302813907524351, 0.2918726850292135, 0.318039917848007, 0.32676521394921587, 0.3493901671268028, 0.325355291922927, 0.29902593733580085, 0.29090344226739107, 0.30538313036509457, 0.3185579048439072, 0.28514992779379167, 0.29406242722204756, 0.24586760386301654, 0.31816670872341124, 0.3231525006074192, 0.1758320492998735, 0.23947103117537105, 0.18973981666864725, 0.19789909715199816, 0.24496426532989013, 0.1927103628567577, 0.19652199238629364, 0.22994829582468435, 0.20184042909568212, 0.217749365658932, 0.22278792085791876, 0.18389551206922616, 0.1958660523400767, 0.2092232704583844, 0.1987743122175044, 0.24310917686429578, 0.20484306339897107, 0.18169489296918984, 0.17173855979962027, 0.16372443292451522, 0.15697187200483764, 0.6418947844551417, 0.1992356860084642, 0.6821050773320456, 0.16099877507502225, 0.16829206336507774, 0.6458474277888386, 0.5687547715046493, 0.15526779280841274, 0.6491330531411265, 0.5254198296179549, 0.16550076170357875, 0.5900074423669079, 0.20711260781171703, 0.5914191144701473, 0.15374412193005516, 0.18459162480757518, 0.18832357943114597, 0.18638208960000857, 0.17728476980087104, 0.15640905585989517, 0.17244815864391805, 0.1657178109114591, 0.17078499302125782, 0.2004062262252705, 0.10279125773283615, 0.08822035308576448, 0.11202399371109828, 0.08128047937059346, 0.0815563004961537, 0.07619790864022236, 0.06664142428216036, 0.08516693211715942, 0.10995695891984991]}, "mutation_prompt": null}
{"id": "f018e904-f446-4b11-ae7d-aa29fe9fee22", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.gamma(2.0, 1.0)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def competitive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.competitive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "Enhanced Hybrid Metaheuristic utilizing non-linear chaotic dynamics, stochastic tunneling, elite reinforcement, and adaptive competitive coevolution for improved convergence and diversity.", "configspace": "", "generation": 88, "fitness": 0.23271879642044901, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.37594893089272774, 0.3466124591526203, 0.3479406884964714, 0.36089905255943555, 0.3977748131523683, 0.39992987111398914, 0.34948304497166083, 0.3620243091611961, 0.34211278481446183, 0.23763803415217521, 0.25338774367740213, 0.2348059372894048, 0.21041241148405077, 0.28249852945653775, 0.2466991465167806, 0.25009765303622966, 0.24636268515494197, 0.22496017556649905, 0.10067586295714004, 0.11617884748130913, 0.08324635383538292, 0.10835655530732946, 0.07780111251582333, 0.09342239227229743, 0.08437081797247536, 0.10090370044740316, 0.09753478900565082, 0.06508050861425307, 0.08067223180026739, 0.05069905855817447, 0.08503214114351831, 0.056368189758228104, 0.05612430711266847, 0.0844604092105985, 0.0872712040346374, 0.056038251484130885, 0.9886668526564293, 0.9909826808503713, 0.9718599619291558, 0.9765272905028286, 0.9653625896241107, 0.9705216696871146, 0.9547149683085082, 0.9938249682386715, 0.9476961346019119, 0.25515908668481924, 0.2666675204593837, 0.20872208623386146, 0.24830048490063095, 0.25689718370102277, 0.22756501207371815, 0.21302519902373473, 0.21724837783178297, 0.25584117085475655, 0.3663869446446598, 0.48661156002261297, 0.6368108851781481, 0.5189718500586316, 0.5236312083338637, 0.4185479818573926, 0.4423483360230266, 0.5353248658821239, 0.5631812924440625, 0.21932245010699303, 0.11421657584237177, 0.16336272291884124, 0.13312993773898574, 0.2079452078692855, 0.1099215840215908, 0.20431255136262527, 0.11679521066158827, 0.21111180139650598, 0.11610309369219918, 0.07710826254703929, 0.01652715566431906, 0.1703715489683556, 0.16108013314178338, 0.2204618802176732, 0.21435980195094995, 0.11924074421980368, 0.20420712359953064, 0.2280742817114364, 0.3199086187109992, 0.2677103664491983, 9.999999999998899e-05, 0.25178504541454805, 0.22414488463535776, 0.23546204257884806, 0.23368727892055818, 0.2309712966608739, 0.19602260316059594, 0.2788998722253019, 0.3166879349391617, 0.3244023922340573, 0.011741149899141212, 0.28974366598710166, 0.3025391710701919, 0.2618638011031966, 0.15963831102395254, 0.12957514271997628, 0.14863073062049226, 0.03570543453029584, 0.14265916173936277, 0.1406192039521067, 0.1945829497388738, 0.10939494290559049, 0.16072599585152603, 0.08453249662113704, 0.19027359990678183, 0.18708602897712268, 0.18173593180267622, 0.17470599288450306, 0.18378837722675023, 0.1712837444520494, 9.999999999998899e-05, 0.2156871123575197, 0.2001256632530043, 0.3231030699544699, 0.3189633582397541, 0.3371448510621071, 0.3172820665553918, 0.31442052823643873, 0.33880849597127827, 0.35186728503990683, 0.3319333960272354, 0.33189186643751456, 0.07976420673830875, 0.10099734036908581, 0.11054832256094183, 0.08953965350077375, 0.04874413964052382, 0.13234579720310014, 0.08294527426035869, 0.09066563704993946, 0.09576301328786707, 0.12294830936055856, 0.09318325854330378, 0.11842175776965747, 0.1433069652048382, 0.1434933247150948, 0.1692935948952201, 0.1416242069400112, 0.18363285018260933, 0.13187118033049972, 0.2573372456570938, 0.2606515246904936, 0.19908627769579557, 0.2716063281614908, 0.2391634588128042, 0.24399673302042857, 0.2782081306832541, 0.2697857495699799, 0.26141511540355955, 0.22026745955129146, 0.1722762328523284, 0.2552700751631416, 0.18242697664541596, 0.20298406714830153, 0.23124187527803253, 0.2199646583431848, 0.2158349489240723, 0.23982931587874157, 0.1750294970523686, 0.15387207607863806, 0.14939407625456746, 0.16422177152343753, 0.16505431050491626, 0.15863642032385783, 0.20786284318462345, 0.14667786082932965, 0.1456534472732337, 0.23574685494226144, 0.17367085787622416, 0.1843922159147251, 0.17860871652712795, 0.1793936557501904, 0.18169992202214158, 0.1991397803893734, 0.19562108692941438, 0.18595307678594974, 0.12268658002398225, 0.14909316831951314, 0.15721547080001796, 0.16973566771902338, 0.1926677447836983, 0.18147786874181004, 0.13755340926627946, 0.17907780920191996, 0.5291344618802795, 0.13365510055262197, 0.19685239011972522, 0.15611359179960038, 0.4689994081979909, 0.13816661784231332, 0.19367263657832479, 0.20406198424154132, 0.20578269013641326, 0.2006698161534004, 0.1882025423298983, 0.18875995211342, 0.16733264355085664, 0.15658369290142637, 0.15657718342043447, 0.18619779801472003, 0.1621037995345519, 0.14423801047120632, 0.18921377501944558, 0.06974007588155928, 0.07823622352505477, 0.07592398732626682, 0.0776152675759808, 0.05855668729374175, 0.07995622170417827, 0.043444805660609376, 0.10442068108050484, 0.057665690383791435]}, "mutation_prompt": null}
{"id": "5e559a73-b176-4d17-bf13-3a16a8f447ff", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.2  # Modified elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.0, 1.0)  # Changed chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Altered scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid algorithm integrating chaotic perturbations, adaptive tunneling, and elite retention to balance exploration and exploitation with dynamic population scaling.", "configspace": "", "generation": 89, "fitness": 0.29848308636620935, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.451982897085102, 0.49934402693059865, 0.4365918650472502, 0.4477835297273829, 0.48018377588906125, 0.4229665612189638, 0.41809833223539894, 0.4656775579694882, 0.43414819154589535, 0.36782323242902826, 0.20871901872090626, 0.27416914687201877, 0.3633073111865106, 0.3037781806083538, 0.3000020195455342, 0.08946349422322053, 0.18257430923944407, 0.370059965314284, 0.12595443493329017, 0.11949516440459751, 0.11817334373006239, 0.12175418672468163, 0.1787784519756025, 0.11207573851739094, 0.10685462728276185, 0.13969068111863814, 0.09217593657584566, 0.09915789853793644, 0.0816972236902993, 0.053906295892313216, 0.13554174728366908, 0.09102262832457597, 0.15064133574515415, 0.09611905274937904, 0.1350422134344359, 0.0789646015199913, 0.8144235546873857, 0.8232573951035823, 0.695614197559902, 0.8667695451962805, 0.7479520135240347, 0.8161080851645914, 0.8619245886373754, 0.7811174417656447, 0.7987267517333118, 0.3668682044969075, 0.2182325104969386, 0.3105734268162642, 0.35652114856996564, 0.3264112445416887, 0.3376918740282555, 0.30929430393092194, 0.2877120207147882, 0.42013158910992754, 0.8362152262670947, 0.22548514048034984, 0.891305483027991, 0.5054971285389007, 0.751939128635204, 0.5458927692738613, 0.8024750385859059, 0.6567342205843538, 0.7844500483228826, 0.4003702406994115, 0.23601445245730956, 0.2673306922300197, 0.12578488721617154, 0.2550257432409416, 0.3146244651548584, 0.4339272557691245, 0.2658668958202727, 0.23376628562085444, 0.20451047899333308, 0.13105043318588994, 0.23117680860061718, 0.16830301513019963, 0.13055987770694433, 0.2064966981229709, 0.1312683805746364, 0.2675169374160161, 0.1320768533718627, 0.41253712461837644, 0.3698311193037114, 0.3552876986418668, 0.40051987477754003, 0.0724252373979225, 0.024977395324193852, 0.3451937076487992, 0.2951707663789954, 0.1323187852872566, 0.42355984339483943, 0.4901571266774497, 0.3859516976790418, 0.3309027094314785, 0.45626717040369413, 0.3959410089553972, 0.4042626163438222, 0.38925213618409016, 0.3148816221719688, 0.0708207081727158, 0.053621626464990135, 0.06987998381022842, 0.2481125575627633, 0.2105853940657355, 0.3714580473195541, 0.1957140227258044, 0.16544484192096753, 0.12223066316038111, 0.3065977890825614, 0.0030660540900236954, 0.2823858603779624, 0.2603133678127625, 0.024652433694576592, 0.24670285698604855, 0.28579057248466033, 0.31227432506523256, 0.15334127725026359, 0.43313142188568954, 0.4270934794593063, 0.4009545685750908, 0.39468779628737394, 0.37069616376908143, 0.4417189962267912, 0.38767009901685234, 0.42851553198091596, 0.4132853657238066, 0.1413231250046485, 0.17230144081158216, 0.10460889316039301, 0.10820397875172327, 0.12125305351513505, 0.1548303544952876, 0.12350937696740782, 0.1658362129891482, 0.1402216548074008, 0.2574191816698608, 0.22933719528894225, 0.17813523118105823, 0.18877426146206278, 0.3831097160676771, 0.38412374287791473, 0.29653358980575584, 0.40097408637493914, 0.20929880787328115, 0.33372708340878576, 0.3305259474288603, 0.3350211569446725, 0.3364069076792122, 0.309181086689437, 0.3440157999889818, 0.321831986915886, 0.3150024273189572, 0.3150252936395346, 0.28815778167825323, 0.3157238974780724, 0.3299107070758509, 0.32794236003486954, 0.3112810350006011, 0.24306237732891367, 0.2988518210876272, 0.2904985977080665, 0.3255028008393527, 0.2096966043262002, 0.3022646550552892, 0.16515005351058065, 0.1944165964044149, 0.20205837874910826, 0.24203849148018475, 0.2791625158594755, 0.16347776492628163, 0.19634895532851926, 0.19473803619002894, 0.1907721776597836, 0.22404148708231042, 0.20815306135731182, 0.19792810606038247, 0.19851260983042807, 0.21312846354607495, 0.19283125122602895, 0.22280363916238988, 0.653075543605463, 0.20818130720746142, 0.634396395723202, 0.1967156752856516, 0.1863961944233512, 0.1982439693812681, 0.13925668425436433, 0.16699740630295146, 0.6561080263048826, 0.522872607665414, 0.5075763805395603, 0.7055169672785405, 0.5841316723941902, 0.20444973841394776, 0.16627935822493678, 0.2081144385117426, 0.5996767036371691, 0.15343352659318976, 0.2367273163557987, 0.1927239203308333, 0.20986620141673318, 0.22429856059782405, 0.1946830722102283, 0.20707777904569957, 0.1749535843369422, 0.18562442843859994, 0.2139791947283487, 0.13192157587451836, 0.09247999718384126, 0.08545646231988036, 0.07138701830518746, 0.08229643934127784, 0.09333862051552677, 0.07283636315719866, 0.08967061440179569, 0.08372018676135595]}, "mutation_prompt": null}
{"id": "263032ed-5790-4610-ba39-6d117b0a514d", "solution": "import numpy as np\n\nclass RefinedHybridChaos_AdaptiveTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n    \n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n    \n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.0, 1.0)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def adaptive_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_probability = np.exp((current_fitness - trial_fitness) / current_temp)\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n    \n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n    \n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n    \n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n        \n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.adaptive_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n            \n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n        \n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_AdaptiveTunneling", "description": "A refined hybrid algorithm using chaotic dynamics, adaptive tunneling, elite conservation, and diversity maintenance for enhanced convergence.", "configspace": "", "generation": 90, "fitness": 0.30033881122479306, "feedback": "The algorithm RefinedHybridChaos_AdaptiveTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.19.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4872623438545307, 0.49476192432238764, 0.43645297208522793, 0.4225627634648169, 0.4579457044367289, 0.4216622771077795, 0.425822877574779, 0.4606464308194871, 0.4512457981486232, 0.32217299838609537, 0.17067341262385416, 0.2600186281746618, 0.38745777942464477, 0.25769634589762713, 0.31447243639569, 0.3289620829138924, 0.2138205667861396, 0.3820835426225463, 0.1257084910356311, 0.11948398968563656, 0.11807253524292194, 0.12174550090821978, 0.17871999605846356, 0.11206248391751383, 0.10802852329492829, 0.1402418759424079, 0.09063877689416844, 0.0981929187333268, 0.08137677921022202, 0.053917531490251025, 0.13671328060996946, 0.09091938811230738, 0.1507748462073618, 0.09777017639548702, 0.1337078534499727, 0.07911607910098406, 0.7942295390398872, 0.7858320219186467, 0.704112406862982, 0.8667695451962805, 0.7525537102102613, 0.8161080851645914, 0.8619245886373754, 0.7961433771799765, 0.81497986894977, 0.34383076614081187, 0.23460036365089532, 0.3201211114885487, 0.40364842839100523, 0.2950266921074275, 0.32874894315851233, 0.3014923920056338, 0.3246447256877263, 0.3642930462649321, 0.68087492645719, 0.6342814525704046, 0.891305483027991, 0.2795375572547628, 0.7794899211505683, 0.6715011356159075, 0.7975017268459388, 0.599463124153351, 0.7919344819929157, 0.39875899228432543, 0.2839197617868171, 0.26073007026466066, 0.12576122208014495, 0.2403068762727617, 0.3337368696853852, 0.4219165968182894, 0.21731782307920988, 0.3063095784478772, 0.09443479746608208, 0.13096416609550177, 0.2733562493638557, 0.24283504072109485, 0.13050050134085756, 0.2238173091418445, 0.13129677518548832, 0.2418245168398936, 0.13197446396375112, 0.41412361261546216, 0.3778597072768488, 0.34851843862779475, 0.4086829804639406, 0.04509907058516294, 0.02258744199482776, 0.36856830661916806, 0.32711611515253247, 0.203402500986552, 0.4135626704567975, 0.41126738880125946, 0.4193849130841253, 0.3223428432690848, 0.45376993076064587, 0.36257957941966124, 0.4617483754147945, 0.40998258285995137, 0.3277526091925693, 0.07335807019485652, 0.04617239678263063, 0.0706647268706796, 0.2927360130180867, 0.19205995107437046, 0.3061589627745348, 0.2128808878713746, 0.16835954115242513, 0.1392802532795011, 0.2861233341118016, 0.013274875016968668, 0.28557951885707955, 0.2754711886267577, 0.028921583633434444, 0.2559398498772304, 0.28375876389177435, 0.3286840605876181, 0.22856184060010531, 0.4206955464628592, 0.42416219737927263, 0.421182835176074, 0.419698841097908, 0.3686870618904853, 0.436938018025554, 0.38513111986148774, 0.39766951904341263, 0.42061805375953054, 0.1415038234763364, 0.17183154343887308, 0.1046426187190338, 0.10783373153577525, 0.12115836925408363, 0.15674616228652627, 0.12350904144620656, 0.16661388557140655, 0.13972557778282935, 0.26795515282716753, 0.23359310101380493, 0.17398462629429923, 0.1886740052878344, 0.38096812121487167, 0.361986972470979, 0.2602735411901095, 0.3849151459961825, 0.1993667110832109, 0.3400569138617997, 0.32953326835483243, 0.33012553919794874, 0.33168799812595173, 0.3263228282437628, 0.3384097871982137, 0.3176274156045359, 0.302653366846681, 0.3274201877343166, 0.22775065490875113, 0.3065904562400279, 0.31794409735005247, 0.3205323204961471, 0.33445066486945385, 0.26931794101058204, 0.25054939620725913, 0.21527915141535436, 0.307281781021405, 0.19593064809011962, 0.3066805637365819, 0.1670323675395744, 0.1944165964044149, 0.2061712764474224, 0.24202713827204136, 0.2813538259638868, 0.16347776492628163, 0.21859880262709874, 0.19474272295550277, 0.19724338208181114, 0.22394841059770798, 0.2406914690980262, 0.19400617682194354, 0.19087696610532445, 0.21688782801889672, 0.19309261415966672, 0.1889074090346392, 0.6373830151950806, 0.20813250382313098, 0.6461683413854222, 0.19671854254688093, 0.18640142207654176, 0.19820238955286107, 0.13899611781569443, 0.1670155222107944, 0.6512623342705185, 0.5919794118112203, 0.5391883340362873, 0.7587805194961499, 0.5934772740138021, 0.20446774593828632, 0.16629149072147154, 0.20813230525087012, 0.5729672092120195, 0.15340764598979095, 0.23416872255004295, 0.1912526239141693, 0.2090082523160084, 0.20498444394560333, 0.1946818055154519, 0.20722011596744871, 0.1749535843369422, 0.18562442843859994, 0.21454571271288725, 0.13183920403479188, 0.09258847777479551, 0.08581985086638866, 0.0714363569729829, 0.08229722426860553, 0.09333830331094828, 0.07283539913718817, 0.08964056699455758, 0.08433314190311725]}, "mutation_prompt": null}
{"id": "500cf285-730a-4ab3-9855-75e7bb535efa", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "2db9f9c8-bc2e-4fcc-9d1f-c3da8c0b781b", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 0.5 + 0.5 * np.exp(-5 * evals / self.budget)  # Adaptive cooling schedule\n        self.elite_fraction = 0.2  # Increased elite fraction for enhanced exploration\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.8, 1.5)  # Diverse chaotic factor range\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * np.sin(np.pi * evals / self.budget)  # Sinusoidal scaling factor for diverse exploration\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid metaheuristic incorporating chaotic dynamics, adaptive tunneling, elite reinforcement, and dynamic exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.2068452204562354, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.32227794825405076, 0.2824614840776489, 0.3034627841516744, 0.30360819262907923, 0.31930167282630084, 0.3208806047839826, 0.3300712924655911, 0.3422801552994639, 0.29643671380264724, 0.21691676144300698, 0.21375600683892715, 0.12815129645873113, 0.11140924654717743, 0.19736063792661218, 0.16944186937400496, 0.20621315138419483, 0.2509436920389694, 0.22164396478515858, 0.11380262185523549, 0.0859866914963161, 0.09184512178001536, 0.08824699672695391, 0.1314841183256824, 0.09749779001375214, 0.13087770252542885, 0.09728823401862918, 0.08853587413475561, 0.05206453300657654, 0.08044907833614545, 0.09710678713519427, 0.07725693266854927, 0.07650329213471596, 0.06124848886000234, 0.06491354730232246, 0.06715264842079705, 0.14912849603694345, 0.9435920294682963, 0.9689442122894695, 0.9616497024997767, 0.9756019091773818, 0.9234201572013118, 0.9366539525312281, 0.9892704797637037, 0.9509265121902784, 0.9200564959106826, 0.08780879777521045, 0.17254028341926408, 0.14170286573840296, 0.23494185923339672, 0.13236777886337459, 0.09231748414654994, 0.07571474176303439, 0.16566319984286149, 0.241187527826775, 0.31778126126827744, 0.2757795841045084, 0.2926165991431673, 0.22759472268033765, 0.31152388207248305, 0.30247927263038243, 0.2911439943490365, 0.2970687477792435, 0.30792738732286495, 0.16223648490111042, 0.1913814984301745, 0.057882540341696376, 0.17086713574428303, 0.06311329785139008, 0.21924522166820548, 0.19015625054643714, 0.12918889976955106, 0.21467615443532684, 0.05809704514025904, 0.010016659043666554, 0.22394454916592188, 0.08286063723104575, 0.1247792720938703, 0.23863994052963045, 0.13143966769420456, 0.18225534137068755, 0.11150902744471403, 0.13601577863492653, 0.03331731189339493, 0.05722768540522083, 0.0004913455323055649, 0.04391474563798725, 0.003992791840390808, 9.999999999998899e-05, 0.06967088675024591, 0.04330774274007687, 0.2379870193748992, 0.2635407853511733, 0.2604085749909977, 0.2590624659256696, 0.27532554879515725, 0.089306471477967, 0.2720610598115273, 0.26401683867852765, 0.12455666742109062, 0.034229882716933946, 0.027523813115854168, 0.06272488679996746, 0.013020018397009281, 0.0499104968817361, 0.03703749331649431, 0.1438008298478689, 9.999999999998899e-05, 0.09007051169253666, 0.11445024100421164, 0.15196511134797352, 0.1545095874552571, 0.0576145503068044, 0.10909266231662673, 0.17910171059038327, 0.134748906644666, 0.19158316228238714, 0.19051961658774785, 0.31709263239297847, 0.2943838546779006, 0.2786345865772234, 0.31427072496785524, 0.31202304250268775, 0.29510221864126074, 0.30182440931107823, 0.3128122016389613, 0.3198062497730222, 0.0888051421027356, 0.12351817512967722, 0.08575594191307923, 0.08708545476073026, 0.09211733325862337, 0.1279403808600198, 0.06348831953029332, 0.09452673775633869, 0.0743551377616215, 0.14657132529745753, 0.12776428920572414, 0.22860131148661744, 0.17359553074638479, 0.1713232147678544, 0.1336945312002441, 0.14468031641453505, 0.1622832983035991, 0.20593810320484995, 0.2330352102718548, 0.21363136409521588, 0.1613932299901244, 0.2335685621453829, 0.21238913473198573, 0.23777061768595975, 0.24295609790866846, 0.20841516579387764, 0.24324461736794267, 0.1865502444871462, 0.22668623922663744, 0.2504649547081763, 0.19946501898492475, 0.17250638000724883, 0.1323137117605786, 0.18072539732269832, 0.23843744665852595, 0.23445604484789873, 0.14969851518011124, 0.1704896883175676, 0.15790043393278086, 0.17042634000284584, 0.1695757227149406, 0.18846463760881393, 0.16768876071147043, 0.18182649110601667, 0.17856925660930612, 0.1623211918988562, 0.16404846835541953, 0.1777055682589317, 0.16260293125219272, 0.2669683229938211, 0.17614711167989405, 0.18437754736420586, 0.19855387814630243, 0.17550699784654267, 0.16558249506002354, 0.5444892388245142, 0.3022805967952209, 0.17352609635686567, 0.171246234247318, 0.163530114695838, 0.41896419353471204, 0.20248239108594623, 0.46275045334362885, 0.37604830472149353, 0.4512417588225097, 0.1563526709360361, 0.1664240823561739, 0.15190957528820093, 0.4068811640438156, 0.41363331042093177, 0.1817020623837965, 0.11596966891111826, 0.16444107106188255, 0.20063271845779562, 0.1762539229449832, 0.19948895362732078, 0.15000412977323163, 0.1602329609338582, 0.18429629792378932, 0.1698347062365354, 0.1737005704326251, 0.07808752665290664, 0.04635646935881954, 0.07015848020684656, 0.053681381888076474, 0.04464588676828296, 0.04930103028482358, 0.06710900241147355, 0.06282595784364498, 0.04874767792886525]}, "mutation_prompt": null}
{"id": "f15e2da3-4fc5-4ce1-8e0d-11c64fb3989a", "solution": "import numpy as np\n\nclass AdaptiveHybridChaos_EliteTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Changed initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.85 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.2  # Modified elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Tuning chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        if np.random.rand() < 0.5:  # Added probabilistic selection for tunneling\n            current_temp = self.dynamic_temperature(evals)\n            trial = self.chaos_based_mutation(current_index)\n            trial_fitness = func(trial)\n            current_fitness = self.fitness[current_index]\n            \n            if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n                self.population[current_index] = trial\n                self.fitness[current_index] = trial_fitness\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Recalibrated scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridChaos_EliteTunneling", "description": "A hybrid adaptive algorithm combining chaotic dynamics, elite convergence, and dynamic tunneling enhanced with probabilistic selection and mutation strategies.", "configspace": "", "generation": 93, "fitness": 0.2952576690493729, "feedback": "The algorithm AdaptiveHybridChaos_EliteTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4818629582683618, 0.45142478088534066, 0.4857054152224427, 0.5055477091253879, 0.48536929715680255, 0.4901243508052239, 0.4054117851250846, 0.5377931547340178, 0.4726338764722986, 0.0, 0.10337219928229535, 0.16700146120651882, 0.4056755836806799, 0.13667434055601713, 0.0, 0.3419510052848256, 0.17635861198929093, 0.04924231040271665, 0.14288787318887042, 0.13983191358829117, 0.09409146887683528, 0.12113138915733324, 0.1294845688169982, 0.14775497581793517, 0.09025709721541753, 0.11332447890764175, 0.1267802828701763, 0.10605150072455038, 0.07391271722665949, 0.09822971565242844, 0.0824017311385089, 0.07669220138065647, 0.11670917133751968, 0.12591117786407302, 0.1395916959801209, 0.0859250267978412, 0.9305981651848774, 0.9164652394629886, 0.8075180635049952, 0.9684287985470064, 0.971641996508583, 0.8948474697899685, 0.9747256196503085, 0.9484358731771868, 0.9118744444642405, 0.2742722816329305, 0.21314971640013514, 0.31257398829492067, 0.3312331554519554, 0.2964161496979021, 0.18020156186970104, 0.16835798630596732, 0.3667342460994214, 0.25359505979176433, 0.6373755645385482, 0.7949179512895939, 0.7741814289173897, 0.8248242845737787, 0.7642706264573076, 0.9001220566627862, 0.8261932250248722, 0.8585507209068884, 0.866707285439426, 0.3421875101250864, 0.11252154829789618, 0.23364604871986427, 0.13074857822678565, 0.2321421353219948, 0.1303044992172152, 0.24258269386972675, 0.13110222207068567, 0.3783166099790235, 0.13576905032208475, 0.22877763250803962, 0.24376593520527845, 0.2253266065125995, 0.3839917640955087, 0.14826905533714885, 0.25197866239231737, 0.19574866420886194, 0.38202802605013586, 0.2943488740965422, 0.17114629295799766, 0.41853438986159086, 0.22084211044137114, 0.2916344337308674, 0.20675765583847638, 0.42955818213835995, 0.03718874382115067, 0.3800702672517682, 0.36268041111307237, 0.3325852578355615, 0.396494415210928, 0.1272768419024154, 0.45252876756646254, 0.45457102809778194, 0.4167870571899067, 0.20873223251002537, 0.44368146136024356, 0.11691445689666158, 0.22189806504421483, 0.28081024962826195, 0.13653149095851946, 0.10201372024084754, 0.23505559199580717, 0.32490901196464295, 0.19863359876964604, 0.11497705169278594, 0.2968162341608158, 0.2617600849064785, 0.16628448266884333, 0.06875310693465986, 0.317931682788424, 0.23842936061962539, 0.18667606694746408, 0.23636691677336485, 0.20265519610520288, 0.4517302303000781, 0.42505432060977866, 0.40722931866688283, 0.417881978910831, 0.423384368838593, 0.40908091282504044, 0.37765032819881295, 0.4357636333182814, 0.47984519573595097, 0.1123279712659363, 0.1289384036385518, 0.08668548033049006, 0.10753097076946339, 0.08682655470165523, 0.1572433958453674, 0.13165047138417796, 0.1559020402890836, 0.12221009954838191, 0.3254315823287972, 0.15286720614381444, 0.17143885201515108, 0.28174406581064326, 0.19496824363679055, 0.16528424138022713, 0.1781183975032311, 0.1201485779962237, 0.1927090874064259, 0.2922063078870658, 0.22440057163237248, 0.3334444108751462, 0.33194120977453845, 0.273780751372246, 0.24588484383565923, 0.39318840304758074, 0.350484164804974, 0.33165460762592247, 0.28352086002516685, 0.23983654021267553, 0.28114283357944436, 0.3359369968132634, 0.3175331351141045, 0.23026907489977166, 0.2586004604167238, 0.3177074621413163, 0.30539414465344883, 0.2014034964825181, 0.27216968836589883, 0.17489041646471493, 0.19551573371368247, 0.19076109108581119, 0.2040123828374325, 0.21319280934836293, 0.23987530137210777, 0.20666432485751918, 0.2048415009670137, 0.2010440782057371, 0.22061273828774153, 0.1984091376150816, 0.19631313273993123, 0.19192903618516388, 0.19167404397973498, 0.19318850009159128, 0.18773832117043598, 0.19634288932577793, 0.7100507516191219, 0.15317714328441412, 0.6670190761185588, 0.1877457368875478, 0.19935158128380803, 0.184627401904499, 0.6940559413192466, 0.4318970412120131, 0.7653941013323697, 0.21117473443600776, 0.7359656421126597, 0.1678482781157894, 0.16757022956545586, 0.19385443308239136, 0.09349511250799003, 0.21034426013487906, 0.5462071295768661, 0.1557116241796106, 0.1803919132297246, 0.2030249999673791, 0.20189275509815152, 0.17776120669193407, 0.2022418693510042, 0.2086155002395399, 0.15782880176482483, 0.19250971972178343, 0.0833511118305259, 0.08255995798662441, 0.0732140304211647, 0.08276792959889567, 0.07531122091761533, 0.07054760819225525, 0.06791465519356132, 0.07682612149283707, 0.07888274222150826]}, "mutation_prompt": null}
{"id": "a73be37a-fc7a-4bc3-9cae-1a2893040719", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)\n        self.elite_fraction = 0.20\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.uniform(0.8, 1.2)  # Switched to uniform distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = max(1, int(self.elite_fraction * self.population.shape[0]))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Elite", "description": "An enhanced hybrid metaheuristic utilizing chaotic variations, stochastic tunneling, and elite reinforcement with dynamic scaling and adaptive exploration control.", "configspace": "", "generation": 94, "fitness": 0.21875947964850498, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Elite got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.328152503547109, 0.32036143049700894, 0.3204249860082762, 0.31053280482692025, 0.31351657707557046, 0.31951073966722854, 0.3414851757435198, 0.3109218435188692, 0.30820369950304694, 0.21431025481291632, 0.23386306258911838, 0.22692466016612078, 0.21243159981063198, 0.21268838033502568, 0.2231971269861831, 0.015445079865845757, 0.23051643057822557, 0.2406439873626146, 0.09735437502852295, 0.0965341659061203, 0.07446324226811596, 0.1141895384496403, 0.08834873651746, 0.10532233376799727, 0.10594968023383022, 0.10889788630642216, 0.12343228333856682, 0.07350173785058978, 0.07261098865637361, 0.09665477532870315, 0.08785206471023443, 0.10313898935631027, 0.10994469153607112, 0.07411779033435562, 0.06376171669873443, 0.06463088345718437, 0.9228248196406984, 0.9206438710964177, 0.944914529807766, 0.872071578922162, 0.9676894193044036, 0.9635464234832856, 0.9391594341008388, 0.9731049550533657, 0.9810889080173383, 0.2291038861424175, 0.2708060193096724, 0.13681739752946653, 0.23719833152363146, 0.24113006820285277, 0.2362165460337584, 0.24668293842012767, 0.2622652436480162, 0.22907785698969607, 0.37400642469830514, 0.3002886057389854, 0.275525448718127, 0.2674531445905133, 0.2838072753528187, 0.38944183594287984, 0.28961993897392524, 0.4864636879959807, 0.29324417178019635, 0.20640866674652958, 0.22310296321443956, 0.11198441860657804, 0.12719480704055985, 0.20691798340813494, 0.22285075103789165, 0.12349521353226556, 0.19105397731427298, 0.20310003247899855, 0.009758453026034286, 0.06117863760591313, 0.04320730972158093, 0.21223136853790614, 0.18268319126886667, 0.11292368637408778, 0.21049922561140522, 0.18513296698285564, 0.16147800511861043, 0.18445095371121611, 0.21883153688514156, 0.21374422884029687, 0.20226489075777543, 0.19768101650007464, 0.15622692657545956, 0.18296816513437042, 0.198449868198179, 0.1913100162778052, 0.27813439716112676, 0.24902620071603931, 0.28261877296153703, 0.2461867995849566, 0.23610984619782616, 0.2695331840405678, 0.11484253008334944, 0.2732393134257145, 0.08657490591628081, 0.03732132815175737, 0.061503648369542474, 0.07545358171983685, 9.999999999998899e-05, 0.14994318620458724, 0.11479770819876634, 0.12755738354025492, 0.04703497973244808, 0.12898001358769395, 0.15001844112146978, 0.1409615461437983, 0.15290716158909012, 0.10264393165027164, 0.15883421590327873, 0.17855377965981, 0.1719399643196864, 0.17057264832468844, 0.16814305217944092, 0.2968163153110811, 0.31029980463956697, 0.30527375410037194, 0.2997202998443451, 0.3029583303505453, 0.29237835132312406, 0.3001196594057062, 0.30432008332095395, 0.29020987724239977, 0.10287317227965975, 0.08704062466651508, 0.06133014364868339, 0.1016657101818279, 0.0808784666522201, 0.07387949110680891, 0.10639920025427818, 0.07573330583296889, 0.13047592255796592, 0.1788262965768972, 0.1745594001472055, 0.15205023959872088, 0.17431324725502761, 0.1959673023139904, 0.10798713552628325, 0.14549128925106958, 0.22007788851319177, 0.1281288147548838, 0.26083314107691646, 0.23379493303641552, 0.2489881508778431, 0.24998664068958865, 0.2239082102999137, 0.22559633908353904, 0.24901307105685244, 0.24512005647578605, 0.2590370661028304, 0.21566595905193642, 0.21337006101952616, 0.22437653534848678, 0.21877361831557196, 0.20492716056914695, 0.14309279453224755, 0.21297170880414673, 0.15975269493030553, 0.22816902946895612, 0.198658518978169, 0.239577540039544, 0.16960760893740356, 0.1567447188070279, 0.17619097936746808, 0.18820085152871535, 0.17695624658852016, 0.22423504439539954, 0.15834034946752362, 0.17918578731557677, 0.18128676373778796, 0.18985122075986338, 0.17985775921230363, 0.18891406208215633, 0.19572853428455883, 0.18907272948898834, 0.20728292504857182, 0.18814506304198997, 0.1633183856587349, 0.17755384746321634, 0.16427928885611343, 0.17857974079386618, 0.1693015976599258, 0.38223421733724716, 0.1809615042096938, 0.1780326242378547, 0.42199132348068646, 0.37848854085933803, 0.19707393857229094, 0.16092399744614772, 0.191142747993454, 0.3945771996231995, 0.11580246261381055, 0.20302782163694655, 0.15036249541361502, 0.19946343724978044, 0.18410738249300662, 0.16675810905655308, 0.1797438905164761, 0.17043806223380942, 0.17892969211911258, 0.17939228857494705, 0.16283690978058663, 0.1737762337719918, 0.18959020431423845, 0.0843174069849667, 0.07864861680632507, 0.060395390275713945, 0.07903435983299256, 0.06660926996545058, 0.07707732175778925, 0.07572029571208716, 0.07640451829032535, 0.06347371535872792]}, "mutation_prompt": null}
{"id": "9ea4d707-3349-4e80-916d-ffcec6602607", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.normal(1.0, 0.3)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Adaptive", "description": "Enhanced hybrid algorithm that integrates chaotic mutation, adaptive tunneling, elite reinforcement, and dynamic diversification to improve convergence across different optimization landscapes.", "configspace": "", "generation": 95, "fitness": 0.2597202162417777, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.3654032293179468, 0.32721678596448645, 0.3417759804619862, 0.35405895084523265, 0.3648949469781393, 0.3664057665600001, 0.35663838440676476, 0.3693515726718597, 0.3720202844185736, 0.2935790350536699, 0.2716831375490203, 0.2732061855157236, 0.2573575956106513, 0.287810308687777, 0.283355844443684, 0.2779868229416316, 0.31080110368147773, 0.26815790765011394, 0.10035828449014483, 0.08684604254201622, 0.08089815101502695, 0.09144555212708216, 0.07668785131946965, 0.12457787425770006, 0.05805449753279679, 0.12224794022007313, 0.10086044440966557, 0.08368667183174561, 0.09820202771675979, 0.08357422019425464, 0.10375151341438393, 0.10388576661314286, 0.07033767235964605, 0.10118181848199614, 0.09809979316879924, 0.11197792438477339, 0.9851795669418527, 0.9030697867093928, 0.9120411814613438, 0.9384143411880299, 0.968501641933965, 0.9739774633071492, 0.9527665669532525, 0.9678759065115495, 0.9592627649028628, 0.27882274911741256, 0.2796225297599654, 0.2737345326102141, 0.2744900652421298, 0.2825023956927275, 0.14088701707918572, 0.2880836485838548, 0.2947383727505122, 0.26522593453845, 0.42074879409438626, 0.4017487085159329, 0.32594570169319936, 0.433007277105644, 0.36254230143537347, 0.4050307947900964, 0.6255028373200835, 0.354719759029576, 0.500650369975933, 0.11271607303135844, 0.2749741204954951, 0.24041722825925627, 0.2566745837748794, 0.10593602433852156, 0.2263591203212234, 0.20441119652980133, 0.2417183336217359, 0.2690557272270234, 0.2658705470716187, 0.27917419104995067, 0.24314207483079853, 0.2423062860096783, 0.11725745123951914, 0.24603711628546476, 0.23154945518716152, 0.27049613760942626, 0.2736587087407082, 0.2701993837062594, 0.29009946018406085, 0.2829023060653929, 0.2545794423760499, 0.2759693960485661, 0.2885612851754681, 0.2750649359790365, 0.26565335782108646, 0.25685113626424494, 0.30059366732056336, 0.3290919857498029, 0.31338795509283657, 0.13503623339221793, 0.34095201211593307, 0.3072995516800333, 0.3006477348026403, 0.2968070260194767, 0.3316872459815111, 0.11931932509848298, 0.13989886171945198, 0.12998894941211425, 0.2261690396773156, 0.13777170554852114, 0.09524396554732573, 0.22870274919613542, 0.1891919773817149, 0.1984197978866178, 0.20614874898084778, 0.2093518238107679, 0.22270828588682956, 0.2086189832328772, 0.20124352164830894, 0.22129155549073043, 0.20123035733763217, 0.2290683557067389, 0.23350314610055278, 0.33221379957896136, 0.31411384211272675, 0.315309950897639, 0.34329018157039637, 0.3260672033510642, 0.33274238528010014, 0.3360251984139979, 0.3233364976164478, 0.3303668564757928, 0.08408129732962677, 0.08649498279272538, 0.08791868336083686, 0.130371201155842, 0.16766843451666225, 0.106787392647263, 0.07306709789949095, 0.10751978675115648, 0.09743104236267974, 0.15623432766039191, 0.28240474357510337, 0.1436059873679304, 0.1498245364620978, 0.14877139537720196, 0.10798713552628325, 0.3424479507054443, 0.20356815176268706, 0.11598933200667472, 0.2535327570078658, 0.25572322678630577, 0.277940121573623, 0.27329227072446016, 0.2717408925117275, 0.26648142671698094, 0.25943120688346955, 0.2961377932690278, 0.26246711046895277, 0.2510796216670649, 0.24380694499705902, 0.2556719888117046, 0.23024998127534557, 0.22353897793186384, 0.2393848238472508, 0.23688582207785935, 0.2399295326824129, 0.23765204362044345, 0.17525591700955245, 0.195982003433407, 0.15494316371406347, 0.18232994483249576, 0.18825196127979382, 0.19629574600931943, 0.18258046709075948, 0.16916858850013172, 0.17382138093538357, 0.17150205567969856, 0.18905784238563894, 0.21512947304069818, 0.19779658955137303, 0.29537121590126403, 0.1985027257635691, 0.17339598445517423, 0.3144318707848448, 0.17575461369692225, 0.201622425929893, 0.48806573378966045, 0.19412074521417666, 0.1710314766654326, 0.19684702233997764, 0.17778489408260634, 0.19352766895717954, 0.5116477861103883, 0.17896820505958566, 0.22401371679478066, 0.43398372909082605, 0.4197754420919001, 0.448479243407889, 0.4781679574458725, 0.4282747701074926, 0.20475686289124373, 0.19250853242115717, 0.1993681645362707, 0.18622154376217914, 0.17072930303077605, 0.20075250063071148, 0.16848553758769325, 0.18507248740725857, 0.1742612826379245, 0.17817653217929585, 0.17847277981150622, 0.187115579962833, 0.07887206143207748, 0.07819515137072175, 0.06309345632402419, 0.08013766083630292, 0.05866045494225747, 0.07410049551466669, 0.07000225819672345, 0.06275800781430374, 0.06887721722760998]}, "mutation_prompt": null}
{"id": "bca89c18-db0c-43a6-9106-57922bfa9177", "solution": "import numpy as np\n\nclass RevampedHybridChaos_Tunneling_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.9 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.15  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.2, 1.2)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.4 + 0.6 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RevampedHybridChaos_Tunneling_Elite", "description": "A revamped hybrid metaheuristic leveraging chaotic dynamics, stochastic tunneling, and elite reinforcement with adaptive scaling and balancing diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4186540107898551, 0.4241629026329946, 0.4190623736979793, 0.45350317794438544, 0.41991284304484067, 0.43971900326280156, 0.4510457681395488, 0.41738406426839736, 0.4499052210520953, 0.35101515358749835, 0.34481970364921743, 0.362436163167974, 0.32142951863409364, 0.3985153801154495, 0.39421541096150514, 0.36682786639790965, 0.36943727655125735, 0.24785718157616476, 0.15434906992065878, 0.09425587296691451, 0.122595825244729, 0.14958114363408548, 0.11743255578373679, 0.17820707882913178, 0.1334481358561499, 0.1583195786270769, 0.13512098938843042, 0.1243434559657387, 0.10660919769144317, 0.07639744748224875, 0.11051873578235905, 0.10449214890154013, 0.12593392965630723, 0.10123387375823656, 0.10462749452817044, 0.10044071771770091, 0.9698622333218567, 0.7322537799198469, 0.6906264462926142, 0.8513187262692608, 0.8439608192183213, 0.879122681909041, 0.9194799385024528, 0.8676378681233655, 0.7637361602128787, 0.34980213857968645, 0.31216267031457356, 0.11212649883267478, 0.3599404626026316, 0.3259798939123282, 0.396383266547512, 0.32973587660730275, 0.3040285771597858, 0.3440676026698244, 0.8936490480732356, 0.7467993142787854, 0.8258673924245699, 0.664016918575025, 0.7474423531166909, 0.8063067429397299, 0.7842466747230822, 0.8789022439196299, 0.88116385908186, 0.3591138087339586, 0.24918831951334108, 0.24800382393755604, 0.2598953245209188, 0.35554595600539973, 0.20357206606138512, 0.26746270241686, 0.31657540498338577, 0.28258638251138724, 0.2869593497799716, 0.12722931546441918, 0.2128681341130083, 0.2286131006773544, 0.28590898228237316, 0.13198487398615455, 0.2718394380177992, 0.13096409686622934, 0.12575337999477398, 0.319216363904013, 0.3657892061121223, 0.33606514693220246, 0.37104684284364886, 0.34122528752625514, 0.3751438455427637, 0.298016851791576, 0.3220465215195102, 0.3561892989912283, 0.41420004786541376, 0.3957791796470388, 0.3951631750171175, 0.35576743461890015, 0.40837381597070266, 0.4060711213383411, 0.39717273841768574, 0.41285168095230873, 0.3981542886678181, 0.11488752879585695, 0.17985692235975825, 0.055990343006937504, 0.3200616246057474, 0.22749115097848482, 0.3031019093777676, 0.18474747130681335, 0.11721240240580888, 0.18278878216120198, 0.28237532289629685, 0.26977153852548486, 0.28529556290942526, 0.2631748010241096, 0.276732111692251, 0.2839133243617996, 0.2539602957421484, 0.2877300077264543, 0.2989660109740412, 0.4147639832256689, 0.3770931506113928, 0.3864581672949633, 0.38835203696855247, 0.39130302081108526, 0.3925982107626139, 0.3929641702117941, 0.37599532845035066, 0.4025823756784701, 0.11694230340843803, 0.10738825999519164, 0.13168432063753188, 0.17981005643135484, 0.13724728644645712, 0.13993678184849923, 0.1084877006185192, 0.1396159963335758, 0.1371149082331553, 0.3423832388881771, 0.3561820788919048, 0.17782037458053346, 0.267543047736291, 0.19321665633693685, 0.15990926699701158, 0.1865767488810236, 0.3986393455431083, 0.19488149044492498, 0.30645578407727625, 0.3115096054775043, 0.31984252407636027, 0.31991552624854314, 0.3159284297460585, 0.3104396547352726, 0.303518362687791, 0.3226898422238087, 0.31171100822202413, 0.3031622067646629, 0.3044594950420936, 0.30263570914246496, 0.31321446871842495, 0.3067067514696279, 0.28431228196402936, 0.31270566919139875, 0.3064164634117654, 0.31538750620357536, 0.2150696813108608, 0.21975572138086397, 0.18081187858032943, 0.20727608657545116, 0.18684770914539828, 0.19308821466625903, 0.21345742892594122, 0.2888849638285814, 0.21428268196332634, 0.236923948112439, 0.19269183166139991, 0.19676717976566882, 0.21752736486488167, 0.1983044186910079, 0.20936270673428437, 0.18699277613818488, 0.18974543704516356, 0.19971818959627052, 0.6372602989349517, 0.1826351396614455, 0.2033641279656535, 0.585816258078564, 0.19942376502894332, 0.641556983770661, 0.5031238423104047, 0.2079995290012927, 0.6329162617989472, 0.5215609930528797, 0.2073567380321122, 0.7270276817199272, 0.6110416192450444, 0.16426661806428, 0.16554485252357132, 0.20915345557846698, 0.15282776035723433, 0.5164216955677032, 0.1792635163626526, 0.19829127030164806, 0.18957033795771472, 0.17893891085637093, 0.22432416026360158, 0.2084019030376768, 0.20143722973007472, 0.19583473637135373, 0.188192024971211, 0.09546274506729857, 0.10143757943454534, 0.08883232088513238, 0.09094350600117196, 0.09402807147775727, 0.09419123496278148, 0.08864620251284738, 0.0997065735002226, 0.078056431739849]}, "mutation_prompt": null}
{"id": "43076eb0-a9d7-454b-8d9e-87cc5370a8f3", "solution": "import numpy as np\n\nclass AdaptiveMultiPhaseOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)\n        self.elite_fraction = 0.1\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiPhaseOptimization", "description": "An adaptive multi-phase optimization algorithm combining chaotic mutation, stochastic tunneling, elite preservation, and dynamic population scaling for balanced exploration and exploitation.", "configspace": "", "generation": 97, "fitness": 0.3104086154834245, "feedback": "The algorithm AdaptiveMultiPhaseOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.40952875116351284, 0.42456701926971674, 0.46528540626920323, 0.4039242879467916, 0.4286468915655087, 0.4153062810224284, 0.4040807757766588, 0.4532150537622006, 0.40979775490033377, 0.3273712921903218, 0.33587473433756, 0.37429186136989223, 0.30431291610062017, 0.36577683197276545, 0.37692043636531647, 0.3447866575026959, 0.36013000753073376, 0.3174389066925464, 0.13933878630103969, 0.11206756764871484, 0.15141589835448854, 0.12618629387056257, 0.12507358726514017, 0.11434974783904706, 0.13729633112765227, 0.1339028642702751, 0.13106662430359517, 0.14559667803045817, 0.11034591588380094, 0.10802748812035678, 0.10646278281742583, 0.061110636230683135, 0.10246575046794337, 0.10698764358500867, 0.09900524031805691, 0.08399334188075713, 0.9755211426598228, 0.6820890744229462, 0.890520920349653, 0.8651753684840413, 0.8439839834172953, 0.9117127889166092, 0.9559305545956388, 0.8241701598241482, 0.8940431659709918, 0.3320077102641702, 0.3118061629999477, 0.3379802400862708, 0.3032281495940352, 0.2783020819880546, 0.3759571271032086, 0.3386403912552489, 0.3062758787654456, 0.30018554413461684, 0.789702510309941, 0.7152004143370634, 0.7888798416686265, 0.5885259062556811, 0.6174018142802558, 0.4767475567785706, 0.7612673049689942, 0.46185779539169347, 0.8038191829639992, 0.33121359285820284, 0.3217148949069165, 0.30289546386085786, 0.36652749347864333, 0.3957141389259884, 0.2943918819669601, 0.17252718369336528, 0.3718494095542404, 0.39761286914309346, 0.18401695282987018, 0.36374882896013994, 0.1940264211513526, 0.2052343680977462, 0.3079810086062885, 0.29852930664562605, 0.2310633572083608, 0.3352817232508678, 0.338035632816835, 0.31051638909936574, 0.35275527824666153, 0.3724739098976524, 0.33595338646119566, 0.35656377620873525, 0.364107844019414, 0.3440725911070204, 0.3313007313809001, 0.33462085614880976, 0.4235242845223868, 0.4152312497522419, 0.42839106969628427, 0.344027954875215, 0.3537136294409874, 0.41170565073234533, 0.36072966300383846, 0.4148106260698122, 0.3845757748107468, 0.07320948607645295, 0.08349803117145238, 0.28986667444482905, 0.27096793764694427, 0.30483821889580043, 0.31554260089931585, 0.2335108058036406, 0.14956952398876855, 0.1776438701688159, 0.2722691526301457, 0.2607065625915863, 0.2775090932845675, 0.26044506515476484, 0.26398179189215265, 0.2995700243319933, 0.2609548150109957, 0.2609222216685624, 0.2685547010875281, 0.3958138249299694, 0.39705204703860186, 0.3799460017069527, 0.40663085518496944, 0.4133162456463755, 0.3768754420417838, 0.41371323326750997, 0.3856951655955798, 0.3858927608564131, 0.12644973915004232, 0.12122061074081758, 0.1520079167238142, 0.13369030472608223, 0.10471710953899982, 0.12070549593276214, 0.11271300170409615, 0.11116872468389027, 0.1724844642563621, 0.2392845858139826, 0.19689677181958742, 0.3147939201024126, 0.3480337032412558, 0.3695975512041558, 0.21958190887766582, 0.2338973967258513, 0.17653280261513904, 0.21949744508503832, 0.3013075178743698, 0.31630478621715685, 0.3021304868454706, 0.3062329312805837, 0.3034220611763323, 0.2996484785088386, 0.3068255205922953, 0.3016495703525145, 0.31472992546605916, 0.28335694617535434, 0.29063311875322906, 0.29004126816045495, 0.2918712933398181, 0.3115986382903919, 0.29061006732447636, 0.30856656355701906, 0.30530751763468866, 0.30798045797414375, 0.1892133531505389, 0.20834853550017562, 0.2511289882146538, 0.25272036589386293, 0.2541828357945567, 0.23774454317584937, 0.21309679551466065, 0.18074486594365446, 0.24510521107407435, 0.2070486410369926, 0.35330596586169016, 0.31402735495369505, 0.20432352925718367, 0.21776738686860875, 0.23465804042625027, 0.1965625205149094, 0.19577211777945136, 0.21574473830561258, 0.165770720439803, 0.1849436582579126, 0.18634102682872966, 0.2098363766227498, 0.19742960884576122, 0.1946721986783677, 0.5879234673152245, 0.1655228285227056, 0.5826591411118749, 0.5595414234664786, 0.2110074036713202, 0.5939679284683181, 0.20380279109462152, 0.20705660362404832, 0.5574414944976682, 0.10431254123594247, 0.4879883630788838, 0.21016182398244365, 0.20880268637554866, 0.1983014193898014, 0.19252728893176618, 0.18549298110624668, 0.20886280157383819, 0.20218751356931175, 0.22602388305199383, 0.19105029503385007, 0.22798422495043935, 0.09872400347160637, 0.08467257032522668, 0.0855811274408621, 0.09502836622291289, 0.09263878842703144, 0.09375999434077309, 0.0890155420259221, 0.08861851532564091, 0.11480598909628004]}, "mutation_prompt": null}
{"id": "9435b4b8-7ccd-417a-99b2-ac2fcc55ae46", "solution": "import numpy as np\n\nclass RefinedHybridChaos_AdaptiveTunneling_EliteRetention:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 70  # Increased initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Adjusted cooling schedule\n        self.elite_fraction = 0.2  # Increased elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def adaptive_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        acceptance_probability = np.exp((current_fitness - trial_fitness) / current_temp)\n        if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def dynamic_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Refined scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.adaptive_tunneling(func, i, evals)\n                evals += 1\n            self.dynamic_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "RefinedHybridChaos_AdaptiveTunneling_EliteRetention", "description": "A refined hybrid metaheuristic using chaotic dynamics, adaptive tunneling, and elite retention with dynamic scaling to balance exploration and exploitation effectively.", "configspace": "", "generation": 98, "fitness": 0.30605314770486075, "feedback": "The algorithm RefinedHybridChaos_AdaptiveTunneling_EliteRetention got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.18.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4201771015510445, 0.42177278076947033, 0.41961517543189064, 0.44813205135427203, 0.45387284489165036, 0.4160205152569517, 0.4327053198632925, 0.42670854907226563, 0.4180149594575009, 0.36185606367474155, 0.26881656678828136, 0.36093459440246023, 0.3280357469237447, 0.34532482890079164, 0.35967312734169066, 0.3363677339112995, 0.33847905436082004, 0.33651932709890675, 0.17281285128112234, 0.16400561601778663, 0.13074997427623714, 0.1684843700633697, 0.14611963042655807, 0.11293561467683977, 0.11322762836763922, 0.14780143512645683, 0.12656144814040016, 0.10009666474498025, 0.0894252215417084, 0.08824775734466472, 0.13039515751115338, 0.08379080600643252, 0.09036044929994891, 0.10999561846373929, 0.06325579277458893, 0.12824612062439789, 0.7588024051937757, 0.9814661834403152, 0.7346829252049996, 0.7312431400226249, 0.8546048023288175, 0.6689418911472838, 0.9148359567975013, 0.8755546329116257, 0.7967931474926688, 0.3555739596256905, 0.3373544943122959, 0.3169160306081682, 0.3198049414238813, 0.33899549462835654, 0.2835403358463233, 0.36046029891218434, 0.3260720601393514, 0.3282426820442821, 0.5235733331605836, 0.7802559843179928, 0.7313680491093383, 0.6273797391335019, 0.8534041599269749, 0.6534171948711167, 0.7532702759898717, 0.7717043407748042, 0.8108526951901756, 0.3466640127007702, 0.25300491958032967, 0.2487980134663238, 0.16441308262954157, 0.3203460858889078, 0.12199705692917073, 0.2730373112830169, 0.2254470419520207, 0.2150092579880215, 0.3034732160125555, 0.12323292018872867, 0.1671915825268797, 0.3266074560093528, 0.19461025930570963, 0.2305371036353907, 0.3752019694313916, 0.19106837095102003, 0.23452916504584287, 0.33872130166375547, 0.3551816498643563, 0.3131211561113414, 0.3353782618897816, 0.29078805091510584, 0.33885150109676887, 0.3630005330509839, 0.3444840128857799, 0.35403187343701037, 0.36347574181418696, 0.3710149055948304, 0.34710052830105387, 0.39630374452327966, 0.41372359394382774, 0.37920908304066725, 0.3754311769101232, 0.3868221533529602, 0.381116083169625, 0.10711754963711939, 0.20227516173004711, 0.15676559804077428, 0.17385509684268163, 0.34417738755266036, 0.33479260300144864, 0.15265206693215383, 0.29560827080570173, 0.1012824952444824, 0.24338895194004895, 0.26907076967330945, 0.27410853501538557, 0.2593867989725449, 0.2886931272919864, 0.2916897103967018, 0.2657707308369215, 0.2685946193592771, 0.28110557305392536, 0.39715608713210726, 0.3829557826328287, 0.3741362101874537, 0.39416937459171963, 0.41616616672091244, 0.38796826086950076, 0.40222756706166773, 0.38276933106548894, 0.3823046744115042, 0.1428770406328349, 0.14700260651602493, 0.08742558502238862, 0.13399250207577296, 0.13466550219337603, 0.13644194070629545, 0.15124146698699803, 0.12295142050530572, 0.1253758062326349, 0.31334232348861835, 0.20980304704858754, 0.17256076018381228, 0.3173272834267066, 0.31577248425877025, 0.16955741834529958, 0.2778596750012816, 0.25259354963902736, 0.1849792653267931, 0.3167288563938744, 0.3107032925694736, 0.3285327954760704, 0.30878764207580955, 0.31743505769607494, 0.3135543131240054, 0.3133280262642294, 0.3086526320649253, 0.30127099653364875, 0.28185225607977404, 0.29332742980189297, 0.30958007484240524, 0.3029002091471088, 0.2883129387125385, 0.29640217890738696, 0.320189910324608, 0.3017989732214966, 0.297146362894943, 0.18642228729896926, 0.24133992422226302, 0.2059461281292414, 0.239841663883673, 0.20658727548414524, 0.1829600829407768, 0.1822860851201723, 0.2103564645602819, 0.21996693659193112, 0.21397056847657903, 0.19426676766009943, 0.3397362353540555, 0.21192993392459647, 0.20980427509785382, 0.1929787586349747, 0.20839313735718923, 0.2341075549338808, 0.21603010287260926, 0.2073481169561664, 0.666327152511001, 0.15119649524661072, 0.5107315286444893, 0.19769335993294035, 0.19506348916344163, 0.5309356072223004, 0.16352374929614433, 0.6411646844459065, 0.6546594854807544, 0.20926860876629017, 0.4419808694243863, 0.20192416161054882, 0.5046528287226297, 0.5065809967223449, 0.1623050258971953, 0.20910349744659262, 0.2074081978568495, 0.18281511268741957, 0.18094061240737402, 0.1812134795610899, 0.2062498272575929, 0.1656240117669684, 0.20468234496637794, 0.20391374939563056, 0.18049800286325557, 0.19568632275719045, 0.08627967911926593, 0.11532732463038087, 0.09416294320538132, 0.08390238543010875, 0.06692083300617235, 0.09265436447752562, 0.08332071586039869, 0.08782374380746005, 0.08863645905528705]}, "mutation_prompt": null}
{"id": "c4ba8cc4-deab-49dc-9277-c1e8ccf0005e", "solution": "import numpy as np\n\nclass EnhancedHybridChaos_Tunneling_Diverse:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.fitness = np.inf * np.ones(self.initial_population_size)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_temperature = lambda evals: 1.0 - (0.8 * evals / self.budget)  # Modified cooling schedule\n        self.elite_fraction = 0.2  # Changed elite fraction\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def chaos_based_mutation(self, current_index):\n        chaotic_factor = np.random.beta(1.5, 1.5)  # Altered chaotic factor distribution\n        a, b, c = self.population[np.random.choice(self.population.shape[0], 3, replace=False)]\n        mutant_vector = np.clip(a + chaotic_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_tunneling(self, func, current_index, evals):\n        current_temp = self.dynamic_temperature(evals)\n        trial = self.chaos_based_mutation(current_index)\n        trial_fitness = func(trial)\n        current_fitness = self.fitness[current_index]\n        \n        if trial_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - trial_fitness) / current_temp):\n            self.population[current_index] = trial\n            self.fitness[current_index] = trial_fitness\n            if trial_fitness < self.best_fitness:\n                self.best_fitness = trial_fitness\n                self.best_solution = trial.copy()\n\n    def progressive_population_scaling(self, evals):\n        factor = 0.5 + 0.5 * evals / self.budget  # Modified scaling factor\n        new_size = int(self.initial_population_size * factor)\n        if new_size > self.population.shape[0]:\n            additional = new_size - self.population.shape[0]\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (additional, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, np.inf * np.ones(additional)))\n\n    def elite_preservation(self):\n        elite_count = int(self.elite_fraction * self.population.shape[0])\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        evals = 0\n        self.evaluate_population(func)\n        evals += self.population.shape[0]\n\n        while evals < self.budget:\n            elites, elite_fitness = self.elite_preservation()\n            for i in range(self.population.shape[0]):\n                if evals >= self.budget:\n                    break\n                self.stochastic_tunneling(func, i, evals)\n                evals += 1\n            self.progressive_population_scaling(evals)\n\n            # Reintroduce elites to maintain diversity\n            if self.population.shape[0] > elites.shape[0]:\n                self.population[:elites.shape[0]] = elites\n                self.fitness[:elites.shape[0]] = elite_fitness\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridChaos_Tunneling_Diverse", "description": "An enhanced hybrid algorithm using chaotic dynamics, stochastic tunneling, and elite reinforcement, integrating adaptive scaling and diversity-driven exploration.", "configspace": "", "generation": 99, "fitness": 0.3093277194116394, "feedback": "The algorithm EnhancedHybridChaos_Tunneling_Diverse got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "f6edfd83-f1b9-49bf-920b-c288d278e8b4", "metadata": {"aucs": [0.4778213343648168, 0.4349279280268934, 0.45682369715456705, 0.4379276217347924, 0.464981898641577, 0.42732141087788567, 0.4307995730937547, 0.43437808285838664, 0.41577615337837803, 0.08309617641554745, 0.389644632514221, 0.38488816008816007, 0.33743110845186797, 0.37428528268233496, 0.3694035794452346, 0.1659178280301703, 0.3609107155582386, 0.16781043582424604, 0.10706406845980487, 0.10092960097555514, 0.07004231195915323, 0.15404295600131623, 0.13654539655383846, 0.13570529376577178, 0.34511760267339564, 0.15188157714984007, 0.1309959004174459, 0.1128431119865434, 0.09631246413603056, 0.06753676892644, 0.08803331575578699, 0.09177061356102167, 0.11175428861274028, 0.09314345780002276, 0.08834236945020513, 0.09051957190157245, 0.8585190902428599, 0.7843191792989487, 0.7477994227830906, 0.7883788336230793, 0.8175376195644648, 0.7726830476278242, 0.8940437669091682, 0.830779277770605, 0.9813900198569281, 0.3734614671412081, 0.3391171824350754, 0.30874475291893755, 0.2764126973550225, 0.3088737899764694, 0.3738250911288815, 0.23046460366951105, 0.30989166054578055, 0.38197618346471407, 0.7986697316386473, 0.8950448401161661, 0.8566681511399745, 0.7715778405053595, 0.8601776536446306, 0.8051096890624846, 0.7567712435627858, 0.6976100467760467, 0.8536943761722721, 0.4224833410746638, 0.18468581382369897, 0.38229428856808656, 0.25066108941501575, 0.12838830471796736, 0.23343784393845746, 0.1619860939558323, 0.3756281477717658, 0.21393343477247284, 0.3199101519631603, 0.24226378934860004, 0.36868085115822125, 0.24013447986381298, 0.23730633238526644, 0.31500562945704824, 0.1333489068135948, 0.2131963054461793, 0.23992495769155475, 0.35419182932243953, 0.2743246340857476, 0.39366197639676404, 0.10414072492560522, 0.2963390128266231, 0.3261359782623837, 0.22609479199371352, 0.10145678411431014, 0.3703306652897643, 0.4349203474679948, 0.3926878118966908, 0.4099064204910867, 0.360640410106825, 0.3953947167664512, 0.295797153434721, 0.3184482043780229, 0.3953719101686032, 0.41858065757984664, 0.13002788333631665, 0.18189158091061997, 0.2571441115198144, 0.3360503688091583, 0.36201064542592465, 0.30455105284555806, 0.35511915578897146, 0.3431155087874642, 0.23485553538485104, 0.29615428277484757, 0.21167376027053486, 0.2965952937569699, 0.03615094430415133, 0.28520427489215205, 0.27860582776220166, 0.29909732922130194, 0.30014828861249776, 0.2162574757979956, 0.39960899353100243, 0.41170375579504237, 0.4118621108027981, 0.3985490003934252, 0.4024848395014192, 0.39818131888642505, 0.3942771000802978, 0.4014511922699705, 0.40304923929662495, 0.11470705888427513, 0.06578539853934073, 0.09383692604335392, 0.10162209808574973, 0.12108541413343865, 0.11793413920965634, 0.11309695029768374, 0.11488686062927866, 0.13369739806816305, 0.15697252770385495, 0.21801532389489875, 0.20894492218484717, 0.3607523174149505, 0.3523105687400615, 0.25445671266051084, 0.2879614714589971, 0.20948902184059703, 0.13980012203879155, 0.3182987191178308, 0.3128159785057556, 0.328338005832731, 0.3302813907524351, 0.2918726850292135, 0.318039917848007, 0.32676521394921587, 0.3493901671268028, 0.325355291922927, 0.29902593733580085, 0.29090344226739107, 0.30538313036509457, 0.3185579048439072, 0.28514992779379167, 0.29406242722204756, 0.24586760386301654, 0.31816670872341124, 0.3231525006074192, 0.1758320492998735, 0.23947103117537105, 0.18973981666864725, 0.19789909715199816, 0.24496426532989013, 0.1927103628567577, 0.19652199238629364, 0.22994829582468435, 0.20184042909568212, 0.217749365658932, 0.22278792085791876, 0.18389551206922616, 0.1958660523400767, 0.2092232704583844, 0.1987743122175044, 0.24310917686429578, 0.20484306339897107, 0.18169489296918984, 0.17173855979962027, 0.16372443292451522, 0.15697187200483764, 0.6418947844551417, 0.1992356860084642, 0.6821050773320456, 0.16099877507502225, 0.16829206336507774, 0.6458474277888386, 0.5687547715046493, 0.15526779280841274, 0.6491330531411265, 0.5254198296179549, 0.16550076170357875, 0.5900074423669079, 0.20711260781171703, 0.5914191144701473, 0.15374412193005516, 0.18459162480757518, 0.18832357943114597, 0.18638208960000857, 0.17728476980087104, 0.15640905585989517, 0.17244815864391805, 0.1657178109114591, 0.17078499302125782, 0.2004062262252705, 0.10279125773283615, 0.08822035308576448, 0.11202399371109828, 0.08128047937059346, 0.0815563004961537, 0.07619790864022236, 0.06664142428216036, 0.08516693211715942, 0.10995695891984991]}, "mutation_prompt": null}
