{"id": "c13dde06-f245-4500-aeea-a240094521a1", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20  # Size of harmony memory\n        self.hmcr = 0.9    # Harmony Memory Consideration Rate\n        self.par = 0.3     # Pitch Adjustment Rate\n        self.bw = 0.01     # Bandwidth for pitch adjustment\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.4 * (iteration / max_iterations)\n        self.par = 0.3 + 0.2 * (iteration / max_iterations)\n        self.bw = 0.01 * (1 - iteration / max_iterations)\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        best_harmony = harmony_memory[np.argmin(harmony_values)]\n        max_iterations = self.budget // self.hm_size\n\n        while evaluations < self.budget:\n            for iteration in range(max_iterations):\n                self.update_parameters(iteration, max_iterations)\n                new_harmony = np.copy(best_harmony)\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if new_value < func(best_harmony):\n                    best_harmony = new_harmony\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_harmony", "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search combining dynamic parameter tuning and memory consideration to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.1728699928049918, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.10.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4770993895106057, 0.40513200166757624, 0.5036919918902989, 0.42135287260350107, 0.5394216293092156, 0.4634239472850016, 0.4671885240920608, 0.49467043782395503, 0.46457570031040574, 0.20277500164456164, 0.10353672472892395, 0.21988242470877972, 0.11850217212484626, 0.22678538397532688, 0.13763233511808226, 0.18430585914901576, 0.13130822340260184, 0.09130287821072902, 0.2511619004280603, 0.22483384523198968, 0.2645266036073701, 0.22666391713542722, 0.16016174283227536, 0.15855082184519143, 0.180888193316029, 0.2646642108011624, 0.1609535903982383, 0.14757320404248042, 0.16608895044144267, 0.19694983217072937, 0.14596680956622987, 0.15725710453340436, 0.13238773302851714, 0.13224131357608382, 0.15830279576800255, 0.1928706758276052, 0.23845161519134095, 0.302354117875135, 0.20768907577985496, 0.1974775313052609, 0.2239209632457334, 0.26620266231788015, 0.21609771486246898, 0.2005573587424826, 0.24530677869774042, 0.18645475911567544, 0.11302340656448362, 0.13945938549941983, 0.1863416644599455, 0.18668298516326465, 0.1567156191339273, 0.14962370829309657, 0.13113548899467498, 0.11628914275480728, 0.14959010136217854, 0.27369240967352215, 0.18630980248574147, 0.1942044679390622, 0.19007515773733819, 0.1959160949237635, 0.1564588952944056, 0.23660636768704613, 0.2026339514880704, 0.0883734122097285, 0.18059982591566348, 0.18482004548202935, 0.1533822176913502, 0.15669015448164814, 0.13285309524317834, 0.12409114414415012, 0.11459366556217976, 0.18784475807376166, 0.11006280680963587, 0.12868528602351348, 0.20929117987346313, 0.1274106259761857, 0.13671741928371628, 0.14249360489251173, 0.15084242049647723, 0.11928885267069, 0.1335854999121039, 9.999999999998899e-05, 0.0003385909647082297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09720511230721096, 0.05643816778781674, 0.038096863567532946, 0.006757344750345284, 0.02307967051358295, 0.07311843654496808, 0.08299052045746269, 0.07549921166922435, 0.05582570141182497, 0.07529612712936729, 0.02262498282704961, 0.02339908820747183, 0.023975506279930725, 0.049452084243424954, 0.04828458683966963, 0.04376680504065067, 0.004968784599705733, 0.0802079616768171, 0.06350438488611398, 0.13667515318295487, 0.08023540663591544, 0.06505054629659879, 0.02899043466942408, 0.07138806118435403, 0.0812530593063695, 0.06946256444351273, 0.08079044480774211, 0.36277741835928334, 0.2935945247671553, 0.38582941242082247, 0.37090959120840894, 0.3329376480965678, 0.32245905174493894, 0.34179653747727656, 0.3144622113363035, 0.3231881157514437, 0.09810678609260526, 0.08694868614595574, 0.08614414291175476, 0.14781468081382443, 0.07993033624271195, 0.08780458124552604, 0.13246785551441076, 0.08316637702489882, 0.10575957459961405, 0.14767076178718175, 0.2062748259101781, 0.21691748812651757, 0.13369742700998577, 0.16716541320843348, 0.11146254727905958, 0.116248979590035, 0.14084614325822298, 0.1328214557151709, 0.25501301837661416, 0.2562900227935615, 0.21807140446017892, 0.1916422411801223, 0.19239558583510552, 0.20162196454298997, 0.22568454846666441, 0.27633862064530745, 0.23687413747613362, 0.17636520084127327, 0.21093049777345596, 0.14960966286414368, 0.18969474816817133, 0.14772193539912115, 0.17217941227341182, 0.1832385052590474, 0.14998112370989058, 0.1807146433921324, 0.17142212162685466, 0.17374668345277644, 0.18052103627691507, 0.19668744854529363, 0.17698573436244058, 0.2064691193192657, 0.1998227019189327, 0.20414852855311283, 0.18214469276772238, 0.20998719668834154, 0.22187586758158573, 0.18086971044914268, 0.21054637507970764, 0.3560033550275481, 0.1784433812866162, 0.21636215460972041, 0.22003189708877435, 0.19729568826737054, 0.3236516118805549, 0.18420674034738427, 0.18808276488475784, 0.37738844591458065, 0.30952801586867285, 0.16809934001591942, 0.1984682299624404, 0.16490502568513532, 0.17238161910971483, 0.37655060713106403, 0.2046748783576714, 0.26767950857130085, 0.1899053736313867, 0.1622744438818774, 0.2571270630474354, 0.20142450753677954, 0.18478068110874524, 0.1035776505301319, 0.15855990847960877, 0.18162555239011902, 0.17647502151089778, 0.17909240743186616, 0.17719625918763704, 0.17636253771714527, 0.18427170080095479, 0.17892044009128605, 0.17727303845063547, 0.09519590724599969, 0.0754172523216513, 0.0879779529161806, 0.08832248148960675, 0.07276685507125658, 0.08953809945450664, 0.07994899219479956, 0.06585963860360677, 0.06847076738939595]}, "mutation_prompt": null}
{"id": "90f75317-eebd-4ebc-92cd-ca4250f5f62b", "solution": "import numpy as np\n\nclass DynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20  \n        self.hmcr = 0.85    \n        self.par = 0.35     \n        self.bw = 0.05      \n        self.mutation_prob = 0.1\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        best_harmony = harmony_memory[np.argmin(harmony_values)]\n        max_iterations = self.budget // self.hm_size\n\n        while evaluations < self.budget:\n            for iteration in range(max_iterations):\n                self.update_parameters(iteration, max_iterations)\n                new_harmony = np.copy(best_harmony)\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if new_value < func(best_harmony):\n                    best_harmony = new_harmony\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_harmony", "name": "DynamicAdaptiveHarmonySearch", "description": "Dynamic Adaptive Harmony Search with evolutionary-inspired selection and diversity enhancements for robust optimization.", "configspace": "", "generation": 1, "fitness": 0.1911487878111872, "feedback": "The algorithm DynamicAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.13.", "error": "", "parent_id": "c13dde06-f245-4500-aeea-a240094521a1", "metadata": {"aucs": [0.4549810753446827, 0.5206674554070814, 0.46475758121027877, 0.4792135933788113, 0.4452740790084132, 0.5321598067669915, 0.5099509191159637, 0.44759703732639766, 0.5640537127426873, 0.2054638159855643, 0.15729401112938357, 0.15549636539600054, 0.18434898043906955, 0.1643198421116091, 0.21150967600731363, 0.2067373823957087, 0.18711858679655458, 0.15784075332380199, 0.29264682018929944, 0.16373507257707864, 0.15518433399276133, 0.1620581973670958, 0.19148683524912202, 0.30027749770277223, 0.1476070232901191, 0.1622957834517127, 0.15010462236868394, 0.1330835668884891, 0.14363548981505214, 0.16689718531855835, 0.1670481664682969, 0.20487632531073396, 0.16442973197318878, 0.1868701958592084, 0.15653138851010806, 0.13980046403992508, 0.513253333003131, 0.585814527421723, 0.5713380436002964, 0.41963543861721475, 0.5803607471596965, 0.5576424307029524, 0.4422179925715354, 0.34147187709217675, 0.5975633636853774, 0.13545803396990486, 0.22623655583225566, 0.22980209389010342, 0.14188977041283923, 0.21818700984678951, 0.2005302882190757, 0.1786351411160746, 0.154612369503922, 0.19983059030153116, 0.19914622516463454, 0.1906273288724728, 0.17614368202547737, 0.2150033566379035, 0.1901545536994106, 0.27880002096234036, 0.1592641963931748, 0.2227018300899688, 0.22020427541835919, 0.28113878824468364, 0.12813704455578445, 0.11699111311913035, 0.1139836624565469, 0.154834017131811, 0.1958138087490191, 0.19146321994542137, 0.10308569326151518, 0.2060358962118698, 0.11566927429659934, 0.10967417684555525, 0.14668068345453245, 0.12065251190582293, 0.10881366544061533, 0.1382798429653438, 0.13904406578442263, 0.10280432845522935, 0.11919967202952064, 9.999999999998899e-05, 0.0183042447571099, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06042261475796462, 0.02864003847167529, 0.07054635618689553, 0.030624275740761875, 0.034625103468089447, 0.0518197792309093, 0.05488510391116197, 0.07026505022669893, 0.06513571181438005, 0.007683008337789565, 0.03031052719785421, 0.04130254325449334, 0.013890419308284607, 0.011421237889007951, 0.011418663596959089, 0.00813502769333585, 0.044829490517895976, 0.02588123405770726, 0.06016270790032374, 0.08544211751096975, 0.06518120219715018, 0.09096058220625092, 0.08753693388013795, 0.045939447310583414, 0.10273074822640005, 0.12040896832131676, 0.06292697648168322, 0.3580772282536395, 0.39804929776367426, 0.34037414176304814, 0.39962604015680114, 0.3969219343387257, 0.3722608120239772, 0.3705570519125363, 0.3607285102805805, 0.34710578589465313, 0.0773282791832034, 0.08157215855862576, 0.07392626645401557, 0.12399169766935825, 0.08141825268277336, 0.1135496558564637, 0.09370576200343605, 0.07449095881786505, 0.07359725246576931, 0.1314258545523408, 0.15690719399418662, 0.16802116033249515, 0.1486735493208987, 0.1655681787098121, 0.12902267082262975, 0.13813665438191858, 0.1208536504804344, 0.12626967070256612, 0.26225488012738873, 0.239680960477903, 0.22511702806151856, 0.25864880975113236, 0.2621140574212588, 0.28741264430093927, 0.22381298356412782, 0.2513203222258823, 0.2272200061755172, 0.2221574795633403, 0.21253590143786327, 0.20652666158752886, 0.150169674759979, 0.1943210503539443, 0.24068699057494536, 0.16452128170116287, 0.1628621388826954, 0.20942933232148775, 0.1790267402078093, 0.18867138572729214, 0.17258958852275463, 0.18645631365226023, 0.2127575637320105, 0.17329777159488058, 0.20816240347699233, 0.1831172634792464, 0.20609148737416527, 0.19214628510083076, 0.20036812620436917, 0.20759893762149706, 0.23250062163080332, 0.19993379861480254, 0.3539355816928461, 0.21977219205712673, 0.1968951812113806, 0.18298386232864206, 0.4811972588671032, 0.1834794899638984, 0.18493078634441418, 0.421590653171381, 0.4867863375606589, 0.17195097581776497, 0.22665347238315603, 0.31035119195618843, 0.15122206895735202, 0.2667014150811704, 0.1639882234391875, 0.23952778862194113, 0.19462173110648484, 0.19734073073289293, 0.19892624076772203, 0.14491053964928358, 0.32947495136338056, 0.10121999731843712, 0.16699511797686606, 0.16626092330470965, 0.21945130582450478, 0.18687130789716477, 0.18071603774453449, 0.17505020337547672, 0.17045001121833125, 0.19234556323907592, 0.1720662017942326, 0.08647196045812655, 0.07040085424553744, 0.07795727460456015, 0.06972249606313363, 0.07198446354984844, 0.08740124983160114, 0.08416434233026315, 0.0780406457814653, 0.07924734820375912]}, "mutation_prompt": null}
{"id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.24571932756985523, "feedback": "The algorithm EnhancedDynamicAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "90f75317-eebd-4ebc-92cd-ca4250f5f62b", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "9c3310aa-c117-4063-add6-98a986d660bb", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.quantum_prob = 0.15  # Quantum-inspired alteration probability\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def quantum_alteration(self, harmony):\n        if np.random.rand() < self.quantum_prob:\n            superposition = np.random.rand(self.dim) < 0.5\n            for i in range(self.dim):\n                if superposition[i]:\n                    harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_harmony = self.quantum_alteration(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "QuantumInspiredDynamicAdaptiveHarmonySearch", "description": "Quantum-inspired Dynamic Adaptive Harmony Search leveraging quantum superposition and entanglement for enhanced exploratory capabilities.", "configspace": "", "generation": 3, "fitness": 0.24253847257759453, "feedback": "The algorithm QuantumInspiredDynamicAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6007418068158972, 0.6702461402847484, 0.5889666468825132, 0.6260194866245032, 0.6496461529759715, 0.6403982379400923, 0.6409909898638234, 0.5987173037307438, 0.6170128654167635, 0.2694712038328344, 0.22545629534540523, 0.2264896783270416, 0.22777318279073544, 0.28578366987938053, 0.24521427231904425, 0.3049084714563606, 0.28057468826407816, 0.2948491504642863, 0.2673357304137952, 0.2816410107611256, 0.3354681985046478, 0.20997455555170996, 0.3215287954628998, 0.2589919179539164, 0.3826581344318397, 0.31634914642875844, 0.26685618398256405, 0.16824221881755708, 0.18498234545664305, 0.31851079367779445, 0.19109923428823927, 0.17208075980447646, 0.1747479945538014, 0.18097125938593395, 0.2611306530588555, 0.29382331695457, 0.8403113965644997, 0.8066462658593362, 0.8521492793016926, 0.8871575943136527, 0.80640890870992, 0.7873429131132892, 0.8478640729942524, 0.8124008360478125, 0.7647283419256077, 0.18311465778527813, 0.26803623070209426, 0.19829654604393065, 0.2851497772141083, 0.21429081068945166, 0.28453969473975094, 0.2811582787541653, 0.18393368329039894, 0.17431019751866894, 0.2129440347726862, 0.12138376905152726, 0.1707117969964871, 0.32559254619516687, 0.19457035620659302, 0.33295101762637147, 0.21236057340796666, 0.2222602974941411, 0.17765177019791678, 0.15848645890333224, 0.21876032933278744, 0.2279305798674186, 0.15674412786954672, 0.14844635986872057, 0.18919625772394988, 0.21847000112455806, 0.3866409687871639, 0.16607897517679615, 0.1593647695745114, 0.1734592445454931, 0.1281822138345622, 0.14181299527209446, 0.1931117729638987, 0.15010995498881707, 0.12856992617478102, 0.13164782983796575, 0.13202876431667665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06019608504316076, 0.06477150347393856, 0.16158869574532453, 0.07223188150739113, 0.06439067435019297, 0.03189630614091532, 0.07971313373486832, 0.09017773725401679, 0.08910746148916793, 0.09435494452066306, 0.08065555724090467, 0.09851878435641137, 0.05152481973828782, 0.0807881683836924, 0.08181214505665069, 0.09424334431170933, 0.07370110027800203, 0.04845390328948984, 0.14152359445472118, 0.22087576234437967, 0.13319865963069988, 0.17118502839614647, 0.0961441577028509, 0.09002400504092689, 0.13897458180852829, 0.14937391548683265, 0.14998381803376692, 0.45115647940276205, 0.4233161507038866, 0.4765084129270326, 0.45530202312899926, 0.4267305495263789, 0.41336912788126934, 0.4356344882020866, 0.4293477005714442, 0.43184652389054956, 0.1417438656692579, 0.08038484799607126, 0.13417717164589082, 0.14058726675566158, 0.07933007874204467, 0.130174223809861, 0.16291203539544508, 0.06935135820663507, 0.09685061259682204, 0.1267780788690317, 0.13730709134286678, 0.14647275542142013, 0.13308454082984988, 0.14389234484086533, 0.14266847900807056, 0.17294099288824016, 0.1894953004257952, 0.13632795694975952, 0.24389489457092728, 0.3161334428839193, 0.31119941147926233, 0.2628762948913239, 0.2678099131270919, 0.2885611230781625, 0.30375981683050546, 0.406348976035091, 0.33735721291255916, 0.16709162983471393, 0.15964584912806423, 0.1869061708359554, 0.2169420228587624, 0.18979122251818048, 0.23371677295450832, 0.22507002574025126, 0.17582359393310976, 0.15514496072324568, 0.19271306507734476, 0.20242268826203602, 0.205909914096288, 0.19682136625997948, 0.1940741070846409, 0.20171090533793135, 0.19433004739108406, 0.19320674485962697, 0.18619280638030844, 0.20770181072301874, 0.21900654398842867, 0.17993184807326956, 0.21624346325682986, 0.48915976758113133, 0.20751185760531266, 0.18238180449766916, 0.2134421255907325, 0.23213759142760604, 0.5582373669190599, 0.18657821862105262, 0.1859124307724428, 0.7867160397482477, 0.21804202703834052, 0.19487022359636885, 0.5915298292262994, 0.4201878920585469, 0.1496664004015238, 0.19479857423459135, 0.21158251611557333, 0.5057835349227229, 0.20101488450573435, 0.16892773944789552, 0.20986605878051434, 0.20429736648448849, 0.12292938981312762, 0.14595586455795417, 0.18914305119142205, 0.19276025808757502, 0.19601416782442427, 0.19604669299713262, 0.1957464544704377, 0.19749669466567954, 0.18687299573929828, 0.19822316409737317, 0.18484370524346994, 0.0964269181708467, 0.08793384274585692, 0.08111033396734713, 0.08888872167008666, 0.0823358402958555, 0.09031683672736812, 0.07614549646032842, 0.08818175182307308, 0.08499510468465776]}, "mutation_prompt": null}
{"id": "db2d5aa9-2d48-42fc-a1b6-57c4c4f6b59a", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "d480421a-314e-4cec-9cc3-d07c3e5ee5f0", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "a0fa52d6-e741-44a9-b116-835f91036244", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "a6008d00-feeb-4e80-b30e-ac2a03fcf746", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "7751dd86-24d4-441b-a33e-ca856ea52d41", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "f761bdab-2adc-4736-9f74-df021366e154", "solution": "import numpy as np\n\nclass AdaptiveMultiOperatorHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.25 + 0.35 * (iteration / max_iterations)\n        self.bw = 0.1 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            # Choose between normal distribution mutation and uniform mutation\n            if np.random.rand() < 0.5:\n                mutation_index = np.random.randint(self.dim)\n                harmony[mutation_index] += np.random.normal(0, self.bw)\n            else:\n                mutation_index = np.random.randint(self.dim)\n                harmony[mutation_index] = np.random.uniform(self.lower_bound, self.upper_bound)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            sorted_indices = np.argsort(harmony_values)\n            elite_indices = sorted_indices[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.choice(elite_indices, replace=True)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.choice(sorted_indices, p=self.stochastic_selection_prob(sorted_indices))][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]\n\n    def stochastic_selection_prob(self, sorted_indices):\n        ranks = np.arange(1, self.hm_size + 1)\n        probabilities = 1 / ranks\n        probabilities /= probabilities.sum()\n        ranked_probabilities = probabilities[sorted_indices]\n        return ranked_probabilities", "name": "AdaptiveMultiOperatorHarmonySearch", "description": "Adaptive Multi-Operator Harmony Search with stochastic rank-based selection and diverse mutation strategies.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 6 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 6 is out of bounds for axis 0 with size 4')", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {}, "mutation_prompt": null}
{"id": "c287fb00-3c0d-4a7e-90bb-d8a3f1dfacc3", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "a7dba749-f29d-4969-8c04-5c650a39a1e0", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.9  # Slightly increased Harmony Memory Consideration Rate\n        self.par = 0.4  # Slightly increased Pitch Adjustment Rate\n        self.bw = 0.1  # Increased bandwidth for wider exploration\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.25  # Increased fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.4 * (iteration / max_iterations)\n        self.par = 0.4 + 0.3 * (iteration / max_iterations)\n        self.bw = 0.1 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearchV2", "description": "Dynamic Adaptive Harmony Search with elite memory and enhanced parameter tuning for balanced exploration-exploitation.", "configspace": "", "generation": 11, "fitness": 0.23827654889535085, "feedback": "The algorithm EnhancedDynamicAdaptiveHarmonySearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6091660714896547, 0.590535210512763, 0.6117512779650058, 0.6101277647073048, 0.6023777506639066, 0.5855654076740813, 0.602559144550844, 0.606184336676223, 0.629989348704782, 0.26852077324418455, 0.27965786407896553, 0.2041272712276565, 0.1582649650640987, 0.2889161838067055, 0.2170618726552478, 0.2026423958339425, 0.2783156510508227, 0.25018379201369023, 0.15933190687759324, 0.39167419354593735, 0.18050665377715036, 0.2391801908959158, 0.24036866828122228, 0.3253215834529597, 0.13714680419344494, 0.2671695588216352, 0.16894272457994708, 0.17020473802362612, 0.19286642017846312, 0.17628434756625067, 0.27742351793633246, 0.1614770899424368, 0.20130382300639216, 0.17804289358184144, 0.297275420740056, 0.16004812636617138, 0.9347055877954736, 0.898557049537443, 0.8934824200733862, 0.921136127348031, 0.953993169755347, 0.9117531781792086, 0.9108431444905225, 0.9095953783119644, 0.9102897444555501, 0.3055594551668167, 0.3697979175096292, 0.2462732312301119, 0.3628855728266913, 0.27331664527210764, 0.37940434010079904, 0.2576659523531285, 0.29784736850289417, 0.3184591953607564, 0.18522755293703108, 0.11878373021125921, 0.1542472921509187, 0.2789902928494574, 0.26660740070341216, 0.18188121684098668, 0.12968998225228479, 0.17648595298016356, 0.15342818214485232, 0.15842303633763788, 0.20275214604934733, 0.12732203345757098, 0.1448342196923379, 0.17995248443348777, 0.14667988989356873, 0.19262489397698623, 0.19772696073526885, 0.16260618727922083, 0.1276752450189611, 0.12531901026212067, 0.13624687177174688, 0.0873458858644881, 0.12987572411554515, 0.14065082510903026, 0.16655897641131545, 0.12895178420763675, 0.17242325801643654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019295160951520174, 0.05277671041169818, 0.04593422192258767, 0.04173488789617208, 0.018220833251238577, 0.025038005523425277, 0.058124985121484896, 0.042402249452435314, 0.08999678483570372, 0.13338777144643266, 0.067626672094244, 0.032125769039348384, 0.09078762588137634, 0.036942558672200754, 0.05216655538814374, 0.043342677880846114, 0.03824379719480442, 0.04641765793586561, 0.037319781755513204, 0.12663120296909425, 0.13738602698605895, 0.16415124213497767, 0.12267869304416257, 0.09992084319156469, 0.06051859445237495, 0.10045772363461836, 0.10174878663871001, 0.10536854686212249, 0.48983331434681054, 0.44949115029175213, 0.5049036557049679, 0.47323988187604904, 0.47880244521932813, 0.48445140757395977, 0.49032366131651917, 0.4586210671879748, 0.45658325148267864, 0.09552764557112514, 0.09282293698682365, 0.11438827150987085, 0.10133794060505374, 0.13108859043235188, 0.13424436414716712, 0.16158771634294533, 0.07841241981385405, 0.10015474208762176, 0.2031293509566935, 0.18323208579124706, 0.22032517979661137, 0.15613964014204762, 0.1483390976018404, 0.30140667121837317, 0.21863544291441883, 0.13877565447058782, 0.2018396223554476, 0.2980529187904887, 0.26227913147532267, 0.17452268689928663, 0.27216077733060107, 0.2353193437345673, 0.2779809732858174, 0.35124296905313235, 0.331105812547551, 0.20173212191505496, 0.1195175133366514, 0.23139665876227078, 0.1336139808687865, 0.18939204277261334, 0.15958514014902214, 0.16576926191514374, 0.11695414752608246, 0.26654820606600327, 0.20666122046673396, 0.20044794285430345, 0.19873506750967107, 0.19436165108333836, 0.19058115796562247, 0.2019483486126521, 0.19444621777471838, 0.20155105551732921, 0.194651164747093, 0.22373859779616956, 0.24321140997854718, 0.22721883016727662, 0.21143150239626973, 0.21121874526717155, 0.43236649432291807, 0.2117243085066004, 0.20973214768859694, 0.19805262433052562, 0.19658023081932174, 0.18467568335703477, 0.1869798003642189, 0.7419927149496144, 0.6674263931164788, 0.20940880900461656, 0.19843661762727316, 0.14798794444133512, 0.8149120755038737, 0.21001046968351733, 0.277684164532204, 0.1697160224584644, 0.27901162898089205, 0.13282700862486285, 0.1695898468827478, 0.20890521462426248, 0.16861314934634242, 0.162963344149488, 0.094358730716251, 0.18863022556796838, 0.18381953661455086, 0.17597694500929717, 0.18073426962986583, 0.20269861570974002, 0.18884437054801806, 0.17897617646045583, 0.18244835831184614, 0.18481128666034397, 0.08898102255552198, 0.09756163546155183, 0.0940031109469992, 0.08447176585600247, 0.09020655552223, 0.12572617263958696, 0.08939755864329657, 0.07777900501159729, 0.10012574053351597]}, "mutation_prompt": null}
{"id": "84778427-dd32-4529-9399-a6f02b752b08", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n\n    def mutate_harmony(self, harmony):\n        if np.random.rand() < self.mutation_prob:\n            mutation_index = np.random.randint(self.dim)\n            harmony[mutation_index] += np.random.normal(0, self.bw)\n            harmony[mutation_index] = np.clip(harmony[mutation_index], self.lower_bound, self.upper_bound)\n        return harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.mutate_harmony(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "EnhancedDynamicAdaptiveHarmonySearch", "description": "Enhanced Dynamic Adaptive Harmony Search with multi-elite harmonies and adaptive memory refinement for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6557495016456192, 0.6139051134624651, 0.687731921903524, 0.6710911306404246, 0.6581561475682003, 0.6493791528204769, 0.6517363591901053, 0.6410969049728581, 0.6263012561710544, 0.2914766949051084, 0.26899002514780757, 0.3132607253683187, 0.3289611203864683, 0.25509363124178175, 0.2918121573410968, 0.2513252679991749, 0.28767094346838507, 0.287226168489751, 0.19504620021239016, 0.3204621634553907, 0.18699421194113197, 0.32469700893468656, 0.23202518858683951, 0.31538574950339093, 0.24031157005751524, 0.26559964985328766, 0.3505098709392681, 0.16264198475902958, 0.18039360152447204, 0.16039641957176032, 0.18041230679466447, 0.17331520517396526, 0.15787376304308254, 0.3215276849977956, 0.1531023959430522, 0.14910751244093512, 0.821825211832926, 0.914233262243446, 0.891055042989407, 0.8735463502705135, 0.8596791762456376, 0.8967987723618213, 0.8814728094277414, 0.8681568201682127, 0.90630482838321, 0.1950056185576894, 0.18250784501477657, 0.29176858276598006, 0.40611511188089133, 0.27269239874429185, 0.3163944678889211, 0.2326353210833666, 0.1490570916009969, 0.17470715310102192, 0.196537260383416, 0.16154163238192376, 0.1690090470072222, 0.35015666936571255, 0.27809537357450576, 0.2781220256815309, 0.14174291567319264, 0.17659209602400938, 0.23349977036628844, 0.22884598618759044, 0.16152102164277637, 0.12954499150769827, 0.2054420910971504, 0.15988493685170557, 0.1561624360101137, 0.15177344624970668, 0.2791437051279627, 0.17466605803713264, 0.15660469385957476, 0.13088519646715013, 0.14901183141817254, 0.32348630410730905, 0.1532067355014226, 0.16751535275990792, 0.12842014465769114, 0.12808833567449873, 0.17245449032537397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07205767491106674, 0.11082768371540719, 0.12263183521763388, 0.04162572827560451, 0.06381329843582684, 0.070713121079092, 0.0655423304185242, 0.07906756519746538, 0.05775400069583014, 0.06480299501881182, 0.0379423644375414, 0.11764974685031826, 0.07925773545447412, 0.09858241511195609, 0.08542628524834295, 0.10812011891754425, 0.0859900238896163, 0.06375426622605318, 0.12110073576997349, 0.20498151048481983, 0.17984326908136938, 0.08253969499127356, 0.1293690772589905, 0.0665811020598861, 0.15748565477579812, 0.14502022492371347, 0.11491208546714626, 0.43022054734526016, 0.4587667994410247, 0.4510572004819241, 0.4681656092887714, 0.44207598545319193, 0.45874298331382324, 0.4524113225419223, 0.4620303293897101, 0.4505788684015275, 0.13474117730332413, 0.09621213837101295, 0.11660912575008553, 0.11871855020012612, 0.12937653813950256, 0.15901645235027062, 0.09308141134971737, 0.1586703130174636, 0.08975670400486613, 0.2083302708129655, 0.1880239037019915, 0.14224437455259253, 0.18850929935443617, 0.18173853731984857, 0.17983124389981697, 0.21835904993512945, 0.1887510002661532, 0.16625030205158875, 0.2820025196048498, 0.2226271906822581, 0.2081214202704862, 0.37406671539068215, 0.33854562634305185, 0.2264222840566804, 0.22104986786302283, 0.21064893919857963, 0.2097633404048278, 0.21283752751430995, 0.17248113011937438, 0.12911221669958084, 0.18745059842625378, 0.3355623104537715, 0.1990997530326588, 0.11332620456145837, 0.15919814916287522, 0.11475065598078549, 0.20666708366503816, 0.22904749958965276, 0.1983467623446994, 0.2134237512850602, 0.19954257450451218, 0.20855484723981865, 0.2139063142983182, 0.22292568753659614, 0.21195802930955732, 0.2189912523931965, 0.20753804685003485, 0.2099162194591535, 0.22798443849156091, 0.20821946813466885, 0.5057766683338556, 0.19875017571539522, 0.22714942031825014, 0.2086819218673237, 0.186401441533816, 0.18706028167916888, 0.18638945232705917, 0.25866150172350644, 0.16964520688065754, 0.8725824643742968, 0.8664692879496548, 0.1688672287465517, 0.1761920932226394, 0.37191160593227135, 0.21223902358851887, 0.2232007731930884, 0.20551972816883468, 0.20604925631596338, 0.2118872353819128, 0.21018773647371625, 0.38719182709644406, 0.18882677124807845, 0.18823996871786308, 0.18337667020377335, 0.1971318273107706, 0.1713940625586261, 0.18393634770026424, 0.19980170249151896, 0.19721823257214266, 0.17853074429181903, 0.2047957502450647, 0.0996407783221619, 0.09597792312464248, 0.10081569815790603, 0.07857635419942166, 0.08915659799319287, 0.07582281960413584, 0.09446032211150635, 0.09278997922734034, 0.08273974440920318]}, "mutation_prompt": null}
{"id": "b2439db9-6a8b-4c63-9390-a2f9bcd050fc", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2  # Fraction of elite harmonies\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return harmony_memory[best_index]", "name": "AdaptiveQuantumInspiredHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search utilizing quantum rotation gates and adaptive parameters for enhanced global exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.2534728700542678, "feedback": "The algorithm AdaptiveQuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "a3206322-b86e-476d-ad07-c90d4bba01fd", "metadata": {"aucs": [0.6310533559624238, 0.6224677521095224, 0.6329831717253603, 0.6356747049289551, 0.6322712443899514, 0.5808156673065203, 0.6564311565533949, 0.6225796283816862, 0.6204501717647017, 0.23942839062889865, 0.28960568674249854, 0.25402173668349337, 0.29159530029006153, 0.25474117342533587, 0.28437091804635906, 0.2654580334174963, 0.25163016921138104, 0.3454655971952285, 0.27299541463861654, 0.3483355873758144, 0.2912848439080209, 0.3515552815325196, 0.17243232857878144, 0.30962499551493305, 0.1726713518670474, 0.33264280799247004, 0.32346084106162964, 0.18704522534883794, 0.3118546596746803, 0.3216000083663434, 0.28446945355860576, 0.18132685005391969, 0.30898031297397655, 0.27599189870947516, 0.22967828181226124, 0.23581016729391469, 0.9558076860347136, 0.9501743110130483, 0.9265581951694053, 0.9287343408170801, 0.9527000264746094, 0.9483098435734492, 0.9566835751521249, 0.942603867228963, 0.9512806398301151, 0.24546316472717933, 0.19607590057071977, 0.2553228689910254, 0.31943235346965226, 0.21998881132884052, 0.35164441840828065, 0.22492582954952445, 0.21582395329119497, 0.2280990543341942, 0.3301801121435468, 0.21582116512376504, 0.24646529285297503, 0.33300780139200736, 0.2411537674581289, 0.8144963921409394, 0.2204625725331446, 0.161960685470958, 0.243202226122747, 0.2311212741494454, 0.20294403952520712, 0.20218088037877746, 0.18197312561199985, 0.20549221010084218, 0.2510007871993798, 0.23002571359277812, 0.24232427461381056, 0.1536835252441493, 0.1303104572946091, 0.14402451425238727, 0.15409284685649527, 0.13729605522136867, 0.2960275708075759, 0.13505150442505998, 0.13118609600681663, 0.1663787296431326, 0.14318753954327856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053036880138063514, 0.12134186481911713, 0.08154418163121813, 0.05388128576476903, 0.0307041222587654, 0.05102563428461726, 0.07580177832367185, 0.1636948955292712, 0.0589277875326486, 0.01773549112520556, 0.05376855438705186, 0.06881596398004253, 0.06447947457695369, 0.09524431178754822, 0.06263575803758936, 0.07806749631025411, 0.05882467563331428, 0.04051353792164114, 0.12001000197288014, 0.030156448152705906, 0.1702636989527131, 0.11006682836260173, 0.038018718647151006, 0.027613778082022145, 0.19124947091338196, 0.1548302597979504, 0.13352971763861354, 0.4648661277004409, 0.4069189693404084, 0.43757768761016425, 0.44644693056848006, 0.44769205440545756, 0.47355897874469144, 0.41302216644839307, 0.4613159231389723, 0.440243104288622, 0.11109060616668831, 0.13581006063468815, 0.09133241240475798, 0.13908320926192153, 0.08750532941273503, 0.10330529056555748, 0.13321639469308322, 0.11532988138543154, 0.1506732615900115, 0.1227687077304418, 0.15346421855659698, 0.16209607188125352, 0.17123327842934266, 0.1837613831477305, 0.1617846378382114, 0.1953241302431996, 0.24763230947858972, 0.23026162310967757, 0.3094244867403698, 0.3268979686966229, 0.2027173782024051, 0.2691605859951689, 0.2607152116380528, 0.3523159376680246, 0.2982988602179757, 0.33629156473669675, 0.3356817867682915, 0.14975631956429902, 0.25584384745441147, 0.19664166823247253, 0.2484065616967711, 0.2079928872546709, 0.2807831377810216, 0.2420640335036255, 0.2437781189743805, 0.27529277565450483, 0.20390411973673317, 0.2039329536437937, 0.20626157360699704, 0.17327469661552364, 0.1966020526059128, 0.19924080165992009, 0.20848075748638573, 0.1886003295155011, 0.19719284707882956, 0.2886453272669621, 0.22287424966511082, 0.22504044471225948, 0.19303743241971383, 0.18897723267397737, 0.21384782597080998, 0.1988839406575379, 0.44536309537789676, 0.22339255015920878, 0.16448625858088695, 0.1673845562437104, 0.18677114111992577, 0.7511010709156241, 0.16973028515279676, 0.16640250817880642, 0.1613482667871201, 0.5310002540875551, 0.1755876684104567, 0.286187341999218, 0.21257218497983554, 0.18686750236785843, 0.20938379645183725, 0.2077223684955949, 0.21181666113620012, 0.21142286372903596, 0.5072950686172166, 0.1626521376177671, 0.19012623016189067, 0.19014111086192298, 0.20282223092754592, 0.18815104917957615, 0.190078441919176, 0.18267011507348607, 0.1781919785694025, 0.18087437678042073, 0.18448167141624694, 0.07811386574511647, 0.10420719468521877, 0.07864877563924422, 0.0918039323699068, 0.08090433443519418, 0.07830118292943267, 0.0889993423341372, 0.09888188569984069, 0.0919133824579289]}, "mutation_prompt": null}
{"id": "39f512fd-9f38-434b-b1df-094fb75d754d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True  # Added feature for adaptive diversity control\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Adjust par based on diversity\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumInspiredHarmonySearch", "description": "Enhanced Quantum-Inspired Harmony Search with adaptive diversity control for improved exploitation and exploration balance.", "configspace": "", "generation": 14, "fitness": 0.25560417863828566, "feedback": "The algorithm EnhancedQuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "b2439db9-6a8b-4c63-9390-a2f9bcd050fc", "metadata": {"aucs": [0.626978144187054, 0.6061540959405867, 0.5928397063850319, 0.7365852897923335, 0.6310712612777263, 0.6451480009259033, 0.6393522074214264, 0.6133117292367327, 0.5997547408379862, 0.21555524297416495, 0.27547195603937413, 0.3051221770842807, 0.26879433321929946, 0.24703570809646658, 0.2778412751565107, 0.28981590488620546, 0.32302701914152365, 0.274360401598018, 0.3712539804251068, 0.3174803454448666, 0.29335858796195446, 0.34028657764524417, 0.3035044163307593, 0.2905044777585698, 0.2812488625559918, 0.24431354345170453, 0.2654719957047862, 0.2924218920817031, 0.2358190727848949, 0.24227426525481344, 0.33000961698226416, 0.17559207561873535, 0.1905594983946981, 0.19696246861418032, 0.19417486096838787, 0.17914092474604637, 0.945140401720115, 0.9470773048556255, 0.9380299300604694, 0.9215705801818691, 0.9551392963881024, 0.9421305915275493, 0.9605655652480389, 0.9473324264408911, 0.9521915733411563, 0.2255267780724758, 0.2522987817565371, 0.20026020169669834, 0.2268204199638737, 0.33015244146937106, 0.3947964132597802, 0.24414902009992356, 0.21623753060407436, 0.23597939247486, 0.22415577684983878, 0.22094025824290042, 0.159604611771348, 0.26893127186153976, 0.2094877589685491, 0.22038492663143883, 0.19400541523013304, 0.3311393209701783, 0.2893511245219633, 0.16974313559969123, 0.2585383582001842, 0.1501511643258011, 0.1610503979008947, 0.18093790034787927, 0.21969182053151148, 0.1384865141690258, 0.15136647748208254, 0.2102460866259297, 0.1458453789410591, 0.21043404964874246, 0.1324256894888649, 0.1284297820663829, 0.13123070953554195, 0.15747895936351453, 0.13796354989778958, 0.1352276385299097, 0.1360376993807043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031768581843951704, 9.999999999998899e-05, 9.999999999998899e-05, 0.014951479960711, 9.999999999998899e-05, 9.999999999998899e-05, 0.10692375201756599, 0.08518551717350997, 0.08500636946713913, 0.011076009850723989, 0.02677385803974741, 0.03971135899681488, 0.1426686555950739, 0.12523184107491558, 0.056425947076153005, 0.06106579875856788, 0.03717635594569657, 0.0652069394303102, 0.06294912462489832, 0.07737533858496459, 0.01970817716456308, 0.08926817498111506, 0.0621707153173815, 0.042660892044466325, 0.05281101926989873, 0.07977504030149196, 0.19554007550870944, 0.1273784481067992, 0.07396095814455561, 0.16129300362561694, 0.08939324269073767, 0.19717462618990844, 0.12560031334884425, 0.43714082824559364, 0.424694746527048, 0.48249386407713823, 0.45063472897137025, 0.5195791645387406, 0.4661220040675764, 0.45181819592539585, 0.4266438291990312, 0.46667264719515755, 0.14484269539085037, 0.15369880799834812, 0.1063287762297741, 0.12217638830578015, 0.13056924725017904, 0.11488230650350739, 0.13509102195002654, 0.14822737872152048, 0.12708195119143617, 0.15433065658742884, 0.12552036933819566, 0.17560758822473144, 0.1516012502792461, 0.12846775043016967, 0.13778205648639485, 0.14086510584007406, 0.14420977568169457, 0.16118729605889692, 0.26899344833112515, 0.2918880085995039, 0.22118430694011015, 0.2372538127369106, 0.3194824212492794, 0.3590594724746844, 0.36653591733077395, 0.3805733923430896, 0.36446502378341405, 0.25237021251472735, 0.16171426734601047, 0.13949738687009905, 0.2490011352438719, 0.24975385972656183, 0.28834524923674554, 0.31656738320343014, 0.3194720289817313, 0.2143087015389007, 0.2240061472094348, 0.22391986883473802, 0.20421916089976966, 0.20286550192431807, 0.18855403330648146, 0.21938975240743452, 0.18916077003713394, 0.20577453515699862, 0.19533989207640512, 0.2100325792475487, 0.1961395255143541, 0.20086559735821297, 0.22633954286330793, 0.23733608858556554, 0.41474023868135634, 0.24612191276098128, 0.19387907654224956, 0.2111649748681158, 0.18701734308786444, 0.18808460794711013, 0.4195912558320579, 0.8404667505091113, 0.1548170775959894, 0.8364472332646613, 0.5997386422444853, 0.5723438362519705, 0.16903588383450696, 0.41565638892074985, 0.16864261362013877, 0.3314168538045861, 0.1669141810664787, 0.2089540792626764, 0.20814753286397603, 0.10522854105542778, 0.23085008694212716, 0.10466415804993845, 0.19611684981970634, 0.19152862445445162, 0.1952747490913883, 0.19186418304175823, 0.1946490706922004, 0.2225883891229513, 0.19319761595479457, 0.1795956489701539, 0.19170391021872424, 0.0741823057987222, 0.08486496025218038, 0.0942032889872425, 0.09102774022533011, 0.10135920827089162, 0.0982930169941737, 0.0836053025442759, 0.07046337568726357, 0.0897606470035327]}, "mutation_prompt": null}
{"id": "f209774e-c0ae-46e2-a9c8-eeca02e91024", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearchDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.learning_factor = 0.1  # Added dynamic learning factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        learning_factor_modifier = self.learning_factor * (np.random.rand() - 0.5)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity + learning_factor_modifier)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumInspiredHarmonySearchDynamic", "description": "Quantum-Inspired Harmony Search with adaptive elite selection and a dynamic learning factor for robust solution exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.24984378638517438, "feedback": "The algorithm QuantumInspiredHarmonySearchDynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "39f512fd-9f38-434b-b1df-094fb75d754d", "metadata": {"aucs": [0.6312209293908577, 0.5967608400103828, 0.6284902158059693, 0.6018703688374454, 0.5998300770640012, 0.5926668051484271, 0.633433756783143, 0.6277804018900491, 0.6212742891995225, 0.31187805203980346, 0.2461400379169476, 0.27644792219922276, 0.2643212313487371, 0.29439464485278566, 0.29638252703938195, 0.251264961334001, 0.30477558093060486, 0.27431088336271914, 0.3879903883812228, 0.2918802373718622, 0.3029535520034944, 0.30520809766985857, 0.34078634684526665, 0.36685299139855043, 0.26229320129252554, 0.2827755741320501, 0.32109843062718446, 0.1648657030461227, 0.15935873736469497, 0.30848832924295944, 0.2720128778218066, 0.16608535556331894, 0.19632211504710362, 0.1888545588174101, 0.2505689686961379, 0.25186500506356435, 0.9253329075343416, 0.9556352111726856, 0.934421906154965, 0.9438305214916024, 0.9431088308706703, 0.9401035259929815, 0.9485595375325576, 0.947234795265901, 0.9550655048322814, 0.2796032721750201, 0.19158553373244247, 0.2930444447756805, 0.30097183140179073, 0.2335524998823093, 0.3061501532621622, 0.22838326523648855, 0.23108736265328556, 0.27273252733393527, 0.22671912567912245, 0.26143047441079015, 0.162406321985351, 0.6452489589167107, 0.19912670579767855, 0.1908140696811721, 0.17939707562571916, 0.1656055938466212, 0.14808308773769407, 0.1780262068999937, 0.30639185263343105, 0.211281697397528, 0.15588524412201366, 0.16830224470552113, 0.2261383713602736, 0.13722904671548364, 0.37688957876386997, 0.14649955808195259, 0.14917755994178805, 0.18389859098909156, 0.12970170879859688, 0.14706352884883522, 0.2533373474258148, 0.14915271848836242, 0.15928852194365606, 0.2928699229005396, 0.13922860458839514, 9.999999999998899e-05, 9.999999999998899e-05, 0.02207135663375559, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023558609316794543, 9.999999999998899e-05, 9.999999999998899e-05, 0.0628463727644637, 0.04763384665293746, 0.08094767496129407, 0.052033783389007104, 0.0502044228264249, 0.028649627508141595, 0.08667029935975512, 0.055730565989061676, 0.08630958948706757, 0.09387044717506965, 0.04568762097973178, 0.06729553880987127, 0.08869147655507026, 0.07736074342674404, 0.05006214163136413, 0.0931180416988121, 0.08070644059676857, 0.06009072994845843, 0.12190534372972761, 0.06283176932582624, 0.1446664911851796, 0.12940278333240163, 0.06087470692154584, 0.08766603439422871, 0.09344390146510828, 0.15720460907245193, 0.08181823415229716, 0.43589276998076787, 0.40326336784865635, 0.4151391653818203, 0.4354278831742069, 0.5163427949010091, 0.45774990152836414, 0.46633311583223347, 0.433526657679133, 0.46787685906434995, 0.13799897577347986, 0.16336534915206025, 0.07224290266676703, 0.1104821640173792, 0.15246254285256733, 0.1148242366026212, 0.13030821086924682, 0.10588676520359297, 0.10928244920803121, 0.14954298638523145, 0.16174329491331318, 0.19236148512587636, 0.1980906539067646, 0.286805765075441, 0.14531251515110577, 0.206666235840536, 0.14755896005001434, 0.1388469498545788, 0.2338952131478429, 0.2281711885321639, 0.2149878960157946, 0.35480562974514085, 0.32078726823860304, 0.30886526180802254, 0.24988367407422862, 0.38105501398599073, 0.3142453465339259, 0.19582044699302248, 0.2842672791128683, 0.18308826112884202, 0.1959598831758167, 0.1989215997319207, 0.25449510800159325, 0.2881090021555921, 0.2871376106951228, 0.27631613806298483, 0.21611671842120694, 0.20188357030922666, 0.19730533399442252, 0.19381195496219572, 0.21232262458128115, 0.2540339737776369, 0.2245871033913841, 0.23486935932082298, 0.20006649615864203, 0.22726693826360633, 0.4307993208680351, 0.19071310137709074, 0.2290228429635447, 0.24114461312712754, 0.20954001570057712, 0.22953764679392963, 0.19813367176575358, 0.22640156878467188, 0.18795967798079904, 0.21405196540247662, 0.1852615112011765, 0.6132436702519191, 0.16768892250652334, 0.35959143458955445, 0.161062328004007, 0.15469251384298588, 0.1613229743451451, 0.39838952196971245, 0.16898735778262275, 0.28402028059946793, 0.1676246733876684, 0.2107442749706686, 0.21123858537323692, 0.10498521694512442, 0.41016991546406967, 0.1833117269589376, 0.18034397862445817, 0.17777382325667335, 0.183909792374922, 0.17647586216153632, 0.19995718398631568, 0.17892336334362413, 0.18116674225017837, 0.18146345621384552, 0.18452578196901182, 0.07134557414750908, 0.08321883719005496, 0.07423284767829896, 0.08117744678583216, 0.08933854716306155, 0.08982085104278792, 0.09448320675909128, 0.08320643267257, 0.07968939784642404]}, "mutation_prompt": null}
{"id": "404cd59e-bdf0-46a1-a282-a024816a907b", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.dynamic_tuning = True  # Added feature for dynamic parameter tuning\n        self.local_search_intensification = True  # Added feature for local search intensification\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        if self.dynamic_tuning:\n            self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n            self.par = 0.35 + 0.15 * (iteration / max_iterations)\n            self.bw = 0.05 * (1 - iteration / max_iterations)\n            self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        \n        diversity = np.std(self.harmony_memory, axis=0).mean()\n        self.par += 0.05 * (0.2 - diversity)  # Adjust par based on diversity\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        step_size = 0.01\n        best_harmony = harmony\n        best_value = func(harmony)\n        for i in range(self.dim):\n            for direction in [-1, 1]:\n                candidate_harmony = np.copy(harmony)\n                candidate_harmony[i] += direction * step_size\n                candidate_harmony[i] = np.clip(candidate_harmony[i], self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate_harmony)\n                if candidate_value < best_value:\n                    best_harmony = candidate_harmony\n                    best_value = candidate_value\n        return best_harmony, best_value\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if self.local_search_intensification and evaluations < self.budget:\n                    improved_harmony, improved_value = self.local_search(new_harmony, func)\n                    evaluations += 1\n                    if improved_value < new_value:\n                        worst_index = np.argmax(harmony_values)\n                        self.harmony_memory[worst_index] = improved_harmony\n                        harmony_values[worst_index] = improved_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumInspiredHarmonySearch", "description": "Enhanced Quantum-Inspired Harmony Search with dynamic parameter tuning and local search intensification for superior convergence.", "configspace": "", "generation": 16, "fitness": 0.152662331552561, "feedback": "The algorithm EnhancedQuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.13.", "error": "", "parent_id": "39f512fd-9f38-434b-b1df-094fb75d754d", "metadata": {"aucs": [0.2830321880568085, 0.34675079776680373, 0.42168686398787014, 0.3508973827140883, 0.3261861434946509, 0.3378830190367381, 0.3693292220814406, 0.46458034446839, 0.32224453226242245, 0.059507595861163276, 0.11504047901769754, 0.045637170943008454, 0.09931741307629616, 0.08337918726309201, 0.0926048024791225, 0.05196464861916261, 0.08242225564545202, 0.12849310920764323, 0.1332187218393095, 0.18399805230054034, 0.10613099436769391, 0.10167250188485943, 0.1328048711788531, 0.12678633054917932, 0.127522685732967, 0.11310175424097091, 0.09427239154646372, 0.12036640138973054, 0.09582887000315765, 0.10359713175902474, 0.1544259000439504, 0.09913160127314635, 0.0873178107233138, 0.11157988655212381, 0.10074419536076207, 0.0984938062840387, 0.7296180705997218, 0.5659161079022932, 0.5205905513405027, 0.6582642380243608, 0.5420947262174691, 0.6237510417734128, 0.4389428608460446, 0.5919897453328993, 0.4663956590485442, 0.0865190725915227, 0.09524255025209127, 0.12497581860580431, 0.11516226041360023, 0.1577102335122732, 0.1321304021152777, 0.13742411697391033, 0.1371789075840254, 0.011276526201019044, 0.16250272248108633, 0.1740279772276534, 0.125926237605132, 0.16031748530998624, 0.18310784917311618, 0.18587700127874118, 0.12554521343747727, 0.25167592687064166, 0.15554818809477744, 0.10594522351414215, 0.09705165964109108, 0.11746732915798963, 0.07121402487499928, 0.093357136615834, 0.06251108711646325, 0.0649161598649558, 0.10944267205599922, 0.23440799459027895, 0.09049152306680641, 0.11031751120157385, 0.11950671543070457, 0.09908431364569226, 0.08195622473699915, 0.05622334322762468, 0.10784719796608244, 0.07765740652519926, 0.011430955411956378, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02598616786648722, 0.03994530066152113, 0.03805172609034946, 9.999999999998899e-05, 0.067459151528521, 0.029926867965044956, 0.06090389431473631, 0.030804180044639584, 0.09155837566481073, 0.020689751577296023, 0.005622660260203527, 9.999999999998899e-05, 0.005301938081171631, 0.006527158912024267, 0.00712337021632703, 0.009543390430495347, 9.999999999998899e-05, 9.999999999998899e-05, 0.046147235252046226, 0.08862413563556604, 0.07017737540183866, 0.07064353089635877, 0.06287992369507789, 0.014868868613102881, 0.055139524874319945, 0.08124989243987346, 0.06816631164723808, 0.3267431761777789, 0.3090879430569289, 0.3433796099137788, 0.30384763067183684, 0.28150110132738804, 0.26834377310426016, 0.3025740876106251, 0.2677196182084497, 0.28477842013794497, 0.0827866213671421, 0.0515549532930798, 0.06346570243699623, 0.05596993371506209, 0.060260273624023974, 0.0702998758946658, 0.08326278839782497, 0.059370164167249495, 0.059900580607071596, 0.11203520137934175, 0.11460424771455435, 0.15208518332664844, 0.11061540632509836, 0.12103181015610787, 0.09072623936894564, 0.16429404115391666, 0.1292807385922915, 0.09613745619026304, 0.1963490958532852, 0.1431783855337051, 0.1537821339264086, 0.2122758421586085, 0.18944272703392895, 0.20479544109862846, 0.218745281219205, 0.27658427145819453, 0.19048729456993063, 0.08022378877980718, 0.1788010456771908, 0.11668625310721781, 0.16225141569702262, 0.1573462064856883, 0.16850963602307234, 0.09219868612629067, 0.143423840500302, 0.11191511219323003, 0.18840706573449162, 0.20675762933551634, 0.20091889064432011, 0.16844271741615358, 0.19323564497842483, 0.1893483012631002, 0.19340671522829556, 0.20652533500956538, 0.20925643076235179, 0.1652018554936341, 0.1692272788703154, 0.16004097393584127, 0.19446629486693068, 0.16370454500202236, 0.1952500418063583, 0.1710013919611323, 0.17947404725067495, 0.16924464235447778, 0.15238420017489118, 0.1453414884031763, 0.17666190044046348, 0.2862836785348304, 0.1627865166564466, 0.14215452423297792, 0.22661243262418085, 0.5256479278953454, 0.12495314299666993, 0.49602140860532973, 0.18947904498990487, 0.16927630076174915, 0.08633017303441759, 0.1603000340084747, 0.12090494571758226, 0.14041503994750948, 0.1837851311383979, 0.08214713297413523, 0.19004672893375696, 0.1811663670865553, 0.18377295119181303, 0.1910533765381941, 0.1784065383039729, 0.17129156321729422, 0.18828588749434094, 0.18524694857249047, 0.17672343187243167, 0.06749828058782859, 0.06123426540870314, 0.08228098008868168, 0.07894708236597636, 0.06397569614979803, 0.0783165454840331, 0.0576071954866042, 0.07198424623919997, 0.06804590538166322]}, "mutation_prompt": null}
{"id": "94e2fcf1-cd62-4c2f-a456-57b76322ffa1", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.memory_adaptive = True  # Enhanced memory consideration\n        self.diversity_adjustment = True  # Diversity-driven mutation adjustment\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.memory_adaptive:\n            self.hwcr = np.clip(self.hmcr + 0.05 * np.sin(iteration / max_iterations * 2 * np.pi), 0.75, 0.95)\n        if self.diversity_adjustment:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.3 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumInspiredHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search with enhanced memory consideration and diversity-driven mutation adjustment for balanced exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.25329798115481456, "feedback": "The algorithm AdaptiveQuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "39f512fd-9f38-434b-b1df-094fb75d754d", "metadata": {"aucs": [0.5999734698866441, 0.6053649370620151, 0.6695718132477014, 0.6508980368803482, 0.6176915971448038, 0.6301995050575606, 0.6126383952431671, 0.6302338489264352, 0.5733826497610428, 0.28189420300839363, 0.2697675023088234, 0.25917867751262824, 0.21764811862817235, 0.26933834735527384, 0.31617962715573567, 0.24711192302422014, 0.2821487248040918, 0.3592210789087147, 0.3437984596039152, 0.35388388093006207, 0.22819140620537637, 0.37812312960579375, 0.3561778956486378, 0.25300137391804733, 0.2758593602000361, 0.31644596692072013, 0.29482469295001335, 0.17702096611348583, 0.29435073366988884, 0.19728714543221793, 0.2847017940018276, 0.27132132212771554, 0.19981636501917077, 0.25384705816570874, 0.2940150567259102, 0.228514732066325, 0.9204708515947647, 0.9481517707043332, 0.9323300993131306, 0.9491112395695659, 0.9562373428896164, 0.9580632374461473, 0.9399450494944891, 0.9580586106656743, 0.9425083326136515, 0.23394641793847448, 0.2618981593127998, 0.2584816624562595, 0.3315679342439518, 0.19491207703021673, 0.34771723862187887, 0.24138156897712493, 0.2445705562218552, 0.19543299047937457, 0.2234749168188831, 0.22612466517796415, 0.17706824020772005, 0.3110599598086107, 0.21051591201906072, 0.27141834558890765, 0.23382214981222516, 0.3205367076401636, 0.21168630036039904, 0.19372323891540166, 0.27047441337915645, 0.14573189712782897, 0.16773330985393697, 0.1533449120673538, 0.22452497488975787, 0.2566925331455089, 0.17072144659427246, 0.1443379609035761, 0.15030712271097058, 0.21352428155233794, 0.14947650500012621, 0.14155422724984656, 0.13765768234425813, 0.13914651083456886, 0.12927675188053722, 0.14014428386069777, 0.13959425819988314, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009631350865599408, 9.999999999998899e-05, 0.00117996982890467, 9.999999999998899e-05, 0.058282071968375426, 0.0008999379033298727, 0.07580155581269987, 0.05149581508853984, 0.08887524582758688, 0.027544602886445002, 0.045505777626885346, 0.040049411426019255, 0.07495333847224739, 0.0660970279516605, 0.08473202210797426, 0.037643910589096774, 0.08788610159995891, 0.148088021652924, 0.06167613217376877, 0.08148750478723832, 0.05100413658459424, 0.12827433551851775, 0.05972840442046623, 0.08046372915875566, 0.08549441079868503, 0.0722007155503126, 0.19266515842989862, 0.13872743940384336, 0.1087151526452581, 0.17543570179212398, 0.0809978368579054, 0.1574651095724363, 0.11490317233101155, 0.47048416236984003, 0.4162505579390796, 0.42844728741994176, 0.548556873904814, 0.4779378548151584, 0.4196968576130672, 0.5039553173342777, 0.42086234260454003, 0.44492974262479756, 0.14070227694889292, 0.14188968748175124, 0.10163523720151313, 0.15258662611057483, 0.10462867937749376, 0.15834918972474787, 0.10233181322856855, 0.13863349925796287, 0.10807938646354232, 0.1543729820695493, 0.12982765135448404, 0.20180051158472967, 0.19902550320998202, 0.1403142801556544, 0.13409646238811712, 0.1614183617851429, 0.13251821133198938, 0.17639753501587874, 0.2689635603521938, 0.32935118708559763, 0.22463149501076674, 0.3181155402156304, 0.27329134216585294, 0.2675542913765422, 0.3250717896377151, 0.37892599293973095, 0.3310346682529761, 0.20673935143553912, 0.1802670441165719, 0.2379147069400096, 0.25297914872464544, 0.2680249068200614, 0.21935800801815597, 0.21065126575184234, 0.30526149522138546, 0.2729749957040104, 0.20140766668011834, 0.20649200798747702, 0.1949786214409791, 0.22194770880268944, 0.1894359591193554, 0.2141708571279175, 0.20349125687508562, 0.20773161917342364, 0.19726468634136696, 0.2310633663306959, 0.21406315161248202, 0.22430725825675557, 0.23127882567925417, 0.22714625336929584, 0.21767288452823064, 0.20421732536376846, 0.19991619607730504, 0.21258513420862957, 0.1881057285431461, 0.18733199205765327, 0.3630558188722174, 0.6235450008812378, 0.601072569906238, 0.8008476793809579, 0.16586191979486653, 0.15308169552059026, 0.1660770851413581, 0.18668629121157077, 0.16925043434813436, 0.3483371289662829, 0.20893654542004592, 0.20995533113200815, 0.20896328860346502, 0.10514087702438213, 0.38569088109653427, 0.10454053824755105, 0.17719891541540544, 0.2025363717806824, 0.18266521643527034, 0.1837458555224073, 0.1996692780858993, 0.17796703362746813, 0.17561148043265407, 0.18848435303404865, 0.18578404919905656, 0.10176557618866122, 0.08382980172690879, 0.09763561043565205, 0.08270955097482913, 0.09867648582872757, 0.09203629125623536, 0.09848214861194571, 0.08829563226737969, 0.08829146803738153]}, "mutation_prompt": null}
{"id": "6567eb45-dc17-402d-be3c-653ae796e0a3", "solution": "import numpy as np\n\nclass QuantumHarmonySearchWithAdaptiveControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.4\n        self.bw = 0.1\n        self.mutation_prob = 0.12\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.3 * (iteration / max_iterations)\n        self.par = 0.3 + 0.2 * (iteration / max_iterations)\n        self.bw = 0.1 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                new_harmony = self.quantum_rotation(new_harmony)\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumHarmonySearchWithAdaptiveControl", "description": "Quantum Harmony Search with Adaptive Parameter Control for Efficient Global Optimization.", "configspace": "", "generation": 18, "fitness": 0.24932115358224546, "feedback": "The algorithm QuantumHarmonySearchWithAdaptiveControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "39f512fd-9f38-434b-b1df-094fb75d754d", "metadata": {"aucs": [0.5731374508329372, 0.6056014356249035, 0.5883095512314538, 0.5678102774117235, 0.561177225075635, 0.6555638415488954, 0.5631242990238875, 0.5997242410656274, 0.5740855416915529, 0.21922927580521556, 0.2503709715599095, 0.2551790786552146, 0.2351500962038392, 0.29814180700550386, 0.2723225800164222, 0.24592069784230264, 0.2756335575504717, 0.2308931564772566, 0.29351116389579524, 0.2895520004168155, 0.3227828132888384, 0.19581011659886038, 0.1813312625227661, 0.18828329034867242, 0.30258605568504293, 0.170659153783438, 0.23214256845440884, 0.18006471885335085, 0.15692437320448083, 0.16279725008512902, 0.22724495727853955, 0.27565156715650385, 0.18320287573766092, 0.15845090678604956, 0.18686608654022063, 0.22298482428290145, 0.9502119641214053, 0.9433903071039582, 0.9309541306129576, 0.9225164660064201, 0.9460722845717247, 0.9393171352442679, 0.9346468467024276, 0.9513245835929892, 0.9556153918383216, 0.22262659205066826, 0.2927203898522516, 0.27236706788222387, 0.3491836833974583, 0.2992777363670919, 0.34928030625502005, 0.2850915010939665, 0.22806627370271704, 0.25974996603253087, 0.21821581682731162, 0.21038990650386657, 0.15784446816966646, 0.27392910880333343, 0.3770138864111041, 0.2182385866292379, 0.21902962771728174, 0.40356947625955886, 0.8629014017276008, 0.22050539133661073, 0.15303859401627273, 0.15687929116739197, 0.16058671079272502, 0.15082526379884476, 0.2363691315573725, 0.2835650000226758, 0.22775872486319937, 0.1738233434079468, 0.1479954307308997, 0.18006095145726464, 0.14923246703465143, 0.16778004555449966, 0.11786519447526278, 0.1544350319534349, 0.13011544359480953, 0.15506318819727116, 0.14061374984300523, 9.999999999998899e-05, 0.006321550788794927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005017453309006381, 9.999999999998899e-05, 0.0660407995296518, 0.04226269485049783, 0.029354112421643208, 0.07916368389847395, 0.011571808713191745, 0.03433446489016623, 0.06213376143235494, 0.07722658813805716, 0.10044968568686652, 0.1434885035669251, 0.04690839874117558, 0.05732683512587722, 0.021516346463959057, 0.036221781274995424, 0.08077983506156927, 0.029700948495562485, 0.06274979543453751, 0.03714077432234009, 0.02631479292567962, 0.08603563531412473, 0.09841152284089727, 0.06373682469437814, 0.12896654084414372, 0.09873727637968588, 0.11597781614689362, 0.09768519793181862, 0.16722583799166457, 0.11960992575791773, 0.44328256779351627, 0.4528660662687316, 0.45232218097244903, 0.44589419713507883, 0.45502354782350074, 0.44477196384594564, 0.4302403417868883, 0.43515583905778576, 0.4995323374259838, 0.11319886300966486, 0.1214259773373586, 0.1318282327583714, 0.17756014944952858, 0.07977518192118971, 0.14308543233809246, 0.07525598759793062, 0.08145266701710885, 0.09967093667299809, 0.1446614225802625, 0.12662598248952595, 0.2090341651873906, 0.15593658749806782, 0.17825642450799473, 0.2231040332785772, 0.17728405063685426, 0.1425694279087848, 0.17751049769912974, 0.34141851332480944, 0.33117981127792895, 0.19350084572303206, 0.28092979751645986, 0.3359037770914338, 0.32427010112985133, 0.35052663075820545, 0.36435403880868866, 0.35130804666164117, 0.24873153679644178, 0.24807648898261525, 0.12489862877980051, 0.2407100917457542, 0.18075362604651324, 0.24170352529369477, 0.1471997523552966, 0.2830401809368637, 0.18336082421040523, 0.23144228527310573, 0.20524217236330833, 0.21226120129377712, 0.23865685956950988, 0.17848883838181284, 0.21895589253135062, 0.22830308841716251, 0.19492329373852746, 0.18658610134396303, 0.38131518970274314, 0.196470430598505, 0.2240957132568584, 0.21793689824941243, 0.20840113186795317, 0.20987967726318302, 0.22962261733155542, 0.23592315455879165, 0.23703245954280006, 0.5165042647871607, 0.1888704761535026, 0.4237602900775852, 0.20071885529108668, 0.17034747665868144, 0.7574782418061716, 0.45421592428956314, 0.16426080586260483, 0.1651682186418837, 0.5270749720158316, 0.16986573967122476, 0.38996991677976367, 0.20912055463184098, 0.2562301223733634, 0.21282567308273337, 0.15978069032588427, 0.1256214139753632, 0.29253978202779385, 0.1834178450116738, 0.18316454450949593, 0.18476150816694814, 0.17468655874314176, 0.17290753840167183, 0.19337854981829028, 0.18431283984650415, 0.19277951360363565, 0.20090348354799725, 0.08424722015389785, 0.08588455360596725, 0.08691869321818468, 0.078346640287841, 0.0804291405320926, 0.09161651488121059, 0.07796298528012735, 0.08941850475358515, 0.08837642240977817]}, "mutation_prompt": null}
{"id": "1168f999-38de-4dd6-844b-e3b1d946528f", "solution": "import numpy as np\n\nclass FusionQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.9  # Slightly increased for more memory consideration\n        self.par = 0.3\n        self.bw = 0.01  # Reduced bandwidth for finer local search\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.3  # More elites for intensification\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Added adaptive momentum for exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.4 * (iteration / max_iterations)\n        self.par = 0.3 + 0.2 * (iteration / max_iterations)\n        self.bw = 0.01 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.2 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "FusionQuantumHarmonySearch", "description": "Fusion Quantum Harmony Search with adaptive momentum and elite intensification for enhanced convergence in black box optimization.", "configspace": "", "generation": 19, "fitness": 0.269347503698594, "feedback": "The algorithm FusionQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "39f512fd-9f38-434b-b1df-094fb75d754d", "metadata": {"aucs": [0.7087676438708763, 0.7148805512114436, 0.7698493312696199, 0.7398878182042475, 0.7370095004688019, 0.759846977705699, 0.7368987240433668, 0.8066057415009791, 0.7713460197141013, 0.3639125175334148, 0.3960486072707283, 0.31464608432033314, 0.3526389459998396, 0.3745058511481354, 0.36081048567588403, 0.381516298476288, 0.3838912594526107, 0.3809513921482315, 0.2385846691281216, 0.34032517127810546, 0.49742985943946905, 0.3726092923100077, 0.5005990642242233, 0.5055299190498863, 0.43568931027732705, 0.39996174185506495, 0.35404519231028697, 0.1605366814061927, 0.285954646548338, 0.3948961616225348, 0.4031910308707788, 0.1944942158140619, 0.3040809062320954, 0.402959858054622, 0.38581349500382567, 0.1793647698761779, 0.9516537543579613, 0.9468811449915528, 0.947376590694314, 0.9448153736678888, 0.9494444728495455, 0.9468361482682668, 0.9571554180055611, 0.9500204453410571, 0.9408295396611005, 0.21845446196719442, 0.24586674180070833, 0.22884574866894525, 0.1970657881240484, 0.3074289287502797, 0.3358638256273282, 0.24586767404653953, 0.17812092755572662, 0.2746159546317919, 0.24044489025664106, 0.1592895326133683, 0.1770457042650787, 0.3676789007335859, 0.28454191002341644, 0.2121885141765466, 0.16164044033505176, 0.14541648320069123, 0.1517470231261132, 0.2719870355039211, 0.16306061559028096, 0.1665361513006719, 0.15556726836779777, 0.23357601778978054, 0.14434277594701983, 0.17721469505539866, 0.2107041319933982, 0.3006287275879995, 0.1432585724141371, 0.13286152870134882, 0.20799212348772256, 0.14234736435802697, 0.12830873044214308, 0.14778196983330194, 0.13977924432400357, 0.11894833273787409, 0.14410751151892998, 0.020297264588351904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001578185761776707, 0.06760552275741594, 0.0401911702625084, 0.06923433808717416, 0.06216514568454368, 0.049020477160728326, 0.03745167050396536, 0.08692714605864837, 0.05745469809617276, 0.08239532655839343, 0.06327664179469794, 0.207517565016616, 0.14770862456539724, 0.09485328720129094, 0.15317893197352117, 0.1003532577685402, 0.14233056078114137, 0.14689122024234935, 0.0859022699476214, 0.10706370591216585, 0.13387635894659267, 0.2822317715804875, 0.1453958725183998, 0.22668353751604753, 0.14218699603210483, 0.2596782107442178, 0.10837871992533654, 0.10935890551868854, 0.49209784788094246, 0.42288234558401105, 0.5507833415939345, 0.4292642097647308, 0.4229674594487913, 0.4152417079468752, 0.42220962490500213, 0.48358265952158397, 0.4572443926371058, 0.10284755624150566, 0.15759468026375312, 0.07773849195341531, 0.09255151384264604, 0.1235546183092674, 0.10568363817113291, 0.13663183918470279, 0.08926901349857674, 0.09662288114208772, 0.19096263264605062, 0.1592135375501852, 0.21580343335164265, 0.2284393730527281, 0.2295427081788991, 0.19453269607587043, 0.17183085578208213, 0.17359538967954335, 0.21476858724388426, 0.2303847581341253, 0.25316764737444997, 0.25524335262029274, 0.25276842699987645, 0.28335630834312076, 0.22381642968002047, 0.38643255612998884, 0.29683215623782755, 0.24262382007645578, 0.20810239757426585, 0.1485017347332609, 0.18810882692429032, 0.20406286967658804, 0.2129247604524156, 0.21108473880570056, 0.1389139794939096, 0.22183333667151872, 0.2151935518339022, 0.20551834149782422, 0.20518310709279974, 0.2600263080764972, 0.1987331946472113, 0.18836080538813793, 0.18823769901559784, 0.22842888175032305, 0.263256619498186, 0.21972536518908714, 0.21855520293544817, 0.22298422919319005, 0.19263697492023157, 0.23708146307719613, 0.21953983092437224, 0.2312463337292342, 0.1980234610413446, 0.23720337476788544, 0.20208240047466441, 0.5416831447679815, 0.5353021449545673, 0.428610680037389, 0.2004348473165103, 0.512964241036483, 0.6916448285385306, 0.24899697943832266, 0.1688292219690959, 0.1663816354695017, 0.15083477776096732, 0.17097718085379132, 0.3770500392808144, 0.20944455866203293, 0.1679443800272966, 0.20839554998526888, 0.16607983374111357, 0.23070872026241618, 0.14111364479901678, 0.18367599398568146, 0.192326521431895, 0.1846243205985052, 0.19377120723315988, 0.18107943251181924, 0.1901522950301371, 0.19512274783128547, 0.20519784154857024, 0.17866291521877808, 0.0924677651818836, 0.08363516546397609, 0.09102070918290628, 0.07333448733710246, 0.10972327101262669, 0.07585358192525782, 0.08149290863083991, 0.07959406404797442, 0.08419062787593723]}, "mutation_prompt": null}
{"id": "a7907306-1d7e-4ee5-b2b7-d940fd0805c7", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85  # Adjusted for slightly more randomness\n        self.par = 0.25\n        self.bw = 0.015  # Slightly increased for better local search\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.elite_fraction = 0.25  # Adjusted elite fraction\n        self.theta_min = -np.pi / 5\n        self.theta_max = np.pi / 5\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Adjusted momentum for more exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.3 * (iteration / max_iterations)\n        self.par = 0.25 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.015 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.1 * (0.2 - diversity)  # More aggressive adjustment based on diversity\n        self.momentum_factor = 0.85 - 0.15 * (iteration / max_iterations)  # Slightly reduced adaptation\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with dynamic parameter tuning and elite-driven exploration for efficient black box optimization.", "configspace": "", "generation": 20, "fitness": 0.25796945381056335, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7152111275533948, 0.6794733247232005, 0.6778849339187434, 0.7318268461047668, 0.6538780578262342, 0.6797859486847366, 0.6733213854266167, 0.7161253715760603, 0.6824987289157143, 0.3344581886607644, 0.34637491003616505, 0.29931674585285273, 0.2953886383772427, 0.3183947921574899, 0.3648941317142995, 0.2808393742138575, 0.40016821189429175, 0.35576763478041973, 0.3938025217634904, 0.2674833239864691, 0.4328751367909516, 0.35477702065327443, 0.427621802819494, 0.3959066127571709, 0.24754469817372715, 0.2716360076136657, 0.42677830224374447, 0.3618707441075141, 0.1849955896625527, 0.31532619216888647, 0.3784361688172002, 0.21255139369233145, 0.2789922025660373, 0.3171740832095872, 0.18982220423271612, 0.3582983983885035, 0.9608342635942673, 0.9429718923103593, 0.9264119052432456, 0.9334734335707577, 0.946782851588495, 0.9536961259161628, 0.9400080973036935, 0.9660332986640895, 0.9315735018133886, 0.27515272225479925, 0.20057353708609427, 0.2885569030626487, 0.32340095048112605, 0.16737406218892226, 0.25494622265544553, 0.22512104369688768, 0.2573242617747944, 0.2104874279553267, 0.16847573675895733, 0.17025279887922096, 0.15630326267626748, 0.3458915627054826, 0.19060385251027123, 0.27666222798432893, 0.15833504842505886, 0.17065580434354832, 0.20587262861688427, 0.13030167224014344, 0.165947672441079, 0.21306117509551115, 0.1631611844524108, 0.204704937737065, 0.18520600936475085, 0.1748506929410254, 0.16550427702915527, 0.1887751247694237, 0.14971890641332652, 0.1309251670005287, 0.1292668644489291, 0.13862024752195046, 0.2097049103906694, 0.2788180322517294, 0.15924615082495053, 0.13363717483824678, 0.14497614530776481, 0.01056789728211116, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03295041304816404, 0.08278144226859674, 0.0477255414046478, 0.0808334274533421, 0.05073192321757669, 0.04543554895567958, 0.04337816178694898, 0.05701161937925914, 0.08191838701716825, 0.1416141870338573, 0.03939146414494121, 0.17071019407884191, 0.13959014331884612, 0.07247634126058766, 0.07256895235772842, 0.18812840536904496, 0.06764817340026408, 0.13648907583223058, 0.05346741707887959, 0.18345693421218634, 0.02877117897913084, 0.1497337631001141, 0.09239405510787968, 0.1468014529794882, 0.10540574452067053, 0.10584162524029084, 0.10285109937909698, 0.10361200238410362, 0.4253768622993741, 0.4687631159813679, 0.44761013582883624, 0.5398221871248567, 0.4124594335782562, 0.41730847461527354, 0.4549436218642482, 0.44308167731889025, 0.46657068234992616, 0.06191375266380106, 0.08078716344334447, 0.08914000612561845, 0.1761428504083653, 0.11797862006890869, 0.1086145606180915, 0.11624625857703741, 0.11169189179731165, 0.09813394802168118, 0.20009109693880067, 0.1397326573989156, 0.1806478079233721, 0.1733634402727774, 0.30716506284305845, 0.13230533467296224, 0.1404051051726406, 0.1363113409397414, 0.19016527159023844, 0.25404242875785477, 0.2702785377122665, 0.17476330839435372, 0.29817988885321045, 0.2524805236888855, 0.2914058510165469, 0.29193362687307745, 0.3701804073499484, 0.3065291236756962, 0.25129637940596095, 0.26870980971704217, 0.14562359083315202, 0.2283679356579248, 0.32817101776189916, 0.2239806194956464, 0.21335569835152335, 0.23118193426862077, 0.15743393459005506, 0.19771237569344946, 0.22908362093454904, 0.21768616341069913, 0.21183508995368916, 0.24999712226614967, 0.23029083453465504, 0.20654272204632473, 0.20245296025334925, 0.2176208756047726, 0.20194412829566755, 0.18909648409880764, 0.2105521594275942, 0.22416476320466527, 0.21058785992324336, 0.19084202770302539, 0.19853149503513756, 0.1881605638391135, 0.22140125273343514, 0.1819437382295399, 0.18831327097425155, 0.43588524545155316, 0.612896458442119, 0.15223763006452917, 0.9127928981299073, 0.1641994713127677, 0.39874397312708154, 0.16075480155867372, 0.16957037744594816, 0.2099440657548427, 0.3202910796682076, 0.16802509031972768, 0.14866737220553838, 0.2110468636112185, 0.10456691104402505, 0.2960853822201861, 0.10469039538933889, 0.18222837166672134, 0.2043928318665742, 0.18349154969742398, 0.18106425464588793, 0.18475587527845094, 0.18503695771144058, 0.18092743132521616, 0.2187401346913751, 0.19251228084336824, 0.09273692350305407, 0.08274636842284822, 0.0857799986540887, 0.0806435734279336, 0.09233185368963459, 0.12010053829611278, 0.08220916159586922, 0.08151599686313582, 0.0856543233683722]}, "mutation_prompt": null}
{"id": "33c1971c-e006-499a-8663-a371827dac33", "solution": "import numpy as np\n\nclass FusionQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.9  # Slightly increased for more memory consideration\n        self.par = 0.3\n        self.bw = 0.01  # Reduced bandwidth for finer local search\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.3  # More elites for intensification\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Added adaptive momentum for exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.4 * (iteration / max_iterations)\n        self.par = 0.3 + 0.2 * (iteration / max_iterations)\n        self.bw = 0.01 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.2 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "FusionQuantumHarmonySearch", "description": "Fusion Quantum Harmony Search with adaptive momentum and elite intensification for enhanced convergence in black box optimization.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7087676438708763, 0.7148805512114436, 0.7698493312696199, 0.7398878182042475, 0.7370095004688019, 0.759846977705699, 0.7368987240433668, 0.8066057415009791, 0.7713460197141013, 0.3639125175334148, 0.3960486072707283, 0.31464608432033314, 0.3526389459998396, 0.3745058511481354, 0.36081048567588403, 0.381516298476288, 0.3838912594526107, 0.3809513921482315, 0.2385846691281216, 0.34032517127810546, 0.49742985943946905, 0.3726092923100077, 0.5005990642242233, 0.5055299190498863, 0.43568931027732705, 0.39996174185506495, 0.35404519231028697, 0.1605366814061927, 0.285954646548338, 0.3948961616225348, 0.4031910308707788, 0.1944942158140619, 0.3040809062320954, 0.402959858054622, 0.38581349500382567, 0.1793647698761779, 0.9516537543579613, 0.9468811449915528, 0.947376590694314, 0.9448153736678888, 0.9494444728495455, 0.9468361482682668, 0.9571554180055611, 0.9500204453410571, 0.9408295396611005, 0.21845446196719442, 0.24586674180070833, 0.22884574866894525, 0.1970657881240484, 0.3074289287502797, 0.3358638256273282, 0.24586767404653953, 0.17812092755572662, 0.2746159546317919, 0.24044489025664106, 0.1592895326133683, 0.1770457042650787, 0.3676789007335859, 0.28454191002341644, 0.2121885141765466, 0.16164044033505176, 0.14541648320069123, 0.1517470231261132, 0.2719870355039211, 0.16306061559028096, 0.1665361513006719, 0.15556726836779777, 0.23357601778978054, 0.14434277594701983, 0.17721469505539866, 0.2107041319933982, 0.3006287275879995, 0.1432585724141371, 0.13286152870134882, 0.20799212348772256, 0.14234736435802697, 0.12830873044214308, 0.14778196983330194, 0.13977924432400357, 0.11894833273787409, 0.14410751151892998, 0.020297264588351904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001578185761776707, 0.06760552275741594, 0.0401911702625084, 0.06923433808717416, 0.06216514568454368, 0.049020477160728326, 0.03745167050396536, 0.08692714605864837, 0.05745469809617276, 0.08239532655839343, 0.06327664179469794, 0.207517565016616, 0.14770862456539724, 0.09485328720129094, 0.15317893197352117, 0.1003532577685402, 0.14233056078114137, 0.14689122024234935, 0.0859022699476214, 0.10706370591216585, 0.13387635894659267, 0.2822317715804875, 0.1453958725183998, 0.22668353751604753, 0.14218699603210483, 0.2596782107442178, 0.10837871992533654, 0.10935890551868854, 0.49209784788094246, 0.42288234558401105, 0.5507833415939345, 0.4292642097647308, 0.4229674594487913, 0.4152417079468752, 0.42220962490500213, 0.48358265952158397, 0.4572443926371058, 0.10284755624150566, 0.15759468026375312, 0.07773849195341531, 0.09255151384264604, 0.1235546183092674, 0.10568363817113291, 0.13663183918470279, 0.08926901349857674, 0.09662288114208772, 0.19096263264605062, 0.1592135375501852, 0.21580343335164265, 0.2284393730527281, 0.2295427081788991, 0.19453269607587043, 0.17183085578208213, 0.17359538967954335, 0.21476858724388426, 0.2303847581341253, 0.25316764737444997, 0.25524335262029274, 0.25276842699987645, 0.28335630834312076, 0.22381642968002047, 0.38643255612998884, 0.29683215623782755, 0.24262382007645578, 0.20810239757426585, 0.1485017347332609, 0.18810882692429032, 0.20406286967658804, 0.2129247604524156, 0.21108473880570056, 0.1389139794939096, 0.22183333667151872, 0.2151935518339022, 0.20551834149782422, 0.20518310709279974, 0.2600263080764972, 0.1987331946472113, 0.18836080538813793, 0.18823769901559784, 0.22842888175032305, 0.263256619498186, 0.21972536518908714, 0.21855520293544817, 0.22298422919319005, 0.19263697492023157, 0.23708146307719613, 0.21953983092437224, 0.2312463337292342, 0.1980234610413446, 0.23720337476788544, 0.20208240047466441, 0.5416831447679815, 0.5353021449545673, 0.428610680037389, 0.2004348473165103, 0.512964241036483, 0.6916448285385306, 0.24899697943832266, 0.1688292219690959, 0.1663816354695017, 0.15083477776096732, 0.17097718085379132, 0.3770500392808144, 0.20944455866203293, 0.1679443800272966, 0.20839554998526888, 0.16607983374111357, 0.23070872026241618, 0.14111364479901678, 0.18367599398568146, 0.192326521431895, 0.1846243205985052, 0.19377120723315988, 0.18107943251181924, 0.1901522950301371, 0.19512274783128547, 0.20519784154857024, 0.17866291521877808, 0.0924677651818836, 0.08363516546397609, 0.09102070918290628, 0.07333448733710246, 0.10972327101262669, 0.07585358192525782, 0.08149290863083991, 0.07959406404797442, 0.08419062787593723]}, "mutation_prompt": null}
{"id": "6116bc37-ecb6-4e4b-b2a8-a2848ed0f29b", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Adjusted for balance\n        self.par = 0.25  # Reduced slightly for diversity\n        self.bw = 0.015  # Slightly increased for balance\n        self.mutation_prob = 0.12  # Increased for exploration\n        self.elite_fraction = 0.25  # Adjusted for balance\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Modified for balance\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.3 * (iteration / max_iterations)\n        self.par = 0.25 + 0.1 * (iteration / max_iterations)\n        self.bw = 0.015 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.2 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.15 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumInspiredAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with dynamic diversity control and elite-guided convergence for robust black box optimization.", "configspace": "", "generation": 22, "fitness": 0.2637281071614492, "feedback": "The algorithm QuantumInspiredAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.6908817162468008, 0.6873443153834116, 0.7107754669709226, 0.7323830533645049, 0.6620215412730708, 0.7040256091578303, 0.6811997621068193, 0.6895646263065358, 0.6888883650519475, 0.3297229076896214, 0.33769001738001814, 0.35185430517155514, 0.32253489827217086, 0.33726798911237055, 0.33203551602970327, 0.3263208242009019, 0.3403841637521128, 0.35779757279078517, 0.43750012117254433, 0.423386320007616, 0.434457786347635, 0.3762197492831725, 0.4222852820937093, 0.46057254918218327, 0.3813958858143811, 0.4487394272858003, 0.40982428265988424, 0.36966950621142947, 0.333173597798913, 0.22240026713658445, 0.3672720494576216, 0.32991562805538766, 0.3427310633065256, 0.1913473546875264, 0.18203707094776533, 0.3300568874535281, 0.95264951586148, 0.9297183441081114, 0.9298624099632404, 0.9265594172402245, 0.910109478913672, 0.9392466832548763, 0.9441052985212242, 0.9298609333888845, 0.9491116305180424, 0.1946985883174096, 0.18191497698976677, 0.21756239729303184, 0.24609282072095895, 0.21592326210203527, 0.32844486227124203, 0.20318021299316225, 0.18551477858325793, 0.21205995991926951, 0.20676116541728684, 0.2076892741792754, 0.16849324469074367, 0.21373822768823714, 0.36280343108254776, 0.270712260717184, 0.20334741121228894, 0.2455940158403601, 0.2981569657228731, 0.16556046994567153, 0.19156614481631573, 0.17813832534561602, 0.1568623204428028, 0.18777692384972156, 0.23997284325944612, 0.2809220123818018, 0.2408194644553373, 0.14067757767594957, 0.1342411259635372, 0.15458929356986828, 0.1401889793791783, 0.1359376158334359, 0.15407315231497865, 0.13701647408448536, 0.1566188801371351, 0.13674481836747088, 0.1357894797471395, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002466615419506213, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053788198710247315, 0.054258108219267354, 0.10972247005971947, 0.0734052026955273, 0.08053131510703493, 0.047560680259664534, 0.11387116683467957, 0.09696487163058787, 0.047746820805766754, 0.053545988337011075, 0.09304148293403103, 0.12305210938350208, 0.10780374065534581, 0.07052419503359975, 0.07892435659971198, 0.15628015281109653, 0.14287374579617496, 0.06990169297489923, 0.07988425892531414, 0.11604131052753386, 0.05363733918980307, 0.06619848948644158, 0.18353662884873034, 0.11168015204505355, 0.0805707388707333, 0.15895222901139827, 0.07961991224891496, 0.4868965282599119, 0.41256404935492197, 0.5298547266303905, 0.41200752686735664, 0.41974116936588757, 0.44405229224162845, 0.4277029621577665, 0.4577693036356818, 0.39437297663297566, 0.1616070739451274, 0.1690711279222784, 0.1469738090648567, 0.07895147387300783, 0.07731933481046094, 0.11905251053056543, 0.10040467421604227, 0.10411482044408094, 0.09966564761948882, 0.16040294938194166, 0.21043968052630524, 0.14112956248596642, 0.13556710831778984, 0.13075364773652232, 0.12020153996076677, 0.1614158588518465, 0.16753167100887822, 0.1900847526281565, 0.26038986386804297, 0.3108801922422304, 0.3212279085245694, 0.2945102960326672, 0.2620800634946657, 0.25508646664944445, 0.291237688120188, 0.3267108577295489, 0.260589724265997, 0.22894109530735418, 0.24727365203494378, 0.175887114164736, 0.15728945675905903, 0.23641900250653258, 0.24278404271792486, 0.24207728283341057, 0.3044240175972168, 0.1651588914063732, 0.2038515963833325, 0.20724734321116944, 0.21385504788134313, 0.2281826016483034, 0.19063979617324545, 0.21262717414837118, 0.19696508082645825, 0.2193784843896952, 0.21107735676618677, 0.23325585786588532, 0.19295277600941063, 0.21174354845932797, 0.20819409645036469, 0.5169312941045343, 0.24718798892345417, 0.20890985974036025, 0.23216055218839882, 0.19501168734735752, 0.3997755454960502, 0.1864784667326097, 0.32961516073959507, 0.2621369506480441, 0.1676797145754061, 0.5609985218321427, 0.19498954919179756, 0.6544622858008611, 0.20711508214980423, 0.40904235842119596, 0.1686393396531648, 0.4240951210532977, 0.21056564169750525, 0.26281402377771534, 0.21594381856671518, 0.1686786213661644, 0.42401928027075386, 0.19624905426911432, 0.19975465603532871, 0.17868925230100463, 0.18866641986268018, 0.19644646055733106, 0.19858666814443882, 0.17908715353389493, 0.196488415211858, 0.17722245734590703, 0.1827088920725155, 0.08379856925026308, 0.08464679131940889, 0.08717749690490295, 0.095381899507187, 0.07532195685358567, 0.0846899980951612, 0.08057091541262884, 0.07764993796051589, 0.08802721135460301]}, "mutation_prompt": null}
{"id": "f2c8dc1e-38db-490d-a7b9-752c32b45d84", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.9  # Memory consideration rate\n        self.par = 0.3\n        self.bw = 0.01  # Bandwidth for local search\n        self.mutation_prob = 0.2  # Increased mutation probability for exploration\n        self.elite_fraction = 0.4  # Increased elite fraction for robust convergence\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.dynamic_diversity_control = True  # Dynamic diversity control\n        self.momentum_factor = 0.8  # Adjusted momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.5 * (iteration / max_iterations)  # Reduced HMCR over time\n        self.par = 0.3 + 0.3 * (iteration / max_iterations)  # Increased pitch adjustment rate\n        self.bw = 0.01 * (1 - iteration / max_iterations)  # Bandwidth decreases over iterations\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.dynamic_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.3 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum Adaptive Harmony Search with dynamic diversity control and elite reinforcement for improved global exploration.", "configspace": "", "generation": 23, "fitness": 0.2537150093526959, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7034891337890612, 0.6810166076918842, 0.6971988006690009, 0.728256982531782, 0.685869520166378, 0.7363196892997257, 0.6845881764326109, 0.6882221289483901, 0.720587769975851, 0.2737214974808988, 0.3192763331176752, 0.2716901657229486, 0.28980159408087114, 0.3191651296492669, 0.34236025561880745, 0.315725508908675, 0.3546037472236403, 0.371277350554142, 0.21259493286772269, 0.36886448638330416, 0.16274950992706805, 0.18949584114523432, 0.301875645609729, 0.23665090571886627, 0.2167406730506919, 0.20255092800787722, 0.38424771344692654, 0.21147408986552962, 0.2342219000734297, 0.32497778962860135, 0.30987304876619626, 0.22862892424980275, 0.19089013199401594, 0.36412104704565296, 0.1801406877216385, 0.2659739483147713, 0.9546160854970769, 0.9559213648641828, 0.9347435514897832, 0.9553807360537081, 0.9443561923917148, 0.9428123709658349, 0.9688851762498618, 0.9591846541814172, 0.965017078367482, 0.2885045063633803, 0.2517006282292841, 0.30283898150882527, 0.20725588279354912, 0.2495953651270184, 0.2905096717176564, 0.2251315275529897, 0.261152495073496, 0.24570240062189275, 0.23171713305695918, 0.22355114921637398, 0.21114909553026118, 0.22524519665173726, 0.19092300091524272, 0.2170895168110425, 0.19032055817665094, 0.3700821155187537, 0.23349905069251287, 0.2111235361001591, 0.15499823601340013, 0.1780100140380244, 0.14352935667240285, 0.1721613244440663, 0.15316386166585272, 0.2687482821891749, 0.3449502876754935, 0.1472635940028384, 0.15210445182371735, 0.11317224698357731, 0.13726250428250986, 0.14781358992552374, 0.13105439105646233, 0.1740908377941932, 0.12993800944448763, 0.12850594286430916, 0.16772283087192863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04005030370543772, 0.06425710146936292, 0.05929104227510196, 0.06285665472835678, 0.09143828191649628, 0.04563334707609079, 0.036681237730637806, 0.09101337149393507, 0.08231171215619448, 0.061217894964611386, 0.03586205884053939, 0.03191214356367622, 0.16645001688154404, 0.0778452878700151, 0.12704071118982296, 0.12291339586981831, 0.08136612470222748, 0.13082061521484867, 0.13709310117245588, 0.13085002067060214, 0.07327392682669909, 0.18986765825222574, 0.23082952729809703, 0.058168600073421506, 0.11406732670030506, 0.18238370050588348, 0.18239054149776668, 0.09481049528740382, 0.4406741296008574, 0.4935373062720181, 0.4002097135419713, 0.45284164398084226, 0.4718201351551209, 0.4328048288428552, 0.4210086070774566, 0.46185299203687213, 0.4536957123207528, 0.10386753344026367, 0.12829812490558268, 0.1449823754372741, 0.1285338967599602, 0.10323470498664444, 0.18161372649476715, 0.09539679634447751, 0.11826583098511767, 0.11317110053474166, 0.17870878069683127, 0.19307726078422693, 0.15727013840430337, 0.1506133412873063, 0.15227630530602476, 0.16189996111168836, 0.17821537210974625, 0.21941905743974444, 0.12931674401907, 0.3504788879514975, 0.281609839313002, 0.22202201845591185, 0.3000042306916817, 0.3065169451928742, 0.27461250569406626, 0.1690631539268641, 0.3434335687795007, 0.3025454635436241, 0.3206696033879032, 0.24257792473846285, 0.12483436486792487, 0.22265012557899877, 0.21573880050741978, 0.21477260460796743, 0.16879308218108946, 0.1930924237487156, 0.1173911240308313, 0.2051862324256013, 0.23574932260898285, 0.2182970357758227, 0.23177831603296717, 0.2046079350563299, 0.2272413429736886, 0.21206706955495147, 0.20830081267643596, 0.1956161674648853, 0.224074007435781, 0.21607182690932525, 0.226621109370018, 0.19993244720136294, 0.2007132900410562, 0.21083000316051093, 0.2142381424121801, 0.21117208900579243, 0.19136402350659776, 0.486346256337163, 0.16635145722666478, 0.5547085663243803, 0.5184699068465686, 0.18670357761593448, 0.20078740798729366, 0.38731514445313653, 0.16651179804033167, 0.15004635638707353, 0.3503837795884177, 0.16770519896204805, 0.42894448443269817, 0.20487262936082828, 0.2098042324837175, 0.20952628668238005, 0.12229325885127851, 0.19821523791504214, 0.10639544409115842, 0.1783761633005141, 0.17751869455479374, 0.18381513566251495, 0.21568214777108752, 0.18814503293686646, 0.19011886891916085, 0.1918549670513653, 0.17570960557586135, 0.194541531931128, 0.09136580649575221, 0.07450077457565185, 0.07555370070564094, 0.10344023979882389, 0.10024612615999051, 0.08957058333947499, 0.09338705164245042, 0.07509576002034157, 0.0916272663885842]}, "mutation_prompt": null}
{"id": "632378de-ed23-43e6-8ec4-c97e25e249c3", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85  # Adjusted for more controlled memory consideration\n        self.par = 0.35  # Increased to enhance pitch adjustment\n        self.bw = 0.02  # Slightly increased for broader local search\n        self.mutation_prob = 0.12  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # Fewer elites for diverse exploration\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Adjusted for dynamic exploration\n        self.gradient_mimicry_rate = 0.05  # New parameter for gradient mimicry\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.35 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.02 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)\n        self.momentum_factor = 0.85 - 0.15 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def stochastic_gradient_mimicry(self, harmony, elite_harmonies):\n        gradient_estimate = np.mean(elite_harmonies, axis=0) - harmony\n        return harmony + self.gradient_mimicry_rate * gradient_estimate\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_harmony = self.stochastic_gradient_mimicry(new_harmony, elite_harmonies)\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Quantum Harmony Search with enhanced elite sharing and stochastic gradient mimicry for improved exploration and exploitation balance in black box optimization.", "configspace": "", "generation": 24, "fitness": 0.2516111861328667, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7075829200037991, 0.6894823401151435, 0.6934297058300095, 0.7079592951142896, 0.7046603018237898, 0.7009175266885255, 0.7060355037079062, 0.6902839538633293, 0.6774228896021957, 0.35079593549724697, 0.3040271418079268, 0.3596202511176648, 0.3142503311961088, 0.3336698312464511, 0.32971732053707314, 0.3208853965610303, 0.31797806042111465, 0.3238426038953247, 0.3818075311504431, 0.39972840152234834, 0.2978052652651392, 0.27810418193452846, 0.4056669002179447, 0.3359632042106683, 0.341743263375029, 0.21092463013565443, 0.2449366631154617, 0.17060743713022752, 0.33424705027222557, 0.20784060803253213, 0.15879944953281555, 0.16346999247716743, 0.34375235133600035, 0.20894214895995322, 0.19945921667474276, 0.19440616182067183, 0.8588798095508176, 0.8399436654556008, 0.8370358665780526, 0.8515672273366002, 0.8384856822682101, 0.875037707360049, 0.8453728479830875, 0.8443135951556788, 0.8495918932587129, 0.20407123287593976, 0.23056335320505272, 0.2451538228038067, 0.3295291974654788, 0.23670965656118947, 0.2808400780784499, 0.27408579810934774, 0.22198794691553747, 0.18293798062933952, 0.24003634190586276, 0.21190051926251652, 0.15491770220449075, 0.2777618960819537, 0.2729896114604079, 0.25919733667944644, 0.1777837810898576, 0.19553770314787433, 0.20641807172939497, 0.14742613725488396, 0.18389099615471027, 0.14913041023710316, 0.17434630914971438, 0.18040149639777825, 0.2816025474692432, 0.2336608703348485, 0.15033814747819085, 0.15158459792882328, 0.131828102815418, 0.1326193708588871, 0.14266958774080507, 0.1451817805399711, 0.26881566495684106, 0.14801690398395018, 0.1440685379478176, 0.13189748513419108, 0.16454682022007616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09647235103803742, 0.06870363372203414, 0.10035651367654719, 0.04717222281575073, 0.04440468481840543, 0.019338925294631548, 0.10438788711799007, 0.08482338740333328, 0.10558773936752819, 0.11099693522319598, 0.13038671439640892, 0.06445291682030607, 0.08146976404998463, 0.12030419729223663, 0.11519206014583794, 0.12112353742424076, 0.11967462247452354, 0.13172420450908773, 0.13405142292793204, 0.0843678325629893, 0.13534376480154497, 0.16055383611227902, 0.20632210979685717, 0.0651741576076823, 0.20362273150001375, 0.16249152771893438, 0.081668088003782, 0.41792167340576725, 0.45598198664679757, 0.4627346696223861, 0.4859432488526917, 0.4257292512138473, 0.5122930585605899, 0.4491760314225459, 0.4222591629353448, 0.5047206797499528, 0.1774611794331622, 0.15791096814487204, 0.07888540202277272, 0.10403836774626307, 0.12220512739288292, 0.14528010256695778, 0.1250024163374157, 0.11343533892043356, 0.1080979166667062, 0.14756562663191763, 0.13872468263079496, 0.13735269295313424, 0.372104821018181, 0.13986006954130747, 0.13295454249677785, 0.14501639863782334, 0.19854401767028473, 0.16651079087160836, 0.2682178851715321, 0.3064889884065002, 0.17669941434753322, 0.36280890123390064, 0.24311587475149776, 0.20200556502915556, 0.3317044099834501, 0.3306308266975748, 0.32424325405201804, 0.2986602126599779, 0.2293169567950748, 0.13767486417494545, 0.24094708344241567, 0.1942407624538217, 0.26106388162299843, 0.23181108071647094, 0.24767357989490546, 0.26631759792796117, 0.23096471069640356, 0.22871372298409076, 0.21897656891229944, 0.21401785971588616, 0.19896221877792886, 0.2239627540440059, 0.19973043784497124, 0.19873899121783845, 0.2034018825219983, 0.2044393019993418, 0.19526379895066226, 0.256690439379487, 0.215848459363149, 0.22680116190397093, 0.20488773221851275, 0.20578369582100686, 0.2034653528093031, 0.20234868911049542, 0.16973368703573233, 0.18864147954836397, 0.18672753054712488, 0.6049366893888803, 0.22165423307998922, 0.4646959699950891, 0.15351162220033943, 0.6181596164248802, 0.1523473024632067, 0.4548989576594271, 0.1671796873166066, 0.1815279552789728, 0.2847575252614327, 0.21289268590630872, 0.21192749133853683, 0.10607988160968107, 0.163147721110113, 0.11084548627001534, 0.18189710748506516, 0.18301668087605838, 0.1839591993964348, 0.19756605907232272, 0.1786453430107816, 0.2051367962011451, 0.1764816556122396, 0.18204156130975357, 0.18725994645771116, 0.09120884753113401, 0.08557987870502715, 0.09012938935226977, 0.08767967082216765, 0.0859938363045647, 0.08659118876096361, 0.08741738178266789, 0.08011569204033309, 0.07279167924697771]}, "mutation_prompt": null}
{"id": "a14db2cd-8eca-469f-84c8-6e6a9c908b20", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85  # Adjusted for optimal memory consideration\n        self.par = 0.35\n        self.bw = 0.005  # Further reduced for finer local exploration\n        self.mutation_prob = 0.15  # Slight increase for diversity\n        self.elite_fraction = 0.25  # Adjusted elite fraction\n        self.theta_min = -np.pi / 8\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Recalibrated adaptive momentum\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.3 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.005 * (1 - iteration / max_iterations)  # Further fine-tuning\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Adjust par for diversity\n        self.momentum_factor = 0.85 - 0.25 * (iteration / max_iterations)  # Tweaked momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.choice(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with stochastic elitism and adaptive parameter fine-tuning for robust optimization performance.", "configspace": "", "generation": 25, "fitness": 0.26793719275563804, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7167644012659157, 0.7232957024672788, 0.6972765750085179, 0.7029633489211913, 0.7687919453700324, 0.7661284630338845, 0.7277522804549494, 0.7452047323123849, 0.7382236406744507, 0.35597088013131606, 0.35689640662461997, 0.36552171316357385, 0.36448119125913503, 0.3044362311071652, 0.3477254474157566, 0.39065607278593595, 0.35052741088915185, 0.31505770278085743, 0.3480936389374506, 0.46987538385789074, 0.39481147322045107, 0.2196040184600383, 0.47507101124271567, 0.465262279989321, 0.35099837725677707, 0.3995223038735344, 0.19848037592697332, 0.1929202837777816, 0.41879807450245976, 0.3609808517789671, 0.2733066566100506, 0.2552767746480482, 0.37856840246374435, 0.21266047411274203, 0.4480691529401124, 0.22338292778099922, 0.9596925140442593, 0.9169020560776524, 0.9278062318627891, 0.942889249550195, 0.9093871165801521, 0.9258152662608768, 0.928358992253752, 0.9071835026846589, 0.918232197754381, 0.1954679222601826, 0.2101644146335242, 0.24524083433824828, 0.24231652239746782, 0.25958214508605604, 0.34204719033469333, 0.23135064065244249, 0.23396036480857285, 0.23527541477324554, 0.3012276827249416, 0.19310202580195923, 0.19461541361333656, 0.2795651084707257, 0.21204509218419165, 0.19630743145318763, 0.19981320551272952, 0.22029288924662338, 0.23416178833106027, 0.2901078180360278, 0.19486169327147873, 0.14741653521235876, 0.17409564710695646, 0.17912605382561575, 0.24864336521736308, 0.2615110196185718, 0.24732102755722885, 0.1444742510298389, 0.15252084048514336, 0.15234573913138827, 0.14664639759898512, 0.13814766913618381, 0.12944902260626734, 0.17282238300100639, 0.12438143134929613, 0.13434066712338188, 0.1325813555932298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07360946674584301, 0.08696431210153643, 0.07756824267391293, 0.058145395371368425, 0.09806123974952807, 0.029863214764299983, 0.0625983780978493, 0.07928800042037909, 0.07360680042869194, 0.10129061987569599, 0.10052000621379664, 0.18262920541133865, 0.15346494963032187, 0.20295246249521193, 0.1329723425214665, 0.18617999900143933, 0.1822246164969129, 0.06989360772354958, 0.05525687048024919, 0.06427455329928455, 0.09300371340669111, 0.23691591115874366, 0.06728027338120868, 0.08717282649219216, 0.14855666528439893, 0.18833621454529825, 0.12018004353633494, 0.3682588760901382, 0.502645839202434, 0.5115219173597816, 0.40103398267485313, 0.4459373085147703, 0.49735119428628527, 0.40185399031920566, 0.4454518177201656, 0.43860482977304704, 0.11447472735229636, 0.1441010512357972, 0.08002186956295787, 0.13350552430564444, 0.12372135695306952, 0.13285199547055004, 0.11302804705019864, 0.0976594250984284, 0.10666404091450199, 0.1946984846172224, 0.17459229712904922, 0.14105113338540376, 0.12288340138567622, 0.12367249019949489, 0.12242242142670678, 0.15874373612472514, 0.1425854045982553, 0.16355791071778858, 0.29050704248124914, 0.30711854108928194, 0.2624192326257636, 0.31740819462010983, 0.26144217097948663, 0.3428561830253124, 0.3299913868484652, 0.3526885823465823, 0.20951578343715116, 0.20536588395429745, 0.2145858787141871, 0.27286209768502145, 0.3178069356274602, 0.21615230772904204, 0.24951333528468023, 0.23435079117541613, 0.2083826491020534, 0.20327073504245075, 0.2117471758103665, 0.24438902620106318, 0.19993664534113764, 0.196155454019311, 0.24339749042419712, 0.2419796517438283, 0.21488278333498112, 0.21566244109914579, 0.24476204166425664, 0.4607126573069973, 0.2270742693690848, 0.21000597898738638, 0.22311844578766327, 0.21256035087537228, 0.214777111672537, 0.22906886548309668, 0.21847697037689195, 0.19923994199083594, 0.5952265088626096, 0.18753196768351477, 0.49087455487079246, 0.19913238374920084, 0.8619193416419413, 0.20554122573924116, 0.167019613191696, 0.7648441631880982, 0.16614141498248935, 0.16714044629894087, 0.16899130951838093, 0.1304750028467253, 0.20789760089450737, 0.16799273873364218, 0.21345468021268876, 0.2953400524831389, 0.16790331426423488, 0.16576206422239304, 0.19887247959612175, 0.19505276405401295, 0.1932692397748481, 0.20938982337674883, 0.17890840882339476, 0.19089348272138262, 0.1934524263376477, 0.17629623587111998, 0.18618655585671595, 0.09981435515453119, 0.08852244616714144, 0.0868099043651338, 0.1084049214181032, 0.07667499111647214, 0.12581638366740788, 0.09586471867383806, 0.07692451179614213, 0.09234882739226324]}, "mutation_prompt": null}
{"id": "47ef7b26-9790-4f0e-91d4-497ca9e7b8e8", "solution": "import numpy as np\n\nclass QuantumEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.85\n        self.par = 0.35\n        self.bw = 0.015\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 8\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.3 * (iteration / max_iterations)\n        self.par = 0.35 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.015 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)\n        self.momentum_factor = 0.85 - 0.15 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedHarmonySearch", "description": "Quantum-enhanced Harmony Search with adaptive mutation scaling and elite diversity for robust optimization convergence.", "configspace": "", "generation": 26, "fitness": 0.26130398844440716, "feedback": "The algorithm QuantumEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7220368689558898, 0.6965204844846967, 0.6854618686398481, 0.7433298992784043, 0.6687400284444991, 0.7042060268987593, 0.7208335467101901, 0.6908212484104826, 0.7782407827573008, 0.3186428503434535, 0.32476420187546773, 0.3500079213217365, 0.2995266699531327, 0.33243266802016613, 0.34833358493514066, 0.2946353042398384, 0.3484956037394502, 0.3503050003977757, 0.31805863148249114, 0.3907743221934695, 0.43700786428107763, 0.26728984949675205, 0.4186353769284874, 0.4027768067114934, 0.34446661432553205, 0.43573750988800775, 0.19923838440003117, 0.20669909287638988, 0.3047550873604601, 0.3968337877007039, 0.22257566969660858, 0.17177023682200976, 0.2772866017025769, 0.18360722736722146, 0.3926580443095339, 0.2047552635403006, 0.9546011925330087, 0.9525605596008211, 0.9167456123438597, 0.9508709272012255, 0.9295719570937849, 0.9412243418204485, 0.9418384842789234, 0.8899012416517809, 0.9244657169276083, 0.2634454429594989, 0.18322081706297633, 0.22089997424736663, 0.2816632331974638, 0.28088771760359244, 0.25947537449630653, 0.21538704417789567, 0.22861926578725522, 0.2299322307146262, 0.20154480996381996, 0.2145631472901529, 0.19149682398909673, 0.21365597272091685, 0.1940599476431707, 0.26633389287701537, 0.22142250555115295, 0.225933537086904, 0.23108471283896337, 0.22701630852743027, 0.15350251469277665, 0.20458143577607202, 0.21652712016968612, 0.1761527056943325, 0.2468436025813261, 0.26098640475292345, 0.20526696418350576, 0.15372373261795114, 0.15735167190178978, 0.17597457150746543, 0.14915669613951033, 0.13966094807821883, 0.1280603255455004, 0.17621183822831066, 0.13524744828799617, 0.13380435347501918, 0.13283467035219165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011739397544014984, 9.999999999998899e-05, 0.016767262827364404, 9.999999999998899e-05, 0.04883366460632754, 0.0535782206841795, 0.09292577196544027, 0.03229449876350099, 0.04170787103476925, 0.047529294403166, 0.14131451909247428, 0.0811442066392214, 0.06621038655253164, 0.16886523005404164, 0.05507985377284841, 0.15417648338505496, 0.13119168365815292, 0.18360429914506116, 0.12415758748987815, 0.10223811355002577, 0.13960047727319647, 0.0682654994788876, 0.05522759090524143, 0.07068637001845979, 0.1159567907560688, 0.08532038169674416, 0.10874847171433188, 0.0835052583796645, 0.17800910528030878, 0.12321292667240125, 0.13568930217916353, 0.4183553035372224, 0.4658298162677753, 0.4034107973413289, 0.4585771702707898, 0.4439962636418754, 0.4482655166135955, 0.45129755104319147, 0.43823822592165407, 0.45994831181846296, 0.13940978315818697, 0.14152950233892647, 0.09080118425240147, 0.10059703697046829, 0.10986893183885693, 0.1035996982755516, 0.11794616502898547, 0.10289443987716917, 0.16941726924711964, 0.25658451854640885, 0.24535716255035045, 0.18940668271506877, 0.1567592787888663, 0.13627752778736613, 0.1457943997453034, 0.2084464466488687, 0.17766758792160176, 0.2249150408845053, 0.3524394033333236, 0.2900660456531656, 0.308805211265918, 0.32698821254569976, 0.2639766734471588, 0.3025267791423357, 0.40361465727688917, 0.4239120991345152, 0.20025688534104114, 0.26599014608984917, 0.2268533546616207, 0.16530758552088387, 0.21141762399305497, 0.3083156953006283, 0.1541320339027048, 0.23579266575315838, 0.23114660046616464, 0.19729413680803287, 0.2037758632224348, 0.18588614928548564, 0.2360218895910906, 0.18912270677034138, 0.20842718420543593, 0.24418867954164813, 0.19093943966136084, 0.2032649325710626, 0.22113971767443985, 0.2122988500278138, 0.2538260710219873, 0.22649018182933645, 0.20186369024626005, 0.5394225395349592, 0.19458838104913534, 0.22963600394524397, 0.25124193906801595, 0.24811595409774623, 0.4822407475709606, 0.17166700519651112, 0.40400561150943126, 0.16914281682268506, 0.16829459959469606, 0.2074264835518118, 0.1648556446913868, 0.48794961675878035, 0.23204866867001972, 0.19266540717912817, 0.2123017894002418, 0.31444434235861596, 0.20714127856831666, 0.20703839336549323, 0.21250188752193933, 0.2804382344736537, 0.276252990925994, 0.23768838280180427, 0.19708420067598886, 0.18331595649473809, 0.19312788550833615, 0.19722850109035395, 0.1856982178139024, 0.19532498500402418, 0.18597701003100597, 0.18574581686708347, 0.18788672067009693, 0.09011581932994739, 0.08704746526875862, 0.10577202803169916, 0.09493617642040131, 0.0898939942935596, 0.09985417732023583, 0.08912263532496167, 0.07969519803964809, 0.09316743043996334]}, "mutation_prompt": null}
{"id": "7ac3cbcd-2d71-425e-ac23-d17c6625ccec", "solution": "import numpy as np\n\nclass QuantumHarmonySearchWithAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 20\n        self.hmcr = 0.95  # Increased to exploit good solutions more\n        self.par = 0.25  # Adjusted for deeper exploration\n        self.bw = 0.005  # Reduced for finer local search\n        self.mutation_prob = 0.15  # Slightly increased for more diversity\n        self.elite_fraction = 0.2  # Reduced to focus on top performers\n        self.theta_min = -np.pi / 8\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Adaptive momentum slightly higher for exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.95 - 0.4 * (iteration / max_iterations)\n        self.par = 0.25 + 0.25 * (iteration / max_iterations)\n        self.bw = 0.005 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.25 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumHarmonySearchWithAdaptation", "description": "Quantum Harmony Search with adaptive strategies for enhanced exploration and exploitation in black box optimization.", "configspace": "", "generation": 27, "fitness": 0.267838103649116, "feedback": "The algorithm QuantumHarmonySearchWithAdaptation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.8771427345804437, 0.8365351362957657, 0.8639001827249593, 0.8417339192095481, 0.8117285390728968, 0.7913192485721076, 0.7952666426767087, 0.7954194741578, 0.8285893210035942, 0.4487082958337325, 0.44856712975759894, 0.40806949341963183, 0.4353833363301227, 0.4701993074346169, 0.4418725126265325, 0.3897047470531553, 0.42784177468366236, 0.4131346293269549, 0.3655985238875281, 0.3310394927865161, 0.3813639338263771, 0.20293715963552983, 0.2747429875892823, 0.18567115175021398, 0.33606937229764444, 0.3857289272752088, 0.17866376242710835, 0.21495892762871138, 0.22414841534901164, 0.18304343576913085, 0.3846848117220918, 0.24790829709627793, 0.24562327855262245, 0.20331348965257567, 0.23257131397682562, 0.19184783312412368, 0.9391411173354721, 0.9514925072786169, 0.9505496346387932, 0.9408057327236563, 0.9436474271296169, 0.9395976567890276, 0.9479506898484942, 0.93774708431119, 0.9430500033233928, 0.2233145780728547, 0.27192131175681866, 0.25749725586840067, 0.3871842246334041, 0.17698781114375162, 0.27542405110227064, 0.24346057516732522, 0.2786178359929664, 0.26913863048436504, 0.16224954144779002, 0.21899378118796808, 0.1527570518747824, 0.2223775396754173, 0.19380191266735158, 0.2804100452900655, 0.175696696441773, 0.22231207918685103, 0.17511122582469762, 0.1456038860091774, 0.16863057319743802, 0.18767336965036296, 0.18217306164846758, 0.1823549264668296, 0.13913967545303707, 0.14393509630501755, 0.22086489451398117, 0.16761895807734617, 0.14650716905187133, 0.16486347844338556, 0.26383555741493725, 0.14033830850368745, 0.16899716142949217, 0.14061939416117641, 0.13353832663164977, 0.13371239376656907, 0.14834318404319724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005073228531780161, 9.999999999998899e-05, 0.08147822530688353, 0.10055734690084006, 0.03267152024441189, 0.06562515984416639, 0.027321374577801927, 0.00373737615971681, 0.03052550284841815, 0.06269861154946177, 0.05841781346099528, 0.045215869138637954, 0.11077969137781385, 0.05928099612216442, 0.2716508571759336, 0.07917413328674905, 0.08323553601290534, 0.2125409263571485, 0.1565753690942474, 0.2506562847910174, 0.14266827310546892, 0.14168700829565528, 0.14127329548356793, 0.14291769290214562, 0.08330269732531725, 0.03502226504160988, 0.07902549893976174, 0.150756430113957, 0.1295092714570656, 0.1117699097476772, 0.4404767244106136, 0.44789402296821446, 0.4284749598720047, 0.41516851217751094, 0.4699222996196276, 0.40015577020171755, 0.4543812567043547, 0.4065596257531393, 0.42629427385152807, 0.14564546617684104, 0.08339147070648945, 0.07620401181919956, 0.1804496146494523, 0.09413327880849154, 0.1482488277340599, 0.09079696119813485, 0.11795564611780462, 0.1078784657160402, 0.2941557774228055, 0.2707792353608982, 0.24263879104861785, 0.25991255368404276, 0.3176737985884216, 0.17811755057918655, 0.13580308348721815, 0.3859125372833232, 0.1641772792678483, 0.2950987544966368, 0.28274553108261125, 0.1584749401339508, 0.2819915076648015, 0.29187559628277493, 0.2877294024541367, 0.28206758588055936, 0.35316525972761936, 0.20120927913196274, 0.14795254253168855, 0.16556691353582298, 0.13471967977028232, 0.13207248249455295, 0.2502914760412238, 0.2076756897593054, 0.10531345164027828, 0.22315611702742544, 0.12227159432443202, 0.21139869523723553, 0.20234534833416162, 0.19385543652045123, 0.23239540595247077, 0.23028469689498365, 0.3077686185155577, 0.26055144065618574, 0.2035541389903679, 0.20218280807403022, 0.19410293737454276, 0.2000835325168655, 0.18477383093430944, 0.5655167244085587, 0.20163965520061977, 0.21890730483361132, 0.19211840832989135, 0.21465313927779972, 0.21052656242032142, 0.1877434528953531, 0.18769722451139748, 0.42573924881690905, 0.908790375205301, 0.5016866940549287, 0.7137145064183728, 0.14670128908135505, 0.20666924028543165, 0.17186091254143754, 0.4889594299704093, 0.1689588947986782, 0.11640635976435132, 0.2049826404979217, 0.16862401940613558, 0.14504532605662734, 0.1244108466714301, 0.2444131880175885, 0.0965661744994204, 0.18456496783636978, 0.1939316677114049, 0.18452044303920778, 0.19183047207661408, 0.2076825814883383, 0.19131444972563516, 0.2480576950275496, 0.18995148373242576, 0.17611138429494344, 0.07649420609371649, 0.08664555502564997, 0.07828714777752754, 0.10997505348583692, 0.10461343683100677, 0.14977945408165982, 0.09130869129992802, 0.09266770755211184, 0.10221876371178873]}, "mutation_prompt": null}
{"id": "dfe24161-8273-4363-99b4-db67b0625dcf", "solution": "import numpy as np\n\nclass SynergisticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25  # Slightly larger harmony memory size for exploration\n        self.hmcr = 0.92  # Increased memory consideration ratio\n        self.par = 0.25  # Adjusted pitch adjustment ratio\n        self.bw = 0.015  # Increased bandwidth for broader search\n        self.mutation_prob = 0.12  # Slightly increased mutation probability\n        self.elite_fraction = 0.2  # Reduced elite fraction for more diversity\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Different momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.92 - 0.4 * (iteration / max_iterations)\n        self.par = 0.25 + 0.15 * (iteration / max_iterations)\n        self.bw = 0.015 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.06 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.2 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "SynergisticHarmonySearch", "description": "Synergistic Harmony Search combining probabilistic elite selection and variable intensity quantum rotations for robust optimization.", "configspace": "", "generation": 28, "fitness": 0.27713585432504956, "feedback": "The algorithm SynergisticHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1168f999-38de-4dd6-844b-e3b1d946528f", "metadata": {"aucs": [0.7632255692586916, 0.7054491573777655, 0.7478870162092168, 0.712346776682234, 0.7222311252037024, 0.7458056926852481, 0.7148748498106494, 0.7330545004261753, 0.7458382497902476, 0.44550482151583104, 0.3212773326154671, 0.35529599015702307, 0.3475131348925048, 0.30283404697861005, 0.33177714408072034, 0.4586747596772952, 0.35725284901566634, 0.40488345068833553, 0.457270378369675, 0.4385924647594738, 0.4597477827608374, 0.37330617763416607, 0.40983078256342975, 0.4763360192537872, 0.3820716373354961, 0.4135310855201153, 0.48658748928275686, 0.38187151664247687, 0.37401064552586083, 0.4164330616119589, 0.3977710967466739, 0.46416079763344564, 0.37354846466532865, 0.40558388660281974, 0.3253831464447783, 0.250379511266546, 0.9418737778922767, 0.9434247478936187, 0.950560872443685, 0.9681071757726978, 0.9454562461627707, 0.941557825638367, 0.9462151696988047, 0.9356673361954649, 0.9500184618339456, 0.21004969376543736, 0.23586112347811505, 0.291470619975024, 0.25283961472814054, 0.31635606983549114, 0.33056346286499994, 0.27119320028169636, 0.21265765922473356, 0.28279521973348076, 0.17308504229689603, 0.2274197322482182, 0.17530179171446858, 0.27054182164489704, 0.38434029321648255, 0.259998386798419, 0.18218193855839104, 0.39061569840350907, 0.27488186087333755, 0.3433342786490766, 0.2073105670340275, 0.22846314207076124, 0.1618120527402458, 0.14239213453510058, 0.33380057788202644, 0.2990639346164923, 0.1617545820062367, 0.1459700563371492, 0.15552433226898754, 0.14452237669286128, 0.17749196692817237, 0.1375636320479534, 0.1771096922122415, 0.15223074342891918, 0.17069135869994845, 0.12862437797876924, 0.1476783331169378, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06008297516525307, 0.01722227630398887, 0.08780308422454686, 0.08406912768179742, 0.0445379400078868, 0.09597195425745375, 0.08515293884836461, 0.08169410101998897, 0.10018218882629704, 0.20617361861483574, 0.17863978812633197, 0.19977045334611598, 0.12749940392288195, 0.10484496556791345, 0.07946399649631786, 0.14834487950517905, 0.11912014118030023, 0.07262703241692847, 0.2007721511812982, 0.059651984711139416, 0.17106697059698694, 0.1312567603078576, 0.21507646806491854, 0.09101722312057359, 0.12285989780701423, 0.21663381781242774, 0.13965870913773393, 0.4161912135590964, 0.4255878850160155, 0.41810780675789816, 0.41639296995014685, 0.5272483046753297, 0.4199057533176309, 0.46902632643138553, 0.4583662511208616, 0.45709863640865256, 0.10245650984929999, 0.10072950796470159, 0.10037519789488392, 0.08582115858732564, 0.0935507163408894, 0.10765578308398038, 0.11266842234584196, 0.12758175350276157, 0.10882821020804445, 0.22532401832356086, 0.17494428114024885, 0.19339910204785626, 0.1505276156048545, 0.14027659453495434, 0.14302664586269243, 0.2307381163285921, 0.18947595163294895, 0.34974528627660195, 0.262834737980966, 0.26872335603166764, 0.2933364394490684, 0.2486371270008223, 0.23365950696486348, 0.22676968442697265, 0.22128821774066987, 0.2723086431800461, 0.3170706528924768, 0.19779069876682265, 0.25853494369988317, 0.162642037324489, 0.2918078738506873, 0.17196123709994304, 0.2269943451287444, 0.18597584554108193, 0.2233777032685602, 0.22913425490907302, 0.2221840223713687, 0.2097545285470741, 0.22004137768090837, 0.2166013271715994, 0.19038152430428212, 0.21074205890480946, 0.2030082899058775, 0.20824034301841843, 0.20637539830757157, 0.2528676297401765, 0.6379434919984183, 0.20112021732152618, 0.5552376740409801, 0.22288225189258748, 0.2160406089140371, 0.2241257662926276, 0.20235625095062937, 0.19915276026184825, 0.37695285550742696, 0.18785160179566962, 0.4851165887963196, 0.5214550752870839, 0.16972437653176986, 0.30090212946886685, 0.17276040160194484, 0.457340793561935, 0.24681324809651894, 0.14776012978423592, 0.16794773303612032, 0.34550546020385164, 0.22588535645083152, 0.22833931006434327, 0.21256366238824154, 0.11906747296286446, 0.15603242495990266, 0.10797504750114573, 0.18274009101172672, 0.17439721362933924, 0.17825726627345995, 0.19015232637643664, 0.19175053455680735, 0.1944494864121643, 0.19053897533334962, 0.1843008591624994, 0.19039580961297387, 0.09936293840364374, 0.08659616848593654, 0.08732192031406116, 0.07689112134323983, 0.09770799468297542, 0.10723756777829163, 0.08392680552517506, 0.07918422499811917, 0.0745764743061913]}, "mutation_prompt": null}
{"id": "1ac55dab-2092-422d-b6f4-c3768708b828", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9  # Slightly reduced memory consideration ratio\n        self.par = 0.3  # Increased pitch adjustment ratio\n        self.bw = 0.02  # Further increased bandwidth for wider exploration\n        self.mutation_prob = 0.15  # Further increased mutation probability\n        self.elite_fraction = 0.1  # More reduced elite fraction for enhanced diversity\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Adjusted momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.3 * (iteration / max_iterations)\n        self.par = 0.3 + 0.1 * (iteration / max_iterations)\n        self.bw = 0.02 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.3 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search utilizing elite mutation and dynamic parameter tuning for enhanced exploration and convergence.", "configspace": "", "generation": 29, "fitness": 0.26376858529961994, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "dfe24161-8273-4363-99b4-db67b0625dcf", "metadata": {"aucs": [0.7039331850436883, 0.7319400272741547, 0.7269871826421239, 0.6968450265387285, 0.720793739584352, 0.7430138111438961, 0.7059487047525984, 0.6890999612256644, 0.7136341235405917, 0.41872281100492703, 0.37007263984443717, 0.3776579875185784, 0.33277096826721486, 0.44081937992669107, 0.3689327078555432, 0.33028037678349154, 0.355442629695219, 0.35991843021886294, 0.4691553065207874, 0.4217611746713791, 0.3160967511530809, 0.3005542208439792, 0.41202730429663403, 0.3665146793303625, 0.44625526193300924, 0.39238118583487225, 0.4548276695096072, 0.23347997452114366, 0.37713998838128504, 0.29931771218618797, 0.2019813091737167, 0.26298222228446044, 0.42225808678192656, 0.17872608731786765, 0.16773262140185508, 0.4242701917458732, 0.9404648629146953, 0.9316324095280002, 0.9450453347144383, 0.9474609072685671, 0.945769769031523, 0.9549710631030822, 0.9235707791617762, 0.9533820668644509, 0.9536463927161648, 0.24639600225116753, 0.211183565766085, 0.2253578648120912, 0.30252989600891655, 0.25436315592759806, 0.38144149075739364, 0.2651689707633407, 0.23995011096612429, 0.280049983225785, 0.21244688988348237, 0.20811316685492598, 0.20242140951040988, 0.21413549191495673, 0.1936233398810544, 0.1931447179860194, 0.21493901635319435, 0.20870781581401843, 0.1691402257445923, 0.21593099748815126, 0.16765476048048078, 0.14736906257671567, 0.18049726690982293, 0.3588154304608532, 0.19439118046258275, 0.15552319657950175, 0.2209869173178065, 0.14386754837128535, 0.1440413182540753, 0.145740849502218, 0.13744378754645437, 0.1370554730803698, 0.12928263023898767, 0.19579488798576739, 0.18086492533986032, 0.13081935350738405, 0.14601005776347542, 9.999999999998899e-05, 9.999999999998899e-05, 0.13355648216968674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06931446986282119, 0.04104772859700023, 0.062108920401496626, 0.08462905023410716, 0.029607087951544098, 0.042779798418120296, 0.01247673120354853, 0.07945938015379883, 0.12224607076021998, 0.05057577035734795, 0.10946642567306808, 0.057634315558409255, 0.11978852278556096, 0.09399219982039808, 0.09481869488757733, 0.08795707854803181, 0.09163952586473656, 0.1289540800228941, 0.07228751012406409, 0.24701168159498144, 0.16299135177615243, 0.13531800143199146, 0.0798843699125038, 0.023553763154892993, 0.12487023517626039, 0.055162410109010684, 0.16150167534259274, 0.09004092591331503, 0.41842172768427754, 0.46587156932981566, 0.4171985311063259, 0.44107734706844504, 0.4106542267477532, 0.4384182152893874, 0.4166921181205936, 0.4539692806063699, 0.4553847587847556, 0.14417720237343656, 0.1040890981734296, 0.09440544206209034, 0.12188431778789965, 0.10860860386806814, 0.13480410772716966, 0.14238495396657547, 0.10557565802264157, 0.1269557949379312, 0.18118728681888274, 0.1480133657043763, 0.23970596547839784, 0.1401821662530094, 0.14336314175348763, 0.18047345169276519, 0.21212841699639062, 0.1417375609252567, 0.15628386119745774, 0.25547161036162636, 0.3912213549521595, 0.23188579502733242, 0.38855441780752287, 0.3120880532111737, 0.27793641177359796, 0.3574822493428482, 0.2907611568940418, 0.3901512126593095, 0.19518923309978387, 0.22266847644367083, 0.23308182287298695, 0.1789926261981516, 0.18979070002442866, 0.22871911838451187, 0.17656210286094642, 0.171199615584684, 0.20346338083982163, 0.20075644632884937, 0.20154246767972184, 0.22717225494557036, 0.2186240828707221, 0.24094754890437275, 0.2248830880099031, 0.212687963643158, 0.2035940827335413, 0.1896071312198272, 0.2264437829652558, 0.2293747971367852, 0.22766233075168474, 0.267091969311396, 0.21856618960060048, 0.2161968404115131, 0.220139761713666, 0.24355511204243774, 0.21849435637900738, 0.15718647863294843, 0.1844750195010625, 0.18750974469538728, 0.6905513933765043, 0.5611900449412979, 0.7245059078460747, 0.16619916316767536, 0.22383685765412487, 0.28631138597847117, 0.33467995554996666, 0.20806890074732887, 0.20936238255249695, 0.16856205072633001, 0.1681886954155536, 0.20163144988535664, 0.10704768088833716, 0.156573550346768, 0.10711471822053231, 0.1854910825600652, 0.18246953278818867, 0.18739396147143283, 0.1773596637972903, 0.18673456181630166, 0.19013318656496825, 0.19239539385204585, 0.18457830251691432, 0.18897712131773192, 0.09079081014347035, 0.07766167646162503, 0.0802304544371355, 0.0877115802670998, 0.08663315249337977, 0.10696332048563584, 0.08769955395720297, 0.08473994477122504, 0.07605198728181162]}, "mutation_prompt": null}
{"id": "a3ffcc4b-03b8-43e7-96d5-484323ad1194", "solution": "import numpy as np\n\nclass SynergisticHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Increased harmony memory size for better exploration\n        self.hmcr = 0.88  # Adjusted memory consideration ratio\n        self.par = 0.3  # Further adjusted pitch adjustment ratio\n        self.bw = 0.02  # Increased bandwidth for broader search\n        self.mutation_prob = 0.15  # Further increased mutation probability\n        self.elite_fraction = 0.15  # Slightly reduced elite fraction for more diversity\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Modified momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.88 - 0.35 * (iteration / max_iterations)\n        self.par = 0.3 + 0.1 * (iteration / max_iterations)\n        self.bw = 0.02 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.25 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "SynergisticHarmonySearch", "description": "Synergistic Harmony Search with adaptive parameter tuning and enhanced diversity control for robust optimization.", "configspace": "", "generation": 30, "fitness": 0.2552700501310244, "feedback": "The algorithm SynergisticHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "dfe24161-8273-4363-99b4-db67b0625dcf", "metadata": {"aucs": [0.6590572644032797, 0.7001510018717727, 0.6608961089565617, 0.6565846101008301, 0.6727640700541668, 0.6907449675175807, 0.677077260987188, 0.6610440845938835, 0.687540017313748, 0.3347040633633963, 0.3062389938929928, 0.3349894726905097, 0.28317851547010364, 0.3208440923324489, 0.3445460666387645, 0.3285987230143602, 0.351779356346153, 0.29187018018135424, 0.3723211155418463, 0.30208045550845186, 0.3092495531442099, 0.36943068009066815, 0.38555179353431235, 0.37472206862817614, 0.40969863259243233, 0.40304439974668005, 0.18559604496786142, 0.35092862067075403, 0.3152596506371944, 0.3339474372349994, 0.23231062400025315, 0.3057549055015961, 0.20880873494339425, 0.1946763932421991, 0.3513252855215, 0.15748100743142457, 0.9153511168191923, 0.9410303823740124, 0.9334897401358702, 0.9471890138511609, 0.9336607672761899, 0.9177480154862973, 0.9351150526141034, 0.9322364741769235, 0.9162573355609535, 0.20866253959890768, 0.25373164184097763, 0.2134933227284147, 0.26562522418707246, 0.2674353976727045, 0.29570218991043073, 0.26832550653239706, 0.23906987941636648, 0.19736822261751863, 0.20160237697807093, 0.16876474482355353, 0.19409149692294225, 0.21902543077137182, 0.3576496947243265, 0.21110089629401307, 0.19632341917750684, 0.291372017805135, 0.23549775994598254, 0.1706315098004738, 0.3581399704893251, 0.18268619617732007, 0.16294236143484564, 0.2979137966903571, 0.1402579911471301, 0.1479817985708669, 0.18676284563721512, 0.17952131015241035, 0.15699998706481422, 0.14560278685811756, 0.16692871522035635, 0.13539139913773668, 0.3990972751567702, 0.13542720706209455, 0.12990488337924977, 0.12744225344523386, 0.13352593450901573, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05849790631978469, 0.045356721777958575, 0.0721528016731352, 0.0622229110144894, 0.030780392045071547, 0.03870735787356139, 0.039375325613491774, 0.04904098070277063, 0.07118475784051281, 0.09407227735056845, 0.07047236049007466, 0.11073290875620967, 0.11252147114357613, 0.06441064338243874, 0.09984814435796852, 0.08697306193088095, 0.10749771012012788, 0.06945686679061058, 0.10182093198720721, 0.04605108751515252, 0.1487212997029712, 0.23196344626981613, 0.14079814795232737, 0.09340743737650481, 0.19305259057101853, 0.2003772268010423, 0.1217938681192059, 0.3850719060082213, 0.4175414243634794, 0.4278636269307875, 0.4623774173500511, 0.41789557723469717, 0.43072800549417667, 0.4040180102330956, 0.47194933402451056, 0.4139878062286727, 0.11534747066996809, 0.11359794244361587, 0.09159015957050165, 0.13471691272391295, 0.10033807609087675, 0.1059940694854331, 0.10123099823494996, 0.10701848693115112, 0.12141728814583908, 0.23030081790056545, 0.1779216981876518, 0.1504744245214501, 0.1421481230068159, 0.15438097261000217, 0.1494447681867478, 0.13440423315555816, 0.13453309066862407, 0.13321586322566126, 0.3130352806688601, 0.2915512143923342, 0.21996192875232723, 0.2363304325908776, 0.2105981058592924, 0.2664989522777448, 0.31535331053155924, 0.3187031039343554, 0.3690308103985661, 0.18260590114570918, 0.2714084404262733, 0.13556687388482913, 0.211557683774651, 0.1928964039450224, 0.19958751454435086, 0.20042465463434078, 0.2419317643949278, 0.29667459815905894, 0.19997836601863062, 0.24081354314251247, 0.20523701859879917, 0.2361449834729693, 0.20924898007846848, 0.22143659449641884, 0.22004246569485075, 0.20268127632764976, 0.2087785293344777, 0.21242943894863853, 0.19613159058476737, 0.22474300413838533, 0.2082741480061846, 0.510571114152351, 0.19615025242350004, 0.22290184367773613, 0.19766410763688913, 0.21201965510182375, 0.1860714772697546, 0.5774520488834624, 0.182292049815572, 0.5378758710538468, 0.19631461904591074, 0.7013163262898308, 0.1790047547577942, 0.16915030866787406, 0.1618999021344103, 0.20451711331977618, 0.21167900999602152, 0.1669505950031045, 0.1639232139750031, 0.2108990075548587, 0.21089133101056246, 0.13324909992504363, 0.4222525202414198, 0.19801621506406852, 0.18726572586317858, 0.19483703496762617, 0.1751625224447969, 0.1848154965286286, 0.18854249282766777, 0.1742806209130613, 0.1879621064755782, 0.1907086386938801, 0.1956947626765877, 0.07639093423069554, 0.08043024377291907, 0.0750464950351496, 0.08701502930355254, 0.0781410654356185, 0.07956353420951512, 0.08649190911689253, 0.07501759440316547, 0.07767199729603547]}, "mutation_prompt": null}
{"id": "9f32eaf3-693a-43c3-8312-5325e70001c5", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Increased harmony memory size for more robust exploration\n        self.hmcr = 0.85  # Decreased memory consideration ratio for less exploitation\n        self.par = 0.30  # Increased pitch adjustment ratio for broader local search\n        self.bw = 0.020  # Increased bandwidth for enhanced exploration\n        self.mutation_prob = 0.10  # Lower mutation probability for stability\n        self.elite_fraction = 0.3  # Increased elite fraction for guided search\n        self.theta_min = -np.pi / 3\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.90  # Higher momentum factor for sustained exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.1 * (iteration / max_iterations)\n        self.par = 0.30 - 0.1 * (iteration / max_iterations)\n        self.bw = 0.020 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.10 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.90 - 0.2 * (iteration / max_iterations)  # Adaptive momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with momentum-based diversity and strategic parameter tuning for improved global exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.2802409625260113, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "dfe24161-8273-4363-99b4-db67b0625dcf", "metadata": {"aucs": [0.7616034250263917, 0.7739787754594566, 0.7894963831883399, 0.7611769174887918, 0.7694918674902731, 0.7648779574433214, 0.7068440585597768, 0.7600934154896481, 0.7408936278074469, 0.3812505192828113, 0.3654205984498311, 0.3607197989955968, 0.38724963675877466, 0.38000535424181503, 0.4085453865120017, 0.34998296611724045, 0.3907519416922546, 0.3592875580122472, 0.5055293837963701, 0.5139686364786771, 0.48401559671591887, 0.4843425470255398, 0.5079234786543444, 0.5054708972745716, 0.4710286296637881, 0.5197583598495519, 0.45823039189130255, 0.4058114119137951, 0.3890236213107443, 0.4490922442909393, 0.46895098693262705, 0.45643055557194834, 0.4309009906005198, 0.4673972285341683, 0.370169704807485, 0.35994780746819843, 0.9266483116259175, 0.9334851925017243, 0.9144414546608747, 0.9465535619939864, 0.9209525650963022, 0.9540903985519177, 0.9369403128083532, 0.9289000508820386, 0.9313021728874804, 0.26789703657823694, 0.3677535897938712, 0.33105240422639404, 0.4553486113099897, 0.277171366511215, 0.388096821061935, 0.25738209384775124, 0.2135828180740742, 0.20683823163979687, 0.17662553475661735, 0.17080459831842632, 0.21376942776628216, 0.2728725437352336, 0.3089949063896291, 0.21441663026213864, 0.16392594633502666, 0.3545126018426532, 0.23083489407215108, 0.16349840989368625, 0.13174456723091754, 0.17922975680795594, 0.1366968161494404, 0.2957640677483774, 0.13964202500542577, 0.31859373120684786, 0.1494336212693146, 0.13505015602486914, 0.15492693788659706, 0.14125609641183978, 0.14518074562974126, 0.15035552623198722, 0.14766067908881308, 0.16033375240164982, 0.1507511253416154, 0.14480138290443378, 0.1725664319505018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01080458905232895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047524349990864745, 0.05465643902612538, 0.07167362513148856, 0.0820078654638643, 0.023099412979297962, 0.07927738809934248, 0.09186981523666293, 0.08665325479523012, 0.10254141758923796, 0.09637954361891865, 0.21034376105248165, 0.09251583344317083, 0.08599061914096351, 0.06630896771017902, 0.09582216277838229, 0.1465130837056582, 0.1441832028271105, 0.12056785003631465, 0.1559766321044186, 0.13651287280238267, 0.14903843887127766, 0.035150329188581186, 0.1147128685795118, 0.0545870165663257, 0.24634827099760837, 0.12696497791863115, 0.25936968632467505, 0.4693345195411561, 0.5038346613718663, 0.39900207997642345, 0.48626545268506116, 0.4487999032625385, 0.5108174403738358, 0.43761175343298897, 0.4139083377806976, 0.42617628686237563, 0.1509108995361057, 0.16067058820259628, 0.12078200481040946, 0.11240401569257463, 0.10055549928846053, 0.12092627773232378, 0.11960328084992577, 0.11152387289443955, 0.12201521976213259, 0.20740160009243613, 0.16968380767357483, 0.16627044283955128, 0.14576219426279147, 0.14593590343280016, 0.15760290236513452, 0.17221018415029754, 0.15881233485376434, 0.12472840456438439, 0.24410360050047164, 0.22850909435463895, 0.2591634586617533, 0.3531414781386024, 0.21575308573704632, 0.24973730137245764, 0.2783420573474181, 0.3643533183533192, 0.40368810120770526, 0.1873294766485637, 0.20502594826756793, 0.2000360868440343, 0.17660872835866304, 0.22530200196119532, 0.2467484080106216, 0.2636687877967844, 0.24542769146921162, 0.20342497621280686, 0.2070134024877318, 0.22188731726526545, 0.23147583864867594, 0.21742545379168876, 0.2623333897497794, 0.19752185948789291, 0.18812444961988184, 0.21508200218275264, 0.21816665603884644, 0.2324764456692867, 0.18946349152587427, 0.21579759533143084, 0.21898934930565417, 0.2251513241250378, 0.20322498802905176, 0.22390150866406922, 0.1865279697765082, 0.20645445111160543, 0.45623415803316236, 0.7118242891355941, 0.18609321111356925, 0.6609377217315057, 0.6163544912472176, 0.19959172912968293, 0.14993189374137927, 0.1680400334325164, 0.16559564153829143, 0.36379492451486517, 0.16836126188333567, 0.30447003864671296, 0.12723216541079474, 0.1645641409633487, 0.20264804213601995, 0.10406226870018176, 0.2067450642789943, 0.20223113152789463, 0.18308713046083613, 0.1910084895751224, 0.18807971360464948, 0.21629156369536007, 0.20342402214088173, 0.18589434128394433, 0.17980342370626456, 0.1746085100873277, 0.20253951298619954, 0.0959504132567448, 0.0864752417708029, 0.10154047540027678, 0.08072786883245986, 0.10887458985263587, 0.10530242944657331, 0.09691621725133193, 0.08142619197281598, 0.08591775824302172]}, "mutation_prompt": null}
{"id": "677005ec-e8d0-4625-9a4b-7489bc112644", "solution": "import numpy as np\n\nclass QuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.85\n        self.par = 0.30\n        self.bw = 0.020\n        self.mutation_prob = 0.10\n        self.elite_fraction = 0.3\n        self.theta_min = -np.pi / 3\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.92  # Slightly increased momentum for exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.05 * (iteration / max_iterations)  # Slower hmcr increment\n        self.par = 0.30 - 0.05 * (iteration / max_iterations)  # Slower par decrement\n        self.bw = 0.020 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.02 * (0.10 - diversity)\n        self.momentum_factor = 0.92 - 0.15 * (iteration / max_iterations)  # Adjusted momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumHarmonySearch", "description": "Quantum Harmony Search with dynamic adaptive control and diversity-driven elite modifications for balanced exploration and exploitation.", "configspace": "", "generation": 32, "fitness": 0.2756584943144643, "feedback": "The algorithm QuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "9f32eaf3-693a-43c3-8312-5325e70001c5", "metadata": {"aucs": [0.7794909931391799, 0.7618122664052642, 0.7406071700414574, 0.7142283773541565, 0.7745043363626237, 0.7335922671216872, 0.740643611127897, 0.7589111035124947, 0.7467567196669531, 0.38298046262335106, 0.35473077058886027, 0.42812422743061684, 0.3827993059157916, 0.38261304710174016, 0.381353709520455, 0.35805219723877724, 0.335972781798792, 0.3968173846409405, 0.4769131856079578, 0.4837420653730108, 0.45004243929950827, 0.45238070776732087, 0.5126961071785296, 0.47800713032518605, 0.4781551761779087, 0.47770882669343906, 0.4744006714675868, 0.3519344370379458, 0.3754737203891093, 0.39006815604562717, 0.4464506125258745, 0.40081574643192364, 0.47448923429022716, 0.41142188645504496, 0.18507342866498788, 0.4278508679580093, 0.930054119177233, 0.9370144269575829, 0.9150243390588573, 0.9314276980659525, 0.9330658669564739, 0.9276197612958506, 0.9300118885726637, 0.9203604173541224, 0.9410717541194752, 0.29355520834829907, 0.2529031471473039, 0.2109893857776246, 0.3588365525821161, 0.38082103539383105, 0.30825865116498485, 0.18570005013151814, 0.19718713638355023, 0.19714898719979324, 0.20186326127611642, 0.28940415473642345, 0.15018069247480903, 0.27792503512017486, 0.2699033753332597, 0.32638618785032736, 0.23068861509018612, 0.23531815095405584, 0.23250570981561813, 0.19772766796849806, 0.1836546446832048, 0.16877834706356332, 0.13846256569150794, 0.16292257434971613, 0.1809405506913856, 0.29689755229912396, 0.15202070022610192, 0.15445517900782602, 0.15100225165450232, 0.13417345753228516, 0.14169547850583475, 0.140979302963551, 0.12690454721115896, 0.1381168117234034, 0.16027226986309928, 0.13397045660348594, 0.13643755709251304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012734534168533873, 0.04259885759993198, 0.07884865980886058, 0.0731533155354589, 0.03700180878201076, 0.03988307524317425, 0.01659152179820189, 0.08165106166684422, 0.10530497220964075, 0.0929264476786631, 0.06927598436339666, 0.21870920027173624, 0.060875604961202257, 0.07308810432318946, 0.07481961138576476, 0.08239311259916449, 0.10763064496273578, 0.1493345790476267, 0.08408835753749921, 0.21481701126460406, 0.1219797167565464, 0.1546375867672305, 0.028815576686082256, 0.19233546515553257, 0.06729108262236261, 0.13292099046577188, 0.16289926391588583, 0.09235058071822799, 0.5600480607354202, 0.4754146340790869, 0.5351684801249939, 0.44795849656534603, 0.4464395475039945, 0.4687530266415386, 0.39913297679681814, 0.435781013893365, 0.4713294573368616, 0.12468961201521689, 0.10942628658337272, 0.10153277069306843, 0.17194656098503747, 0.09602565624793002, 0.09880926282246238, 0.06883238763720345, 0.15589512741926703, 0.1301733026702534, 0.14357542718654226, 0.14036846719945228, 0.17036461105033962, 0.16995187200628914, 0.15915333544446164, 0.14682758180610966, 0.14839732039927, 0.1887947151327083, 0.15043907014212787, 0.2702489613361603, 0.2456896400567915, 0.28497404764203005, 0.3061814630969465, 0.28822002724020657, 0.44907386529533055, 0.3362014848171069, 0.29281495248374767, 0.2960965939617509, 0.1867849414698889, 0.2418870943274921, 0.17122732891246728, 0.21330630249581972, 0.18445376286259596, 0.15796835953750465, 0.22082410361685, 0.23597211667872375, 0.3016303739374383, 0.2080374026474714, 0.2222674285270002, 0.20441157777804753, 0.2025655624943432, 0.20686043559680134, 0.24992621213126454, 0.22063771586800274, 0.19422408904687882, 0.2125349876439706, 0.21547603672020454, 0.22349843183117146, 0.22506818868957168, 0.2287779052031812, 0.4570717969755037, 0.21132070127126057, 0.22797655105284764, 0.18833934298800692, 0.18862886490133612, 0.1852403328845249, 0.18611977260583334, 0.15905917423316918, 0.5990927699129687, 0.7356703899162708, 0.7386997823490571, 0.16179341390881286, 0.1407412492601321, 0.15694722096614622, 0.405830152605146, 0.16830049799213698, 0.2903641560953164, 0.16648172916363568, 0.1872223721584917, 0.1649065096749791, 0.10458283553470626, 0.1163637755029755, 0.4574283259244859, 0.18597504719746694, 0.18545870774960382, 0.18259290872870937, 0.21015030288214442, 0.19566335052603567, 0.17626121756235957, 0.17351411864483102, 0.1869466078766887, 0.1978954903109541, 0.08818642459580484, 0.08449001413274493, 0.080804312406071, 0.0861220893432324, 0.0961155145500392, 0.08889123665978116, 0.087003142981107, 0.08378695735454056, 0.10511577243405645]}, "mutation_prompt": null}
{"id": "d40f33f9-6e81-40ff-960d-85d007951a08", "solution": "import numpy as np\n\nclass QuantumInspiredHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.80\n        self.par = 0.35\n        self.bw = 0.025\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 2\n        self.theta_max = np.pi / 2\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.80 + 0.15 * (iteration / max_iterations)\n        self.par = 0.35 - 0.05 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)\n        self.momentum_factor = 0.85 - 0.25 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumInspiredHarmonySearch", "description": "Quantum-Inspired Harmony Search with Adaptive Parameter Control and Stochastic Diversity-Driven Exploration.", "configspace": "", "generation": 33, "fitness": 0.2707376749719902, "feedback": "The algorithm QuantumInspiredHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "9f32eaf3-693a-43c3-8312-5325e70001c5", "metadata": {"aucs": [0.72550723973379, 0.6572749390558057, 0.6782226945527075, 0.6852710940180198, 0.670760798509735, 0.6731995994555717, 0.698496810350494, 0.6959182413604972, 0.7003550422320279, 0.3489917006773453, 0.3611378322682324, 0.4071801707825631, 0.3470421389991327, 0.349317077403572, 0.3892570939011567, 0.34994557653883784, 0.37241390600814517, 0.3483371456498098, 0.3781124021703417, 0.46787399251814954, 0.43971226763107085, 0.45059071797069306, 0.44658827776050103, 0.4425369048356802, 0.43999555587437944, 0.3733607865545411, 0.3894946534420184, 0.4384172097592538, 0.36309836071575163, 0.27181855273306343, 0.40583321007366036, 0.2486472885528649, 0.30257329356345075, 0.34146388866785915, 0.35095670350419894, 0.39820063276337847, 0.929307819143837, 0.8928299708760086, 0.9413773056857229, 0.9282460970129275, 0.8938756587837449, 0.9163608354042182, 0.9324890920652064, 0.9494787446627161, 0.9412969903375349, 0.21880377210312985, 0.20594651539997688, 0.21496930581878637, 0.2751830625818684, 0.21323749749302268, 0.3572205714329568, 0.20705527697437864, 0.2273447620612835, 0.2729046374559081, 0.22196203219903654, 0.33433749609698793, 0.2015239245127013, 0.27599440044873635, 0.2729117326216075, 0.27765689366645085, 0.2136329330779324, 0.38281648614854047, 0.2319301732944371, 0.22964868833491925, 0.1382614147673803, 0.14790617394584094, 0.1417899124061489, 0.2392030199753542, 0.2424040187802463, 0.14480912103159949, 0.17925946466460208, 0.404311435610889, 0.1446957209465468, 0.12489570032588815, 0.16325802215683727, 0.14051098644205684, 0.12367828831840033, 0.14530529461362007, 0.12737658154324527, 0.16044181492078058, 0.14303073848894088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002612210034249607, 9.999999999998899e-05, 0.007787005290808557, 9.999999999998899e-05, 9.999999999998899e-05, 0.05576690941316642, 0.06472632039879156, 0.09679507260886333, 0.04894348747523514, 0.04483764269562529, 0.023996893017230625, 0.10142782371832237, 0.05656855020368401, 0.06951687402067708, 0.15004882533183905, 0.0713631580572448, 0.07190061703393824, 0.08433571058630385, 0.07066629143672631, 0.09445892707927672, 0.13084227479228216, 0.16880943823949024, 0.06271518582209523, 0.22357941781095958, 0.17855858852854545, 0.07860292062495988, 0.10324133585213313, 0.07086718702777473, 0.20255473544635927, 0.1937395886668729, 0.10482960301716471, 0.09774727328866972, 0.462301560240032, 0.4269072018021569, 0.5098020303616104, 0.4359194886158193, 0.44303566731366095, 0.48608453739241964, 0.4086568655567969, 0.39389436314588633, 0.4734582186015064, 0.13869292740549022, 0.12005042362320839, 0.12732795209436576, 0.10017613007346404, 0.11646320930234, 0.10432703555175071, 0.14449832132552565, 0.12394774906740913, 0.14393476014452278, 0.17203324421527433, 0.15814513785257767, 0.1412943325606586, 0.15804914714878238, 0.15215170616193185, 0.1580591689555615, 0.19984799698675892, 0.16393742812616396, 0.12604306848427493, 0.2544699647647398, 0.24541701912115887, 0.24961735430826648, 0.37087818755474355, 0.3798747038916045, 0.30928400145621227, 0.32749730617193507, 0.30805324482859453, 0.29781415305954206, 0.20594302707069423, 0.24131031980467155, 0.16578130090682097, 0.22792722493038486, 0.2960581312579057, 0.20692819113368688, 0.22301335804281808, 0.2882700225609165, 0.21572519946950075, 0.21826260512124673, 0.2042798723698398, 0.2264098343684976, 0.20744284473973396, 0.215563347703581, 0.21665632250703848, 0.20088829194425484, 0.1950774511155594, 0.20918749430617456, 0.21525389346859625, 0.2215581272506073, 0.22437290510967967, 0.5279503334698323, 0.19575711368204862, 0.3507451492087421, 0.4674993921854289, 0.49209221684348536, 0.2219356174859124, 0.19610849866503877, 0.15972122782589215, 0.3974933468754722, 0.6220937790931043, 0.19895660215476774, 0.6514087199122025, 0.1585758484121499, 0.3835706386204569, 0.15627034878297397, 0.3645135014688158, 0.15528914053755327, 0.1789220214319659, 0.2071688610764133, 0.2095689448473248, 0.20344745824391441, 0.10376502280803057, 0.16678487565029076, 0.11104593850740074, 0.18957904581464724, 0.19072961501477048, 0.19557835338011598, 0.1743541287758812, 0.17751296402858174, 0.19222800525030415, 0.17729761041682668, 0.18035078918521807, 0.18045058237319211, 0.0897329308408753, 0.0888650252560379, 0.0828284326571227, 0.08706456472116819, 0.08398627831548788, 0.08594219576020423, 0.08356940436785121, 0.09368424403572517, 0.07747058980798249]}, "mutation_prompt": null}
{"id": "ca791d90-f879-419d-add7-d901f885fd3d", "solution": "import numpy as np\n\nclass QuantumEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Harmony memory size\n        self.hmcr = 0.85  # Memory consideration ratio\n        self.par = 0.30  # Pitch adjustment ratio\n        self.bw = 0.020  # Bandwidth\n        self.mutation_prob = 0.15  # Slightly higher mutation probability\n        self.elite_fraction = 0.25  # Adjusted elite fraction\n        self.theta_min = -np.pi / 4  # Different rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Adjusted momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.05 * (iteration / max_iterations)  # Smoother adaptation\n        self.par = 0.30 - 0.05 * (iteration / max_iterations)\n        self.bw = 0.020 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par more aggressively based on diversity\n        self.momentum_factor = 0.85 - 0.15 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedHarmonySearch", "description": "Quantum-inspired Harmony Search with dynamic parameter adaptation and enhanced diversity strategies for improved optimization across diverse landscapes.", "configspace": "", "generation": 34, "fitness": 0.2810175867562426, "feedback": "The algorithm QuantumEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "9f32eaf3-693a-43c3-8312-5325e70001c5", "metadata": {"aucs": [0.7327783364901186, 0.7208918159437163, 0.7320576815760835, 0.7316672512052131, 0.7205921488091485, 0.7447520175135139, 0.7994055713483798, 0.7143492656094725, 0.7217645591474307, 0.44155810015233554, 0.37962289095989177, 0.3773248028847036, 0.3495625598758374, 0.37219725129184067, 0.44668039715904573, 0.3764347913082956, 0.3869565080381222, 0.39572835955917196, 0.38073744400917797, 0.4421469398871609, 0.4482111265243045, 0.43519168618799, 0.46562209225845064, 0.4633347426121731, 0.46389227253972765, 0.4185502547076768, 0.4712653873320216, 0.3943040656805147, 0.4069240405831802, 0.1794920254225515, 0.32531271012676455, 0.39864230541769763, 0.3915699379169034, 0.4231896462772815, 0.41491822906396836, 0.4043493312652203, 0.93168843874482, 0.9552384816621039, 0.9116395567126658, 0.9312779444155026, 0.9355624798730553, 0.948186694024816, 0.9424072604918409, 0.9228388294557569, 0.9206876641125008, 0.2274529301643784, 0.2723286285370039, 0.2519212778594474, 0.3783489509763429, 0.4342855178583551, 0.3675200211801154, 0.24585371999532257, 0.2101028840196032, 0.26343148653835435, 0.19916413662958732, 0.1653263018452268, 0.19130335793900766, 0.769837559120048, 0.27474202655297, 0.2572210963383753, 0.27012193987913724, 0.20721537931282796, 0.24007787561214322, 0.2534955855060219, 0.14278633191728152, 0.13736168214184286, 0.141313783389848, 0.17747620459804603, 0.29041875097391034, 0.21010421400890456, 0.14466606575591578, 0.1559749055824432, 0.24486152310888543, 0.13982021473289952, 0.12947085234173905, 0.15500796686458929, 0.2217837222059088, 0.16142204023269713, 0.13936797807186818, 0.13322821721063904, 0.1590573025586235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00034523055123447666, 9.999999999998899e-05, 0.06417789052694134, 0.09005214393652528, 0.06191491812469174, 0.07151545590077601, 0.05006048077422498, 0.004084956575233445, 0.036573481851189915, 0.09489787703170971, 0.1061480068542503, 0.06910911441410428, 0.16638947249688207, 0.05522718345293487, 0.19221097678300514, 0.07039866331647571, 0.13377507119465049, 0.07216373822734568, 0.16800435392349333, 0.12117187358796966, 0.1769288535734882, 0.13443919027615525, 0.07328379420392261, 0.11120005480970596, 0.19011697482150514, 0.10510512692211016, 0.21024245621186666, 0.14812084396919634, 0.16320762209058048, 0.1074540714443698, 0.5071529359690116, 0.46913599083742363, 0.4186852116705113, 0.43360118772778156, 0.45374885202807813, 0.49260295879248517, 0.49073939396926003, 0.43456891072731474, 0.45278980384653067, 0.12176797605416811, 0.09498392106224329, 0.1496836204937264, 0.11279423799833332, 0.15699988595934988, 0.1383209777412756, 0.15034143466534367, 0.09045533837885256, 0.14387512159179727, 0.14603800451877957, 0.16045643012122113, 0.20745770525926432, 0.1503042458634467, 0.13695632653422307, 0.11738105713668934, 0.17160002626825732, 0.16614704839887984, 0.1360028222295514, 0.24237187275655836, 0.35920572823033714, 0.22857546602883194, 0.29327077171004967, 0.20725802617029532, 0.2725535591231335, 0.3502653963086455, 0.3084423475657846, 0.29191826856746617, 0.20684058944484718, 0.24274878791867394, 0.2214779649466343, 0.2427817549658231, 0.20479791906668277, 0.28050810032046336, 0.24972083961148672, 0.2950873372122649, 0.22502129713600594, 0.19198086490883137, 0.20852744606764861, 0.2219557361454274, 0.20088767857244905, 0.20825715195891437, 0.22803602219161212, 0.20466759832298775, 0.21297628422625425, 0.1977977224152928, 0.19368451173611478, 0.20981161515019398, 0.22426499732306115, 0.2315857602182444, 0.5706840474126138, 0.25238336676658524, 0.5525228826650129, 0.21951823394559822, 0.22056069360100516, 0.45029355837629137, 0.16526230496725436, 0.5266319166790004, 0.7805720844975979, 0.19772279127699632, 0.8102297690739717, 0.1658008155116435, 0.17193736802767612, 0.1569847301236197, 0.17109589927606816, 0.18458857883391566, 0.2230513239836388, 0.2094995994689386, 0.20300682653713098, 0.210479075237051, 0.10436205363466888, 0.10425010382660616, 0.10445426121088242, 0.18982037289674403, 0.18872082845241944, 0.19136880874607343, 0.1995714658475808, 0.18000329918036662, 0.20439854994713014, 0.18520160127342922, 0.1907059229749275, 0.19021741479608767, 0.08444121421041983, 0.08501258664602118, 0.0842771280639747, 0.09251513402724088, 0.07819482091188179, 0.08845035683224745, 0.08832653904063303, 0.08724340806014075, 0.08916795475750183]}, "mutation_prompt": null}
{"id": "13d03f7e-8d7e-4573-89e9-c3501cd40da6", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.9  # Adjusted memory consideration ratio for better exploration\n        self.par = 0.25  # Adjusted pitch adjustment ratio for improved balance\n        self.bw = 0.015  # Slightly reduced bandwidth for finer local search\n        self.mutation_prob = 0.2  # Increased mutation probability for enhanced exploration\n        self.elite_fraction = 0.2  # Reduced elite fraction for broader sampling\n        self.theta_min = -np.pi / 2  # Expanded rotation angle range for comprehensive exploration\n        self.theta_max = np.pi / 2\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum factor for persistent exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        if np.random.rand() < 0.1:\n            self.hmcr = 0.9 + 0.05 * (iteration / max_iterations)\n        if np.random.rand() < 0.1:\n            self.par = 0.25 - 0.05 * (iteration / max_iterations)\n        if np.random.rand() < 0.1:\n            self.bw = 0.015 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            if np.random.rand() < 0.1:\n                self.par += 0.05 * (0.15 - diversity)\n        if np.random.rand() < 0.1:\n            self.momentum_factor = 0.9 - 0.1 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with stochastic parameter tuning and enhanced diversity for robust global search.", "configspace": "", "generation": 35, "fitness": 0.2785554142224566, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7386952442746998, 0.7382376115699765, 0.7720533192269052, 0.7370907476989765, 0.7800270825026994, 0.7450349977669879, 0.7550717814726955, 0.7235989407489275, 0.7218849358146012, 0.41648271398743686, 0.3568280191236094, 0.35642582834116243, 0.3246529314109682, 0.32141986390179245, 0.3247715809505912, 0.35115567694278194, 0.3510999648608105, 0.3466103601755711, 0.4175578920375501, 0.5080224969974954, 0.45744642551791226, 0.49861730953301253, 0.4526038040018687, 0.4618096251707554, 0.46813936384511123, 0.4779210239927737, 0.46681533682017595, 0.41969461872978053, 0.40393209688608245, 0.3303365560383137, 0.48997704574825107, 0.4489852080084895, 0.4202725021085153, 0.4879465099941436, 0.40312513930044647, 0.43648880418476177, 0.9532875951863468, 0.9526743490180117, 0.9494310572720343, 0.9590691339889261, 0.9521714391340672, 0.9659849898915686, 0.9455235570915757, 0.9536307429640049, 0.964417371622681, 0.23599402858293306, 0.3063220442849237, 0.27435194107662864, 0.3787342310944528, 0.25435934261457105, 0.2261286228995204, 0.2110809153631169, 0.2101443034780356, 0.24983953145954352, 0.20299997122321434, 0.21841308185946862, 0.16628407303960124, 0.2602855674547343, 0.26477078880360716, 0.3251625063531842, 0.2275223556341952, 0.2567773099545406, 0.21964644969225955, 0.1777394135190561, 0.17280007736239955, 0.2363105305491895, 0.14848879692075934, 0.14249539946831935, 0.20203381469630088, 0.20137065997397918, 0.27569114097308733, 0.1578081430466578, 0.13017103377000927, 0.16328247493137438, 0.1647889852224238, 0.13893207242994154, 0.12375352352240443, 0.14987925636385446, 0.14073227039076808, 0.13427668938199766, 0.14177875922825167, 0.01366966144102133, 9.999999999998899e-05, 9.999999999998899e-05, 0.009552367002430562, 9.999999999998899e-05, 9.999999999998899e-05, 0.00927060119776546, 9.999999999998899e-05, 0.023409650474980448, 0.07370110117663986, 0.04332501044003634, 0.0854026101294747, 0.0561071962716565, 0.025058120385222482, 0.029688500031397225, 0.09646158335546129, 0.09969514903506405, 0.05435225388093745, 0.22938758427543804, 0.11828579721376553, 0.15781199602976326, 0.09796602661926246, 0.2156510511825862, 0.07558075538874509, 0.09196778413121798, 0.10814849371754753, 0.09594191316856227, 0.10770975740272237, 0.10191421216566465, 0.15562589083858258, 0.13149112976586386, 0.04962268928313662, 0.12294022391607362, 0.2269760778241815, 0.16094090154037255, 0.08845630480434452, 0.47627252824147503, 0.4768295442291538, 0.4047074409116048, 0.48990158753671553, 0.47069002974887075, 0.4673553066335969, 0.40890160241025475, 0.4180377880531011, 0.40990294895234336, 0.10935161510437263, 0.10948812486141646, 0.1511362467116938, 0.10931569875282598, 0.13883851490771126, 0.12116523066626539, 0.10641297701378749, 0.10186709646551206, 0.13754721555208727, 0.16819946264050722, 0.14503463819292606, 0.21420304860788297, 0.1442355183722306, 0.1641214811344266, 0.14288658465796666, 0.1767510035013352, 0.16150403966870397, 0.13235976334916044, 0.27700500184377774, 0.26064045694455995, 0.3323481692546715, 0.2891412574950101, 0.3501672415742527, 0.23561266808739822, 0.28690203753890087, 0.3436027213666082, 0.42640985703302026, 0.25866852335667734, 0.1570492622248021, 0.16953146732247026, 0.2142571450546351, 0.24565964162268472, 0.254266104240486, 0.1559563470833486, 0.3250909202719757, 0.25757475825288534, 0.22258135076870944, 0.19893261358312175, 0.2467320477021976, 0.24684449106973227, 0.20740402343068998, 0.23214344062302084, 0.22536221477320217, 0.20019246495746434, 0.22004587298261868, 0.19768312166766822, 0.5420676903476764, 0.241751941671021, 0.20974205013075908, 0.2316983226063809, 0.22554976373850022, 0.2125466483003441, 0.2063293729065031, 0.19356186232151895, 0.19446784175369825, 0.187276578496952, 0.7188216050469445, 0.6854347270808072, 0.19799795597999104, 0.45435002977106853, 0.14136705597208332, 0.15176987878548842, 0.15832862531685843, 0.3930779269256559, 0.16767543780405336, 0.21045627691689262, 0.2081231821400913, 0.16575268959834688, 0.2080112344630466, 0.10865807329376653, 0.635416479344844, 0.10400222035080042, 0.1810731960380877, 0.1771617299213707, 0.18226372662558565, 0.18232213697010724, 0.1782618804614705, 0.19237499142207948, 0.17565681930567878, 0.1785976165746319, 0.17761198512727971, 0.08160208083081943, 0.08651321214409857, 0.08355766648088159, 0.08861824462297496, 0.09146132348080138, 0.14300797858978442, 0.08375600871816569, 0.09452327476384548, 0.08576177333927082]}, "mutation_prompt": null}
{"id": "882d22a9-bce6-4e2e-b9c6-989bc665262c", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.9\n        self.par = 0.25\n        self.bw = 0.015\n        self.mutation_prob = 0.2\n        self.elite_fraction = 0.3\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.05 * (iteration / max_iterations)\n        self.par = 0.25 + 0.1 * (iteration / max_iterations)\n        self.bw = 0.015 * (1 - (iteration / max_iterations)**2)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.1 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.2 * np.sin(np.pi * iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search with enhanced elite preservation and dynamic diversity control for robust global optimization.", "configspace": "", "generation": 36, "fitness": 0.2720444379941751, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7096960636714145, 0.6925259038401133, 0.7303862483715674, 0.7448209021481299, 0.745106550490248, 0.7053915110229838, 0.776472047371772, 0.6964635559270684, 0.7528304245857883, 0.38944755571232526, 0.35995431420182344, 0.38205993180807596, 0.410814527355128, 0.3676062984708276, 0.404321247845432, 0.38657235314002414, 0.38910650187494644, 0.34277333767768114, 0.5028095480943244, 0.35739366699812913, 0.30923143104284323, 0.4386435834230611, 0.4150434289727416, 0.44097697786352397, 0.44399479664310637, 0.41250677003594194, 0.44902792202704567, 0.3800085608738183, 0.3324051891945109, 0.1867706451765907, 0.36665725569372065, 0.39965762510885583, 0.41771860701888963, 0.40219070515736954, 0.18259430165586132, 0.36512293759401815, 0.9423399055056496, 0.9379829089396908, 0.9309251877539466, 0.9081186445645211, 0.9466354245838908, 0.9226048776426597, 0.9246293110432078, 0.9538581271553727, 0.927827621178725, 0.30534933386934826, 0.2848652465606316, 0.2601559954783237, 0.39428556759877853, 0.38525082300802227, 0.29718364694881527, 0.2807326313460017, 0.25565929245548724, 0.2695230095262712, 0.2023819766269146, 0.2027094590909806, 0.16692189652500145, 0.38214319927070317, 0.2765133893120425, 0.26721914580253603, 0.3628902952787322, 0.18888819856104067, 0.23605853730163118, 0.3418888288015344, 0.137897872380787, 0.1661015945747949, 0.18099550956700816, 0.19506790195310875, 0.14338845546928147, 0.2867895436980753, 0.30659664363491823, 0.15582095371360716, 0.16379691933095963, 0.1330958741064806, 0.126673453606019, 0.12801361248643583, 0.14604445686936474, 0.12937388039630626, 0.12738782600039888, 0.13383738299207437, 0.12955845661252008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02983099997900429, 9.999999999998899e-05, 0.039501445439836025, 0.08352158700141243, 0.04480844984168164, 0.06822433091874314, 0.038504403396543596, 0.0315530296090577, 0.059845598639923225, 0.09898515448453704, 0.0747458125726409, 0.13343708688930855, 0.057648080767482845, 0.15142624457075893, 0.12300369940226086, 0.07093447000026831, 0.10297947877020219, 0.11839306383335624, 0.12122952725763225, 0.11605536211101408, 0.09692971260168248, 0.1621858273777238, 0.11891499384260173, 0.1217005353311984, 0.07831087000491077, 0.08770105365748537, 0.1872071962831997, 0.13317229120399166, 0.20734183864797473, 0.09158968071093931, 0.5526807658645749, 0.42225215735303523, 0.45992060070489493, 0.44697235485340836, 0.4808595330079508, 0.48905717149474415, 0.44524092531113313, 0.4717021248653964, 0.47094047101378034, 0.14412635252627626, 0.11421256958490744, 0.18432730642749462, 0.10590863479295243, 0.1187163050337724, 0.10864939089610559, 0.10493332774392039, 0.10929952642232998, 0.11628000747735678, 0.15696851212470897, 0.1743909049345832, 0.1350657274112116, 0.19932281712709699, 0.17726586383489773, 0.1661396583943886, 0.1671691829542562, 0.17038871865893812, 0.15634729853244023, 0.3497701371983952, 0.37944616651674323, 0.26962604291112235, 0.3149071674282421, 0.3508814636392932, 0.3417866733385959, 0.22107523815591124, 0.32258713303994424, 0.41065186839838086, 0.2336259339942658, 0.10417979718033543, 0.19121970806039146, 0.28467489266016077, 0.24637633255877267, 0.26596380297297484, 0.22894433439288897, 0.32459346391781685, 0.24433647133818803, 0.24326409639565627, 0.20695961263770413, 0.20184308805061546, 0.2102516844786967, 0.19782855749034012, 0.20893481916121193, 0.2191199461948723, 0.20276284813952317, 0.2125783493461405, 0.5674519836371301, 0.22734604979567596, 0.24322125811621964, 0.21697170364541696, 0.21083590300973454, 0.2237803962679603, 0.22530799338873175, 0.216805657417803, 0.19857323863289245, 0.18620225715394523, 0.18603963980014537, 0.5543399850895487, 0.6248453336561659, 0.19962010575069222, 0.11698385827618762, 0.16502415263036052, 0.16568959301125996, 0.16804536413207005, 0.37586302871453237, 0.1544983499748892, 0.11395870001279962, 0.20097688536662572, 0.14647554152237385, 0.21112900205775054, 0.10461794943235814, 0.10414417210193228, 0.09482371698643277, 0.19258742765459635, 0.17283299258229468, 0.19721010757273538, 0.19692607810782514, 0.18782972876385762, 0.16834355360862463, 0.1815459659868578, 0.19870265994493075, 0.19414068536791973, 0.08903325596429568, 0.09050050738950444, 0.0888606738634038, 0.10079057768660127, 0.09427691338071686, 0.1057284422812601, 0.10256914417630836, 0.08540097616319964, 0.08795138536184044]}, "mutation_prompt": null}
{"id": "32b4edb9-f3fe-4a07-b2ad-3e9a6b314af7", "solution": "import numpy as np\n\nclass QuantumDynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Harmony memory size\n        self.hmcr = 0.85  # Memory consideration ratio\n        self.par = 0.35  # Pitch adjustment ratio, slightly increased\n        self.bw = 0.025  # Bandwidth, slightly increased for exploration\n        self.mutation_prob = 0.10  # Lower mutation probability\n        self.elite_fraction = 0.20  # Reduced elite fraction\n        self.theta_min = -np.pi / 6  # Extended rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.80  # Lowered momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.10 * (iteration / max_iterations)  # Smoother adaptation\n        self.par = 0.35 - 0.08 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.10 - diversity)  # Adjust par more aggressively based on diversity\n        self.momentum_factor = 0.80 - 0.10 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumDynamicHarmonySearch", "description": "Quantum-Inspired Dynamic Harmony Search with Adaptive Parameter Tuning and Enhanced Exploration through Quantum Rotation and Strategic Diversity Control.", "configspace": "", "generation": 37, "fitness": 0.27781606037048756, "feedback": "The algorithm QuantumDynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7394138747786818, 0.7488133560870687, 0.7245520809477781, 0.7569035913819793, 0.7909208623536815, 0.75022080379904, 0.7559404325744804, 0.7508577732962796, 0.7671606985505487, 0.3770728998141156, 0.40779706259610105, 0.3833497004273375, 0.3582229025050324, 0.4083655705387116, 0.3654187287389786, 0.3707027142856214, 0.3758188965539113, 0.40036969474229067, 0.4779555315072608, 0.4815720718344897, 0.5165942599265156, 0.413115582291258, 0.48188605355839587, 0.4806711781916161, 0.33074886704810924, 0.43822120291188105, 0.47471147783301104, 0.3493934369132603, 0.36580299087883383, 0.18982037386683714, 0.382065220723934, 0.4195481109267606, 0.1864297717926091, 0.4026476317713116, 0.4174066660143372, 0.21132534799274427, 0.91539435658366, 0.9406704678967761, 0.8872691348360392, 0.9378619843524895, 0.8856439393022503, 0.9229392223375958, 0.9144490930456868, 0.8969664865566296, 0.920379308517184, 0.2563675865000219, 0.2322447906313626, 0.3376618084703803, 0.4855774867093785, 0.42185017737427055, 0.43280462108803575, 0.3110020581920153, 0.23155728145276167, 0.26589609348469134, 0.21119518030044748, 0.18980200411894632, 0.15573770095046768, 0.2659342315556975, 0.27772241510483686, 0.33012725613449834, 0.17382698551128162, 0.18130418413192517, 0.17008113898923038, 0.1267625074931471, 0.15153399975438164, 0.3217713895018707, 0.1622633800527663, 0.20378658986560427, 0.19267523581318824, 0.14217180711548294, 0.1516344076679823, 0.2291216072530965, 0.14849982268680684, 0.1315225344238552, 0.1293807488454657, 0.14143523699835914, 0.21851056032492244, 0.13388274055747573, 0.1471045488254038, 0.13634905615655568, 0.1653250819532739, 9.999999999998899e-05, 0.008649901446021846, 0.0002119298976591688, 9.999999999998899e-05, 0.0008965156048558187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055964811172065865, 0.06511540428220519, 0.09158158778989922, 0.055032323152037876, 0.05832505718629799, 0.05607704607991015, 0.10147839310275941, 0.04717623783221847, 0.06735873540092763, 0.05667673710023924, 0.05198264312105749, 0.26070438063433243, 0.0930369305841503, 0.2056288119963665, 0.12089042063751843, 0.11138542889760172, 0.1675137628457678, 0.063151820442373, 0.18538347025709512, 0.06665357458444465, 0.18970461795090054, 0.06967411320200245, 0.04297428298047512, 0.20241526776709573, 0.1517149404587873, 0.1688547219385369, 0.09312663233894658, 0.48348104754847554, 0.47989822061493037, 0.47387779055332047, 0.43956749734616096, 0.47756475270927945, 0.44658141988332045, 0.43502499252182114, 0.4385608190411212, 0.5028000628148932, 0.14847410483895362, 0.12174048237634905, 0.07662109841987563, 0.13446829759356949, 0.11567108872145104, 0.10440535585454547, 0.10936186733222653, 0.103609904046988, 0.09639422838027711, 0.16185379546572076, 0.16235016774640787, 0.16326367220287796, 0.14879655013279425, 0.18154722872174933, 0.1995151586406192, 0.20394928570511783, 0.1379477722597663, 0.15714244317837367, 0.251286317463144, 0.34972738219821675, 0.337158621072266, 0.3738041394965338, 0.2502889503302812, 0.35544223639798056, 0.22560093245101198, 0.41569103462859414, 0.314794142766166, 0.22452761778052777, 0.26754836317623165, 0.2436526877852503, 0.23139282125367155, 0.17470970024714594, 0.20103091424916553, 0.2711149464418341, 0.2683736001778748, 0.2786194364359992, 0.2387323253718202, 0.22890034874635745, 0.21024394384955003, 0.20511257753225476, 0.21745402524473378, 0.21200707548604714, 0.2071941260688207, 0.20962597106314151, 0.2086727685836397, 0.2236472429519809, 0.5017174849246495, 0.22338547112366125, 0.20914247705732447, 0.21879914502149578, 0.2228424279446103, 0.22401925451140292, 0.22708167707927718, 0.5527800179882018, 0.1864869986118034, 0.16582347735656788, 0.44738792440005093, 0.5386049120689436, 0.5997218452006863, 0.717965333030042, 0.16573862350733326, 0.14939752969785602, 0.15924168454544074, 0.3280076659147998, 0.16721571678728164, 0.23716335176505576, 0.20883151329736616, 0.20048829440126392, 0.21049275153490155, 0.1049296070141379, 0.1043175110955501, 0.10381882456673797, 0.1758783844139118, 0.20865560639876357, 0.19219780840657819, 0.20045330956372653, 0.1841713290232675, 0.1836884608565692, 0.19686752971428856, 0.2156608202525434, 0.18342624376074823, 0.0802002699966522, 0.10227756531147802, 0.08680570999659942, 0.09453567121590989, 0.09725190022782104, 0.10256697534226455, 0.09626625791713594, 0.0963836105556729, 0.08700054266617041]}, "mutation_prompt": null}
{"id": "de4bff66-e69a-4e33-b7f4-85a583d7126a", "solution": "import numpy as np\n\nclass QuantumReinforcedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Harmony memory size\n        self.hmcr = 0.85  # Memory consideration ratio\n        self.par = 0.35  # Slightly increased pitch adjustment ratio\n        self.bw = 0.025  # Increased bandwidth for exploration\n        self.mutation_prob = 0.12  # Reduced mutation probability\n        self.elite_fraction = 0.3  # Adjusted elite fraction\n        self.theta_min = -np.pi / 6  # Adjusted rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Adjusted momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.05 * (iteration / max_iterations)  # Smoother adaptation\n        self.par = 0.35 - 0.05 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.15 - diversity)  # Adjust par with finer control based on diversity\n        self.momentum_factor = 0.85 - 0.1 * (iteration / max_iterations)  # Refined momentum adjustment\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumReinforcedHarmonySearch", "description": "Quantum-inspired Harmony Search with reinforced adaptive strategies and variability control for enhanced convergence across black box landscapes.", "configspace": "", "generation": 38, "fitness": 0.27657066738875774, "feedback": "The algorithm QuantumReinforcedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7436570236986881, 0.7473314065540116, 0.7602143864913745, 0.697678740066571, 0.720742121150566, 0.7257561489331579, 0.7485490988281251, 0.757811144089521, 0.7357980639055703, 0.38957392326131624, 0.3982718963649279, 0.380959221170612, 0.3496010162323441, 0.3968082706181807, 0.3169289893084153, 0.34127133691870526, 0.40315501482148663, 0.3523382807147435, 0.4277526187640147, 0.46193851986490075, 0.4661751665460505, 0.3916606500397699, 0.47312378033445623, 0.45289549559505726, 0.3807748175677115, 0.4951127559668277, 0.2880927594902466, 0.4031015365371502, 0.38459660924569516, 0.3767488586450908, 0.40651636609059694, 0.3787546405013632, 0.20783810736105945, 0.38798042248516074, 0.18263927069522556, 0.40119682646630517, 0.9323475866684938, 0.9140925292534334, 0.9356672589622101, 0.9128974240167084, 0.9452281715426312, 0.9260609706918617, 0.917857966438672, 0.928872529164754, 0.9192506163053966, 0.45261556106789413, 0.3509524303145434, 0.42127054312878787, 0.24577070232991205, 0.2516060720538488, 0.3683330914064271, 0.2743991271162194, 0.23963359464373368, 0.25165991534686105, 0.16400147638183038, 0.2010226077791606, 0.16871190643856004, 0.21713794235118822, 0.3171552137118442, 0.3216260893101971, 0.16584805816343196, 0.22023488995291052, 0.2502736836345715, 0.3583588248753242, 0.18095685405138306, 0.1556722212617604, 0.17794822096842167, 0.15935687790735897, 0.1985717952084729, 0.18273019118445222, 0.27107363857987055, 0.1570311678469236, 0.14514128697517137, 0.1339887119137666, 0.13116513091437032, 0.13525367551953837, 0.1997780176600238, 0.15655887768524768, 0.13056204481424882, 0.1753471742481706, 0.16583791577228435, 0.004386541612633521, 0.005801623531783151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007561922396141063, 0.06196467791300597, 0.025861416143301397, 0.05338477939012942, 0.07720698754722577, 0.06057183967902002, 0.054469200724048594, 0.045828495896589994, 0.07000966964244204, 0.10816090091345143, 0.07818682809927446, 0.03501493768337427, 0.1663294293451152, 0.1951094406744237, 0.15617552525739686, 0.07242952662834756, 0.06898311996554862, 0.10276693339472132, 0.17763531853977088, 0.12527115567612457, 0.16998926450628826, 0.10856135102701137, 0.12933890940273907, 0.15613391112455388, 0.08402807001385004, 0.1873475866119455, 0.1111668302473019, 0.19511004947342703, 0.13188790122807037, 0.08034131398907252, 0.474020211625631, 0.45274337695374045, 0.46798116685728885, 0.44877671706049194, 0.4860233159229156, 0.4464749514149796, 0.4649991017294546, 0.409720164167776, 0.4624370346782314, 0.11446561462074589, 0.1058374500781365, 0.15026014746804117, 0.10645536758281993, 0.08057345612760713, 0.11129978913182426, 0.09471125610590447, 0.15526288633022944, 0.1043749863417639, 0.1631555786218145, 0.13620096065580034, 0.1485762584651622, 0.14165999973626842, 0.14925295845736086, 0.1610265274174535, 0.16359379270026275, 0.1595242273344395, 0.21067106926777956, 0.32922389781979233, 0.33475221183254456, 0.3113090501032211, 0.3856580919378795, 0.34531264016400287, 0.2730305095783445, 0.2609037535805452, 0.3202825583768383, 0.38676989286711305, 0.20634934459498366, 0.21290413274350284, 0.22031621886686903, 0.2035758418261161, 0.19364472139294053, 0.22588090118913073, 0.22500102732378335, 0.1911355517427148, 0.19431148016306676, 0.2045871293869551, 0.21359374401015374, 0.2214725223876316, 0.23919588393423752, 0.23869846530231642, 0.2032742950307932, 0.22613377739934282, 0.2144309973879287, 0.2122734676178556, 0.5437004398346849, 0.210912290363372, 0.19416712725525687, 0.21440463641605634, 0.2490433616414851, 0.21563917372251085, 0.20865630906334232, 0.2526679083469682, 0.21259294240027948, 0.1864959052680788, 0.18598229242973996, 0.18735614446099558, 0.333817847119933, 0.8202176928907939, 0.7233446466831012, 0.16139767227806912, 0.1474698568109165, 0.17583806965803506, 0.41377089893235264, 0.16950653106034186, 0.16473903270280532, 0.20928405339926626, 0.1624514608999118, 0.20995363291066704, 0.10416202159094246, 0.6052281975077121, 0.10465748570759226, 0.1717145758535329, 0.20877957898574728, 0.17045987680664332, 0.18831135739395788, 0.2033116354055744, 0.18629429096234085, 0.18424736264109365, 0.18866781562268775, 0.18157399285182407, 0.08934649673681305, 0.09957686972156676, 0.08779915397967075, 0.09619677163889628, 0.09054715894073029, 0.11333830102917597, 0.08891390007129174, 0.08935467576480571, 0.09865090562957757]}, "mutation_prompt": null}
{"id": "56523145-ffdc-4f5e-a65f-3c9f07782139", "solution": "import numpy as np\n\nclass QuantumEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Harmony memory size\n        self.hmcr = 0.85  # Memory consideration ratio\n        self.par = 0.30  # Pitch adjustment ratio\n        self.bw = 0.020  # Bandwidth\n        self.mutation_prob = 0.12  # Slightly adjusted mutation probability\n        self.elite_fraction = 0.20  # Adjusted elite fraction\n        self.theta_min = -np.pi / 6  # Wider rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.80  # Adjusted momentum factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 + 0.07 * (iteration / max_iterations)  # Smoother adaptation\n        self.par = 0.30 - 0.07 * (iteration / max_iterations)\n        self.bw = 0.020 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.12 - diversity)  # Adjust par more based on diversity\n        self.momentum_factor = 0.80 - 0.10 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedHarmonySearch", "description": "Quantum-inspired Harmony Search with adaptive parameters and robust rotation angles to enhance convergence across diverse problem landscapes.", "configspace": "", "generation": 39, "fitness": 0.26939592675821056, "feedback": "The algorithm QuantumEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7525764634749046, 0.7057685232027726, 0.75779117749783, 0.7849039297178498, 0.7639615742961527, 0.7593943102213183, 0.7936770104585636, 0.7552213068086144, 0.7705364518098646, 0.3554500853912872, 0.3938509236600052, 0.4045383671383025, 0.3896765634055156, 0.3923634611278204, 0.37267347897940695, 0.37403852365806434, 0.4139372050162452, 0.331346339332487, 0.45439785528193055, 0.38585717169493705, 0.4293523209237554, 0.47340723503967197, 0.5129359202027479, 0.4953824401716945, 0.18496904162972516, 0.4175636709000159, 0.4377824124867098, 0.460893568227178, 0.2986862026520828, 0.3047569299639742, 0.430914884016079, 0.18176655697810862, 0.40384565804483186, 0.1833166764383476, 0.17428545723408895, 0.40920077442224667, 0.9030440679802517, 0.9292491720065291, 0.9100176889491159, 0.9262002045241695, 0.9216548101702196, 0.9301739275497989, 0.9150388586832803, 0.9222330136755056, 0.9174934894355108, 0.22565233463537915, 0.22510388232693435, 0.2629716966929996, 0.33363359136835324, 0.3133970128403437, 0.28131788394990576, 0.2650137855222109, 0.22376678448823173, 0.22910297384769995, 0.20362453716694107, 0.15301342822552833, 0.2185370079905572, 0.2162557153103889, 0.20857883408782252, 0.2763841269306231, 0.2198768107472966, 0.2662509387852513, 0.15653123357393706, 0.20933790591764767, 0.1692465265148294, 0.22468030383117166, 0.18975013222921844, 0.24292763673784712, 0.13224302939638743, 0.15206314949205135, 0.14413481679299678, 0.15578842839884677, 0.18374451896626065, 0.12768163835579527, 0.12534639770874, 0.12577512761585097, 0.14368148639940415, 0.12911487256292153, 0.12528225079351285, 0.15387124456950474, 0.1459817493322242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758797322456988, 9.999999999998899e-05, 0.007797882540254597, 0.08111743052366749, 0.045351885517262436, 0.06438874066684397, 0.051035018442707414, 0.027166136273387598, 0.019088584426332655, 0.09042837777532642, 0.07661517382626426, 0.06875401277506377, 0.22696689154200256, 0.19792617824980685, 0.2223568166281923, 0.0704304499123295, 0.2253732501006782, 0.08340861504292008, 0.13181049058757743, 0.11495262138354978, 0.0820428447116337, 0.1949709142257552, 0.07230930708741601, 0.18684853686337144, 0.07923866983455574, 0.07909622151783591, 0.043734833351953384, 0.25380535720525255, 0.11167164504655125, 0.10197837171659829, 0.4183128655922762, 0.44090490078289224, 0.4119389607274425, 0.43058620665402836, 0.4538542244515036, 0.4098497937310215, 0.4562478829264832, 0.41824549490409524, 0.46495286955398807, 0.09059816122983488, 0.1393611472033044, 0.11439934280048203, 0.11528906919174353, 0.12331914269089261, 0.14565730994535753, 0.10986347048390233, 0.13960110019634853, 0.1354269148790258, 0.17775171093003028, 0.1360837709742787, 0.15224788317158322, 0.12905872236367655, 0.21485663466943505, 0.20933558971346433, 0.2154839441268931, 0.20254835147541084, 0.15040602811379888, 0.3178497171661001, 0.2459342587319714, 0.3395576001474624, 0.39617284773347505, 0.22865589286722465, 0.23985911307949814, 0.3630677108992666, 0.3981396947025796, 0.31358826574211784, 0.2191303243769933, 0.23646790271690965, 0.1980680035978326, 0.2092371938723121, 0.22039252847776436, 0.25434032940424545, 0.2600391500464273, 0.3379994562721237, 0.24827173833298577, 0.18950722880169868, 0.20289896693562148, 0.23952168458095746, 0.2008626003834827, 0.1976311087977155, 0.20946683950131895, 0.23197747999262797, 0.1977458118683918, 0.20638418884132492, 0.5954782204807874, 0.24080172762499108, 0.22612870388227946, 0.21185974692010046, 0.20244742632164958, 0.21190532752084879, 0.23010109106747745, 0.2059440238089324, 0.19587586258664103, 0.18424759839871996, 0.18684720170980995, 0.17274312257027846, 0.6651451591182782, 0.6217769473758676, 0.6021380115976194, 0.1656430718361802, 0.15474318564680212, 0.14961899614071061, 0.16696838809472925, 0.16961857777337497, 0.31578269235360734, 0.21104630478116992, 0.20764869262479102, 0.21051061566882145, 0.10420909841922799, 0.10489054638897544, 0.10455124866226484, 0.18257885082404812, 0.1770542612706909, 0.20288245384269388, 0.18444776316899625, 0.1822476468176093, 0.18094132977589916, 0.18253920834063098, 0.18478080181228695, 0.200042813763891, 0.09266333589835363, 0.10232506258255603, 0.09056683441766344, 0.09069633628184948, 0.09504251802117958, 0.07603819601355899, 0.09258844865760651, 0.09247996380187051, 0.08907008007086736]}, "mutation_prompt": null}
{"id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "solution": "import numpy as np\n\nclass DynamicQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25  # Adjusted Harmony memory size\n        self.hmcr = 0.9  # Increased memory consideration ratio\n        self.par = 0.25  # Slightly lower pitch adjustment ratio\n        self.bw = 0.025  # Increased bandwidth\n        self.mutation_prob = 0.1  # Lower mutation probability\n        self.elite_fraction = 0.3  # Increased elite fraction\n        self.theta_min = -np.pi / 6  # Expanded rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum factor\n        self.local_search_prob = 0.05 # Probability for local search\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.05 * (iteration / max_iterations)  # Reverse adaptation\n        self.par = 0.25 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.1 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "DynamicQuantumHarmonySearch", "description": "Dynamic Quantum-Inspired Harmony Search with adaptive diversity and memory update for robust optimization performance.", "configspace": "", "generation": 40, "fitness": 0.28140816959940895, "feedback": "The algorithm DynamicQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ca791d90-f879-419d-add7-d901f885fd3d", "metadata": {"aucs": [0.7664176128259089, 0.7562678150889117, 0.7603337207300533, 0.7695650088319219, 0.7336598324228583, 0.7902339143957776, 0.7571863312180052, 0.7511983479295794, 0.7591590247376081, 0.37264620642484925, 0.3275571664212522, 0.33572272927505287, 0.36343343985614407, 0.3223321655141689, 0.4100052951576827, 0.4064852163332199, 0.3894697324391042, 0.31826014203811315, 0.43947794078386904, 0.4269208031617825, 0.38314972066481634, 0.35557306973938807, 0.5411751077465089, 0.4711111540336066, 0.18083533157121567, 0.5032206023038945, 0.47130800198781353, 0.2926333704703221, 0.17628415804916386, 0.29136121770017087, 0.17384898567259877, 0.34080142623853915, 0.42574519259041343, 0.400982989429854, 0.3105809416761317, 0.34204163906982676, 0.9195144132195521, 0.9464859961414925, 0.9235100297156456, 0.9314656729946545, 0.9417898353779539, 0.9485279382996511, 0.9058391138448507, 0.9335014361672027, 0.9301342297276507, 0.32377719064080646, 0.3415397301681251, 0.24592401027488808, 0.2932157605924939, 0.45293814009982747, 0.4241621356715142, 0.2739609313265715, 0.2930626989293529, 0.36629468677630217, 0.22230820790452777, 0.16472532288640396, 0.14086822542535882, 0.2747731433851903, 0.2535035057195951, 0.19150669617817517, 0.2321393218119162, 0.19633903307138478, 0.3730128082207089, 0.18521658092731108, 0.20417427965470847, 0.23859376336742466, 0.22415465797946532, 0.3158857908353804, 0.17860998459740463, 0.15343417099953638, 0.25250279798225095, 0.3129358463515379, 0.13238668047137925, 0.13395678362406838, 0.1468296311626922, 0.13268088210181905, 0.14270478271986908, 0.15497861511408706, 0.1754660060745451, 0.12868238588664394, 0.14044555376632395, 9.999999999998899e-05, 0.03183486838330407, 9.999999999998899e-05, 0.0645777959207664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03609934268560133, 0.05804535663902277, 0.048081733975442464, 0.14607987089832963, 0.059811495242471424, 0.05444173938309449, 0.04190542029392741, 0.12372393166555962, 0.06474204568329534, 0.06529335554297377, 0.08757045446137812, 0.198372444097626, 0.17742064335164998, 0.10010716584655166, 0.07440380475282804, 0.21879777073835904, 0.17504247533133288, 0.12315952073411185, 0.06971338506441749, 0.10205000343564608, 0.07845992346632957, 0.1330701163430662, 0.16111163184603006, 0.21095342206558776, 0.10301133391812622, 0.24548133991102994, 0.14563807604172907, 0.08257860563952513, 0.5337989418466604, 0.48688871718629767, 0.4541180878286838, 0.5002531193330227, 0.5660194689268214, 0.42902762727294574, 0.4559129987263669, 0.47139403966689675, 0.4896604297340974, 0.11008807780062202, 0.09318798807913886, 0.05795327817849971, 0.11651362977162338, 0.12251990041482475, 0.13630385302375325, 0.1239859393431767, 0.12697983329652618, 0.09517661663933341, 0.2140716672081825, 0.13719290784490878, 0.21306657807259366, 0.17872624305713602, 0.18992311358558833, 0.2389646137450503, 0.18199572474498937, 0.18071871338334056, 0.15345188921967323, 0.3618528265287485, 0.2920716214591309, 0.22020986695219835, 0.2669492366567304, 0.2761955142541601, 0.24176786340149703, 0.27904671642834833, 0.3713597731768604, 0.25011555746704717, 0.14814490446362782, 0.26831445020411904, 0.2681513244494761, 0.2948304519856746, 0.2110105710953274, 0.181553755944179, 0.2757972865344518, 0.2529320189020192, 0.25987369839061447, 0.20649972902745695, 0.2090769564571553, 0.2512078299251005, 0.2020689962534039, 0.2155976263466155, 0.20278353582184816, 0.20045889017141116, 0.24871859680028552, 0.2102355045067873, 0.5607104994090544, 0.22344649093175017, 0.2526301611804067, 0.5794363263719132, 0.1909159657128774, 0.1999323525336324, 0.25580624160184096, 0.24275589565711253, 0.2163523406475949, 0.18747516088428107, 0.1889423187560787, 0.1870411275602989, 0.6968799990912378, 0.8382105332054304, 0.6972198582968285, 0.13469396443447845, 0.15771558480714742, 0.14002465326768865, 0.15508750768211432, 0.16878696280242733, 0.2114800161291155, 0.21018147198896198, 0.21109853899719144, 0.2087521103798371, 0.10353406361490869, 0.4305213244987194, 0.09437336235752558, 0.20103691807934643, 0.2009938509866548, 0.1802852040412507, 0.17631869661791066, 0.19055132822745258, 0.1799390821797946, 0.20582196515142337, 0.178427161881758, 0.2110052621456303, 0.09827870913558467, 0.0884098459538698, 0.09643353907274232, 0.10505763304374827, 0.09520908722107635, 0.14936931676937326, 0.09425079782907664, 0.0793307953729554, 0.08709766934972052]}, "mutation_prompt": null}
{"id": "12e755b2-78cc-44d3-8434-1a0a6c2a854a", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Increased Harmony memory size for more diversity\n        self.hmcr = 0.85  # Decreased memory consideration ratio to promote diversity\n        self.par = 0.3  # Increased pitch adjustment ratio\n        self.bw = 0.03  # More significant bandwidth for broader exploration\n        self.mutation_prob = 0.15  # Increased mutation probability for higher variability\n        self.elite_fraction = 0.25  # Decreased elite fraction to allow for more exploration\n        self.theta_min = -np.pi / 8  # Expanded rotation angle range for greater exploration\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Lower momentum factor for diverse search\n        self.local_search_prob = 0.1  # Increased probability for local search\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.02 * (iteration / max_iterations)  # Slightly adjusted adaptation\n        self.par = 0.3 + 0.03 * (iteration / max_iterations)\n        self.bw = 0.03 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.05 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Larger perturbation for local search\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with stochastic momentum control and dynamic exploration-exploitation balance for improved optimization.", "configspace": "", "generation": 41, "fitness": 0.26000670658789093, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.6706178774847783, 0.6697957108978536, 0.6725751695909621, 0.653962711586819, 0.6758741062809233, 0.6568422644402419, 0.6498914166454643, 0.676471749592625, 0.6897484851441373, 0.3025092203790257, 0.28028028951050854, 0.3453633662703468, 0.3433475176740324, 0.264637213391561, 0.34730239404592267, 0.35623531970094413, 0.28647256390165554, 0.2724297068623296, 0.36891851578582446, 0.37888012721780384, 0.44232767239704995, 0.27745784765797965, 0.416582868664653, 0.3416474418859632, 0.23858808143612542, 0.34711616704610315, 0.33605566648766416, 0.18829849829538603, 0.28993587239066876, 0.2806674025005266, 0.2794187861909335, 0.18602547408763426, 0.18557011966716142, 0.20813838521736805, 0.22828590193121523, 0.3068190532837374, 0.8947800904378159, 0.9017514864747485, 0.8912614710355165, 0.896288732078402, 0.8842743721137323, 0.909591058199187, 0.8860028638491241, 0.8953908852124794, 0.9277138115727736, 0.32953887509354995, 0.2030728844885149, 0.2102874545253769, 0.2867509143517587, 0.25605681262522684, 0.35007418231375353, 0.25393661634427256, 0.24689868752082644, 0.2741946264067988, 0.23488113964449953, 0.2806528799033078, 0.16629511949501286, 0.26865972669806804, 0.3398747718783588, 0.2094222778362942, 0.17019103276160363, 0.17489293841677134, 0.21975596800962072, 0.1657559425056867, 0.15934466252227908, 0.24942940970297334, 0.16160426948790518, 0.16232562297437214, 0.1877789451480606, 0.15053204101369355, 0.13420915756546725, 0.1743399531402633, 0.14168243036070272, 0.134300312280626, 0.14257742778000504, 0.1257262921672595, 0.13830382302673339, 0.13481274602764592, 0.12369865454028439, 0.16725794620248036, 0.13370533447481214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026543620954502245, 0.007592134939695239, 9.999999999998899e-05, 0.0039262635859891315, 9.999999999998899e-05, 9.999999999998899e-05, 0.05748734866152794, 0.05068631812205093, 0.13313911661266442, 0.06225726303376855, 0.027337997773217326, 0.035885572181848846, 0.08109923880501069, 0.05849923350170938, 0.04851559098586644, 0.12131571377403072, 0.053753079622442024, 0.09111530837263926, 0.06320114743133132, 0.13879745685558786, 0.12090775110805774, 0.1088121512500364, 0.10058846522682174, 0.0575979851209093, 0.14649781244730709, 0.036657915963361654, 0.10842346003387171, 0.1465703689525153, 0.0888116155233134, 0.047372140192687984, 0.2085745882779696, 0.11796879279662498, 0.13396046873851486, 0.4313473050420096, 0.44590166980587387, 0.49768985033256563, 0.434165288516983, 0.451494080556634, 0.43144693411638935, 0.5038775354767631, 0.44208189682465393, 0.41915011924786816, 0.13334348986110633, 0.13269321141022106, 0.08507658363090287, 0.10337420154874122, 0.09469652657120164, 0.14344911834339058, 0.10044658731888467, 0.11967581593176513, 0.12337446856276624, 0.1347104235469826, 0.1363880519284959, 0.1847387934664526, 0.13213340907776783, 0.15015196682976206, 0.16095002408439596, 0.2577797035611977, 0.163047871576408, 0.13071954160662502, 0.356497113821151, 0.27517374959215357, 0.2766283948239986, 0.3019740035102869, 0.3471337986035413, 0.351309235291129, 0.36775679329531086, 0.3794706230131063, 0.39116788659650725, 0.21778668087084885, 0.22442209177645622, 0.1954479777656949, 0.2577995770639089, 0.252474104235924, 0.20948438546108406, 0.19702637103120246, 0.2616518818867274, 0.2811671182810289, 0.18155235107392387, 0.18965001457299147, 0.19486609198355043, 0.22298979514393225, 0.2134804155515876, 0.20850992110647038, 0.2160604847629174, 0.19833179145667368, 0.18258702034879914, 0.22165331167172386, 0.227851939284741, 0.1992954834442654, 0.2370762950642077, 0.5241156336673246, 0.19912317385888323, 0.22544995988232475, 0.2370737009909727, 0.1882724520798592, 0.1850797187801495, 0.22853724917474239, 0.7627258902907519, 0.6476675868176873, 0.2184836492610499, 0.8606023868699111, 0.14112306948887254, 0.8576885398313868, 0.15120526579074145, 0.4248809394712155, 0.16568631960379643, 0.1471699936358174, 0.16527447514030513, 0.16598061805332942, 0.20905432880904007, 0.2444937471766261, 0.377344344292209, 0.10456072404490546, 0.19580398772544927, 0.17333750665230674, 0.1888006056060284, 0.18889086832342505, 0.1822581448704942, 0.19652907664216823, 0.17765496442492024, 0.17974045714204945, 0.18896353081870854, 0.08619267919165197, 0.07897234023575839, 0.0766658341547829, 0.08215484687401764, 0.09028660795921806, 0.08112746771380241, 0.08990784757909731, 0.08100826180569343, 0.08380437935091811]}, "mutation_prompt": null}
{"id": "80992027-e080-4bb2-a6bf-162b48fc3f5b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25  # Harmony memory size\n        self.hmcr = 0.85  # Memory consideration ratio\n        self.par = 0.3  # Pitch adjustment ratio\n        self.bw_init = 0.05  # Initial bandwidth\n        self.bw_final = 0.01  # Final bandwidth for tighter convergence\n        self.mutation_prob = 0.05  # Mutation probability\n        self.elite_fraction = 0.2  # Elite fraction\n        self.theta_min = -np.pi / 8  # Rotation angle range\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.local_search_prob = 0.1  # Local search probability\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.1 * (iteration / max_iterations)  # Dynamic adaptation\n        self.par = 0.3 + 0.1 * (iteration / max_iterations)\n        self.bw = self.bw_init + (self.bw_final - self.bw_init) * (iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)  # Adjust par based on diversity\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.05, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search with enhanced memory consideration and dynamic bandwidth tuning for improved exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.2597181760851976, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.6894711022284532, 0.6447117975376135, 0.6761399161362922, 0.6454044730022547, 0.6963815176280088, 0.6766961275911885, 0.6700873390501947, 0.6423248652969511, 0.6810393592837183, 0.3026694295553404, 0.28785381716200764, 0.25671724788750816, 0.27797239298131604, 0.38725391205952797, 0.36110715040709995, 0.29611616352111736, 0.3382968963302395, 0.40170252955972985, 0.18383716634068925, 0.26893991594865485, 0.32665180024111706, 0.26130256056649304, 0.24165628470032396, 0.3470401250705534, 0.20055415413828592, 0.3118288782619324, 0.4053117755068719, 0.1665849468661389, 0.23187793983762295, 0.3135528873090574, 0.16697197058533197, 0.31311252894069896, 0.174484390550386, 0.19981938534212018, 0.2591149539633819, 0.27404119973644747, 0.8784039606142012, 0.8721602586157019, 0.8937631998775912, 0.9005825624344765, 0.906574611431895, 0.8671549501493542, 0.8898199251821715, 0.8961693787643022, 0.8755341910483665, 0.2609228544537092, 0.23487090454294035, 0.2817217142446501, 0.28755706202861986, 0.38314211537632614, 0.3849564444490621, 0.2711529347206115, 0.24692304214261684, 0.34784051567429797, 0.15918076558551242, 0.17793955157428643, 0.2147302511088255, 0.2700256769417889, 0.31849094362557695, 0.3541946693439352, 0.157247419454985, 0.2339532540631135, 0.35083916083124744, 0.2275567967120128, 0.1632106688546976, 0.14119003873908753, 0.16364067624830514, 0.12930113514753538, 0.2434010258624849, 0.2631791556451848, 0.16590932863273278, 0.30202862338810776, 0.14441225530235446, 0.1541370916442354, 0.12843168198600963, 0.1450830091438915, 0.12650627561534422, 0.1501619705179259, 0.16965494350341692, 0.13416774600972714, 0.17037414689260455, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06178655314163228, 0.08327849607600624, 0.03769115633928721, 0.08595138028291727, 0.07095444466766987, 0.013213704596644282, 0.01813216725874245, 0.05329383116373554, 0.04733404746131542, 0.1182981353499365, 0.0850532958454947, 0.08655203914439358, 0.1346747001062999, 0.11156826905982486, 0.07858378802264576, 0.1164028476583373, 0.1666480122657371, 0.06759007710555176, 0.07634389515622264, 0.13248173672961838, 0.0641647711858665, 0.18211325227904485, 0.141680127964655, 0.036000546184708715, 0.10696951511043462, 0.09817209224454782, 0.1847915910726955, 0.11933558910936659, 0.4803530704130595, 0.45993755204733067, 0.4700468879153067, 0.46045288360533787, 0.4816852648390234, 0.4456957441064865, 0.44928245091940455, 0.5007061321042618, 0.4942972704178339, 0.12334143037466261, 0.17852258562186762, 0.08338208263610958, 0.15446497196311482, 0.08240522550162, 0.09551003383590595, 0.14931865712275083, 0.10795440348975605, 0.1484402854322765, 0.12752089977905112, 0.1838377112857642, 0.1443402520234942, 0.1752034138613635, 0.13993309657736241, 0.2566052083099287, 0.1550512282499149, 0.13859010317861087, 0.15158433980064312, 0.17713105433365384, 0.3258295423658707, 0.2422479213604054, 0.25286022316990775, 0.30478709673713655, 0.35477070783341025, 0.37874316513304995, 0.400329755662872, 0.3917918320416365, 0.12974679909052445, 0.2885453939861754, 0.21787408803499786, 0.18854312986634436, 0.2056857659569178, 0.194180712006212, 0.3218322987714958, 0.22612175686369884, 0.22078151341062469, 0.20736898492171485, 0.21969652618357582, 0.2025858195180935, 0.23489990166923858, 0.22868273957610497, 0.21367264408990028, 0.2309427223528101, 0.21503160430856194, 0.23141677695725194, 0.2109047420905822, 0.1958977364057758, 0.22449540684868952, 0.22503264974995496, 0.4766950372990061, 0.1949245128630518, 0.20129938199289354, 0.24095197855363704, 0.22124179789743137, 0.6354401141274612, 0.13097303827004636, 0.16018502247901323, 0.8341422275127908, 0.7147689671524139, 0.7438850681900842, 0.16822124978447206, 0.16800890035616178, 0.1643647134480829, 0.387631663476231, 0.1659752256267797, 0.3125780396718173, 0.16595855667604287, 0.21130719259615194, 0.14952882301219017, 0.10356938258358428, 0.24515221592272218, 0.10484458370065708, 0.18315728190221203, 0.18966904880544144, 0.1881929958130758, 0.1835164515799218, 0.18142496514116302, 0.19499799375104865, 0.18181574899405528, 0.18596826261858845, 0.20026938243160808, 0.09446330801851965, 0.08280656348334448, 0.07911314141072068, 0.09287940483330348, 0.08888335902823907, 0.11128075388557468, 0.0845081879647791, 0.08911589523577823, 0.08783354776932883]}, "mutation_prompt": null}
{"id": "4a2f74bb-8306-4dab-9fc1-1620e8bd9e78", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Slightly increased Harmony memory size\n        self.hmcr = 0.85  # Adjusted memory consideration ratio\n        self.par = 0.3  # Increased pitch adjustment ratio\n        self.bw = 0.02  # Adjusted bandwidth\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.elite_fraction = 0.25  # Adjusted elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85  # Adjusted momentum factor\n        self.local_search_prob = 0.1 # Increased probability for local search\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.05 * (iteration / max_iterations)  # Reverse adaptation\n        self.par = 0.3 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.02 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search blending adaptive parameter control with strategic memory refinement for flexible optimization.", "configspace": "", "generation": 43, "fitness": 0.25961908168941233, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.6632608975111164, 0.6597713876048171, 0.7023309359146573, 0.6668169035521264, 0.6723537573237024, 0.6496569392166269, 0.6890069373647667, 0.6517174124625681, 0.688258568280854, 0.36737900382535926, 0.3655282843235578, 0.2946563273860169, 0.35095275599608444, 0.2847931784491988, 0.3722448299887442, 0.3104687085893614, 0.32981939314987263, 0.29374945843962275, 0.43340559689369484, 0.4099636460488, 0.3212268903405143, 0.27910926884213405, 0.4028884019933363, 0.3798416412979514, 0.3688063639981779, 0.372642635818934, 0.36724715780916184, 0.33699278268565236, 0.2606057279292405, 0.18104244420103366, 0.19803327781842095, 0.1805584832742616, 0.313738909162672, 0.29054999934426473, 0.31987599989854165, 0.2866857751923185, 0.9033338842819327, 0.9087552193543548, 0.8317932585296822, 0.9041856674002676, 0.9092668086948612, 0.890838997199, 0.9242935478488343, 0.9026802519572923, 0.9368105040798657, 0.21289513538416627, 0.2546451733003644, 0.22675438819322746, 0.2846386568891064, 0.23168604407967208, 0.2653405329018771, 0.26546332752221324, 0.2301416343341981, 0.2162072968938925, 0.34204318376535425, 0.3018153516613238, 0.15541083731843486, 0.2737559332613744, 0.27035626332265916, 0.21104340136192545, 0.21214846884894312, 0.22897574833226353, 0.3552990564099261, 0.2360770147507173, 0.1863134676553323, 0.15850146864844084, 0.16244346111232244, 0.13975731588742168, 0.2771341587459816, 0.18042182962325948, 0.25800066672597655, 0.1275758194940516, 0.13486721116618972, 0.1551046057280866, 0.13685492850356462, 0.14229496070656655, 0.13665618096247978, 0.1580987732612692, 0.13978425556379825, 0.13953064044726815, 0.13078549451070043, 9.999999999998899e-05, 0.0005929221588587552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007464191710098156, 0.0737046340971318, 0.022502773450338465, 0.06705995258657349, 0.043567764297289924, 0.03284975325576489, 0.02185386218692964, 0.0572463795384216, 0.0742970521602363, 0.06673601564330789, 0.17632155883695777, 0.08496798647888248, 0.15000970979132744, 0.07220189005332722, 0.10956443040956343, 0.07949231794044131, 0.07998737721087001, 0.11659837376628346, 0.11559588973558876, 0.22877084981102702, 0.1697656421643292, 0.11383019534544148, 0.08519494928625881, 0.20295145377629653, 0.07212713486274702, 0.11922004570936184, 0.08695953221396191, 0.11631447045494747, 0.4283005990634977, 0.4509108264405889, 0.3911614767302928, 0.4750580871118556, 0.4594959890267315, 0.4278223477262406, 0.44523576781389007, 0.43969040906590207, 0.449394244744014, 0.12404047423881825, 0.11875757716772006, 0.10672166472700395, 0.1101900253511432, 0.1348947525191384, 0.1060466556147539, 0.14386824420626287, 0.1491347268088522, 0.12348056608746316, 0.13959825963249406, 0.16114917417045105, 0.14679492751330236, 0.128930345819956, 0.13791198096611734, 0.14475740562626338, 0.15113293181728782, 0.13938300306272322, 0.1668696214037535, 0.31825779333872883, 0.2943457443115127, 0.37866514788067773, 0.3009437658976146, 0.33001553947970474, 0.39665727565266484, 0.3722268279062524, 0.38880892078873286, 0.25817453608112806, 0.19506901454183156, 0.18632163084584308, 0.19149992044992603, 0.1921692745510849, 0.18655873625947883, 0.2551268497179553, 0.21344906088526006, 0.23512121786838203, 0.21660472481632775, 0.19939722773466306, 0.1856109963843987, 0.2207783960173797, 0.2030690164098975, 0.19940775222254303, 0.204672797702942, 0.19497939759331817, 0.21436016301794614, 0.2309929733502074, 0.5006597345576613, 0.20199813580438342, 0.24159095998591873, 0.20626920737880627, 0.37712129039783915, 0.22811270494444846, 0.2469058139607072, 0.21422482240680807, 0.20270898490380607, 0.1824691409477226, 0.14058727466953058, 0.5259369691768403, 0.5368190642285142, 0.606831746064937, 0.7199157456419157, 0.17110845785626005, 0.1641401503243307, 0.1635010457240984, 0.1608596969255517, 0.1655056250052015, 0.3454532002313335, 0.26594789164290245, 0.16700429219027668, 0.21049639567141043, 0.10419773986139513, 0.11100656620941607, 0.21526204209414979, 0.19766272345617264, 0.1829362710546798, 0.1823796962269334, 0.19231138263658643, 0.19491503730907755, 0.18428016238013334, 0.20655653826664566, 0.2149462036248031, 0.20402500443824734, 0.08352454554484612, 0.08581190643697423, 0.09084018841772545, 0.0766018390697274, 0.08594891389709047, 0.09272165077997374, 0.07558634606482861, 0.09248862480422326, 0.08504028059322877]}, "mutation_prompt": null}
{"id": "6549930d-4ffa-4567-b82c-216cecc4c34e", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Slightly increased Harmony memory size\n        self.hmcr = 0.85  # Slightly decreased memory consideration ratio\n        self.par = 0.3  # Slightly increased pitch adjustment ratio\n        self.bw = 0.05  # Increased bandwidth for larger exploration\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.elite_fraction = 0.25  # Decreased elite fraction to increase diversity\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Decreased momentum factor for less aggressive adjustments\n        self.local_search_prob = 0.07 # Increased probability for local search\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.85 - 0.05 * (iteration / max_iterations)  # Reverse adaptation\n        self.par = 0.3 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.05 * (1 - iteration / max_iterations)  # Decreasing bandwidth\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.1 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n                \n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with adaptive momentum, dynamic bandwidth, and probabilistic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.25905937354573794, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.6215387645861861, 0.639755694118033, 0.668128147543653, 0.5986661105614949, 0.6403017772567112, 0.6271366025312379, 0.645200859211509, 0.6208053292010594, 0.6526551720995006, 0.2607649312918534, 0.27374073236086205, 0.25502919149435566, 0.2504502316396353, 0.2837437935738065, 0.26553055794980507, 0.2794176446244364, 0.2918234821650544, 0.2561848935539147, 0.3376473084203201, 0.3523136995146604, 0.30611231223739155, 0.2856396999234936, 0.36471034376230504, 0.35739036026372073, 0.27651342343455776, 0.3492790652805515, 0.31731018816543344, 0.3051244784833873, 0.3066980842905619, 0.3483706129358438, 0.24338675265865872, 0.2247951156541007, 0.3252630075093226, 0.24217233917155767, 0.227480269557073, 0.16923230172426607, 0.9164055139464657, 0.8969461132859153, 0.9217286416298717, 0.9269062964137129, 0.9129022691542737, 0.9061503713043356, 0.9367683563927923, 0.9381573151627666, 0.9219231544952592, 0.25762564036835756, 0.2534520162322579, 0.25890389135784975, 0.31927082442764576, 0.2323871831423573, 0.3147092234811407, 0.2886560321328693, 0.23411803037744217, 0.2063512620420892, 0.21940139020094995, 0.23003027194277847, 0.1777577489475669, 0.21629082726185955, 0.2774696495049237, 0.3368956550872386, 0.2588315016151379, 0.3491290123965858, 0.31922673479306596, 0.26666544147465987, 0.19531221142232313, 0.1909705655827093, 0.20847662785915222, 0.1934873124596247, 0.25118891773973906, 0.15330032030885954, 0.1588701544671156, 0.16024527726172366, 0.15758075127365867, 0.14280852460223037, 0.13020067591270112, 0.1346105264023989, 0.13224995037069986, 0.14820472366813975, 0.14008827174835514, 0.13992492862928463, 0.12915557421712842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06443189345743883, 9.999999999998899e-05, 9.999999999998899e-05, 0.029398946956957994, 9.999999999998899e-05, 9.999999999998899e-05, 0.028173273687171374, 0.04553250499708206, 0.07384435487807128, 0.07238189109673654, 0.0703816404103389, 0.03722248049624255, 0.05436845697999537, 0.051174790176588436, 0.06604538266593385, 0.09112334200861982, 0.0784304073553358, 0.1313382232595215, 0.07501428999302917, 0.11524188464185958, 0.1013581292144563, 0.08814009490974273, 0.08653491714211325, 0.05349964974850141, 0.1538668643811656, 0.15821563761548008, 0.1706360118070548, 0.0717975003068978, 0.06443809675805257, 0.15107484544413852, 0.1336104992632534, 0.1803180382323073, 0.11672564519140383, 0.40975020769249537, 0.46988982640583954, 0.4335929824172555, 0.44816022858950966, 0.48448157701728056, 0.478801414000417, 0.4389164999894717, 0.44541235418446523, 0.4782196048875853, 0.08429801474740872, 0.12682645422803074, 0.08804860203147713, 0.10262762112120583, 0.08074350392905993, 0.10713043830195823, 0.1466737153812494, 0.10145314905544578, 0.12390892381275809, 0.18497292180795122, 0.14888814221888913, 0.14719732498600624, 0.16750412640591839, 0.17653075088941972, 0.19397022266371078, 0.13181690800523171, 0.15018024949956665, 0.13294471674096242, 0.3322908859642527, 0.2834054387283288, 0.2794084591443736, 0.3628299663237714, 0.29675986259449605, 0.29628556691508234, 0.36003811914688644, 0.31249376358571856, 0.3798842998667713, 0.23997911398883132, 0.25799159267676697, 0.17122134227336716, 0.2508818384859913, 0.2228298375699136, 0.24316106480684496, 0.2727165439886352, 0.23766775775101123, 0.24948101577669723, 0.18747117392708323, 0.19762878396591887, 0.19875119824105036, 0.20255339290664387, 0.21381467608140048, 0.20999719392860794, 0.21058956472173262, 0.20897975340329544, 0.22052404796894842, 0.22709626174317166, 0.21520324479839348, 0.2112782513383299, 0.2102529882567864, 0.4563075050290364, 0.456635908546309, 0.22047505168343484, 0.24256442149539947, 0.24889927596710415, 0.4253582007374055, 0.16706233916717683, 0.4456311223355691, 0.597377218950226, 0.3026935595867818, 0.6172208013720901, 0.14763961735050035, 0.8587455140075465, 0.16709430406467796, 0.3601217548725595, 0.16521213363389908, 0.16441443851431048, 0.20584282181774893, 0.168668891214945, 0.21039423427412252, 0.15755161898867076, 0.20325635280853205, 0.10516897388137514, 0.17638568575726787, 0.1772777743708337, 0.18611620098321013, 0.1877481611758567, 0.1985861182950267, 0.18178908231684354, 0.18358809950342303, 0.20990958126000614, 0.17422780517852876, 0.09186958414918844, 0.08399294398816948, 0.07622369295452625, 0.07938087061867316, 0.08303643799550431, 0.12407542056650478, 0.09290455235357564, 0.07767437968261037, 0.08422609822673277]}, "mutation_prompt": null}
{"id": "f4a041cb-3f18-440c-9ab2-cccdcf0441e7", "solution": "import numpy as np\n\nclass DynamicQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25  # Adjusted Harmony memory size\n        self.hmcr = 0.9  # Increased memory consideration ratio\n        self.par = 0.25  # Slightly lower pitch adjustment ratio\n        self.bw = 0.025  # Increased bandwidth\n        self.mutation_prob = 0.1  # Lower mutation probability\n        self.elite_fraction = 0.3  # Increased elite fraction\n        self.theta_min = -np.pi / 6  # Expanded rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum factor\n        self.local_search_prob = 0.05 # Probability for local search\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.05 * (iteration / max_iterations)  # Reverse adaptation\n        self.par = 0.25 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.9 - 0.1 * (iteration / max_iterations)  # Adjust momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "DynamicQuantumHarmonySearch", "description": "Dynamic Quantum-Inspired Harmony Search with adaptive diversity and memory update for robust optimization performance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.7664176128259089, 0.7562678150889117, 0.7603337207300533, 0.7695650088319219, 0.7336598324228583, 0.7902339143957776, 0.7571863312180052, 0.7511983479295794, 0.7591590247376081, 0.37264620642484925, 0.3275571664212522, 0.33572272927505287, 0.36343343985614407, 0.3223321655141689, 0.4100052951576827, 0.4064852163332199, 0.3894697324391042, 0.31826014203811315, 0.43947794078386904, 0.4269208031617825, 0.38314972066481634, 0.35557306973938807, 0.5411751077465089, 0.4711111540336066, 0.18083533157121567, 0.5032206023038945, 0.47130800198781353, 0.2926333704703221, 0.17628415804916386, 0.29136121770017087, 0.17384898567259877, 0.34080142623853915, 0.42574519259041343, 0.400982989429854, 0.3105809416761317, 0.34204163906982676, 0.9195144132195521, 0.9464859961414925, 0.9235100297156456, 0.9314656729946545, 0.9417898353779539, 0.9485279382996511, 0.9058391138448507, 0.9335014361672027, 0.9301342297276507, 0.32377719064080646, 0.3415397301681251, 0.24592401027488808, 0.2932157605924939, 0.45293814009982747, 0.4241621356715142, 0.2739609313265715, 0.2930626989293529, 0.36629468677630217, 0.22230820790452777, 0.16472532288640396, 0.14086822542535882, 0.2747731433851903, 0.2535035057195951, 0.19150669617817517, 0.2321393218119162, 0.19633903307138478, 0.3730128082207089, 0.18521658092731108, 0.20417427965470847, 0.23859376336742466, 0.22415465797946532, 0.3158857908353804, 0.17860998459740463, 0.15343417099953638, 0.25250279798225095, 0.3129358463515379, 0.13238668047137925, 0.13395678362406838, 0.1468296311626922, 0.13268088210181905, 0.14270478271986908, 0.15497861511408706, 0.1754660060745451, 0.12868238588664394, 0.14044555376632395, 9.999999999998899e-05, 0.03183486838330407, 9.999999999998899e-05, 0.0645777959207664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03609934268560133, 0.05804535663902277, 0.048081733975442464, 0.14607987089832963, 0.059811495242471424, 0.05444173938309449, 0.04190542029392741, 0.12372393166555962, 0.06474204568329534, 0.06529335554297377, 0.08757045446137812, 0.198372444097626, 0.17742064335164998, 0.10010716584655166, 0.07440380475282804, 0.21879777073835904, 0.17504247533133288, 0.12315952073411185, 0.06971338506441749, 0.10205000343564608, 0.07845992346632957, 0.1330701163430662, 0.16111163184603006, 0.21095342206558776, 0.10301133391812622, 0.24548133991102994, 0.14563807604172907, 0.08257860563952513, 0.5337989418466604, 0.48688871718629767, 0.4541180878286838, 0.5002531193330227, 0.5660194689268214, 0.42902762727294574, 0.4559129987263669, 0.47139403966689675, 0.4896604297340974, 0.11008807780062202, 0.09318798807913886, 0.05795327817849971, 0.11651362977162338, 0.12251990041482475, 0.13630385302375325, 0.1239859393431767, 0.12697983329652618, 0.09517661663933341, 0.2140716672081825, 0.13719290784490878, 0.21306657807259366, 0.17872624305713602, 0.18992311358558833, 0.2389646137450503, 0.18199572474498937, 0.18071871338334056, 0.15345188921967323, 0.3618528265287485, 0.2920716214591309, 0.22020986695219835, 0.2669492366567304, 0.2761955142541601, 0.24176786340149703, 0.27904671642834833, 0.3713597731768604, 0.25011555746704717, 0.14814490446362782, 0.26831445020411904, 0.2681513244494761, 0.2948304519856746, 0.2110105710953274, 0.181553755944179, 0.2757972865344518, 0.2529320189020192, 0.25987369839061447, 0.20649972902745695, 0.2090769564571553, 0.2512078299251005, 0.2020689962534039, 0.2155976263466155, 0.20278353582184816, 0.20045889017141116, 0.24871859680028552, 0.2102355045067873, 0.5607104994090544, 0.22344649093175017, 0.2526301611804067, 0.5794363263719132, 0.1909159657128774, 0.1999323525336324, 0.25580624160184096, 0.24275589565711253, 0.2163523406475949, 0.18747516088428107, 0.1889423187560787, 0.1870411275602989, 0.6968799990912378, 0.8382105332054304, 0.6972198582968285, 0.13469396443447845, 0.15771558480714742, 0.14002465326768865, 0.15508750768211432, 0.16878696280242733, 0.2114800161291155, 0.21018147198896198, 0.21109853899719144, 0.2087521103798371, 0.10353406361490869, 0.4305213244987194, 0.09437336235752558, 0.20103691807934643, 0.2009938509866548, 0.1802852040412507, 0.17631869661791066, 0.19055132822745258, 0.1799390821797946, 0.20582196515142337, 0.178427161881758, 0.2110052621456303, 0.09827870913558467, 0.0884098459538698, 0.09643353907274232, 0.10505763304374827, 0.09520908722107635, 0.14936931676937326, 0.09425079782907664, 0.0793307953729554, 0.08709766934972052]}, "mutation_prompt": null}
{"id": "79bb6497-1bbf-4190-9b22-60bc7425d546", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.25\n        self.bw = 0.025\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.3\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.momentum_factor = 0.9\n        self.local_search_prob = 0.05\n        self.learning_rate = 0.01  # Added adaptive learning rate\n        self.tunneling_prob = 0.05  # Probability for stochastic tunneling\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.05 * (iteration / max_iterations)\n        self.par = 0.25 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.025 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        self.momentum_factor = 0.9 - 0.1 * (iteration / max_iterations)\n        self.learning_rate *= (1 + 0.01 * (iteration / max_iterations))  # Adapt learning rate\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def stochastic_tunneling(self, harmony, func):\n        if np.random.rand() < self.tunneling_prob:\n            # Tunnel to a random position within bounds\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.learning_rate * (self.bw * (np.random.rand() - 0.5) * 2)\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                new_harmony = self.stochastic_tunneling(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedDynamicQuantumHarmonySearch", "description": "Enhanced Dynamic Quantum Harmony Search with stochastic tunneling and adaptive learning rate for improved exploration.", "configspace": "", "generation": 46, "fitness": 0.25104193539709513, "feedback": "The algorithm EnhancedDynamicQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.6000616364563193, 0.6745964995320723, 0.6387581609769288, 0.6209035913308163, 0.5996644417999246, 0.6455547213621635, 0.679048258681942, 0.6753897222937775, 0.6089822469649248, 0.3065499518499297, 0.33753211337183464, 0.16732987806966082, 0.20304393519524988, 0.24727762349065274, 0.20289084472282415, 0.263467361197391, 0.30931098072847185, 0.3009061178915192, 0.2815969636016623, 0.3215417438628134, 0.2153473218176457, 0.25561722899071815, 0.3663102543701121, 0.26842243238464114, 0.24628716509474324, 0.2728066165953702, 0.31090813672346185, 0.4521752255160837, 0.21744778392786324, 0.21821189801929963, 0.5041958059159333, 0.17529991757550856, 0.3292055986871676, 0.3089038942331337, 0.28123674729014525, 0.17772643353921025, 0.9209735319790994, 0.9589776014376886, 0.9147263535905367, 0.9318634724820927, 0.9428959697719298, 0.935426597990805, 0.9372082342504667, 0.9405453803658419, 0.9359129977163725, 0.20863134997995825, 0.3023084777466506, 0.3130857845040903, 0.2589454824927686, 0.3261027459107987, 0.2900516028589649, 0.2570371752719305, 0.2568155724935821, 0.24152842231043437, 0.16352420041430127, 0.11668230370445165, 0.17087558476655684, 0.1768913909773766, 0.19344431088654812, 0.8822545030098266, 0.32649415674280957, 0.22103233547844936, 0.5308977004017459, 0.1709627012095032, 0.14731959503593894, 0.1998864319334731, 0.15189856158494275, 0.18354990667877114, 0.19289514679276376, 0.1686569524700322, 0.16782704276074056, 0.1558596895954959, 0.13472744265799208, 0.13041303797515424, 0.20160175192897078, 0.14159645566648105, 0.1477415396445253, 0.14840011952914633, 0.17694472424476848, 0.1287509556445311, 0.13132344991426503, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012025793279879515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12563732681957973, 0.06513061148416799, 0.0371711569203137, 0.061744880708741734, 0.06487832770769197, 0.07298798926091021, 0.026822504986812268, 0.0985672823294026, 0.0721986028192565, 0.09722193672094359, 0.04629124424117981, 0.03615134485508875, 0.05338126092406814, 0.014201583211507551, 0.06582219659331545, 0.04645595409367964, 0.06293948797233839, 0.11096764346223864, 0.07749413169945363, 0.05736920442236915, 0.09308274306556719, 0.14813416056443618, 0.07278835990164534, 0.11948751342345221, 0.09763928878929784, 0.19353158477211008, 0.060220093916809825, 0.1065882770359563, 0.40212261752786194, 0.5980091596170611, 0.4102192914434384, 0.4468770477125109, 0.39517907719301026, 0.3804731250265363, 0.38302398506346547, 0.41139054951070286, 0.4089894193422736, 0.15052976845804988, 0.09039064710154798, 0.14508975882004183, 0.09198225508444069, 0.07841701210032426, 0.09782074248418848, 0.11811250591451139, 0.10900837822164866, 0.12921511539534836, 0.17886295677262076, 0.16705767477393896, 0.1788831574751263, 0.13545700886881806, 0.16958908910136683, 0.14762584405858759, 0.17253285117159034, 0.13615079304522837, 0.14426969491212238, 0.24970094472828563, 0.287370840488294, 0.2064727265324674, 0.30856001550515777, 0.23128817382715838, 0.27017647575640436, 0.30863487112019206, 0.28333546787653063, 0.25989728900839904, 0.19834435365384195, 0.21395651996918275, 0.15444542588987553, 0.20475193624996557, 0.20983952740520895, 0.20070366829805986, 0.1744336084719902, 0.18897303109300279, 0.11460305250641145, 0.20157863053671676, 0.1838358575324185, 0.2034935951998731, 0.26715580445139453, 0.25482855998346743, 0.20396569308093893, 0.23854913251935117, 0.2796455890232744, 0.21877951630557924, 0.2348430162507532, 0.6147560815263353, 0.19627825492421813, 0.22443635664541717, 0.20145563561138036, 0.195142651272753, 0.18515494310520986, 0.2284917803335602, 0.21619555155355197, 0.47939838937727586, 0.16894138594933994, 0.16591392944065486, 0.19861881817349836, 0.693139832784203, 0.6670796687007436, 0.17168685725356259, 0.16428532705495513, 0.1645413572646245, 0.2949348127341095, 0.16826194865893251, 0.19665070303739685, 0.21164426055736252, 0.16782257334491824, 0.2128288633357257, 0.10448292774913859, 0.40749155440202456, 0.4202538309358166, 0.1940943191992479, 0.18852992866365337, 0.17663240685827752, 0.17480475899273884, 0.18786156932911546, 0.1943487829831686, 0.19042444921839874, 0.194087234955316, 0.19412578342334297, 0.08434782395954221, 0.08857235174080014, 0.07999174342007531, 0.08234525609683951, 0.09252840997072109, 0.07746336140298882, 0.09886697580141246, 0.08500241612143322, 0.08597437894758442]}, "mutation_prompt": null}
{"id": "a68098a9-2f26-44bb-8b1c-7ef2272b0b57", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.03\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.35\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.1\n        self.gradient_step_size = 0.01  # Gradient-based refinement step size\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        self.hmcr = 0.9 - 0.05 * (iteration / max_iterations)\n        self.par = 0.3 + 0.05 * (iteration / max_iterations)\n        self.bw = 0.03 * (1 - iteration / max_iterations)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * (iteration / max_iterations)\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  \n        self.momentum_factor = 0.85 - 0.1 * (iteration / max_iterations)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def stochastic_gradient_refinement(self, harmony, func):\n        gradient = np.random.normal(0, 1, size=self.dim)\n        perturbation = self.gradient_step_size * gradient\n        new_harmony = harmony - perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.stochastic_gradient_refinement(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedDynamicQuantumHarmonySearch", "description": "Enhanced Dynamic Quantum Harmony Search with stochastic gradient-based refinement and adaptive mutation for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.27700460290986517, "feedback": "The algorithm EnhancedDynamicQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.7515100016108034, 0.6644176933350447, 0.6957856161928977, 0.7000672591962056, 0.6980574018285028, 0.7359193781040421, 0.7327429592949761, 0.7055710133845332, 0.7325909938363246, 0.3618875861812175, 0.4244075269428913, 0.3255926906867078, 0.38806181926322025, 0.3343081738879562, 0.42944024081555066, 0.3258115704136877, 0.3836375753035409, 0.3882368315206416, 0.44805765958144084, 0.45354543006549786, 0.34598672759200755, 0.4016800975003293, 0.3715163493710065, 0.4366322645854962, 0.43063325737311875, 0.43210378364451063, 0.4794710945822911, 0.39196601102426687, 0.1866163738821096, 0.3024099302636447, 0.36645876942656674, 0.1858892217218352, 0.4237009299049924, 0.4320794949661618, 0.358511522719164, 0.30888625525285407, 0.9536474576344488, 0.951292783930436, 0.9316787546011407, 0.9382617142957241, 0.9360028683742286, 0.9355987888435235, 0.9261138687933471, 0.9367200321825702, 0.9516196683241185, 0.2554990824555561, 0.30346807983217916, 0.30432084791614744, 0.37610980102037495, 0.22065637899670965, 0.4137666508771045, 0.2881041135399861, 0.24830331264594518, 0.2513967432164934, 0.2989542098210731, 0.21458119536910236, 0.16423937840467628, 0.27769980007473627, 0.18664306382036067, 0.2113465119193445, 0.2034655259959378, 0.22867952801707625, 0.2655308984013013, 0.3650149481509911, 0.21492012185637044, 0.18172127210503863, 0.3224395752532522, 0.17601371921872955, 0.1506540199933788, 0.1660008343649122, 0.17374796618850064, 0.1545152404916178, 0.13917437699302515, 0.13360602378628483, 0.16868268306223833, 0.13607793282068104, 0.14784560327406238, 0.15928867590567697, 0.1882179180697734, 0.1441432259110541, 0.13554743619084642, 9.999999999998899e-05, 9.999999999998899e-05, 0.047191598184341044, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005848040223056516, 9.999999999998899e-05, 9.999999999998899e-05, 0.002065080766172067, 0.050929345422890626, 0.041514698795820704, 0.12182222315459623, 0.048278097373959494, 0.019656630738591807, 0.03809651788346413, 0.06585141770898484, 0.07898947984720328, 0.0910688841307361, 0.13006626767024976, 0.15542850469151004, 0.1737853396631328, 0.06736406058521605, 0.15360660842476992, 0.08876955027803946, 0.21719842924132304, 0.17045405629054622, 0.14390219713557184, 0.1979103682854959, 0.0623859756483327, 0.12667512312175966, 0.20893851134866182, 0.08598183512924262, 0.0989792675103155, 0.14553289181718432, 0.09965970322813011, 0.23695273763107916, 0.4590006112901146, 0.44732557223113545, 0.4986841312959719, 0.45756945518899483, 0.44065808742799406, 0.46907342423561704, 0.49975897021589333, 0.45739440234198325, 0.4787240083069433, 0.08757619609074863, 0.08479072353186656, 0.12663282880519933, 0.13079816811209488, 0.12997613788708118, 0.14129489656530747, 0.12427941266602505, 0.12329780072812113, 0.1134612924288988, 0.2175743489995864, 0.1735740560316592, 0.1515437640460403, 0.2944925246166653, 0.1450937282744379, 0.20694621473296748, 0.14192501125324486, 0.1659044230349529, 0.16792870081034794, 0.2248816092415018, 0.26013810123488346, 0.2073193260360202, 0.3037502971006233, 0.21600579912454787, 0.23585565321754043, 0.2508540845561821, 0.2934920569620133, 0.40160139173555276, 0.22597510899987405, 0.1855283363996738, 0.1912819333228285, 0.20066658787530134, 0.184908277276579, 0.23766469592418416, 0.225551468566492, 0.2821856311916875, 0.20091233058643243, 0.21270595774089185, 0.21579184336034907, 0.20288548418659724, 0.21672353824920743, 0.21628772545329644, 0.20770583289024258, 0.20084413188811245, 0.20992158517957937, 0.21141678879153503, 0.5396318991546071, 0.2274774593682921, 0.20671949167970327, 0.20979405151080366, 0.2257777321987101, 0.19960496040207565, 0.23686501615091204, 0.21281915767766924, 0.2231971387858196, 0.18498742028122261, 0.6521297311668657, 0.38599548446995413, 0.17706971642978842, 0.16962024695940614, 0.8372052172716808, 0.16018638206819413, 0.7510281437984354, 0.16168806910357036, 0.1572395175061323, 0.314280595135807, 0.22571116395888646, 0.1605101590596656, 0.618634626166209, 0.2123776833026373, 0.104604739312402, 0.3597314789967826, 0.09463617564794291, 0.18417238539743075, 0.17851179283007745, 0.17713906780491195, 0.1874059132970357, 0.19287875515683062, 0.17934895841747622, 0.17897868170663644, 0.20959366564647097, 0.1815026544014675, 0.07918706331719128, 0.09036144008764457, 0.0979678221133885, 0.09323123327829286, 0.08760572927999999, 0.12867615257050657, 0.09348231571213161, 0.08365332350457633, 0.10589500427726473]}, "mutation_prompt": null}
{"id": "0cfa641d-26d7-4384-99de-72c76162ce03", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.28673058410141944, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "eb7164f1-7ae7-4e0a-8fd2-07b8fef4e701", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "97565f5d-798d-44cc-8bbb-3538f8a23da6", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "c4ebf34e-488b-49f7-8ec6-6f47fbf9da0b", "solution": "import numpy as np\n\nclass AdvancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Increased harmony memory size for better diversity\n        self.hmcr = 0.85  # Slightly reduced harmony memory consideration rate\n        self.par = 0.35  # Increased pitch adjustment rate for enhanced exploration\n        self.bw = 0.05  # Increased bandwidth for broader local search\n        self.mutation_prob = 0.2  # Increased mutation probability for diversity\n        self.elite_fraction = 0.2  # Reduced elite fraction for more exploration\n        self.theta_min = -np.pi / 3  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum for faster convergence\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.6  # Adjusted chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        scales = np.random.uniform(0.05, 0.15, size=self.dim)  # Multi-scale perturbation\n        perturbation = np.random.normal(0, scales)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdvancedQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with enhanced diversity control and multi-scale local tuning for robust optimization.", "configspace": "", "generation": 50, "fitness": 0.2563303431412379, "feedback": "The algorithm AdvancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.589973810984787, 0.5932198699036209, 0.5853788610249511, 0.6184458997716513, 0.6235120255790931, 0.607162008014944, 0.5874948381574421, 0.6110366912945904, 0.5963434004034848, 0.2653096199890047, 0.24864708799569268, 0.27447491604281404, 0.2985693884349566, 0.259686211600324, 0.2803281246138891, 0.25166466705678836, 0.28832138524438033, 0.2333782494743738, 0.3378150017235242, 0.33176028297361815, 0.3398193704910494, 0.3112212916322241, 0.2737795847053257, 0.3075953981074623, 0.3217109114412563, 0.33180629683957263, 0.31408785603661804, 0.26845307672991736, 0.190491927914616, 0.301281303016952, 0.26780853753862144, 0.27460966474728743, 0.28216930608249124, 0.28822657901932836, 0.2921572389918795, 0.2435217618683443, 0.9367510398047472, 0.9159453969462257, 0.923770099405971, 0.9407599930489244, 0.951103712877163, 0.9257750339315728, 0.9333458930300291, 0.9185544054440204, 0.9390918773739524, 0.2526866554319156, 0.20030642847957758, 0.22485152282348742, 0.2844862775470278, 0.27166903112766494, 0.29160872072579014, 0.275206963530065, 0.20796012161322663, 0.2752236574211373, 0.200045617531023, 0.21509318353104168, 0.2220858386575726, 0.27682531846177794, 0.21458193714129825, 0.3425627219474503, 0.3198252620856935, 0.23779680799588365, 0.2084567792451969, 0.23178672459492733, 0.1742370144115859, 0.16929619062209478, 0.15859691063308856, 0.20072908097640918, 0.15216186649245322, 0.2713527382351806, 0.1834679421767199, 0.19172631151833353, 0.1447435981481573, 0.128334006646176, 0.15167116546170678, 0.13654764703765343, 0.13690732020480423, 0.13940240033240625, 0.14284627995134946, 0.12813387033037837, 0.16428798407099388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015287194516648728, 9.999999999998899e-05, 0.03655561586764944, 9.999999999998899e-05, 0.004952080995783259, 9.999999999998899e-05, 0.12593039972323572, 0.08449152007797633, 0.05038888884543524, 0.05723631721365019, 0.09311417199053051, 0.011861546934845646, 0.11261079687400055, 0.0702682997236983, 0.08300835556200348, 0.07105747676851426, 0.04690384554681315, 0.09155574026426039, 0.04585713591899443, 0.058748674179464944, 0.04482134654277958, 0.06187730814894843, 0.09395516636694667, 0.07263881374705594, 0.12278868230734186, 0.07935558134100706, 0.1281984225482855, 0.08160954881387061, 0.06242745253652904, 0.16058470968214955, 0.15531558596320771, 0.13031523545454204, 0.10030094859275163, 0.39387872205452146, 0.4208795654707347, 0.4593616391813249, 0.41598622084115966, 0.4387159849964808, 0.4475619260685023, 0.4318328528542894, 0.4069830706105434, 0.462303801041706, 0.09581166977723476, 0.09700073668970399, 0.11485704120748519, 0.13306452052296103, 0.10729886679479572, 0.09278992921934315, 0.1396222044889508, 0.10847501418720729, 0.11388004798388862, 0.1379382541664429, 0.14071858316691066, 0.13576591464910692, 0.1289338816578538, 0.151796121931701, 0.16574951874388277, 0.13642238094846382, 0.13832922067788567, 0.1341155281374844, 0.30699974271030783, 0.3091911440087227, 0.3126466892079671, 0.27260347295943677, 0.2843659317212337, 0.3613213744663991, 0.21827967660353165, 0.32674512660391875, 0.34752037337021, 0.2383026907097836, 0.1995633428889616, 0.23161656885342108, 0.237379620954553, 0.19405957620816638, 0.2711436481010996, 0.2378836355367142, 0.20121527458863298, 0.25346911668075767, 0.20280223151677412, 0.2216340147537862, 0.21739527698873173, 0.21569974981803997, 0.2106837080484939, 0.20970966068525876, 0.2146433797716445, 0.19942117953719185, 0.2017342956912166, 0.2058049166009296, 0.20991713070593798, 0.22319313858197087, 0.21945919166503713, 0.4219266657834937, 0.22429204662700697, 0.2479841720047219, 0.1893766343330301, 0.22271071459545322, 0.5012115098826805, 0.6314333354853567, 0.3370559105847477, 0.8384970559510107, 0.7496160833050425, 0.3094825545894635, 0.13943943760107902, 0.7881232402439936, 0.1518111842261487, 0.3315134745688798, 0.1687445795325766, 0.46343179468369244, 0.20669748141573407, 0.1652191220640048, 0.2103880823074057, 0.10441901646123164, 0.28187850677689896, 0.20596083272302745, 0.19088128800992177, 0.19440518660457207, 0.1786648350738651, 0.17220536221423122, 0.1769178318290202, 0.20479648248168758, 0.18566105920625253, 0.18696820427364058, 0.17812888688677353, 0.07848666138206994, 0.08863781030199713, 0.07924834525058344, 0.08428068376720932, 0.08512710753282571, 0.08328740520331557, 0.07649153042985013, 0.07917758420239407, 0.0878176620014558]}, "mutation_prompt": null}
{"id": "cc43e580-4c03-429f-b06b-6faa05c56de4", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Reduced Harmony Memory Consideration Rate for diversity\n        self.par = 0.35  # Slightly increased pitch adjustment ratio for exploration\n        self.bw = 0.02\n        self.mutation_prob = 0.2  # Enhanced mutation probability\n        self.elite_fraction = 0.2  # Adjusted elite fraction\n        self.theta_min = -np.pi / 6  # Tweaked range for quantum rotation\n        self.theta_max = np.pi / 6\n        self.dynamic_learning_rate = 0.9  # Introduced dynamic learning rate\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.8  # Adjusted chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.35 + 0.05 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        self.dynamic_learning_rate = 0.9 - 0.2 * chaos  # Learning rate influenced by chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle * self.dynamic_learning_rate  # Apply dynamic learning rate\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.dynamic_learning_rate:  # Use dynamic learning rate for rotation\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search using dynamic learning rates and differential elite selection for improved exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.26630083800891946, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7427231226235937, 0.6905848993868535, 0.7233463080225577, 0.7214308805825651, 0.7119749435864648, 0.7037020488011007, 0.727331376040656, 0.6894664363069667, 0.7397237368676713, 0.3328119446108043, 0.3413032379126453, 0.3294894586143029, 0.2842788997096871, 0.3570152403771102, 0.37295942045541475, 0.3630546058970574, 0.35552085428353175, 0.3586682058910212, 0.4099661903158227, 0.30008841751976856, 0.29776061888591043, 0.24038333945654788, 0.24478673715551313, 0.4853967854086174, 0.18594965476779468, 0.37647758142831933, 0.4048879534361547, 0.1942237620632562, 0.1677973551707923, 0.4010718974919526, 0.16788123198701, 0.18268613038489812, 0.17933884782162257, 0.18503672255708736, 0.34378811377569407, 0.20736160280697735, 0.9263319265160606, 0.9180663980753703, 0.9333902766110608, 0.9078233953786395, 0.9143599987384201, 0.9370877214401898, 0.8981264885922817, 0.9208069052499404, 0.9230372958212575, 0.23674637792856623, 0.2551507318252074, 0.29878611574637515, 0.3066557231105793, 0.27820210434645765, 0.2744249154928865, 0.26784404128524153, 0.23371319897659837, 0.2516452960154646, 0.22386707583962984, 0.16507289396760938, 0.16823211231768387, 0.35432743675783973, 0.1936659390671005, 0.27455133765311823, 0.14820907014156115, 0.23396189879967688, 0.8206052779722655, 0.15734792188362312, 0.14456933736680366, 0.15281482838269933, 0.14718617950623336, 0.22344328165028915, 0.25762072922934987, 0.1887631338683633, 0.1397155332625052, 0.1518915895478158, 0.13240343755537765, 0.15461874879966853, 0.1551585105835973, 0.14029616449542537, 0.14206209599779762, 0.15690681796398398, 0.16770470640656354, 0.12685324189270086, 0.14364405890175946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003057413873174708, 9.999999999998899e-05, 9.999999999998899e-05, 0.002319161315505913, 9.999999999998899e-05, 0.04476380576771355, 0.07571369975727027, 0.050347278145259744, 0.10670030678348763, 0.038876736061555284, 0.06758349554106768, 0.04942801064090796, 0.16521488688922092, 0.07943920464447163, 0.11996375296947825, 0.0785804364448528, 0.06628149932306493, 0.10362272112169701, 0.1565809782011176, 0.06410434576299362, 0.11152772813550815, 0.15816215786005394, 0.19110292572364995, 0.07896123844031122, 0.1733315387987383, 0.13654735160361708, 0.17610713142139633, 0.13107192486106345, 0.16260174709496555, 0.08661769362274208, 0.23221748387539431, 0.14404045851361846, 0.10671261435564772, 0.4261157586382377, 0.4782619925817456, 0.4198437272244899, 0.39691032663483816, 0.5417064298731884, 0.40589941933533824, 0.48887244738184443, 0.4712396637882601, 0.48588367356301365, 0.1167356466712085, 0.1401754295910279, 0.1357042957832869, 0.10008306216483509, 0.11863127575689703, 0.10697530080142492, 0.14526182890963169, 0.14243961682794137, 0.09930388777351784, 0.34258384047157486, 0.260122797769612, 0.3205085541938786, 0.19631268889663123, 0.16858248677176269, 0.21302628796101608, 0.15628598957450135, 0.13771450563854648, 0.13870989853426796, 0.3802783126955316, 0.3473621599116047, 0.18492933049681992, 0.27295411937059, 0.26735352983276994, 0.3352240654814985, 0.39780801596204096, 0.38533975527654774, 0.19695293448336149, 0.24410800483521022, 0.25781999301274106, 0.2483763058476507, 0.2954998105776303, 0.26024854269768416, 0.24939136754458902, 0.3493271987790445, 0.2669924711325069, 0.20541689844312783, 0.22068613323881636, 0.1934945159940925, 0.2069250991108349, 0.19010104551856544, 0.20356453013064713, 0.2161324874632714, 0.20028477216231222, 0.20158099756241765, 0.19603966703703857, 0.21987928148189195, 0.19306864955631875, 0.20921216833914003, 0.1995255836294969, 0.24428106408252503, 0.22593405867384153, 0.251434970949331, 0.21703575345055037, 0.18830356499512046, 0.42452312040156026, 0.18578888150189599, 0.15682638987504838, 0.8668365041317203, 0.14783090928850418, 0.1978703681645705, 0.1649831801609375, 0.7358435172713194, 0.1509677444531169, 0.397894200766887, 0.26688983303358504, 0.41464283813059766, 0.20409588816613466, 0.2395784544604872, 0.20951095711817902, 0.10477469564231545, 0.18831455664439922, 0.1106419204663438, 0.17440726727514866, 0.18162620095865878, 0.18176128977391104, 0.19404273008791584, 0.19300178042147687, 0.19778728203554996, 0.19663712150267598, 0.17044266898905558, 0.21243293680187214, 0.08249354902519368, 0.0767295236462322, 0.07985943685695385, 0.07092126531147114, 0.08460384741856597, 0.10647276725658561, 0.08382600046175415, 0.0808848751633332, 0.07833795347803318]}, "mutation_prompt": null}
{"id": "970d156d-433c-4105-b10a-9871a946362c", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearchEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.35  # Slightly increased pitch adjustment ratio\n        self.bw = 0.025  # Slightly increased bandwidth for finer local tuning\n        self.mutation_prob = 0.1  # Reduced mutation probability\n        self.elite_fraction = 0.2  # Reduced elite fraction for diversity\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Adjusted momentum factor\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.75  # Slightly increased chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos  # Slightly adjusted HMCR\n        self.par = 0.35 + 0.15 * chaos\n        self.bw = 0.025 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Enhanced diversity influence\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearchEnhanced", "description": "Quantum-Inspired Adaptive Harmony Search with enhanced chaos-driven diversity control and stochastic local search for improved optimization.", "configspace": "", "generation": 52, "fitness": 0.2657712483315415, "feedback": "The algorithm QuantumAdaptiveHarmonySearchEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7222783512601196, 0.7246917009303524, 0.7161429870978397, 0.7172306356755155, 0.7124840486258559, 0.6886966137561061, 0.7133473982087007, 0.6967177838963297, 0.729505644935259, 0.2919075198885247, 0.32604267373711815, 0.3237779948552314, 0.3471983289634283, 0.2922758839947305, 0.3194044256853965, 0.25152832400215974, 0.3550808601791655, 0.343726118132734, 0.4535116131295386, 0.43703721694791486, 0.43924531586134474, 0.36082961532330415, 0.4514348967249735, 0.40786908973531744, 0.4293109581737462, 0.44032621361061597, 0.22383107112205347, 0.36533238032330884, 0.14526118025858925, 0.3302810396462429, 0.3407938113902551, 0.3728994701271773, 0.2509052257008365, 0.2554233352859042, 0.3722859264088274, 0.23910874430573814, 0.9064208460066423, 0.902396524132172, 0.8954503279211078, 0.9243912987709101, 0.927950245038792, 0.9048671134723609, 0.9232169008111213, 0.9227477825185982, 0.9446448793556479, 0.4063536596449864, 0.2815006257662417, 0.19511727053536465, 0.2555682465299913, 0.348744474435264, 0.24293385573759163, 0.2568138932167019, 0.22046685128426147, 0.20172056033269192, 0.20030681333814815, 0.14781604152264594, 0.2246612804262026, 0.2129726452932862, 0.3083418771911265, 0.21231942861602937, 0.16890593554127464, 0.22327882372084695, 0.27935693046659127, 0.2561502605322755, 0.18899004353309012, 0.1511402900684934, 0.15520021843485543, 0.21858633353206336, 0.24779410490592735, 0.32572260483348536, 0.15349325150017323, 0.16355221167916967, 0.13092225707657112, 0.12997469296105701, 0.129791840295994, 0.14169413595107816, 0.14550117809031404, 0.15718405552146253, 0.15220649944978726, 0.13513206203681527, 0.1532593800166252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07188515984060284, 0.010494535892648704, 9.999999999998899e-05, 9.999999999998899e-05, 0.00667367702458721, 0.03972725863346749, 0.06860819691537068, 0.12578543006899823, 0.05654142539944185, 0.040800461701515967, 0.03896294403806655, 0.04432496825228249, 0.07866973508263653, 0.04603965283516176, 0.1344201045899439, 0.08022110083975931, 0.13724443316465296, 0.08421533694360828, 0.07980986051968142, 0.10617356783203447, 0.18361816413144072, 0.14980737636854757, 0.06519435922757677, 0.11257974831084872, 0.12494267301918227, 0.15739651661273057, 0.07958489857144502, 0.0867199570981404, 0.11176713999197907, 0.15991937756394237, 0.11765451708420682, 0.08048931966770412, 0.4297910852037903, 0.39377053282272845, 0.40267637365350417, 0.42859806295744174, 0.4011187076860271, 0.4567964854585165, 0.4474067971444745, 0.4441861304051823, 0.4537955480212641, 0.12145196463385821, 0.14005302276455256, 0.1090726582823256, 0.0886781312033258, 0.09439128011064168, 0.1104827615055799, 0.10454674843934808, 0.13798865167836594, 0.10791539473781608, 0.1976320920196728, 0.12729882849802143, 0.1668264655798235, 0.22827485276935922, 0.15872149465932395, 0.12052132855399633, 0.1441133904685099, 0.1807712075071135, 0.1477946145480078, 0.2562668594901957, 0.2637549948820842, 0.33164793337999654, 0.3561999533179706, 0.31725407712070464, 0.21994721184070787, 0.4174274362861644, 0.367743319844845, 0.3883508212756581, 0.22066812495685018, 0.2908383059030042, 0.1327269403121143, 0.2629871821136608, 0.21224645610503334, 0.23957639826595223, 0.211303068870919, 0.2729040569279385, 0.21166477544797757, 0.1958474711524385, 0.22927312113265874, 0.22099774250232518, 0.20132456423979495, 0.20729118315536543, 0.24136508198915385, 0.20419389727957027, 0.20041761855649642, 0.24506889486530103, 0.5463288137090261, 0.24884057231819146, 0.2279284224050524, 0.22410554046678877, 0.23709360155859782, 0.20398641584523514, 0.2657527474429098, 0.20893997098196138, 0.2459278627503203, 0.18525069508197756, 0.5264246479972587, 0.16864519041884085, 0.6659668636319669, 0.35589925803314804, 0.5702309298103752, 0.14211502365023276, 0.16743094431870809, 0.16288096805900054, 0.5297215081013308, 0.15419250520666594, 0.28181677560964413, 0.2076038981760424, 0.1805134374884314, 0.22734977642298904, 0.18382898608199216, 0.3203249523814673, 0.19813380457058793, 0.17294098615432763, 0.17449153329164002, 0.19479935872042364, 0.19532114244352627, 0.1756839235084311, 0.17523846095474127, 0.19987646927586988, 0.17833834601739362, 0.177533724513947, 0.09925952118015424, 0.09328195752319957, 0.08109041555247354, 0.08821871394057557, 0.09180480882305675, 0.0967160964689614, 0.08009254157941559, 0.10367230286919915, 0.082876274581128]}, "mutation_prompt": null}
{"id": "37b0eaf0-e180-4092-9be7-e25daba122be", "solution": "import numpy as np\n\nclass EvolutionaryQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.85\n        self.par = 0.2\n        self.bw = 0.05\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9\n        self.local_search_prob = 0.1\n        self.chaos_factor = 0.8\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.2 + 0.15 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)\n        self.momentum_factor = 0.9 - 0.05 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EvolutionaryQuantumHarmonySearch", "description": "Evolutionary Quantum Harmony Search with adaptive local search and dynamic elite selection.", "configspace": "", "generation": 53, "fitness": 0.2704787930167163, "feedback": "The algorithm EvolutionaryQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.742685595031458, 0.7399459385086544, 0.7297900003625137, 0.725026924837982, 0.7194763299979767, 0.7171059402231882, 0.7348170696710786, 0.718914082609825, 0.7406842495839108, 0.3945922017263831, 0.4202447637043236, 0.3724691523583552, 0.4134821327269461, 0.3118823911719374, 0.34577605997798466, 0.36147778232426475, 0.34251768262089277, 0.3529146607435285, 0.3873410428359295, 0.38677637124874986, 0.4363269111478787, 0.1785889798292436, 0.4926319813896781, 0.39094163756406985, 0.44174310499403335, 0.42195206961735365, 0.4673613560895298, 0.23201684124961774, 0.3711878242171157, 0.2565582107544758, 0.35509597346955857, 0.16954284361879435, 0.18016626465744467, 0.27434227380694687, 0.36981930670526886, 0.22780393484256511, 0.9145659912921723, 0.8445657283874375, 0.8988530274302988, 0.8901522894126788, 0.9047707435332598, 0.9228619607428798, 0.936712123330772, 0.8835021170146102, 0.8805587915945304, 0.1789034131439996, 0.22486509273232702, 0.17058168245443506, 0.2799846605940065, 0.33191628668987316, 0.30175225731680677, 0.2606488090363863, 0.2282977761767907, 0.29001788263050143, 0.29643077545512464, 0.1635306753590956, 0.17202679971200907, 0.8619580607937197, 0.27624306291076006, 0.35107818509712474, 0.2969652554762371, 0.17534032096128116, 0.7075232865580616, 0.24283762194018776, 0.3889156834702884, 0.14217106435135507, 0.16931639266268594, 0.14582856914394127, 0.23863725062255758, 0.2721192160297159, 0.16972098529471624, 0.15574487105481016, 0.12984298160256202, 0.11844000693276324, 0.13554797206750369, 0.14631066383790292, 0.12432330226850008, 0.18496247321813808, 0.12776521926237328, 0.1150658908173875, 0.11578902751489895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05842234769820209, 0.07325402787615676, 0.10525799701421312, 0.04016762848652833, 0.017514382541133466, 0.046752657646439766, 0.10261984111192779, 0.07565961508609886, 0.10272338921498847, 0.12477858937334207, 0.04588413163192928, 0.1491309196963928, 0.06003100450976839, 0.08797884785625942, 0.09307545530650352, 0.15144517509175892, 0.17310597796642158, 0.1137515202976962, 0.08181295673076616, 0.10344614871440894, 0.1796112782076842, 0.06131395838677378, 0.18064320589184824, 0.09805730065420992, 0.13519229380730813, 0.13593200421121432, 0.14280570999815123, 0.4381838330571147, 0.41509292259965447, 0.43143563203879187, 0.41884004411887077, 0.4745490075931724, 0.541555028827573, 0.4622513960917215, 0.5109411413619608, 0.4578689648593356, 0.15254512089104078, 0.13128437005250948, 0.1447834888385633, 0.11361717350266098, 0.11159034901092035, 0.08442593049382852, 0.1513556572760617, 0.1575674742173514, 0.16590701950427778, 0.1667769714991888, 0.16608019007490415, 0.13809508443094531, 0.13520212779460983, 0.12483292120527967, 0.18389638002426945, 0.1858247420577651, 0.2674921024135495, 0.1467265043356465, 0.27847729045366143, 0.2839780601566062, 0.28119333007800684, 0.32687557267678835, 0.30060187080232725, 0.3338694653846712, 0.4039611135963771, 0.3960642930401407, 0.3840868253347216, 0.25348418780300264, 0.24740895929032092, 0.21022342017649742, 0.22322600453139196, 0.2629629137552111, 0.21101463391007924, 0.2016526724730605, 0.2707380324568258, 0.27886260952715825, 0.19432424325359088, 0.20616371608291006, 0.20506813073352226, 0.18484107680107031, 0.19097821063854092, 0.2072428346512576, 0.19363305369366413, 0.20287726677950146, 0.2066521951228325, 0.5096533125482503, 0.22664468872318544, 0.3503335920662566, 0.20895130772695825, 0.2063965958381646, 0.2288656293923753, 0.2045200731541691, 0.22838159497885513, 0.20053261975017267, 0.18399236575796007, 0.16584361594289643, 0.3692751612495976, 0.6596907216906951, 0.6977803452800933, 0.175527898796495, 0.14088287188831183, 0.15820486205557172, 0.16651504723977395, 0.29617307273499605, 0.16855800158800538, 0.20330739637412587, 0.15538066127756134, 0.16649357029286804, 0.21015660186838125, 0.1673273680054086, 0.20824328089872657, 0.10474484948916507, 0.18542576946924727, 0.17772195938421897, 0.17479577622321596, 0.18646422735596546, 0.17603092724407, 0.18241275737433793, 0.18191025189532106, 0.1926261345107716, 0.17673079450593865, 0.08280782652681573, 0.08405303708607736, 0.09265859418872846, 0.08054573508309382, 0.08761846412000107, 0.08427977235829165, 0.08055275898989078, 0.08700239854406622, 0.09500693960928952]}, "mutation_prompt": null}
{"id": "1a656ad8-02c0-4a28-88c1-dbf9eaf563da", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "80a48671-e07c-474d-bcf7-382a5dd1ff8e", "solution": "import numpy as np\n\nclass QuantumEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.95  # Increased harmony memory considering rate for better use of knowledge\n        self.par = 0.35  # Slightly increased pitch adjustment ratio\n        self.bw = 0.015  # Decreased bandwidth for precise local search\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 3\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum for faster convergence\n        self.local_search_prob = 0.07  # Increased probability for local search\n        self.chaos_factor = 0.65  # Slight adjustment in chaos factor\n        self.sde_intensity = 0.1  # New Stochastic Differential Equation component\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * (iteration + 1) / max_iterations) ** 2\n        self.hmcr = 0.95 - 0.05 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.05 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def stochastic_differential_perturbation(self, harmony):\n        noise = np.random.normal(0, self.sde_intensity, size=self.dim)\n        return np.clip(harmony + noise, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                # Apply stochastic differential perturbation\n                new_harmony = self.stochastic_differential_perturbation(new_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedHarmonySearch", "description": "Quantum-Inspired Harmony Search with dynamic diversity control and stochastic differential equation for enhanced convergence.", "configspace": "", "generation": 55, "fitness": 0.22820876845356078, "feedback": "The algorithm QuantumEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.5119705647976203, 0.48816337282465927, 0.5359169543469584, 0.49422466822663014, 0.4905797626205739, 0.4763928385946036, 0.48911342520745404, 0.48382902154195484, 0.48333160852153656, 0.09768269960873244, 0.07873360248755812, 0.08680499167961808, 0.07238334363710197, 0.09193387453271007, 0.10626767220852873, 0.0839062069596812, 0.07667520749048895, 0.12185441599532898, 0.12884279495151763, 0.18651552932449567, 0.179666747186356, 0.12663986766258417, 0.12034724641526773, 0.22843596208388217, 0.16851853473719602, 0.16448867101278686, 0.15562369959993305, 0.13349922733210973, 0.12032792722691488, 0.12438492965408099, 0.13302919564195348, 0.13621546309305288, 0.15379607708485543, 0.13553604922555407, 0.10565861179080116, 0.13995620796791985, 0.912500731100245, 0.9427534927165565, 0.9197454617654489, 0.9485097187264984, 0.8937744020295242, 0.9220119044770974, 0.9529822095953486, 0.9437643789865628, 0.9293066311138716, 0.30821612390981634, 0.2897542077233919, 0.2933214922301086, 0.31189383129029025, 0.27224738238579604, 0.2911350478410901, 0.3037668967218906, 0.2830435426787473, 0.3035244767952422, 0.34025953159473865, 0.3336619901292667, 0.213850113007361, 0.22645493607114364, 0.5574089164292555, 0.2547249851665806, 0.1903690169243557, 0.1846091644646738, 0.23790442070734708, 0.18873544823316113, 0.22278264254060098, 0.23682638262505917, 0.1532603831949757, 0.1070462728351187, 0.19378869049349678, 0.19210715385639887, 0.19332876830821843, 0.15286882433743432, 0.14278299684334994, 0.14078957679360737, 0.2660882359704809, 0.1500941582315063, 0.14653611146661627, 0.15617787004504846, 0.1876678794973463, 0.12917722228613493, 0.17176066162969328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001395674411613257, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03724618953325187, 0.06711150700755275, 0.03378798958282592, 0.07187498326764075, 0.019139010001651524, 0.00024995122016047144, 0.05118203916402164, 0.08240094023247913, 0.07410119253797898, 0.11834924110385348, 9.999999999998899e-05, 9.999999999998899e-05, 0.003114160035279978, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13534688476612955, 0.10791976375470658, 0.12372889609821636, 0.09097787981409733, 0.09471588023506305, 0.08429096360665367, 0.1074699874530044, 0.08077702780864271, 0.08709676167472191, 0.441304330422289, 0.42483912399072543, 0.4447377465574184, 0.48323243691160256, 0.43911240576509813, 0.4222763208109911, 0.42096843346545254, 0.45118092933528164, 0.46034170109495853, 0.11772299723352664, 0.14445987442423736, 0.12016407516577277, 0.11814846013332447, 0.11019084305587434, 0.1102025442320006, 0.0968138999629613, 0.09460923372436758, 0.10086401479427243, 0.23330202115417598, 0.22501117502454737, 0.17606982112084402, 0.20589781663019058, 0.24974569081839393, 0.21137097868102295, 0.22738731511540555, 0.24887683247705272, 0.17266243392113234, 0.3158456482029611, 0.29436371449575016, 0.19915851870574186, 0.32516141782610475, 0.3079567703563012, 0.3275627254506682, 0.3193670188114137, 0.30745174682678356, 0.31879909138028295, 0.22452906836762254, 0.25033442764732683, 0.20204615255000857, 0.22917667247276063, 0.19526826399754804, 0.22122547809013704, 0.197027513185981, 0.2469101351920463, 0.2270590719897858, 0.2424113841211415, 0.21718414290422483, 0.24847080989099002, 0.20548129309619456, 0.19843331348821192, 0.23556884688611468, 0.2384192547633487, 0.19993175782903982, 0.23158222737027245, 0.202282278571431, 0.21934135838536384, 0.24213286553676294, 0.3206297679892067, 0.20935510842550165, 0.2213063177098311, 0.3320801066420279, 0.23715796149848734, 0.20364017506799081, 0.13581936738675782, 0.1874909793499986, 0.18470655012075254, 0.7199070164504049, 0.1706965455282089, 0.6603040007279453, 0.13580158047107105, 0.16793500719982624, 0.16231826543890715, 0.6108402430833568, 0.16807238200757824, 0.12530150749549174, 0.3148943599444115, 0.44457178423970745, 0.21805635200242357, 0.10453834474697543, 0.10508604034472668, 0.3055599743016657, 0.18645218291274057, 0.1767618500024115, 0.1790995471174749, 0.18139663015098484, 0.20407632135600617, 0.1714327940963869, 0.2059888635126491, 0.17943321714044924, 0.1726166026413839, 0.08358865900614088, 0.08716153314449016, 0.0902651507477098, 0.08335700366165422, 0.08427923309915952, 0.0842922813386594, 0.08278637681545098, 0.08235976632483688, 0.0913616279589996]}, "mutation_prompt": null}
{"id": "5dd2891b-bac0-49fe-9aa1-97c8182a4ded", "solution": "import numpy as np\n\nclass MultiPhaseQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Adjusted harmony memory size for better sampling\n        self.hmcr = 0.85  # Slightly reduced harmony memory consideration rate\n        self.par = 0.35  # Increased pitch adjustment for broader search\n        self.bw = 0.015  # Reduced bandwidth for more precise adjustments\n        self.mutation_prob = 0.2  # Increased mutation probability\n        self.elite_fraction = 0.3  # Enhanced elite fraction for focused search\n        self.theta_min = -np.pi / 6  # Extended rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.07  # Increased probability of local search\n        self.noise_reduction_factor = 0.8  # Introduced noise reduction factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.noise_reduction_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "MultiPhaseQuantumHarmonySearch", "description": "Multi-Phase Quantum Harmony Search with adaptive noise reduction and enhanced elite selection for robust optimization.", "configspace": "", "generation": 56, "fitness": 0.26473270530540627, "feedback": "The algorithm MultiPhaseQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7213317050518944, 0.7568656206818682, 0.7475532557835856, 0.7452043119550448, 0.7453945175550445, 0.7140703223744194, 0.714129086485346, 0.7504906538194323, 0.7104664114228711, 0.34606977092788704, 0.3143992941114735, 0.4113173456728043, 0.3214438414702331, 0.3037851018486918, 0.3886185548798685, 0.3459554285512836, 0.3428969137532224, 0.37691282114366564, 0.44103854790510666, 0.18857404734936944, 0.35578437693140186, 0.4328444693861916, 0.45172524338578335, 0.4657142093875496, 0.4173145344719593, 0.4785759429486194, 0.3460734244796805, 0.36270342624096896, 0.1839682219897143, 0.4236276909470744, 0.3192850457944848, 0.19020675964253686, 0.24197286421493336, 0.18286638350684736, 0.3087387843476863, 0.24332183667041518, 0.9580871291175298, 0.9226517522309372, 0.9197518734124762, 0.9116179406351879, 0.9188987681399549, 0.9021372345203738, 0.9028543343471551, 0.9040841401081264, 0.9360801544615465, 0.3097771103724759, 0.2793755040883056, 0.22974757431517367, 0.28963254113415826, 0.2081397596860518, 0.27526609575302885, 0.264029790537754, 0.22462874602019556, 0.26951896307314405, 0.20582057361098516, 0.2524134103152753, 0.22145765269242979, 0.274702088049793, 0.21005674394522333, 0.21070625971259638, 0.3043682962210623, 0.23517928713223257, 0.27288144471572817, 0.15026440566716215, 0.14912304025269274, 0.1337538976771322, 0.20244567039943173, 0.23358790790870831, 0.17089916385594495, 0.14548647720188546, 0.21048094252888028, 0.17637782563248527, 0.1454995569718751, 0.12879872596212028, 0.12006777974014127, 0.12596465330738016, 0.19827689477925492, 0.13402336516019098, 0.135773271101006, 0.12991492117562242, 0.13185514488790617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005306019030276943, 9.999999999998899e-05, 0.0291626044514538, 0.06992439288003771, 0.0872271005641142, 0.10109155935130931, 0.07349714351005077, 0.022986402093004066, 0.056676341962578536, 0.06446698331025491, 0.07395499349485568, 0.07755122872410536, 0.09847000984920362, 0.05761106033713481, 0.14859027732740815, 0.12427504252301935, 0.09062517476139254, 0.06721326826323437, 0.14079360733395296, 0.09045119081398567, 0.07969474890839134, 0.18141733026197981, 0.06116245678263077, 0.2169516980123284, 0.13132236265538244, 0.12086488589418021, 0.15655288948473245, 0.16849808292541402, 0.1212584924941994, 0.08236726785008863, 0.420857330361887, 0.4050625594748034, 0.4633914563751489, 0.44329984241162235, 0.48788041821802397, 0.44280755587874365, 0.4141698747213791, 0.38046914272810384, 0.4396973813002183, 0.10158258435630318, 0.12204943019335257, 0.1080721044409394, 0.09767267414651815, 0.09114301758112564, 0.1600598850978726, 0.11816859756953413, 0.12107301164682815, 0.09686591342685047, 0.16018087943540193, 0.20566688206222838, 0.14410540031742092, 0.15130331446646073, 0.1405013814493139, 0.18782565072413993, 0.13956976433500745, 0.1463909138999303, 0.14051913330818155, 0.24633532270797454, 0.241102387463899, 0.3057546870127896, 0.25223411231190496, 0.40867859004797824, 0.2612951062304302, 0.3640750335554003, 0.4057455792793101, 0.3753822926898369, 0.24897621831469885, 0.2453852990222909, 0.23269911289883238, 0.21670528509466247, 0.2197598297076504, 0.23168119694212475, 0.20960384991093095, 0.2930163441881989, 0.29316390894025623, 0.20836994816218257, 0.20269734121421912, 0.2121004377882164, 0.2069775163894515, 0.20922970269784102, 0.21236020610528417, 0.20132265473545574, 0.21178961073517621, 0.20510464287550245, 0.5227524885586828, 0.24354525586547515, 0.22986217701328082, 0.19021787635891085, 0.2254509770847144, 0.20535871460898747, 0.24945422805112272, 0.21593110767514367, 0.20131668209029607, 0.1853733817518637, 0.2933719370975859, 0.1833415047089142, 0.532008051080097, 0.561756489754597, 0.6893483476156763, 0.164698595444859, 0.16584549246825087, 0.1571959781679112, 0.309266647233175, 0.26965227683899085, 0.16189666009307424, 0.20713235099243388, 0.16648039639026446, 0.20755456851681842, 0.10518085414894363, 0.35145474278064925, 0.2649315717958436, 0.18606865653115623, 0.19614836377447564, 0.18160275183904384, 0.20236774526583845, 0.1788477917137341, 0.17867584756726662, 0.19567581751753838, 0.17953769211988113, 0.18335795023090362, 0.09069280263155433, 0.0777420567542404, 0.08568701727024142, 0.08339869043198322, 0.09469745142251063, 0.07569369721618846, 0.08651250824774104, 0.07817492332685327, 0.08670671547181741]}, "mutation_prompt": null}
{"id": "755ecab4-4036-4f14-b835-9519a223ebed", "solution": "import numpy as np\n\nclass SDEQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Reduced harmony memory consideration rate for more exploration\n        self.par = 0.25  # Pitch adjustment ratio adjusted for enhanced exploration\n        self.bw = 0.015  # Reduced bandwidth for finer adjustments\n        self.mutation_prob = 0.2  # Increased mutation probability for diversity\n        self.elite_fraction = 0.2  # Smaller elite fraction to encourage exploration\n        self.theta_min = -np.pi / 6  # Adjusted rotation angle for balance\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.8  # Modified chaos factor for parameter tuning\n        self.sde_factor = 0.1  # Introduced SDE factor for stochastic perturbation\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos and SDE-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.15 * chaos\n        self.par = 0.25 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                stochastic_perturbation = self.sde_factor * np.random.randn()\n                new_harmony[i] += rotation_angle + stochastic_perturbation\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "SDEQuantumHarmonySearch", "description": "Stochastic Differential Equation-inspired Quantum Harmony Search with adaptive momentum and time-varying stochastic perturbations.", "configspace": "", "generation": 57, "fitness": 0.26404647137808945, "feedback": "The algorithm SDEQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7239154522207607, 0.6409907537132368, 0.7350139501925617, 0.7162723529862983, 0.7015731722270748, 0.7159971513313568, 0.7286415909368247, 0.7028723802982707, 0.6745655542228064, 0.33369522490017, 0.34278461099670277, 0.31237148494281997, 0.35274642578724646, 0.3169352127720818, 0.3277541732247259, 0.34784449315095256, 0.34150348355402005, 0.28199408795024183, 0.18684347216732833, 0.441363777204973, 0.4495710369497037, 0.4649488318898609, 0.44009347860945514, 0.2554236780137107, 0.2516854456292126, 0.438962903741837, 0.2831867952106609, 0.39012251089271444, 0.17601283111792365, 0.23533741981006062, 0.2728950670694129, 0.1792237063789358, 0.25418803228992504, 0.25768570648255773, 0.42766296271645865, 0.3873212378496478, 0.9042310410908907, 0.9045467760996497, 0.9032175549625647, 0.8890818913913605, 0.9170211124666368, 0.936440734970523, 0.9363462233735517, 0.9346662542500321, 0.9357058311989169, 0.22476084464077883, 0.2550907724808642, 0.28705882920459314, 0.2931336500725954, 0.2686575738284773, 0.28933132959615226, 0.24775433255956414, 0.24899819939059942, 0.2294726944165728, 0.20873477183481515, 0.2244002834711194, 0.14618122768189046, 0.240689925577243, 0.31785768092515476, 0.269764286543153, 0.4392621949876544, 0.21428164800609384, 0.1728614573131283, 0.21837651828487292, 0.2235897019886255, 0.15939779166669454, 0.2384490421075529, 0.3261001426488438, 0.23849732747401498, 0.15182018513562467, 0.18507383008856892, 0.15349838881068556, 0.1293712320679895, 0.14606356819128763, 0.13552422550445298, 0.15216798839524837, 0.1417430979045624, 0.14516940255752286, 0.14440058042380677, 0.12996594203986644, 0.18647769838779304, 9.999999999998899e-05, 0.03142601836495762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007125470807799683, 0.05240710280953842, 0.07760306729623112, 0.04247037457905556, 0.08280089971243743, 0.11483092059448063, 0.1012079418597559, 0.053030121658726004, 0.06670604144683256, 0.061184458009485354, 0.07003460745292356, 0.05215236807853274, 0.06557481255174502, 0.13524532327900418, 0.11368513640398947, 0.08383367380593698, 0.08063371381272677, 0.16281009283740255, 0.13212755788642205, 0.09274121497998711, 0.10365548028916294, 0.053850009528480736, 0.1113115698913465, 0.18817473090108872, 0.07406298450366433, 0.03902899120081216, 0.1288249738302798, 0.14050570707445864, 0.1646369636150019, 0.08953136967392838, 0.3995717324155674, 0.4185695873486709, 0.43984282430715727, 0.40328144692579293, 0.4206314338590411, 0.4238172662039831, 0.40717757626799134, 0.4413335120444819, 0.4780117793105291, 0.08762751285420634, 0.14328489352378804, 0.14464018965798464, 0.11109034787910077, 0.1051569367868096, 0.1458270649009934, 0.08038043515829452, 0.12916741216090322, 0.1309596952322658, 0.15286334636128363, 0.16535748998149846, 0.183615862165734, 0.14648425167549262, 0.16267673147493555, 0.13170740308671736, 0.18394956995825573, 0.17012412242954056, 0.12665575264701456, 0.26857349123206486, 0.3015602905720338, 0.293652262457064, 0.3241856224803056, 0.3396088175264502, 0.4008184409254102, 0.36615794894220777, 0.32561255474216755, 0.3595300524248132, 0.1585107037161093, 0.30658897819183617, 0.18041037086256706, 0.22255784092262842, 0.22921844125482493, 0.2526852655913079, 0.19344862059310775, 0.1682750048235162, 0.20950057387617738, 0.2169598969437524, 0.22018652484214163, 0.2130892253647957, 0.2046943046334453, 0.20756466400999785, 0.22293612335827862, 0.20707645589114276, 0.20473441772841572, 0.18749576927717193, 0.21483419227012757, 0.22357843445618497, 0.22772409243584124, 0.30862488788499254, 0.36769560742213914, 0.4488073217962013, 0.21231815459024905, 0.21977100790523252, 0.21189568153084937, 0.1709901987973682, 0.18418298249702414, 0.18569606534803018, 0.6119907117655665, 0.43110729960878436, 0.5438836523938817, 0.1565162759690002, 0.15058198932901778, 0.16185904170814247, 0.4819864109092805, 0.16468954970443306, 0.16780346105787125, 0.20891563048540418, 0.1666784225167346, 0.2097850803426261, 0.24466916097511093, 0.5586535486635007, 0.2917018129245412, 0.18162281710558004, 0.172134968635821, 0.19061635033305702, 0.19419019638257595, 0.189183923465704, 0.19347570652705248, 0.18771057511661293, 0.18390144812258435, 0.1884100690628696, 0.10339852637374114, 0.08291778117101845, 0.08561389175778855, 0.09682344878564841, 0.08849667674940609, 0.07868690817110857, 0.10368500590558527, 0.08025669230596899, 0.077583382423976]}, "mutation_prompt": null}
{"id": "1f90a9fb-acca-4338-999c-f7f853993ee3", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7\n        self.multi_layer_chaos = True\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        if self.multi_layer_chaos:\n            chaos_layer = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n            self.momentum_factor = 0.85 - 0.1 * chaos_layer\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaotic multi-layered adaptation from elite harmony refinement for improved convergence.", "configspace": "", "generation": 58, "fitness": 0.28163485402956734, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7662210288508716, 0.731141765681264, 0.7689677350671649, 0.7750782247552487, 0.8154482071524201, 0.7873307735237024, 0.7927126004529732, 0.7449586132453918, 0.7823789167096499, 0.3707589794511179, 0.39473277301349596, 0.3797701148329091, 0.4237333207759775, 0.3500529483736652, 0.43031153918894305, 0.3966681341200494, 0.45346333935557714, 0.3590721752498951, 0.4959223250524639, 0.4043218442907863, 0.4842782819844006, 0.5179714109064085, 0.4280789259923723, 0.3058622273504995, 0.5101859679547481, 0.46926323855195384, 0.4862063863160585, 0.45417509850768356, 0.43650149157262774, 0.43188739507589113, 0.2854603689976327, 0.3946618644648965, 0.2165922268193724, 0.18597766412944294, 0.46456696148201626, 0.22489609660218268, 0.9557014967162496, 0.9380154930892151, 0.9341402697695765, 0.9397281763283586, 0.9570289999905256, 0.9544748104062244, 0.9417495784323525, 0.9549858317801385, 0.9516781693628263, 0.24052164603327353, 0.25664021088865596, 0.22209533975856588, 0.3069264855077354, 0.30134503871052853, 0.3430619147334313, 0.2817662439030736, 0.23414275279471808, 0.25839888316128634, 0.3169867485171999, 0.2226802939438508, 0.16548101746138177, 0.37027036808584246, 0.3712886838280479, 0.2745591208475806, 0.1672322651397693, 0.22036282050622458, 0.3665512252387424, 0.1933859387838407, 0.37016231810011735, 0.1403614890946392, 0.2232527667904498, 0.20762323695222218, 0.14803161549113064, 0.26653631379813436, 0.25817902543109916, 0.14744236968632618, 0.1321657758981737, 0.13654640944294483, 0.16281993926816374, 0.12724381930374185, 0.14631005061274138, 0.13404458831685317, 0.14835605080561687, 0.13727132673901254, 0.18104323961515778, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06041249162454987, 0.06698048608922635, 0.09733120571666609, 0.07025269694506642, 0.05387314481981886, 0.04500145945938272, 0.07056325965898091, 0.10009365883184362, 0.06632106060022602, 0.11218391292602736, 0.2330354493395107, 0.18752779742975245, 0.08328591564809995, 0.09044836057424344, 0.09697932523601516, 0.15667031112581153, 0.19255977022143678, 0.21631113790327916, 0.2584153872951399, 0.06852376698785778, 0.2093549961906176, 0.19090837450086806, 0.14624950730546593, 0.1571500311848144, 0.17770475505839345, 0.15445791454043867, 0.12242649249945226, 0.4108744319978056, 0.4708583013441605, 0.3982611068769878, 0.4232190893614767, 0.4820303336108466, 0.4520875672579472, 0.5261952953376778, 0.42801489362855705, 0.43563765046398717, 0.17004234442674204, 0.09335492373683463, 0.09464301827231614, 0.10931829174432883, 0.12971653097435887, 0.13062451337031966, 0.14613207911112458, 0.12880105061911395, 0.1201360572846728, 0.12312094301417531, 0.1549600238925345, 0.22752271562920334, 0.1738525302913504, 0.1743521885087823, 0.20002054372264944, 0.14080986273085072, 0.19229185664303372, 0.15955314887816952, 0.26028551778075115, 0.278475348108723, 0.2410497741065173, 0.38188105881791456, 0.27430886644263075, 0.37374430799278857, 0.4315279076006733, 0.45739680743184086, 0.2241830835523021, 0.188395239468779, 0.2576806964335443, 0.1735800128228444, 0.17013781217759882, 0.29210242297434186, 0.23781621046272294, 0.24739783120767922, 0.18241001532392231, 0.26917967746834737, 0.22158721004974058, 0.20489287025978908, 0.20788299061694226, 0.24939800094408449, 0.20875815719568058, 0.2144714018809899, 0.22094558734452208, 0.2070540144455817, 0.2144727340410223, 0.6315243961036807, 0.20042156048331028, 0.21242868971446205, 0.200503367458308, 0.25964873921351384, 0.22712212929075382, 0.22771926677763876, 0.20223823658208973, 0.22914920197787192, 0.18266106791297476, 0.16538169548865356, 0.18715465179830226, 0.6908420063948113, 0.18652281246470892, 0.5749400544052454, 0.16634077051921536, 0.1667551691131508, 0.16083763114534488, 0.3031584356324879, 0.16658932858003117, 0.12678714864323737, 0.20749641866391322, 0.17754064178759288, 0.21258347193399219, 0.10209949472519131, 0.4462411278364594, 0.17790701238944673, 0.18068524487684612, 0.18812658153910056, 0.18826803113250978, 0.18411949237333758, 0.18692452417901018, 0.1946779878202065, 0.17385221988374744, 0.17879558900280224, 0.2138989833117909, 0.09602944545340852, 0.08403101337091323, 0.09647598112240663, 0.0824606748528911, 0.0950490692819469, 0.13088305220304808, 0.08327999379938011, 0.08750437644194864, 0.0939010383920984]}, "mutation_prompt": null}
{"id": "26719cd1-10a6-437c-bbc5-061395a7e903", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.88  # Slightly adjusted harmony memory considering rate for diversity\n        self.par = 0.35  # Adjusted pitch adjustment ratio for exploration\n        self.bw = 0.015  # Finer bandwidth for local tuning\n        self.mutation_prob = 0.12  # Reduced mutation probability for stability\n        self.elite_fraction = 0.2  # More focused elite fraction\n        self.theta_min = -np.pi / 6  # Expanded rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Adjusted momentum for exploration-exploitation balance\n        self.local_search_prob = 0.08  # Increased local search probability\n        self.chaos_factor = 0.75  # Enhanced chaos factor for parameter tuning\n        self.multi_phase_learning = True  # New strategy for multi-phase learning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.88 - 0.08 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        \n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        \n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.08, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with multi-phase learning and chaos-based dynamic parameter adaptation for robust performance on diverse optimization landscapes.", "configspace": "", "generation": 59, "fitness": 0.27809407285574295, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7909208700589813, 0.7777193586777711, 0.7856493659077535, 0.7830668597237017, 0.7526128237309471, 0.7686060398107866, 0.7598996670423361, 0.7525006009512505, 0.7764568348971777, 0.40108513311379757, 0.37133770565723667, 0.4207458750763362, 0.4227026954849502, 0.4222218120461405, 0.38605029051037887, 0.37298688482012643, 0.4309193517957791, 0.39582376057755386, 0.5043816691946785, 0.5666346028501132, 0.5131431479795159, 0.5613640370880513, 0.47691572479852706, 0.5474328488790401, 0.522489567624581, 0.4936099139142648, 0.5810614614279195, 0.2439764945832158, 0.35289508424661054, 0.2310688855876264, 0.19993622664521582, 0.20654192784292058, 0.4872184290148994, 0.17655946547937018, 0.44552213884973324, 0.4604671916010782, 0.9421431458308075, 0.9296812735730783, 0.9390191182847711, 0.9217897153442972, 0.9432752804162327, 0.9156557708010539, 0.9053385650891017, 0.9199606671652945, 0.9283451754097024, 0.22235915474713186, 0.249942701864451, 0.22793041626033417, 0.46126324754361403, 0.3146635573652714, 0.27108047373742694, 0.23802553830634343, 0.22837801133847102, 0.27212441409240773, 0.19320200818962208, 0.15051734398505145, 0.16807255867652915, 0.3733005075578586, 0.27618344392121497, 0.20695470879674072, 0.17344414514675643, 0.28355931542980783, 0.1878878467876539, 0.20985836158330184, 0.250035831016335, 0.20846641157349455, 0.14158215142810326, 0.14249601993486993, 0.35842324800620096, 0.1563300960419538, 0.2947667398467123, 0.16152462014971403, 0.16214436452235004, 0.17125638318682446, 0.12718188241022854, 0.13726145930866462, 0.15284009489936456, 0.19995860133544108, 0.15256131382537919, 0.13444758384335487, 0.13553328053954117, 9.999999999998899e-05, 0.008422137693227194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06493999326387911, 0.051397441175741965, 0.07602897277093412, 0.06629184080395045, 0.008423375804633149, 0.047338821111572726, 0.11236728451730138, 0.0721746025952551, 0.06537151486117965, 0.056953932570028565, 0.22388253054813978, 0.21394648482088696, 0.07970221522881571, 0.06905145732297202, 0.11798182868777607, 0.21206441377148744, 0.22094883788999853, 0.1576641844387825, 0.1063486694103174, 0.07662810799335784, 0.17164390648539973, 0.09467197673894645, 0.16032625014591306, 0.13941741292570464, 0.14683655873667467, 0.19541134418586437, 0.07910444016086582, 0.4489586762829494, 0.43754512558483194, 0.39232270463302776, 0.4433645797971928, 0.5390659780673519, 0.4431711620467669, 0.444009978533375, 0.471939404417548, 0.480675854992231, 0.10331010465781565, 0.1446320169382801, 0.12671116096052715, 0.13216257590071945, 0.12002421504993888, 0.1341202371219471, 0.11607322999974234, 0.14374210794256836, 0.08994695196152103, 0.1594502607816577, 0.13590005802928795, 0.1447941158648649, 0.32028559455067107, 0.16485670449767242, 0.18656366447480677, 0.18636395567402808, 0.20308824364843492, 0.1367079146660204, 0.25713917444995604, 0.273534284187829, 0.23855787018231978, 0.3533956447017106, 0.22991786598478714, 0.3074799993386248, 0.3760066477273639, 0.33274752654359663, 0.24788609943088102, 0.19946560437702843, 0.2059969562650198, 0.15996064364486462, 0.28792799136137326, 0.15948557426083065, 0.2856123331415428, 0.18747689865160488, 0.22552356866395473, 0.17070065039243731, 0.2065892693595015, 0.23032375296949736, 0.20909285405731748, 0.22572079414734114, 0.2001531250321008, 0.20388511540845589, 0.22096617130829632, 0.21015092149001224, 0.23741732207362987, 0.6441879118875795, 0.20223190925570544, 0.23702627194063675, 0.22866655008984538, 0.6218120833981743, 0.24528320308738738, 0.20026973431266082, 0.18879635129054706, 0.2068841725386238, 0.17355715555320517, 0.12529390166675114, 0.18590828389822145, 0.25555763876516446, 0.14774810016708395, 0.19897393867564828, 0.16344385831603536, 0.17459148653315537, 0.5245983971290269, 0.3162287962562462, 0.1676669006432019, 0.2997941637988275, 0.21553219748494556, 0.20809884308657123, 0.2091094320569059, 0.10321561035720006, 0.37767349666560335, 0.2360038012423452, 0.18135628163059214, 0.18758759902662636, 0.19017312170172618, 0.22131060755001963, 0.19133945139984354, 0.17683342247141887, 0.17529075771821268, 0.18095022719147114, 0.19002875948102538, 0.096699139308425, 0.10276842282863707, 0.10611797876714368, 0.0848027491996961, 0.08434417864417154, 0.09925621572668697, 0.08913805093682803, 0.09558706106799186, 0.08424845260218061]}, "mutation_prompt": null}
{"id": "4fd2d622-2a82-48ae-9042-977ae8864785", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "26d539ca-32d2-4351-9d34-b8f094942de5", "solution": "import numpy as np\n\nclass QuantumSwarmHybridHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.8  # Slightly adjusted harmony memory consideration rate\n        self.par = 0.35  # Tweaked pitch adjustment ratio for improved exploration\n        self.bw = 0.015  # Narrowed bandwidth for finer local tuning\n        self.mutation_prob = 0.12  # Adjusted mutation probability\n        self.elite_fraction = 0.3  # Increased elite fraction for stronger influence\n        self.theta_min = -np.pi / 6  # Adjusted rotation angle for diversity\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Enhanced momentum factor\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.65  # Updated chaos factor for better parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.8 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def swarm_update(self, harmony, best_harmony):\n        inertia_weight = 0.5\n        cognitive_component = 0.3\n        social_component = 0.2\n        velocity = np.random.uniform(-1, 1, self.dim)\n        new_harmony = harmony + inertia_weight * velocity + \\\n                      cognitive_component * np.random.rand() * (best_harmony - harmony) + \\\n                      social_component * np.random.rand() * (best_harmony - np.mean(self.harmony_memory, axis=0))\n        return np.clip(new_harmony, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n            best_harmony = self.harmony_memory[np.argmin(harmony_values)]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_harmony = self.swarm_update(new_harmony, best_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumSwarmHybridHarmonySearch", "description": "Quantum-Swarm Hybrid Harmony Search combines quantum rotation with swarm intelligence for enhanced adaptive search capabilities.", "configspace": "", "generation": 61, "fitness": 0.2003323650431962, "feedback": "The algorithm QuantumSwarmHybridHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.40258668055563485, 0.4191031862658685, 0.3809806180230608, 0.39586651181531984, 0.37116470865455353, 0.3870653858852764, 0.38467378617903314, 0.37043232217148503, 0.37346555882838006, 0.008968228840983694, 0.002221380724295563, 0.04554578321457192, 0.05298578427935152, 0.014183251681910924, 0.014689383983022664, 0.0021656854244623824, 0.05147280411714206, 0.014335482456833581, 0.13869375295202868, 0.12136011537911529, 0.13090021581175937, 0.12258813913646227, 0.11190965059972624, 0.12913584864383443, 0.15825405885640975, 0.13144702741218117, 0.11060864738858511, 0.10175048371180673, 0.09645063075733307, 0.12446039545259813, 0.1077723537590557, 0.1081296218275245, 0.10647322409963433, 0.11692074132314323, 0.11850257207068005, 0.10327324476738153, 0.9349384962031733, 0.9147724361533127, 0.8399856688573935, 0.9218843595214494, 0.890624030336375, 0.9259147491724992, 0.931745805222225, 0.9183185551248909, 0.9420044049852784, 0.21227687626812386, 0.22140650743613288, 0.23307482952693637, 0.23697281630502687, 0.23752523591483576, 0.22962716770749325, 0.23136372325355992, 0.24154975564443792, 0.21543728024099562, 0.2832499943418174, 0.22847145699125315, 0.28929005459977253, 0.27939502243674086, 0.28118707720608704, 0.2900564649161652, 0.2266438040314216, 0.22313856722339043, 0.23750388467195016, 0.11206637392886132, 0.13630732672338197, 0.13819401796825148, 0.13526881372427635, 0.14118491419805146, 0.1327708491544174, 0.16234978393963861, 0.16368273329190963, 0.133170459016536, 0.1362261962967738, 0.09584329501692412, 0.12154969734710908, 0.13316205166584527, 0.14258245179077134, 0.1428245522318885, 0.14044915281660486, 0.13918301045998593, 0.1324791526958914, 9.999999999998899e-05, 9.999999999998899e-05, 0.039208689428885224, 9.999999999998899e-05, 9.999999999998899e-05, 0.01306177432141542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09617824946505193, 0.050048932314311734, 0.09612523965479991, 0.05819971732354845, 0.08977304745389647, 0.03344912515843046, 0.07567946077851462, 0.08113775372405685, 0.0906173667060699, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0750261442924568, 0.07016811185621719, 0.07935296867412744, 0.06077188601737238, 0.07047479542857926, 0.07675228782818944, 0.056989851650113055, 0.06400779005384816, 0.07276635230719564, 0.3430364356756379, 0.35113850452465045, 0.36150375080822583, 0.36874876617983177, 0.38889216891440515, 0.406064538436805, 0.34183895892765603, 0.3570898254058189, 0.37970459890267494, 0.10058322396674779, 0.09747264588034033, 0.09419776440068384, 0.09130801519316434, 0.10835084414886464, 0.11501174146956528, 0.13785454619955995, 0.09442767779087302, 0.10163864007819323, 0.14448181666569904, 0.1486507440253454, 0.14561279467116361, 0.13366153467578423, 0.17005398909251235, 0.1349698208592628, 0.19217294356446057, 0.14698012409778372, 0.13825147725298448, 0.24967867137696065, 0.26126372291288, 0.2850081868086598, 0.25910347449001503, 0.2743497572805065, 0.2561563485139583, 0.26757730262674706, 0.2670244681778411, 0.27082812486887453, 0.18785198404572423, 0.1989310998670506, 0.1674880604030452, 0.18692183862083556, 0.19734288317592386, 0.20049703872089408, 0.1967513054292367, 0.20501856365258397, 0.20317042290510756, 0.22047474447535886, 0.20629416921209853, 0.21498025540353638, 0.20984709784003375, 0.19928326702980137, 0.20721890161068024, 0.20869003394528673, 0.23088235488250985, 0.22050352577360421, 0.18393216502454512, 0.17707746217197728, 0.19520083062523264, 0.22919573885212197, 0.22113674151728724, 0.186035464246185, 0.1906577686636215, 0.19229113766658312, 0.20273179042639922, 0.5213751129892354, 0.18452185178106661, 0.14714865147570677, 0.527518330098826, 0.19710949352858775, 0.19870562298324357, 0.12173186207839826, 0.16955370867792985, 0.4914065781637159, 0.5168783561959678, 0.3826840008812522, 0.3973123119363249, 0.20759736256251993, 0.17586280961939849, 0.21159862157462617, 0.16752053321061544, 0.3964884265633608, 0.10408437445241647, 0.18362001965019292, 0.2084208165031931, 0.18778964176150814, 0.16894122857085914, 0.20881917076450263, 0.195282789602932, 0.1871314480469578, 0.18442930953524783, 0.18169003204801637, 0.08446365808855949, 0.08936617483441445, 0.08014819846222454, 0.0863954186183673, 0.08793873647291528, 0.08485987265230632, 0.0922873288972873, 0.08608876371004259, 0.09034496923787605]}, "mutation_prompt": null}
{"id": "e5f8365c-f3c0-49d8-bcba-3a6ee33a6448", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.35  # Slightly increased pitch adjustment ratio for enhanced exploration\n        self.bw = 0.03  # Increased bandwidth for broader search range\n        self.mutation_prob = 0.12  # Balanced mutation probability\n        self.elite_fraction = 0.3  # Slightly increased elite fraction for diversity\n        self.theta_min = -np.pi / 6  # Improved rotation angle range for flexibility\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.07  # Increased probability for local refinement\n        self.chaos_factor = 0.75  # Enhanced chaos factor for dynamic parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.15 * chaos\n        self.par = 0.35 + 0.15 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.07 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.15 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Adjusted perturbation scale\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedAdaptiveHarmonySearch", "description": "Quantum-Enhanced Adaptive Harmony Search with dynamic chaos-based exploration and convergence control for diverse solution discovery.", "configspace": "", "generation": 62, "fitness": 0.25698139865182495, "feedback": "The algorithm QuantumEnhancedAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.688746103932314, 0.6738623422340173, 0.6280273663377742, 0.6210757399765265, 0.6599706657725145, 0.6458347656688044, 0.6429894105455785, 0.600037056659974, 0.6250017341905469, 0.3350969670689975, 0.3287849736121732, 0.3259771020286829, 0.28074503040539467, 0.31420570513828583, 0.28705851915380354, 0.3396116111305465, 0.36113755097199884, 0.32917965237752267, 0.1847782285677112, 0.3617043394945485, 0.3748493168302439, 0.3206033180887653, 0.346820783529324, 0.3340961499859175, 0.39557721377661637, 0.3988009548116481, 0.33476963028142204, 0.17853088482207835, 0.341070596036526, 0.29935498072988254, 0.32128565553565236, 0.3264877721063192, 0.364375024630332, 0.2388303191818869, 0.294524449983416, 0.17777091374048215, 0.8943454128910392, 0.8640652868786467, 0.9084182767625979, 0.9006253393433667, 0.8863375843713811, 0.9194355519691229, 0.8491132356271471, 0.8709191195452386, 0.8510930122038816, 0.2417390319194216, 0.28543033531922124, 0.3116839544059491, 0.3155675224712734, 0.3281014107366842, 0.2690668075169509, 0.26866556947848763, 0.24159196530233829, 0.2717368639037867, 0.28937175054925024, 0.22001104996689214, 0.15641584461704483, 0.25916290795874497, 0.3393171996315002, 0.3475204280012416, 0.17352159499476405, 0.23433437749631003, 0.31391281885347566, 0.15176111182497554, 0.1599581828930181, 0.14181589955962082, 0.2107618906185672, 0.15379005229603304, 0.16208734686925563, 0.35267308745350634, 0.2249544304965323, 0.18245618527330776, 0.15659387645163536, 0.13924055153946102, 0.13566170084196638, 0.13684182729489203, 0.15957425929347935, 0.15084352527390787, 0.13499179575951348, 0.12704210494562596, 0.1234131018703718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009622398271626142, 0.013132534826949982, 0.057099313440820865, 9.999999999998899e-05, 0.09301176707027958, 0.049253387991451736, 0.06676705920218662, 0.05339908668644677, 0.0359049987252027, 0.032282158846227094, 0.03536463999167261, 0.08870883024649667, 0.10515628158017176, 0.04962352791309643, 0.10950067073212444, 0.04145724757882452, 0.06875724696365759, 0.17103037994234183, 0.06011278932582842, 0.09579358789172587, 0.1284123078476378, 0.0840568065728472, 0.125143760947117, 0.13766106868547778, 0.17791581712080606, 0.14951609971437552, 0.16472008289927675, 0.14603877024749268, 0.16106524054058957, 0.1479719586794136, 0.17986222303910238, 0.42160630829634405, 0.4202891064505878, 0.3972302796524336, 0.5026867699820168, 0.49669340207959534, 0.4125617032451192, 0.4403789614415088, 0.42616928104835883, 0.47821369287824145, 0.11735620643320888, 0.08977422118315537, 0.14285648433998466, 0.11969613619876929, 0.10853157798096358, 0.11452431586855638, 0.12046619835667838, 0.15757342198803148, 0.09656524356948071, 0.14673558445717827, 0.2037316559497595, 0.17241111106119078, 0.13449642778386928, 0.1257524344928681, 0.1842198503197967, 0.17352753836588086, 0.13921482525060325, 0.13328193852732584, 0.34816787899161405, 0.2840033340719832, 0.34263351571003964, 0.2831783406397471, 0.2663425512343036, 0.3132878353199554, 0.30521917916285934, 0.3158087551375669, 0.3618819832369421, 0.22229606074316066, 0.21776736389871654, 0.17217876161621493, 0.25320052334668863, 0.23166211838684325, 0.2547331551913158, 0.22013547914819276, 0.23706064001401972, 0.20972490837243607, 0.20907650723554927, 0.20125010856771297, 0.19535580158775123, 0.20760165337769942, 0.2523141086264039, 0.20620671752354047, 0.20136975368313814, 0.20884729000755164, 0.19437383732467384, 0.22444634725354062, 0.21819860628271603, 0.24517050988920353, 0.21318299228276238, 0.1982481843085233, 0.19039948016584807, 0.21992020151157465, 0.4274514777547217, 0.1915343610580028, 0.18453241641911056, 0.5920414770386655, 0.18499918981638397, 0.6951851173827795, 0.7391946682103563, 0.16634512032046278, 0.1649888724280557, 0.17017390536773913, 0.1580805937612042, 0.4080486935767773, 0.1702606846217255, 0.14946238127525813, 0.2000511747213347, 0.20788057042940222, 0.2084884164678974, 0.10321528731652851, 0.20014216544701335, 0.18347107264301687, 0.1789137046922118, 0.17584278436915501, 0.1753823200004817, 0.18494724035680932, 0.1755539043240102, 0.1730059743755904, 0.1830128730744518, 0.18369961188136363, 0.17958811099953598, 0.08440854598676584, 0.08018404459417183, 0.0863583274730858, 0.08448548497901975, 0.08461701446928294, 0.08416029681580439, 0.07980726029296326, 0.09126224909598024, 0.07893549777385833]}, "mutation_prompt": null}
{"id": "dba26e17-b9f8-4709-8a08-2e6c34499e38", "solution": "import numpy as np\n\nclass SelfAdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Adjusted harmony memory considering rate\n        self.par = 0.35  # Enhanced pitch adjustment ratio\n        self.bw = 0.03  # Enhanced bandwidth for better local tuning\n        self.mutation_prob = 0.2  # Increased mutation probability\n        self.elite_fraction = 0.3  # Increased elite fraction for better selection\n        self.theta_min = -np.pi / 3  # Wider rotation angle range\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.75  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.35 + 0.05 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.05 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.05, size=self.dim)  # Increased perturbation precision\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "SelfAdaptiveQuantumHarmonySearch", "description": "Self-Adaptive Quantum-Inspired Harmony Search with chaotic elite selection and dynamic mutation for robust optimization.", "configspace": "", "generation": 63, "fitness": 0.25825439411634904, "feedback": "The algorithm SelfAdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.6454759478468679, 0.6608239227293888, 0.6943276028579672, 0.6450192813435127, 0.6960283434583969, 0.6705755950120573, 0.6715022074464616, 0.6755315798412214, 0.6773973686613308, 0.31931006475655554, 0.31293816254715534, 0.3139400998433336, 0.3191465039797071, 0.2533212227082615, 0.3038450084260115, 0.3246326380393705, 0.3179919568677243, 0.3068286183580301, 0.40255256360680425, 0.40837423578355947, 0.3827321417959876, 0.3893878878164916, 0.400773531685244, 0.460084314501207, 0.26700877179257687, 0.3927968394179716, 0.29286117876851747, 0.18807105472636054, 0.40616270442065594, 0.36686413589063893, 0.17888458246025762, 0.2381757448191828, 0.20844162779450914, 0.2125003446514231, 0.40301717220436695, 0.23584410337038253, 0.9366686454920857, 0.9392475527836772, 0.9261380039513207, 0.9402127796000529, 0.9203845359398652, 0.9262076866361835, 0.9273681115140207, 0.9324318824957017, 0.9268996669952959, 0.20087811911301134, 0.31476368722367853, 0.29573787830769704, 0.2572139736499486, 0.3735135138363286, 0.3021928195440432, 0.20393329095548296, 0.2366070424258534, 0.22423743832064402, 0.24971626103071065, 0.21671610127636276, 0.15553871641429595, 0.345890678162285, 0.1755880059489815, 0.2787776711493095, 0.18496735489813243, 0.17611646127795544, 0.2127043361264146, 0.2616018758792268, 0.14145663015867194, 0.311794982852178, 0.1482586272239409, 0.15559727647679156, 0.1503933641290821, 0.24663106865718187, 0.20083663128424245, 0.1358602827240868, 0.12973977284199556, 0.13588310875795673, 0.12728564214090987, 0.13175507206766857, 0.14509984126476883, 0.13114942289867648, 0.1344458575381685, 0.1476993252448674, 0.16326590126275764, 0.0001252925022250384, 9.999999999998899e-05, 9.999999999998899e-05, 0.002710984830756602, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0493329922639123, 0.07654024289885109, 0.059393896558881165, 0.09939224073646324, 0.04463694230908366, 0.04169018556327031, 0.026829949830781685, 0.1065726398748208, 0.05643584415021796, 0.10918742548596272, 0.12698898536510206, 0.1388593614135385, 0.13482802708030217, 0.07768742897140979, 0.06691565900220009, 0.07302909324317441, 0.05788884676691197, 0.13528839430272765, 0.06168315948401726, 0.12033741115870378, 0.10873242263206706, 0.12287941796336, 0.09454706598247908, 0.20132037663393365, 0.09155955740295363, 0.15877159778126404, 0.1189936814321545, 0.08266729299494868, 0.4125444989782432, 0.45655686930601136, 0.3894693969891422, 0.433054822896218, 0.40548193749125716, 0.47732698397316786, 0.46001772694598664, 0.47953231888676373, 0.4415269498561655, 0.10328302542080747, 0.11903590891802762, 0.1158524291256775, 0.10202022220752827, 0.1305077599991078, 0.10809402933531242, 0.10354154840882568, 0.0965811128483518, 0.07290807107507735, 0.18951899342738976, 0.14022648250549552, 0.12721602819311306, 0.1284653059572931, 0.13715648702433214, 0.1506634014825966, 0.14941537162608898, 0.13911564022373513, 0.22653433370649678, 0.22441291153701315, 0.34256163021362507, 0.367394823215747, 0.3173740698419292, 0.33865242164388387, 0.32328425061697497, 0.36450811572739916, 0.33661649387426995, 0.3434381519741262, 0.19857666220359715, 0.2933618128304748, 0.15409843787376742, 0.20556838391505927, 0.1803739122313296, 0.24364024112886007, 0.17467351899776717, 0.3042923291848276, 0.2499787617187721, 0.20246635069481278, 0.2173814383872661, 0.1961747827004109, 0.20513928251949543, 0.20854101076244747, 0.19574811570274275, 0.1978830445577633, 0.19289644334078448, 0.21926040721882822, 0.21563728686247485, 0.20237939970437635, 0.22024028924848393, 0.2240334762973668, 0.2285105005197684, 0.20830753415240144, 0.5120632708114571, 0.19611443921091865, 0.21110436906205965, 0.43901436152687934, 0.18654093377727354, 0.18296755435684553, 0.556321194483445, 0.5086281037915221, 0.5618119208771086, 0.4177843573767235, 0.13925717915524816, 0.15906616089954861, 0.14838822142365082, 0.16904073741397063, 0.29788967055649385, 0.2073341733283861, 0.14463884267021854, 0.21045364211949757, 0.15780576263279544, 0.28340033185473035, 0.10484579442444442, 0.21327327060915025, 0.172321715208973, 0.2021921413794654, 0.1904544929563271, 0.18524911847176395, 0.19056301109011375, 0.19860999794474266, 0.19420906746029754, 0.18522571621853312, 0.0869792191440043, 0.08426258518094587, 0.08056717870426688, 0.08646220484020817, 0.0876498029645203, 0.11641319378467019, 0.07423650377819957, 0.08846629371058157, 0.08928627040587489]}, "mutation_prompt": null}
{"id": "44d472e4-6176-4c8e-9a96-779667edce13", "solution": "import numpy as np\n\nclass QuantumMultiCrossoverHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.35  # Slight increase for more exploration\n        self.bw = 0.015  # Finer local tuning for precision\n        self.mutation_prob = 0.12  # Adjusted for diverse solutions\n        self.elite_fraction = 0.2  # Slightly reduced to allow more exploration\n        self.theta_min = -np.pi / 3  # Increased rotation for diversity\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.88  # Increased for more aggressive search\n        self.local_search_prob = 0.1  # Increased to enhance local refinement\n        self.chaos_factor = 0.6  # Slight adjustment for balance\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.88 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def crossover(self, parent1, parent2):\n        mask = np.random.rand(self.dim) > 0.5\n        offspring = np.where(mask, parent1, parent2)\n        return np.clip(offspring, self.lower_bound, self.upper_bound)\n        \n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                parent1 = elite_harmonies[np.random.randint(num_elites)]\n                parent2 = self.harmony_memory[np.random.randint(self.hm_size)]\n                new_harmony = self.crossover(parent1, parent2)\n\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumMultiCrossoverHarmonySearch", "description": "Multi-crossover Quantum-Inspired Harmony Search with stochastic ensemble strategies for adaptive exploration and exploitation.", "configspace": "", "generation": 64, "fitness": 0.27331131009445425, "feedback": "The algorithm QuantumMultiCrossoverHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7482463002965645, 0.7349666979138094, 0.7241824660591986, 0.7361978068145978, 0.7232618471405541, 0.7130899676214126, 0.7447975811120571, 0.7422960691529135, 0.7431860802860264, 0.36839311173834, 0.3181906441424819, 0.38066501361100136, 0.3579640667612256, 0.3484946089361788, 0.3985956187182459, 0.3635984240891601, 0.422704573116775, 0.36198127734962715, 0.47260526609536435, 0.4809507173181211, 0.3921092307136177, 0.44919570941578124, 0.4872797238661193, 0.45762789040511276, 0.4404696829668435, 0.5161311400865217, 0.4738112931791385, 0.3418556309242895, 0.41471470177289915, 0.3640116295905341, 0.44057930646612686, 0.4575080554260298, 0.39670868017823424, 0.20145507223716674, 0.4066867353483513, 0.44408094980657975, 0.9254429220516689, 0.9427440096404082, 0.9376967115055784, 0.9636378341351021, 0.949252286700445, 0.9329038175359572, 0.9513504822583594, 0.9292083997797205, 0.9519143520877237, 0.22325741002097943, 0.2926623208569873, 0.2946973123467218, 0.3145879858413524, 0.2573987798057664, 0.438245597851732, 0.2397846324919537, 0.21925695117622113, 0.24138791305238572, 0.21700127555108983, 0.14482802262568062, 0.13802156891092132, 0.220391059575474, 0.18829559476045554, 0.2523168178751505, 0.30053804608574064, 0.16867735555079288, 0.23098755398378745, 0.14975000942638783, 0.17112733098980948, 0.29324036550581645, 0.14545562636948084, 0.24277705521895, 0.1597458572384054, 0.204263553109163, 0.26123380899260584, 0.1506791971728464, 0.16392935068832926, 0.14902455650592894, 0.13706821146325077, 0.1387470419352287, 0.17338717002922643, 0.15947898915656644, 0.14522472701420086, 0.12757347661309026, 0.13978542852236764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06706879360574514, 0.04463192079676359, 0.00048003728044387906, 0.027725361240999336, 9.999999999998899e-05, 0.07760091381517153, 0.04545595271233471, 0.05832747058766796, 0.04336626894459428, 0.01738590401310225, 0.027790070694104774, 0.11380571987775234, 0.101797618786444, 0.06706533376526236, 0.16078896942323084, 0.2149039619014267, 0.202790091145561, 0.07418859694545155, 0.07569439224393815, 0.12637453746688387, 0.141014879606141, 0.1710282391251352, 0.07626600822939944, 0.07587057379370654, 0.12760692050817046, 0.16832377660607412, 0.25075064236604494, 0.0915784601011721, 0.08014292673025014, 0.13319687423030135, 0.14664309617016702, 0.1034506154542445, 0.4581036945687208, 0.4312870037850203, 0.399136125928362, 0.4425513925080782, 0.4746632454675147, 0.4574373193288509, 0.43465737692934414, 0.49197085282802044, 0.4427417826452532, 0.127899582820455, 0.13624398163364548, 0.09143144058265806, 0.11232328954968673, 0.07926977306692917, 0.10507418334226981, 0.14616558647609068, 0.10505036260220058, 0.12072087385087138, 0.24790510417121758, 0.20843001388113003, 0.20189667569954373, 0.22683517221878446, 0.15273640821539192, 0.1401434592214852, 0.14300904328446518, 0.11925319747480811, 0.16766538081817928, 0.2876277229477099, 0.2505828894956317, 0.32794173386118586, 0.34029233100443523, 0.29936215846728587, 0.28442206518369606, 0.4307461138980302, 0.3320350224169982, 0.37630309565249453, 0.10533079849268712, 0.23007382688458078, 0.1723189776018602, 0.2652004837316644, 0.1586843677331553, 0.25369761533133395, 0.26001077065601297, 0.17326641757068284, 0.16615690970542019, 0.19785391280230502, 0.20371008239590238, 0.27988856385454786, 0.19722177006396835, 0.2085119848710134, 0.22023604923014584, 0.20570689510301532, 0.20803859832419347, 0.26224345322222076, 0.22517679132948965, 0.2488046481413404, 0.20810753702690443, 0.582187557495077, 0.24043675487825045, 0.2242144585445196, 0.21233755574847446, 0.217706156738239, 0.596420461673788, 0.18522108173664908, 0.1718255540749969, 0.18531372505864374, 0.5561426902683714, 0.16952772018273643, 0.16874088968253342, 0.16457130630096584, 0.15908396268311265, 0.1581876254516843, 0.5180014137372089, 0.15378062018399252, 0.16835754870864983, 0.20280251642246827, 0.1650231665738907, 0.21057777602892247, 0.10433006109215437, 0.10385020427195124, 0.2680657744434335, 0.2025599517848754, 0.19239059920323343, 0.18741443916393852, 0.18455987377004923, 0.1805357870901374, 0.1883532222583394, 0.17780048075231547, 0.18346000809725804, 0.17267348625337187, 0.09374108697144456, 0.08157165029080893, 0.08749315956823867, 0.0869806760759193, 0.08267085420460629, 0.09119655590317566, 0.08390863195069798, 0.07959123506605192, 0.0862915212835651]}, "mutation_prompt": null}
{"id": "a7fa7d79-dbb9-4b62-9cbd-77aaea879e6b", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Slightly increased to enhance diversity\n        self.hmcr = 0.85  # Reduced for more random exploration\n        self.par = 0.25  # Adjusted for better pitch adjustment\n        self.bw = 0.03  # Slightly increased to widen local search\n        self.mutation_prob = 0.1  # Decreased for less aggressive mutation\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 6  # Adjusted for moderate diversity\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9\n        self.local_search_prob = 0.08  # Increased for more local fine-tuning\n        self.crossover_prob = 0.2  # New crossover mechanism\n        self.differential_weight = 0.8  # New parameter for differential mutation\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.25 + 0.05 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.05 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def crossover(self, harmony1, harmony2):\n        return np.array([h1 if np.random.rand() < self.crossover_prob else h2 for h1, h2 in zip(harmony1, harmony2)])\n\n    def differential_mutation(self, harmony, best_harmony, random_harmony):\n        return np.clip(harmony + self.differential_weight * (best_harmony - random_harmony), self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                if np.random.rand() < 0.5:  # Apply crossover with probability\n                    rand_index = np.random.randint(self.hm_size)\n                    new_harmony = self.crossover(new_harmony, self.harmony_memory[rand_index])\n\n                if np.random.rand() < 0.3:  # Apply differential mutation with probability\n                    best_harmony = self.harmony_memory[elite_indices[0]]\n                    rand_harmony = self.harmony_memory[np.random.randint(self.hm_size)]\n                    new_harmony = self.differential_mutation(new_harmony, best_harmony, rand_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with adaptive crossover and differential mutation for improved convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedQuantumHarmonySearch' object has no attribute 'chaos_factor'\").", "error": "AttributeError(\"'EnhancedQuantumHarmonySearch' object has no attribute 'chaos_factor'\")", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {}, "mutation_prompt": null}
{"id": "b1fa83a5-d151-4ad3-8a78-fe8dbb6feca4", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.25  # Slightly reduced pitch adjustment ratio for stabilization\n        self.bw = 0.03  # Increased bandwidth for broader exploration\n        self.mutation_prob = 0.1  # Lowered mutation probability for stability\n        self.elite_fraction = 0.2  # Reduced elite fraction to enhance exploration\n        self.theta_min = -np.pi / 3  # Broadened rotation angle for diversity\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Higher momentum for stronger influence of history\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.65  # Slightly altered chaos factor for tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.25 + 0.05 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.02 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.08 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.12, size=self.dim)  # Slightly increased noise\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with stochastic perturbations and elite-guided exploration for robust optimization.", "configspace": "", "generation": 66, "fitness": 0.27781510788713376, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7367021510702716, 0.7516054644341887, 0.7608416449433995, 0.7391701492268827, 0.7011926849146899, 0.7619641325154141, 0.7539004454426741, 0.7352035484664701, 0.7435796241023347, 0.3487580099931159, 0.3831220614505896, 0.39515159396516064, 0.35595677324549535, 0.3978795618086418, 0.4685522175756357, 0.36597280043799274, 0.35514329199967265, 0.36779066527457305, 0.4973851926817232, 0.4055032873615477, 0.4520263561499508, 0.49271217811050594, 0.47659195756416384, 0.4753754897061717, 0.5112300853359191, 0.42524968912253014, 0.4532381553902164, 0.4363692563720539, 0.4128628510436779, 0.42032183654223176, 0.23080429917974266, 0.4025624453405523, 0.4264519147566802, 0.45752989279401235, 0.41181904542905, 0.4245593513857935, 0.9227035529411827, 0.9308491792062625, 0.9207866291687792, 0.9422979134856271, 0.9444744294870866, 0.9347374863601987, 0.9373429038620075, 0.9506495849630701, 0.9309187422974577, 0.16468434855762537, 0.2289487549086271, 0.26417033088042685, 0.25967276452319765, 0.4163654916634977, 0.286759191137266, 0.31775252343342053, 0.22623150068681408, 0.25475953336507196, 0.173934165289239, 0.13816283614229163, 0.20374430932188947, 0.3175281584074394, 0.2729473537353009, 0.35444699529747636, 0.20718565375023767, 0.3245868433845599, 0.33584835095615073, 0.19506103742566272, 0.21583065677894797, 0.13431640844843895, 0.2005186031203734, 0.1502491057747698, 0.23882669978768334, 0.13915857233564133, 0.18536261611978833, 0.16212105541348576, 0.20575575357114695, 0.133262485234674, 0.17164619539392167, 0.15049893434956207, 0.29176752913617987, 0.19348257593981866, 0.13688910283633482, 0.13268799280518784, 0.1933352785679734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040013303821733626, 0.08707451789463427, 0.06193226484153547, 0.05565827675300283, 0.058231668714262774, 0.02247261009731427, 0.04811465403000237, 0.09924112824340736, 0.08856354471887717, 0.05263917293055742, 0.10709723026548545, 0.13278816956139783, 0.14159297855988462, 0.07508191194031644, 0.09015936974560246, 0.10842866010301877, 0.19503760285277472, 0.08882321486512212, 0.07231178309991626, 0.08474935239262626, 0.08513461585730953, 0.08676032460617955, 0.08056117660491668, 0.1980610682998769, 0.25610876508593217, 0.18670976287398267, 0.1211545841837175, 0.08463380623113825, 0.45402061240677893, 0.43926922680015346, 0.40062214542816277, 0.46906028722709014, 0.45244392039146886, 0.4950475439021065, 0.4666882788588542, 0.4391139761747729, 0.4409529803976323, 0.1551159686631559, 0.1552831230031816, 0.10122717200516707, 0.12962136039255767, 0.09561819667754157, 0.12654336227821605, 0.12458313742630112, 0.10326415230609998, 0.10427505683452887, 0.1777560470583166, 0.1805808242965995, 0.2099735862738351, 0.22179401295603518, 0.19786955885669555, 0.18119448010902994, 0.1913889827552765, 0.13443789955518792, 0.16866571642816486, 0.2478027982160741, 0.29010722198176075, 0.3113735070041903, 0.2909683351452066, 0.3237300574383988, 0.3633830953149316, 0.4173231677306529, 0.29453780478837666, 0.25334615075040223, 0.2834136093009254, 0.20853889093074118, 0.11862860951052623, 0.2426324936613854, 0.18264337292248045, 0.21769268353975213, 0.21799637572040387, 0.25279889772895026, 0.22507937916245446, 0.21352977247740923, 0.21244518463326112, 0.19388216944439873, 0.1926721272177131, 0.20408371854987073, 0.22858129880859968, 0.21206340065494944, 0.20370758786876753, 0.22213347772083314, 0.20995816596810846, 0.2226951788119793, 0.4084190170822043, 0.20980543027266396, 0.2541610987403713, 0.20930443412938704, 0.23200547581088482, 0.21479233651639085, 0.1924488452900811, 0.4022313030824023, 0.18849345305335197, 0.4056008482493023, 0.8735470527088576, 0.1698476087783538, 0.19918538394847696, 0.16385318005766347, 0.1706442575766186, 0.16512475779979008, 0.36323478553811916, 0.16653587217044352, 0.16534703816760388, 0.20701763999831457, 0.2080418977263213, 0.20520229246075306, 0.10489883589151794, 0.3764343118008422, 0.24175810017189303, 0.19140812131464802, 0.1980879555773004, 0.20780684221155632, 0.20958550829524647, 0.16914092972931194, 0.18915442059493848, 0.18029390964070824, 0.1831614544276602, 0.18297264289745552, 0.0860961058172115, 0.09648393004984335, 0.08135998066495143, 0.08456029561544687, 0.08883925311201091, 0.07919302620278901, 0.09439540980307026, 0.0865923632086325, 0.08856000040904333]}, "mutation_prompt": null}
{"id": "0df1c83a-62c1-4292-9c66-a47678992631", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "50f15c4e-0651-404f-b44c-d4d4bb436446", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7\n        self.levy_alpha = 1.5  # Introduced Levy flight exponent\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.tan(self.chaos_factor * np.pi * iteration / max_iterations) ** 2  # Replaced sine with tangent for chaos\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.85 - 0.1 * chaos\n\n    def levy_flight(self, harmony):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = (u / np.abs(v) ** (1 / self.levy_alpha))\n        return harmony + 0.01 * step\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                if np.random.rand() < 0.1:  # Added Levy flight condition\n                    new_harmony = self.levy_flight(new_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with Levy Flights and Adaptive Chaos for enhanced diversity and convergence.", "configspace": "", "generation": 68, "fitness": 0.26595557866467345, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7710315494267863, 0.7191635937235363, 0.7000853440869546, 0.7019995054152832, 0.6865996672372399, 0.7151811531870322, 0.7303305265621882, 0.6898715707415016, 0.7223546065796431, 0.4210465948995692, 0.32127983335290433, 0.3579223007890783, 0.31106564434567774, 0.29369596382784624, 0.33659114295196035, 0.30500547134733136, 0.31865084901608487, 0.3334095799938632, 0.18850409508148047, 0.40634659936666406, 0.4388681497607013, 0.4770482291971688, 0.41788548949044446, 0.4677203179352367, 0.44737381298620316, 0.4359868615281107, 0.28474761306223384, 0.22392600812574337, 0.19895202545794144, 0.23825247023530327, 0.37591066138843976, 0.1791829354450334, 0.3093517121081424, 0.18639169998438687, 0.26092981284074424, 0.34474552783676937, 0.9535624946076764, 0.9442651302326288, 0.9310072104857529, 0.9536148526131508, 0.9492787331432188, 0.9215622730042778, 0.9275922623054569, 0.9628970070900991, 0.9457123247608475, 0.2627056003512044, 0.275234622991548, 0.2665798974658935, 0.3646699938807687, 0.23553309543283163, 0.26332075699783486, 0.2654085130414542, 0.23151499603636427, 0.22639403047540096, 0.21304156120126905, 0.19058211341508824, 0.14607868439727356, 0.21254518044187032, 0.2985396900295081, 0.21299339431918718, 0.17484007803734658, 0.7689337475350663, 0.20075435339933567, 0.2663217950185929, 0.19112880515528174, 0.29633228671619805, 0.19689877525272703, 0.2398262309598198, 0.15845108183310586, 0.14446357846792612, 0.25946646446103383, 0.17662422127291033, 0.13103300600621826, 0.1467014516309746, 0.13119736183685948, 0.1290334003352589, 0.2052772527593839, 0.16977547061980514, 0.1626595688313187, 0.12930944094990593, 0.14804935279973908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0338649373429073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008986128979379115, 0.05110397198227945, 0.03398816144711514, 0.10731628486546996, 0.03761043029984468, 0.039060353694003624, 0.06618145780164797, 0.07388864566637332, 0.04163090301570138, 0.060140460521828976, 0.10500383379176093, 0.12023322721903673, 0.16660072474386511, 0.08560502713559248, 0.19494434413920858, 0.10556448310270805, 0.10899907224373584, 0.14093608110859535, 0.0722358210718177, 0.19693036388765583, 0.06222373380669155, 0.08297375949092312, 0.21673507230797917, 0.07709395209378522, 0.14675505103473574, 0.1900655215181115, 0.19199234409681443, 0.10798905605456788, 0.43803381288380283, 0.3950759700329941, 0.4060162156853311, 0.49509348967703937, 0.43083164945131247, 0.43008105264685015, 0.405840716128248, 0.45308518237676054, 0.4397187710605679, 0.14156414442912668, 0.1057789312630748, 0.1405187380080164, 0.1073860663040832, 0.10422438103623644, 0.14762277337038177, 0.14261602601862433, 0.11337060630420293, 0.09633389683707172, 0.13351936788075602, 0.16280231400398804, 0.15693770432119325, 0.13109235469353897, 0.1719324463194074, 0.21916625735021678, 0.1470113084968543, 0.13506127935740608, 0.20226470923317585, 0.3110193806396371, 0.26411464683786456, 0.2508065824419101, 0.2848424259518698, 0.31702923217693035, 0.27617802345929265, 0.22610321625260144, 0.4004743189023028, 0.2596033065053437, 0.11398943331288136, 0.29991028353457583, 0.1852814475346518, 0.22982524796854908, 0.2536956578381655, 0.27453510831175354, 0.29300392211490345, 0.2489211723385989, 0.18442770841304323, 0.20316784578874103, 0.20771717371700416, 0.18492630330157367, 0.20037280908302957, 0.18785666454658845, 0.1907967602366324, 0.23195656474990867, 0.2233337338763446, 0.2222023552971315, 0.20017632353814285, 0.252670253760358, 0.2160534427068963, 0.45177625651639075, 0.5671759526271848, 0.1996146591382495, 0.19272497268737487, 0.21227406086347, 0.1912750169590317, 0.186970185450135, 0.19748488280595522, 0.39272826281606477, 0.7686751895206744, 0.14954973683084682, 0.4546508413463819, 0.15413485821008377, 0.17715550714705497, 0.15870364136336634, 0.39335894965535223, 0.168831818821763, 0.1310027736826188, 0.20898407699948007, 0.21340399613227823, 0.24213618413789761, 0.13903053887778916, 0.30807196430798056, 0.21220938108199583, 0.20095581254266048, 0.19629272995915703, 0.1913665739648216, 0.18843928637077356, 0.18408296110266786, 0.20503138018912836, 0.18641021164749827, 0.18071831545912154, 0.1851933414606075, 0.08018524813520689, 0.09374501738752328, 0.08724430943774497, 0.09254275063924411, 0.09123206792471339, 0.07985700021472075, 0.08738565240964746, 0.0741010518368519, 0.09525179622168123]}, "mutation_prompt": null}
{"id": "0492a044-cd39-4f45-bceb-236eefd47a32", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Slightly reduced HMCR for increased exploration\n        self.par = 0.35  # Enhanced pitch adjustment ratio for better exploration\n        self.bw = 0.03  # Slightly increased bandwidth for enhanced local tuning\n        self.mutation_prob = 0.2  # Increased mutation probability for diversity\n        self.elite_fraction = 0.2  # Reduced elite fraction to increase pool diversity\n        self.theta_min = -np.pi / 3  # Expanded rotation angle range\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased probability for local search\n        self.chaos_factor = 0.75  # Slightly adjusted chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2  # Altered chaos equation\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Increased perturbation scale\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with self-adaptive parameter adjustments and probabilistic exploration enhancement.", "configspace": "", "generation": 69, "fitness": 0.24366012092535516, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.5703597147352557, 0.5811050256512234, 0.5348350431612654, 0.5568206943947225, 0.5727897478219033, 0.6665989599350859, 0.5898294873448178, 0.5436657709758843, 0.5743158648044442, 0.24451715345960678, 0.2962324855847034, 0.27884866199851444, 0.23675489505110547, 0.25913511301587944, 0.27973515636762614, 0.2798602737775421, 0.29460426389481387, 0.28643187596363173, 0.28603117370833375, 0.2921384191837184, 0.3219959942566024, 0.2658126475161423, 0.3122957296480259, 0.2894239982917295, 0.3501217342343179, 0.33493454450126925, 0.32581789564924535, 0.26546354799577243, 0.2561992701867555, 0.1703066863384609, 0.3064390878850971, 0.27617295047170765, 0.2970817086467883, 0.28635690676116476, 0.30308581963994974, 0.23614043026243348, 0.8960200006016125, 0.9358639277734336, 0.8826224093224908, 0.9034799392870234, 0.8876458891885664, 0.9189840935731086, 0.9135492560920746, 0.8996335216207667, 0.9273265410948539, 0.2709690554079639, 0.1907269924381062, 0.1971539031802213, 0.308762868305957, 0.27153165079994035, 0.2620245206218853, 0.24065476291146437, 0.19921894323201916, 0.21606934153735435, 0.22085486426650325, 0.2057992772403875, 0.20376476315590253, 0.22417698722668356, 0.3127526793633859, 0.27112625922482414, 0.16426331649369363, 0.21275515718209204, 0.1646716343333161, 0.21561345317852942, 0.1499956044994376, 0.14783959521774126, 0.13609517481779598, 0.14207392378812234, 0.25342314332040483, 0.15702998640437038, 0.1776684236619629, 0.23075726365642435, 0.10282044380624156, 0.13373395174876146, 0.144574825674456, 0.12800163157869426, 0.14959041041452403, 0.15674685805015964, 0.12813004180963505, 0.11956207625374504, 0.1385428388720702, 0.0028096097149453714, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000422411394215505, 9.999999999998899e-05, 0.0007396376384304348, 0.07091714681827621, 0.032265725976576176, 0.06679827627076151, 0.08090002749004177, 0.0668431537819788, 0.07504183106777274, 0.10694716838277396, 0.06479224997315591, 0.07255969162508047, 0.03191428784536254, 0.07485109970486825, 0.08814877585324754, 0.06095142433518119, 0.102743739104449, 0.08425257507717654, 0.058384012854842515, 0.057247527236704454, 0.036200825723772145, 0.10391368839390613, 0.022815248568335167, 0.14145551757742159, 0.14468662225779405, 0.15706084572002887, 0.1564863787938524, 0.09068802586294167, 0.14387867081852201, 0.09741602964438534, 0.4329775780952545, 0.408992307912168, 0.37478479236319995, 0.3960093555150783, 0.4310868743895877, 0.41436693076031217, 0.40190636651959244, 0.41428548702590307, 0.4900148091809674, 0.08177164346595378, 0.10026348004757435, 0.11767029722041555, 0.12055980588767412, 0.1265670538205117, 0.09480338672116428, 0.11719386305848534, 0.13750017161374162, 0.1062458725429416, 0.12430210178593792, 0.1630569015812292, 0.13683868415671163, 0.16050795605555102, 0.2063386091617142, 0.14498544386021617, 0.14203947007762274, 0.16918839475854297, 0.14457117038969458, 0.2934143916364621, 0.31195611698228254, 0.2882998595517683, 0.2791937031562779, 0.31029409676791364, 0.27657555356446395, 0.28556874928188347, 0.2951716429862007, 0.2967890339931464, 0.213069447716134, 0.27804167550127035, 0.20401471895578904, 0.21476849373144202, 0.27920914022921883, 0.2573784615494744, 0.23193726705021844, 0.24282691056072614, 0.1879747015760609, 0.19902926905329976, 0.20686711188643625, 0.22330472615023544, 0.19862293943329423, 0.214702536185842, 0.20935588748445533, 0.20786961872801601, 0.21068157824024614, 0.2111968022176287, 0.23751886222448115, 0.42909373796239725, 0.19440830608492798, 0.38655881228537825, 0.2260900031011911, 0.3211531815341877, 0.2309976929647286, 0.22190342990575873, 0.20884905849619262, 0.18549806014620474, 0.18672695914900983, 0.16500040742396782, 0.5309345227720508, 0.16699485132594782, 0.6792626688727166, 0.15902331790814828, 0.5211946889321806, 0.1488939734042689, 0.15267722073852452, 0.1858576939986185, 0.19751946233362028, 0.20757535258189908, 0.16507834293417256, 0.21149163001098925, 0.11234294947975831, 0.4921982064952203, 0.2369629808772037, 0.1808073576177135, 0.17950856781375935, 0.17125166488535049, 0.185529682264565, 0.18988668780517914, 0.20960312085056132, 0.20130862920627712, 0.1810644943430072, 0.1787641893108305, 0.08020358736827293, 0.07951906107878037, 0.07506081947628296, 0.08940662500562524, 0.08436097328272374, 0.07200803362390185, 0.09304719801851402, 0.0934099540156258, 0.10550269697702208]}, "mutation_prompt": null}
{"id": "8f18875b-b0c1-474a-8e8f-287cd0b8b76b", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Slightly reduced harmony memory considering rate for more exploration\n        self.par = 0.35  # Increased pitch adjustment ratio for diversity\n        self.bw = 0.025  # Slightly increased bandwidth for local search\n        self.mutation_prob = 0.2  # Increased mutation probability for diversity\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 3  # Adjusted rotation angle range for more exploration\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Adjusted momentum factor\n        self.local_search_prob = 0.1  # Increased local search probability for refinement\n        self.chaos_factor = 0.8  # Slightly increased chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.abs(np.cos(self.chaos_factor * np.pi * iteration / max_iterations))\n        self.hmcr = 0.85 - 0.2 * chaos\n        self.par = 0.35 + 0.15 * chaos\n        self.bw = 0.025 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaotic quantum rotation and adaptive mutation for enhanced convergence.", "configspace": "", "generation": 70, "fitness": 0.22164465058681188, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.46321664712757404, 0.46390568374600993, 0.5707747613932233, 0.5352828505704867, 0.47375904395309865, 0.4816270581426536, 0.5273978808025162, 0.5154513918006414, 0.49640765849818225, 0.2317101468153201, 0.17893496308585888, 0.2051026908138801, 0.19733141338848792, 0.22976763259239696, 0.2291811951672672, 0.1876261022924559, 0.16422811855000619, 0.203609855459031, 0.27190740289549786, 0.2743118259992069, 0.27479176147681006, 0.2628012205807848, 0.26192632498177193, 0.2628059282507771, 0.2848042268044183, 0.314167117769659, 0.18424012434081338, 0.2347576511875542, 0.21619281716594518, 0.2517195854302471, 0.19276145794754285, 0.19369339867304203, 0.20186854734018866, 0.205631806639197, 0.21693597905828788, 0.23488566101566688, 0.8212077671145319, 0.8398447974981568, 0.8747156789041973, 0.7524367467739322, 0.8680573624040586, 0.8591742159555574, 0.8459212442620961, 0.7609003434968367, 0.8645376886006486, 0.20698597190776657, 0.1590648015934919, 0.19244668625930705, 0.23089984880802616, 0.2897942837949836, 0.2561866805916747, 0.23512588682713176, 0.24393725618297335, 0.20169150721190643, 0.2449933463717957, 0.1979770440013081, 0.1907201194689223, 0.20456383951264046, 0.23267170807306847, 0.27137986809299186, 0.16647649688734978, 0.2768550491292844, 0.2577029090899645, 0.1414796537127806, 0.17816756460939032, 0.2758747504323331, 0.18118387578021977, 0.24076946017084855, 0.175639649354414, 0.13653251780903375, 0.17455236692543674, 0.23453907349094838, 0.12099759023803658, 0.11860573978511435, 0.12202438262966131, 0.14273598692188771, 0.1325803166388716, 0.13883580520667638, 0.1276213983063652, 0.13701495752456394, 0.1580002293572319, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019900719127022626, 9.999999999998899e-05, 9.999999999998899e-05, 0.02479963945204422, 0.01654986072621467, 9.999999999998899e-05, 0.11640433938569295, 0.03741604148636157, 0.06224300538534988, 0.053023371155453636, 0.07408759295636969, 0.051883426136562605, 0.047932413628876236, 0.12757339088545017, 0.10274505071192575, 0.04234899349352361, 0.04001744206307589, 0.03850471347888651, 0.04393404800108203, 0.025972212323815747, 0.04218798058067297, 0.06672232356867913, 0.010119322589119295, 0.06149714774994808, 0.10632312976890768, 0.10604583253195654, 0.08975400649012477, 0.10409971946389251, 0.1252489858300696, 0.06802656726767942, 0.06572353726157687, 0.11631870372642994, 0.11281802762974036, 0.4289414700822848, 0.33062756723971964, 0.37528299559393785, 0.39659062950839286, 0.3904296475628647, 0.41377276793605355, 0.38568726407897924, 0.39511227499395096, 0.4235247126203522, 0.09001014141108477, 0.11799871512666582, 0.10703223881398771, 0.10039292706810665, 0.1266018047421752, 0.09416429291230399, 0.1007495535547992, 0.12515171106067335, 0.08561611710929173, 0.1451982000743588, 0.15347646744065313, 0.12733337791125054, 0.17132345298385532, 0.14038162623229622, 0.15873754688418484, 0.20576065168145385, 0.1264512508774378, 0.1429359448304962, 0.28279596077060454, 0.28770541943138384, 0.29159549545665564, 0.2951530625251033, 0.26418745598821447, 0.28247646669647264, 0.2910563178399105, 0.29385671898645904, 0.3018848131646802, 0.25412299316528375, 0.23503880445129566, 0.23216103664839216, 0.20993777465597996, 0.1838951758409677, 0.17515993617887748, 0.21836572091419182, 0.23947919403316054, 0.24066460049468041, 0.18286821642471351, 0.22993094388901392, 0.19184792785059612, 0.20336086570803513, 0.22561274876032078, 0.1968603703837173, 0.19903550192572306, 0.1802414551321685, 0.2075624313432035, 0.20080736858281123, 0.1886931590294576, 0.2119636241958578, 0.2304474880037567, 0.20297817934042328, 0.19745516010123243, 0.20989519223111786, 0.2052254958012596, 0.209292009868995, 0.19145568782878353, 0.1821978667345523, 0.18104299755217812, 0.4545329822585078, 0.1931065613059033, 0.52019063759671, 0.16106090451518718, 0.4111425639685379, 0.15965879071974487, 0.349901554568363, 0.16692176316982188, 0.1602262260121743, 0.19750103764348248, 0.18941860752877449, 0.2085749504395038, 0.10261856652815404, 0.21596594176369932, 0.11126373294427072, 0.1901272174603923, 0.18988959150253892, 0.18523694700663884, 0.1981736189897927, 0.17691051195377383, 0.18282560607853005, 0.1747605193103685, 0.17712353100260736, 0.20523221575468176, 0.08161918798376588, 0.07670895077126139, 0.09216255887463753, 0.09072300874151373, 0.08586721866821667, 0.08065934826548415, 0.08666897124614825, 0.06324025572662162, 0.087869513868292]}, "mutation_prompt": null}
{"id": "f7b79d9e-a167-4f71-a981-0a0ff863dc84", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 3  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.6  # Introduced chaos factor for parameter tuning\n        self.learning_rate = 0.05\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n        self.chaos_factor *= (1 + self.learning_rate * (2 * np.random.rand() - 1))  # Self-adapting chaos factor\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with dynamic learning rates and self-adaptive chaos factor for robust exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.2620190107137196, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.6461418513418049, 0.6885031530168048, 0.6509835061829459, 0.6370317448342762, 0.6712913101451118, 0.6125446640929884, 0.6566122769676863, 0.6594357268122895, 0.6564825979394622, 0.3186311627824332, 0.33468769787248664, 0.2646174050386121, 0.2945359080363946, 0.3302137298889205, 0.31388341699281996, 0.34704053024557013, 0.3470959815325345, 0.2897263334761667, 0.39114201005681504, 0.31291496591638157, 0.4009987469210645, 0.4520057367912773, 0.3801816258813472, 0.3952168556710566, 0.47087166955642235, 0.38082122645892347, 0.4516261341464147, 0.3764918216542058, 0.2793391348160661, 0.39352597465064254, 0.395262335300665, 0.259826075219699, 0.29591227738206416, 0.35546012005493344, 0.3564792686731847, 0.4077179185652965, 0.9565109653329441, 0.9399701155079834, 0.9517097314225348, 0.9474018398385774, 0.9310022601186133, 0.9388785103483365, 0.9350182021209094, 0.9379359857872839, 0.9282942897538393, 0.23241749596493488, 0.22249802178351952, 0.2417521228565177, 0.3282582242506442, 0.25135825028559033, 0.3324683433598118, 0.26138949456363103, 0.2660388965628301, 0.2147459083630736, 0.21865720740427275, 0.21577124392384195, 0.14140988937542565, 0.30216736330170324, 0.35184742657831936, 0.24624407801944814, 0.2043396252168691, 0.23280951217956714, 0.22555718968310245, 0.19052160310866673, 0.25991814223458776, 0.15589427253915078, 0.14767125195488828, 0.18714561283170328, 0.2279592177417289, 0.14760740271487083, 0.1571699584255779, 0.18844170415281347, 0.14870001868168603, 0.1329626252728816, 0.1399444502827859, 0.147192467608789, 0.13306334811648268, 0.13714649253028788, 0.14119330135425567, 0.12471056577344664, 0.1403203244883987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0169832933918469, 0.07530058247319926, 0.06650437345232207, 0.1336717485316984, 0.08242515566350972, 0.06016104861192728, 0.028117010441959023, 0.06836740109698258, 0.0917404020866508, 0.059056333116152215, 0.11116040211638933, 0.1101056302890171, 0.12489120675689569, 0.048315762544668184, 0.08966426487876067, 0.06624733956154927, 0.0865263636638921, 0.0789422013335076, 0.0448918427861108, 0.15373211851724422, 0.08821230183801332, 0.11812991858672373, 0.15395586566375807, 0.1460007243320104, 0.12556607980274148, 0.07255407081483933, 0.18916694577292414, 0.11118054369018715, 0.5479175271967405, 0.4810785363011425, 0.4038828873957493, 0.4331675764671815, 0.4189288486055275, 0.4178896459738729, 0.3990017000123651, 0.3966741223614151, 0.3697554392471132, 0.10521006413356426, 0.1412866123848565, 0.12482627469426666, 0.14927021544105523, 0.08777946838746686, 0.10871288946539948, 0.12590509353361867, 0.11050067592191903, 0.13734824704616333, 0.21095187194534948, 0.15219483542530798, 0.1699835728300645, 0.1573304447648004, 0.16668481021229165, 0.19517513280090082, 0.13567646419681711, 0.14177496379284005, 0.24812104125349066, 0.2819574757465869, 0.2922801778351597, 0.31459391836180073, 0.27561222117180606, 0.26476915966133796, 0.3192395643235628, 0.3157005128876741, 0.35888879794204354, 0.2332299694145794, 0.2673046174917145, 0.21282366586723633, 0.15380830739683138, 0.28422148731035257, 0.21660334153269822, 0.2708750544592704, 0.20349064179070087, 0.20877064495008912, 0.31028963086371397, 0.20841923064067747, 0.20301186986934383, 0.2473065352206556, 0.20351884719195845, 0.19599441269987516, 0.212572305854549, 0.2054954592584396, 0.19961011435019682, 0.2108514479327933, 0.21900796558706492, 0.21728742706357762, 0.20250306264801476, 0.21901192561100957, 0.46698403016815715, 0.20542160530469422, 0.19219300497445613, 0.2128507758492697, 0.21871932661813953, 0.18178982292163381, 0.16467060357657914, 0.18487658418285424, 0.13082680480104936, 0.6766540105789951, 0.6633985482077616, 0.16257833605143202, 0.5784535159124784, 0.1613356333776157, 0.16557848509813444, 0.3287813761231734, 0.32047695013099076, 0.16519398946633246, 0.16782880131369715, 0.20848990431393233, 0.10432630426294964, 0.29136842468615165, 0.10460829041260822, 0.1901162565491663, 0.1775048035657517, 0.18762324757220372, 0.18124960420449365, 0.18269172823607782, 0.18250466081175454, 0.19065186955607027, 0.17924640538715286, 0.21239260286454287, 0.09551085772092882, 0.07761164194966153, 0.09873830132851236, 0.08268590069695181, 0.09822951384516398, 0.1240610929600745, 0.09268638437795185, 0.08823528122456059, 0.08924349780435681]}, "mutation_prompt": null}
{"id": "d460ebfa-2938-4eea-9d79-825ee405f0d4", "solution": "import numpy as np\n\nclass QuantumSinusoidalHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.sinusoidal_factor = 0.5  # Introduced sinusoidal factor for parameter modulation\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Sinusoidal-based adaptive parameter tuning\n        sinusoidal = np.sin(self.sinusoidal_factor * np.pi * iteration / max_iterations)\n        self.hmcr = 0.9 - 0.1 * sinusoidal\n        self.par = 0.3 + 0.1 * sinusoidal\n        self.bw = 0.02 * (1 - sinusoidal)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * sinusoidal\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.85 - 0.1 * sinusoidal\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumSinusoidalHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with sinusoidal control for enhanced convergence and diversity.", "configspace": "", "generation": 72, "fitness": 0.2825030607569281, "feedback": "The algorithm QuantumSinusoidalHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7261128243119643, 0.8033666513857741, 0.7891077795332447, 0.7481126187157023, 0.7753207360857778, 0.7424752804364538, 0.7698321603941796, 0.7323744447575615, 0.7398182130358348, 0.3580061215840835, 0.3931688851472147, 0.34901828438589233, 0.35732947822621897, 0.3670533446001797, 0.4195093376251744, 0.40214462127023776, 0.37875241121329284, 0.35775515192344176, 0.3470478721019733, 0.4317178209417396, 0.43172264318416265, 0.44739635943069456, 0.4067572568436866, 0.44962299364118286, 0.48451221245876164, 0.4128096053169025, 0.462255016916125, 0.39804166871274005, 0.3594441102347744, 0.4050315908284149, 0.3543404543388762, 0.2930258736880521, 0.3924316640333335, 0.2398148770508679, 0.3747351538267576, 0.25167305962289765, 0.9579592472570571, 0.9473821301063928, 0.9283839078730947, 0.9556811912582646, 0.9385311647085287, 0.9278642346986503, 0.9380424714171903, 0.9395039078034362, 0.9369488447273167, 0.2466263243997604, 0.2612737612367395, 0.30429113389120765, 0.3568847262075464, 0.20615666156030266, 0.48058344412373555, 0.27031444379443503, 0.22728834683956822, 0.2225125160672512, 0.21163723604181706, 0.22506881473973706, 0.14228318845981724, 0.3842441696472446, 0.275611330210213, 0.24865667866720065, 0.22164968755910608, 0.17025008040641132, 0.3325332884039086, 0.3754606025234025, 0.1921156921795908, 0.14917695006569354, 0.40609887915063014, 0.1612315704905255, 0.15728100371374498, 0.2715292377107046, 0.14127111496690736, 0.1647789858392278, 0.13982749674024075, 0.12855766864766827, 0.1576286159588124, 0.12799876842609015, 0.1297621807591377, 0.16772656062217606, 0.17508975776598745, 0.13683604213978817, 0.1722213404071401, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005419830263871939, 9.999999999998899e-05, 9.999999999998899e-05, 0.007724462448230551, 9.999999999998899e-05, 0.05081427038590158, 0.04764555083560207, 0.06522315925579714, 0.0699006539157172, 0.025656695061599954, 0.04852921346386607, 0.07871134376459066, 0.06428573677936489, 0.06975720263895913, 0.17067351026689304, 0.16756066351629417, 0.09416378977955375, 0.12304473816972983, 0.16420257233385438, 0.16941431045595068, 0.1185181928277469, 0.10632677762007203, 0.13187791134392268, 0.1462893764513441, 0.22816652445294094, 0.11846022514447829, 0.09681942297351176, 0.20018047090126556, 0.250714936997263, 0.09911105170731793, 0.16949272566606122, 0.20511282838590328, 0.502993394063838, 0.42656200090491825, 0.45420554504866695, 0.4758024127843471, 0.44295857447903764, 0.40700919094700283, 0.45132265164144314, 0.46257233720250035, 0.4994492037389193, 0.10318163778843203, 0.10968977826737625, 0.08681555179501976, 0.08724631124720383, 0.09808621814323037, 0.11937884636080431, 0.09206869649603266, 0.16461813069430242, 0.14573502312180242, 0.16656025833737498, 0.13389096154432134, 0.1993726010160859, 0.1895321636286973, 0.1700589501138403, 0.14548325221831493, 0.14108928257357733, 0.16276174567902013, 0.19184676501115172, 0.21777884171407247, 0.33992524592191664, 0.3643961781624545, 0.3271749563319799, 0.2334867599846987, 0.31553133754978413, 0.3905911715083513, 0.4417206428808008, 0.39825252813194534, 0.14044130428342017, 0.22276665175677557, 0.1999456110055814, 0.29224086902057456, 0.21775974692731614, 0.2853677379241438, 0.2580477913478145, 0.23169355206705344, 0.19332757604693485, 0.19600500564756396, 0.2132549432534866, 0.18546955466030246, 0.20117074245146982, 0.20428156956228039, 0.19611045459567844, 0.20993597871282377, 0.1984591274046651, 0.2263123719415978, 0.2101631397569973, 0.22504174987798709, 0.19729375811335337, 0.2313999004507653, 0.2878110177393606, 0.5280612660280244, 0.2262485161841874, 0.22498389913161154, 0.20905337210961927, 0.5125973693996799, 0.54372232127036, 0.18795147463186657, 0.6714193040913417, 0.7121218545397605, 0.8685265106088589, 0.16586109886010636, 0.16067530451151724, 0.1634962805278639, 0.15208388073985812, 0.16851418623894987, 0.16612463302339597, 0.2051342783581911, 0.21117721467930772, 0.21151062088742345, 0.1037952492567058, 0.16881813063364715, 0.2075566797929459, 0.18914820756722917, 0.17512656566868623, 0.18774850789190156, 0.19824131564088043, 0.19626507163899887, 0.19389596125966224, 0.18210055592591967, 0.19341278421617603, 0.185847103207192, 0.09684336669688476, 0.0842894257022272, 0.09392303453194051, 0.07274845182332534, 0.08892881113036855, 0.09503733411970294, 0.08176111630026262, 0.12224316420367354, 0.07620332029730836]}, "mutation_prompt": null}
{"id": "2392b6a2-0b2a-4440-aba0-b10a3f24ce4d", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3  # Adjusted pitch adjustment ratio for better exploration\n        self.bw = 0.02  # Adjusted bandwidth for finer local tuning\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # More balanced elite fraction\n        self.theta_min = -np.pi / 4  # Expanded rotation angle range for more diversity\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7  # Introduced chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        # Chaos-based adaptive parameter tuning\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.85 - 0.1 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaos-based parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7815671085824505, 0.7404415866183902, 0.7848363534883241, 0.765444498276399, 0.7533737591797844, 0.7608330561827388, 0.7829098667209279, 0.7776568810881367, 0.7686381530394029, 0.40677226196122995, 0.36345592133736504, 0.3383588196874163, 0.5012953715854214, 0.40775722675183457, 0.4119132414861293, 0.4159359708256547, 0.41180543078635345, 0.4031963927472382, 0.5066984643868782, 0.4522619689962939, 0.48634112952067976, 0.466400143795652, 0.4911711927110798, 0.51577163024621, 0.2249687977627851, 0.447031028380553, 0.5098804910176669, 0.456147843363933, 0.20943814895036617, 0.44603660599565564, 0.3178721762752471, 0.2521677137429196, 0.4454941410160357, 0.4645179086047685, 0.3925600409031653, 0.17667903339037838, 0.957245171644895, 0.957085585337092, 0.9192191685623751, 0.9491744047825259, 0.9580358536897704, 0.9304639006128048, 0.9319818225470935, 0.9575441822319111, 0.9303795088722487, 0.29103271444472734, 0.3599416409522326, 0.22071984367820674, 0.25292237155850394, 0.21560375325264747, 0.42725905085773697, 0.25347366861920595, 0.22522236128469075, 0.27081278601699876, 0.22523280412698654, 0.22309960379638138, 0.3231791042069321, 0.3592999106756566, 0.2740860438535777, 0.36232833745397175, 0.16106240003175298, 0.24404777166266278, 0.3654977988088264, 0.27887592100460845, 0.20068304740385645, 0.2075548334409889, 0.2714837397033917, 0.15779035771763938, 0.16836825217642382, 0.3281332605924686, 0.3131502608129362, 0.15685433563443307, 0.14972286387067146, 0.13898398705090276, 0.16307876506628893, 0.13437371439678103, 0.13852859413509488, 0.18556801355636532, 0.1695743936814964, 0.16998142269780492, 0.13320955545527757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011892696602049724, 0.04241651435738736, 0.05397370615497166, 0.08576251010166802, 0.05862603818885559, 0.037135801084068554, 0.025783495427276315, 0.08083428539052862, 0.08803065712364111, 0.11025881884429889, 0.13962272470463177, 0.185859098737432, 0.2335466464948438, 0.10377362165459092, 0.13773718481230846, 0.12879736537623343, 0.10266636334475321, 0.1086460502306108, 0.06797578388731074, 0.1339506563431654, 0.15632482736930564, 0.24648815432099558, 0.0881364139959474, 0.1934090087992768, 0.22214105057097466, 0.0801061603616916, 0.16216235894536202, 0.11615789569726798, 0.4949508401332642, 0.47224304456624355, 0.5072108329661117, 0.4482438053027835, 0.4721092286405545, 0.44721009733334405, 0.47028460303838393, 0.47146080839593874, 0.41400951751157944, 0.11494068111446487, 0.07033668201835641, 0.09202706076929013, 0.10963703325700447, 0.1144549845441255, 0.10559247765659963, 0.0926937135924536, 0.1393473249331817, 0.12914354449009646, 0.1753268311447731, 0.17253421531456803, 0.1459871994623574, 0.17212831048931043, 0.20507518487399734, 0.18271336961392337, 0.12624353138101085, 0.13958957406086425, 0.14269809509816844, 0.2428445973082498, 0.417058759164859, 0.28974392423277495, 0.31630250857103426, 0.3045178683071941, 0.35404317287549303, 0.31463391145532504, 0.41319426086820554, 0.41162593239566125, 0.21879321498605397, 0.17980004789823145, 0.21280381802467285, 0.3012217716662978, 0.21106529883761416, 0.22884012696138867, 0.27157623139811526, 0.2781023686207844, 0.22586081122720303, 0.2057699508355022, 0.2008065350942475, 0.19738457470359283, 0.21221422791115274, 0.1973051091477942, 0.22522591496739686, 0.20784226421947516, 0.24014125850462964, 0.22800305024977852, 0.19977290652943225, 0.22679274559219387, 0.23074687163187813, 0.6348696757706004, 0.20075515722261872, 0.6042651188661525, 0.603126110601448, 0.19568461076546573, 0.19694675296145037, 0.19906119413816203, 0.18749163141713066, 0.18770499079171987, 0.742361463740999, 0.17078006325514794, 0.7144583097275741, 0.16610980805696252, 0.16095416407726193, 0.16499051019944178, 0.5061502031296731, 0.16811341068784602, 0.17854388166934276, 0.20043759520279003, 0.21066565863909192, 0.2102908381777796, 0.10380923728511748, 0.16879309850725965, 0.0964964719242134, 0.19075020829563083, 0.18676880810694518, 0.19137259602588308, 0.19294919877161165, 0.18398435725845452, 0.17728861253244377, 0.19756267664129368, 0.18429856193098493, 0.19628606414135297, 0.10006663867551902, 0.08328167623674487, 0.08157590477095, 0.08672049797084036, 0.10928496308393132, 0.07523166596959585, 0.08166877840670894, 0.09939972863329427, 0.09771551546342838]}, "mutation_prompt": null}
{"id": "b0c2adc8-3b1b-4cb0-b4b9-6fbd8cef8671", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Adjusted to allow more randomness\n        self.par = 0.35  # Slightly increased pitch adjustment ratio\n        self.bw = 0.015  # Finer local tuning\n        self.mutation_prob = 0.1  # Reduced to focus on core strategies\n        self.elite_fraction = 0.3  # Larger elite fraction for stronger convergence\n        self.theta_min = -np.pi / 6  # Slightly compressed rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.6  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.35 + 0.05 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.15 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.05 * chaos  # Chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearchV2", "description": "Quantum-Inspired Adaptive Harmony Search with stochastic perturbation and learning-based parameter adjustment for dynamic exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.273189942808639, "feedback": "The algorithm QuantumAdaptiveHarmonySearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7207443551083563, 0.7489475381608117, 0.7431882757484529, 0.7263862528405027, 0.7525847168887366, 0.7256961042366941, 0.7128534593063547, 0.7122140891317403, 0.7304919185383411, 0.3598970227867977, 0.4249024265710505, 0.3424922927476549, 0.40836472253870293, 0.4143476567743887, 0.3924801500175008, 0.36989241970815556, 0.3548807788436543, 0.4042432442123358, 0.44420058865902967, 0.4632031221919367, 0.42679594056769943, 0.3421721071852014, 0.39887662442500227, 0.4623812339856579, 0.3879616457343905, 0.41886317088675573, 0.47743252312728124, 0.4003301648523435, 0.2934440185797377, 0.25667043572138004, 0.37492051052843167, 0.1632284606370733, 0.4335649381910889, 0.3229108860386828, 0.3816878590522935, 0.3768638626623396, 0.914676690654383, 0.8840703424183074, 0.9108342733011405, 0.908092593149678, 0.8918644502960313, 0.86690968908901, 0.9083813059590079, 0.9114689521291797, 0.9047573956728895, 0.3033203327632379, 0.26727878672356187, 0.23067832352894313, 0.24944414170022444, 0.2163219304916867, 0.2939519001006383, 0.2516952735170387, 0.22851248895328558, 0.21510115707410993, 0.15825566331253427, 0.16850672587563453, 0.1388785206696037, 0.2927951212809923, 0.33265808423085275, 0.26681922366624844, 0.2102689322925414, 0.18821978593157251, 0.23510608467238192, 0.17991478797509008, 0.2373872152331088, 0.14556152179970083, 0.1569169122804226, 0.20254503633461018, 0.2501846738121567, 0.17542592356557196, 0.26822705920479617, 0.158902569876332, 0.14822467587133725, 0.25765080021335374, 0.18033577123522027, 0.13819860927606242, 0.13159531683920433, 0.1499048755156085, 0.13515999068571727, 0.13356325214360654, 0.16066455112138245, 9.999999999998899e-05, 9.999999999998899e-05, 0.014559496225889368, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005866940818046729, 9.999999999998899e-05, 9.999999999998899e-05, 0.07568289518399796, 0.035580172109982544, 0.1428153938523541, 0.025117107580913012, 0.04026923759297352, 0.08678476052928585, 0.06624212008385799, 0.0767349002744433, 0.09855138922189377, 0.10362189979224223, 0.08407931016234793, 0.21108583629357358, 0.07394555689253834, 0.0734305772264292, 0.10880183130140908, 0.18403504624243017, 0.15082253287973435, 0.1622807763368297, 0.12222469606604358, 0.2196379015684472, 0.16974433454979554, 0.013119372361203974, 0.05453812919683221, 0.19260271345016355, 0.1328935654959139, 0.13895658022113366, 0.14642526929824728, 0.4548432129329977, 0.4753109754946033, 0.401762326401774, 0.42911235769099, 0.49339857295563316, 0.48371433082606663, 0.48288730983132444, 0.48874320873863664, 0.43997824813413844, 0.14027578978604727, 0.1226112369105764, 0.10764799886638443, 0.11230346658220913, 0.10372600492135642, 0.08516674571766947, 0.10975225206334727, 0.0705556632191019, 0.15539722749225615, 0.21449003741854833, 0.1600532633415236, 0.21106072385327057, 0.16879692434543025, 0.33199534285699384, 0.1664728590553195, 0.20458850526602035, 0.13665277718174074, 0.127481484298969, 0.23170156541431208, 0.31304526583564973, 0.33990436968398896, 0.22518736929062222, 0.30435918317440835, 0.20810720602154154, 0.1818830953784697, 0.350522948967116, 0.21957985021949644, 0.30625528446824724, 0.19164244632726923, 0.2506822575313631, 0.2573954067995744, 0.3146232753027861, 0.22673930058417668, 0.22895810984370235, 0.17839868163381745, 0.1825446934673065, 0.20442953064357383, 0.2064423176726562, 0.21144005867350701, 0.22060156278094978, 0.21997122849283146, 0.21110337867978446, 0.2069013192128879, 0.19108681150381912, 0.24740737086314601, 0.2031980137673337, 0.35332973694966174, 0.21555050379343088, 0.2020750719869061, 0.20253896756786616, 0.21022870510925373, 0.21686434010888478, 0.22518854079696815, 0.22309240079521164, 0.18202165323966224, 0.4679021219145545, 0.1641575140424495, 0.7127532580019209, 0.6311315250182654, 0.7007145752652525, 0.16830852792699003, 0.15741962585946845, 0.37689797529942415, 0.4396750949840431, 0.14911752475207762, 0.2955563839094719, 0.2598670414898705, 0.24065892374602837, 0.20763497368213357, 0.10439888648544182, 0.24580454075853486, 0.21839312812750822, 0.18047411556976733, 0.17796662374928474, 0.1938278330768446, 0.19172139558910972, 0.19645040578881057, 0.20290886622394633, 0.1837312358277573, 0.18259700968667458, 0.17912098233408746, 0.0893107397492342, 0.08349959367828064, 0.0796077667474947, 0.08999441530590868, 0.09433387332097187, 0.09979368074107298, 0.08392905089994696, 0.08892438793542479, 0.09144605471560241]}, "mutation_prompt": null}
{"id": "8c91523e-e1d3-4344-a5ef-6fb8d257b3cc", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7\n        self.stochastic_boundary_exploration_prob = 0.05  # New parameter for stochastic boundary exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.85 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def stochastic_boundary_exploration(self, new_harmony):\n        if np.random.rand() < self.stochastic_boundary_exploration_prob:\n            for i in range(self.dim):\n                if np.random.rand() < 0.5:\n                    new_harmony[i] = self.lower_bound if np.random.rand() < 0.5 else self.upper_bound\n        return new_harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_harmony = self.stochastic_boundary_exploration(new_harmony)  # Apply stochastic boundary exploration\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with chaotic variation and stochastic boundary exploration for robust optimization.", "configspace": "", "generation": 75, "fitness": 0.2849772847591065, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7586909393856265, 0.7441321320327499, 0.7514305197115283, 0.767931743104296, 0.7266157241010374, 0.765019107847684, 0.7468140573581735, 0.770736056509662, 0.7795624605351904, 0.40399422974886323, 0.41823625180724044, 0.32887823446154885, 0.3804256514868719, 0.40356224521064443, 0.4215807977382754, 0.3827943517852431, 0.37901738843144717, 0.29700065098823825, 0.5336309629702494, 0.5162969672496323, 0.526021340371436, 0.3951657642215205, 0.49611974432365824, 0.5003896854962631, 0.42146575435829114, 0.4813094424608554, 0.46954282785821555, 0.3931364841628052, 0.3790975286756447, 0.4384547805540092, 0.49248930820123504, 0.20678426285747098, 0.41290126470337485, 0.3346425111462398, 0.36542114800605785, 0.44605229934665536, 0.9446101879009303, 0.9655171997909038, 0.9530658437256387, 0.9671495972263019, 0.9487427466028058, 0.9580197809593557, 0.9581341758854519, 0.9574529709451463, 0.9731301976866998, 0.29211796210171426, 0.25188124474548834, 0.28094720328946965, 0.3216633261771885, 0.21229793342290526, 0.39342637405737213, 0.31523954096122864, 0.25631855316838914, 0.24300992153391066, 0.1870871118308327, 0.20989527376517447, 0.16927638609359952, 0.2021236983488276, 0.21778627742745182, 0.27216892724328523, 0.16123278877730496, 0.17097644812108614, 0.23165204433936992, 0.17545458936935698, 0.15291581427791767, 0.16993891692193197, 0.22501809301704812, 0.39348537292670127, 0.21290816680273628, 0.25128765847657564, 0.19986614876552844, 0.15198197170781091, 0.1289757228363625, 0.15972286668752422, 0.2466668545923767, 0.14732497405845713, 0.251061199254928, 0.13889087160351787, 0.12934350636474534, 0.13298723648334743, 0.1284258852585035, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021361382797800976, 0.03154882888025934, 0.04767783660465719, 0.09818837564203564, 0.04049724968751234, 0.053629329102145684, 0.044126039088890456, 0.026720104268969425, 0.032514056461235286, 0.07539431036816802, 0.08583924436799883, 0.13984243092015947, 0.05161813053143394, 0.11294977106084503, 0.12240069940217235, 0.09279268833573551, 0.12054896340925858, 0.12257195281279487, 0.1563299338034, 0.11497246312298193, 0.08537160063481353, 0.192365720942282, 0.050713039472824906, 0.18823091087036303, 0.11744745213922014, 0.03856575638543558, 0.1057509284194561, 0.08741945070418244, 0.19782170768233387, 0.08956470874126676, 0.43011395298020616, 0.48912703517600953, 0.4306757128534071, 0.445875568854202, 0.46404111675284176, 0.5009971965255403, 0.4421009670451619, 0.3977254846471622, 0.4258440826361861, 0.11417547080382229, 0.1352905953418947, 0.14771274532035372, 0.08792544333417696, 0.10602854242774229, 0.14277079907786372, 0.09236399641082738, 0.11362961634844793, 0.08482724829741783, 0.16625917806523305, 0.12302882347547406, 0.14193852891352576, 0.12253049503973057, 0.24323822185100952, 0.1837827389971428, 0.17173018243412408, 0.18462012450344423, 0.2179594086179757, 0.4382782878050362, 0.305421968448076, 0.23701674263019157, 0.3507337107046331, 0.31956640896363564, 0.42928645970168566, 0.4331965946611329, 0.43100443481529693, 0.3343106820125171, 0.20449651744900255, 0.23492729525069944, 0.19235263249625045, 0.24479045224379492, 0.24760816762572013, 0.24325151867281725, 0.28261948905489576, 0.2989117427145299, 0.16712983096502865, 0.20715766998218876, 0.20372799528573482, 0.20117146617926607, 0.21254136464865891, 0.2060589129739111, 0.2377267515659518, 0.2503196731483994, 0.20828666312168176, 0.208956644077134, 0.21441857353047722, 0.22010792353861586, 0.22881799783648726, 0.2518837216001548, 0.25500534981354017, 0.2052877658158584, 0.2535069372836698, 0.559271241749961, 0.201046969564182, 0.5062216776302992, 0.18619167724057495, 0.4142086722551849, 0.6113833430245852, 0.16045592405800657, 0.8902505088750202, 0.1574320485750471, 0.15779125581123477, 0.1577282000744037, 0.45571993445937886, 0.16795259840847487, 0.3589809259503529, 0.39037599671161893, 0.22064103489453246, 0.28893234521433775, 0.10378905901813518, 0.1561841190809179, 0.1129917539218146, 0.1801762243682835, 0.1895506374650695, 0.20200656974563247, 0.18885205507861724, 0.18337143358529828, 0.20623510881001017, 0.18308942017334362, 0.18108967489227812, 0.1832610262277855, 0.08772178883908177, 0.10028588941672911, 0.09724202729296116, 0.09022607632033819, 0.09157779492179308, 0.10761984484161946, 0.09222972189194967, 0.10212344713262644, 0.09201985021417236]}, "mutation_prompt": null}
{"id": "fc0397f0-e05f-49a4-ac1a-dca0de61879f", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 6  # Adjusted to increase diversity\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.75  # Decreased momentum for broader exploration\n        self.local_search_prob = 0.1  # Increased probability for enhanced local refinement\n        self.chaos_factor = 0.5  # Adjusted chaos factor for smoother tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.75 - 0.1 * chaos  # Dynamically adapted momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with dynamic momentum and elite diversity for improved optimization efficiency.", "configspace": "", "generation": 76, "fitness": 0.2700440892256611, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7404491300843412, 0.6895853461105118, 0.7366410063375599, 0.7208482505456139, 0.7480444544107658, 0.7669549301649612, 0.7555925193605701, 0.7249282826044874, 0.7377155693774685, 0.3578011247122318, 0.39149928661416034, 0.3781545627205063, 0.3303977693783966, 0.40092010360047947, 0.4347517058915792, 0.420872573644159, 0.38884262043247253, 0.3354625889443813, 0.4826394696820595, 0.4118473789041973, 0.2643199139143241, 0.3652357290022502, 0.3385902663371029, 0.37451006321161784, 0.3150452001895053, 0.4090326736084111, 0.35710608533024746, 0.18474095973926352, 0.46929726363922153, 0.19096554385061537, 0.18379082215631337, 0.40500075456718854, 0.4524073561320848, 0.3384539280043968, 0.38242025390973333, 0.16464975270375437, 0.9253629858413035, 0.9452747208603718, 0.9193659430103928, 0.9239401653162268, 0.9173578659184731, 0.94657374311467, 0.924230456636483, 0.913018672586486, 0.926472972232278, 0.4222165007163762, 0.2711080965601823, 0.31145112095289806, 0.4074027113915075, 0.2216527095566334, 0.2878247030849298, 0.2890665437243277, 0.2514377753280581, 0.29655969682027417, 0.21861097850133515, 0.1681719015255818, 0.16700615375971106, 0.27639103432070256, 0.2800217591001126, 0.2677583800036214, 0.12697981513634748, 0.17862008210682145, 0.2793133442943324, 0.21668591435781448, 0.1691022414535004, 0.21194367831985372, 0.201990767358311, 0.19390369123506568, 0.1676770080866702, 0.21775662442799937, 0.1439739528695263, 0.1463975152681669, 0.15555058158311985, 0.14567955910785935, 0.12619573724828514, 0.13790148529402946, 0.1457893287331279, 0.14796017798783578, 0.1496218028542644, 0.13811124553160647, 0.14233625976932585, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05009939130772112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03596302709043697, 0.04976465517576312, 0.04435843945579743, 0.06542550314790607, 0.0690033218719256, 0.04107750531986254, 0.17473434839632063, 0.07389363314342012, 0.06805156907213805, 0.1914853311194935, 0.1639131324782911, 0.1260956693876677, 0.1042769853459824, 0.09892099220548012, 0.13369361727992823, 0.15759951739929168, 0.1894302260841081, 0.07613771337016662, 0.14225336404026712, 0.03718198401353934, 0.15053631386099442, 0.07388057801556702, 0.22204991932307616, 0.15808475971622538, 0.23333415777698552, 0.17543189003891002, 0.12981540987560225, 0.47505793923233086, 0.48841710168574304, 0.46097374100446653, 0.4346691927779339, 0.5110758847961456, 0.45779812123254937, 0.4938559342041061, 0.47673461333312006, 0.4436627071672492, 0.10190106680324151, 0.08548586086883447, 0.1297905967787768, 0.12142225450112365, 0.13376431632295738, 0.1538850483973907, 0.1063546739088631, 0.10451484730104643, 0.11875172312447757, 0.20508995163247523, 0.1866741352375142, 0.29476461208232285, 0.2324148978918974, 0.15518259054964034, 0.1729937727590306, 0.23150605367533927, 0.2593871978158879, 0.24236215491378166, 0.18535110135921062, 0.28255517581256706, 0.2283365365165333, 0.37766398083921693, 0.30166878553492493, 0.3258878046760434, 0.37178703428294935, 0.3562709676903695, 0.2168004070248326, 0.160976187852226, 0.22306869447906197, 0.18220811599509967, 0.35515451706273093, 0.21668544942493873, 0.3644701457331081, 0.17897285308223831, 0.21500721440013593, 0.2879277031759917, 0.22592182185477316, 0.2360392387595236, 0.1980365481367864, 0.19536047504171372, 0.21343127676098805, 0.1949404041817343, 0.2198815792378327, 0.198905613115137, 0.3056151930643921, 0.2018945395907945, 0.5764060128039983, 0.22416338521622992, 0.21732150871922684, 0.5498221988708012, 0.21094903659022102, 0.21179912397182388, 0.22602327315499593, 0.21413596059001094, 0.18152134190323854, 0.18457855525100508, 0.16835737048119448, 0.6637153859220579, 0.27791066284261656, 0.19738529533739924, 0.1657495987531462, 0.11427213851978268, 0.16856415522035073, 0.2563720846902129, 0.17474221288679515, 0.2006670156665913, 0.16743606432650626, 0.1668622363597546, 0.20954324114446043, 0.10443432884835724, 0.1760709767476868, 0.10103172504974478, 0.18957048374282126, 0.1908733358959933, 0.19459223369288625, 0.17996041008052832, 0.18503932055331984, 0.1840535188404523, 0.18728748733071665, 0.17782269623930624, 0.18841590843644496, 0.0911161697961228, 0.0829035916465275, 0.09500871647240294, 0.08716079736947735, 0.08716830811425424, 0.12513022081217673, 0.08716195254095604, 0.08550182597944089, 0.09303445163006363]}, "mutation_prompt": null}
{"id": "7d0acf08-9b68-43dd-945a-ab19a82895c2", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.88\n        self.par = 0.35\n        self.bw = 0.015\n        self.mutation_prob = 0.12\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 3\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9\n        self.local_search_prob = 0.1\n        self.chaos_factor = 0.6\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.88 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def levy_flight(self, harmony):\n        beta = 1.5\n        sigma = (gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return harmony + 0.01 * step\n\n    def local_search(self, harmony, func):\n        new_harmony = self.levy_flight(harmony)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum-Inspired Adaptive Harmony Search incorporating Lvy flights for improved exploration and convergence.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'gamma' is not defined\").", "error": "NameError(\"name 'gamma' is not defined\")", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {}, "mutation_prompt": null}
{"id": "9e896a91-aa2e-4b01-9b06-c95256c6bc16", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30\n        self.hmcr = 0.85\n        self.par = 0.25\n        self.bw = 0.03\n        self.mutation_prob = 0.10\n        self.elite_fraction = 0.3\n        self.theta_min = -np.pi / 3\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.75\n        self.local_search_prob = 0.1\n        self.chaos_factor = 0.6\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = (1.0 - np.cos(self.chaos_factor * np.pi * iteration / max_iterations)) ** 2\n        self.hmcr = 0.85 - 0.15 * chaos\n        self.par = 0.25 + 0.15 * chaos\n        self.bw = 0.03 * chaos\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.07 * (0.1 - diversity)\n        self.momentum_factor = 0.75 - 0.15 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.05, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search with dynamic chaos-controlled parameters and hybrid local-global exploration.", "configspace": "", "generation": 78, "fitness": 0.2511683042744813, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.6275698673013794, 0.6320023422642026, 0.6487249888427273, 0.6007381256900801, 0.711465865639447, 0.6605796488024044, 0.575769966556444, 0.6729158602080721, 0.6281407440860076, 0.3297624475069022, 0.31494666009679173, 0.25861222406391293, 0.37750451117647466, 0.3018992160781252, 0.2805772767615279, 0.2957685338473157, 0.31219925290040307, 0.42104823870653063, 0.39573589865205827, 0.45400124032423417, 0.36623098084036443, 0.31910225421391214, 0.2604638656716647, 0.32873709295573605, 0.3704679237928775, 0.33933319604484047, 0.33079333159921576, 0.3232417759994395, 0.2744327189534679, 0.323755741743155, 0.24070914035392654, 0.31126198907142566, 0.2974603305670638, 0.23938605476603825, 0.21173387551934653, 0.3031843551897512, 0.9401448313632247, 0.9275863072497509, 0.9345106590799759, 0.9407785756911109, 0.8957910581806254, 0.9246915033448033, 0.9064393634368071, 0.9188597802699964, 0.9203835783806237, 0.20706480707507469, 0.2261092761798924, 0.2188857405009551, 0.282422092587882, 0.2804948687458805, 0.3362198239858588, 0.18775354417932977, 0.22352768110468602, 0.19554867587807312, 0.1854931093970863, 0.1744422159836886, 0.14878666190155054, 0.23958866913310295, 0.27201360729478974, 0.21050074172341704, 0.16282460871776294, 0.18027852095510133, 0.18446466137397022, 0.24624913256776648, 0.1592429804771911, 0.12615350454107954, 0.15866333196424198, 0.14414660663170653, 0.32564953320739454, 0.27874767690981805, 0.18756940078959194, 0.23593045061048046, 0.13073706481028036, 0.13298778742410688, 0.13234724318150237, 0.11717941695925349, 0.127572485830603, 0.13639703121358382, 0.1351179040864321, 0.16270577493973415, 0.1266071757588224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018541465005375568, 0.03782316719004453, 0.1001318316336065, 0.03352987772871163, 0.07720007832135578, 0.050977640567203664, 0.03916858158705128, 0.04039931755541115, 0.0591904850176701, 0.05870756986337944, 0.034562580207555094, 0.08843820409545022, 0.12042182717744832, 0.06706335164823418, 0.08689386068828953, 0.056883571087429474, 0.09466904120032738, 0.07102159390883278, 0.10825485390983247, 0.05287592577865108, 0.08150764615997974, 0.14119560031459255, 0.04541762905395663, 0.09792570252301902, 0.11125029297917843, 0.06524994570111142, 0.11996819804637904, 0.15108494386924065, 0.1049838528197119, 0.4325528505322179, 0.38843989894226383, 0.48083114420901296, 0.41702205232921574, 0.40318080878209606, 0.3993910114194308, 0.3752833521080332, 0.3848286932420829, 0.40584625648482886, 0.14918940947718295, 0.12880463156603905, 0.1430273613682448, 0.158046374090831, 0.1178857041816802, 0.1446126541589201, 0.12197852205691084, 0.13024237672191508, 0.11681209025872197, 0.13682981968880648, 0.13334781530730366, 0.15851276353271793, 0.13854823914069292, 0.14012976682298472, 0.1403017948864126, 0.1732809201485841, 0.17030220171804844, 0.15653599683721675, 0.28840137200125915, 0.23065340308560167, 0.26483609308951483, 0.30654649895756203, 0.21777454395916618, 0.31349330847018286, 0.2602190413788701, 0.2664307592545758, 0.30031265838280685, 0.16608748598979362, 0.22646893583758365, 0.24096915155658105, 0.19376126062194376, 0.19352075465469987, 0.21758871880391673, 0.20220194366515976, 0.24508790884439124, 0.22000828227189761, 0.21044185449724184, 0.21667579442585405, 0.22688052784311508, 0.19475459047294685, 0.23827170811929388, 0.19782630423310765, 0.21787153084540856, 0.2032113715882652, 0.21071504621566128, 0.20951929374654688, 0.18666804467212628, 0.19804073582196435, 0.20496405123749195, 0.18184100495819944, 0.435758205387052, 0.19179919120992506, 0.21981848565332862, 0.2203235874796583, 0.16577812908351375, 0.18695003143423405, 0.1608283915833676, 0.5334917399485228, 0.7174682824497761, 0.785694074507689, 0.16368894909866338, 0.5625156276156589, 0.161141420474607, 0.4141850950314525, 0.16806491366157494, 0.16783414242939232, 0.2070538379321447, 0.2057445088325368, 0.20586208132241612, 0.3496374186123459, 0.1547764479000966, 0.10448437848871583, 0.20848542448857332, 0.19096375754249162, 0.1902392478489947, 0.1780339897017802, 0.17204958477970433, 0.18000109053835167, 0.18357242321014589, 0.17934380611045087, 0.1691009240664605, 0.07570241606928596, 0.08463404499804161, 0.0794069992473907, 0.09491651242029386, 0.08122053348475178, 0.08485762501966232, 0.08687788525249629, 0.08972887682836495, 0.09660551398401529]}, "mutation_prompt": null}
{"id": "e5bfa1ef-8189-4cc6-91b1-2b037f5534e5", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.35  # Adjusted to improve exploration\n        self.bw = 0.015  # Refined bandwidth for precise tuning\n        self.mutation_prob = 0.17  # Increased probability for mutation to enhance diversity\n        self.elite_fraction = 0.2  # Adjusted to allow more exploration\n        self.theta_min = -np.pi / 3  # Increased range for rotation angles\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased probability for local search\n        self.chaos_factor = 0.65  # Fine-tuned chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.35 + 0.05 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.02 * (0.15 - diversity)\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.05, size=self.dim)  # Adjusted perturbation scale\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with dynamic harmony memory update and enhanced local search capabilities.", "configspace": "", "generation": 79, "fitness": 0.280468620414326, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7067726069598114, 0.7433823946118573, 0.7540460640159906, 0.7617322228229098, 0.7338343424822871, 0.737990360246966, 0.7319655027348958, 0.7388408643632931, 0.7406729004359272, 0.393633281682668, 0.4247382782321748, 0.3990462201202084, 0.41023544671692247, 0.36411618746917296, 0.38403533783848975, 0.3365630270700637, 0.36702581955046454, 0.3914996812320636, 0.46174637913821703, 0.45358606776780186, 0.40222896588321, 0.44386172392237655, 0.509716235618465, 0.4656503762806773, 0.48259945736363075, 0.46384844877658926, 0.47827806039751464, 0.4177813807465661, 0.4006843440655291, 0.28435472348813995, 0.4162364863136254, 0.427804579523798, 0.2963961702958494, 0.36274520989803216, 0.4417861929761967, 0.3433856737769675, 0.9490457612888129, 0.9513887764471808, 0.9465592429639487, 0.950822023127107, 0.9337042025641175, 0.9482013072619273, 0.9487328333593004, 0.9255464947135228, 0.9542550218343396, 0.28420224657698423, 0.273280233455763, 0.35974110680047744, 0.34338024185995997, 0.19228683531447133, 0.33952169641296437, 0.26344948868889984, 0.21504306949450824, 0.24467594580562735, 0.2231349362316778, 0.16643683663081132, 0.2184127349816205, 0.34734903346823176, 0.416162132266242, 0.34079228048325827, 0.2131108671748132, 0.22389888504160893, 0.1753272115649379, 0.1839696728822301, 0.16847920014331996, 0.14438205326059728, 0.15116740934813355, 0.1752968435070894, 0.29791359868710965, 0.1799372735421615, 0.3472594935151071, 0.18225663350875054, 0.1394929355355542, 0.13028517592565136, 0.12891079082916568, 0.15079417033238096, 0.15676436595610088, 0.21072138124530193, 0.1324296520609929, 0.07016012877095312, 0.18157980802106855, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013003883276929695, 9.999999999998899e-05, 9.999999999998899e-05, 0.020565882070545327, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054312596289182724, 0.0572279626124913, 0.06956469719125091, 0.0366853779563735, 0.04182633965461957, 0.01686476783897084, 0.07373520582787729, 0.05119228596204206, 0.09305025763678809, 0.09693011503013682, 0.06620580253090935, 0.21574053521544811, 0.08662826824051606, 0.09908727306485854, 0.12680820234830736, 0.1353439693077666, 0.09772809703290064, 0.13462988187480918, 0.20917540507087728, 0.06915980381981879, 0.23125667759322577, 0.11286632288253007, 0.12875669709812942, 0.2125280477414242, 0.18910007154839503, 0.16582865734794627, 0.18481475488961263, 0.41519988248275497, 0.4204626432668622, 0.40213644027185147, 0.42973756532125584, 0.4233679377055223, 0.46948717961725395, 0.431569026644114, 0.40585065832764633, 0.47449519690981035, 0.12211157162003639, 0.10719562311886854, 0.08870164177202355, 0.14061121837584145, 0.1125944547278761, 0.11899132342250507, 0.12795446230869256, 0.17751978596867724, 0.1342136881917455, 0.16391526904439502, 0.15049025235096192, 0.15809605627107337, 0.12820578455295983, 0.13638177644838012, 0.12001292917074757, 0.2079181114946026, 0.18786481064616523, 0.16077535048835467, 0.3420012203201698, 0.32000246105328256, 0.29085754483152326, 0.2696631120732189, 0.2776349524748811, 0.2940347433422823, 0.3418259829467626, 0.44573995173550196, 0.34972721043538224, 0.3284489852784366, 0.22721352978449028, 0.2667854492800007, 0.2053570327665588, 0.25532137638717534, 0.273334550386481, 0.2521426379581009, 0.31344378267852824, 0.2070156472130723, 0.25821783261271736, 0.22299456318631716, 0.19294751878746197, 0.21792472013289022, 0.20500609852453777, 0.1981863687170362, 0.22913805433596202, 0.2234536317140231, 0.19868110163785646, 0.19548295793837434, 0.2230371566316276, 0.5631056920014449, 0.25218549683816505, 0.47577455596224627, 0.19787655840654728, 0.21450136835669287, 0.21859372496390583, 0.2406568701043741, 0.46234196523528515, 0.5277050052090088, 0.1520985759233694, 0.6207616022503175, 0.16945460967191484, 0.171596193932532, 0.1740055759999477, 0.5702570989877195, 0.1653494814537253, 0.24966247023630417, 0.21147184512247763, 0.24438768189239246, 0.20498701287471477, 0.1269874014429765, 0.20860695014958208, 0.10432862533038856, 0.166224670832527, 0.1046104205770314, 0.17739070341620355, 0.19733063988158095, 0.18229010442390625, 0.1834986708074744, 0.18730686936071217, 0.18294169052436704, 0.19602904082875816, 0.19365548052532555, 0.17198757677584542, 0.09026571136821349, 0.08772792600720347, 0.09030635082615535, 0.09297475493896801, 0.08941950240925867, 0.1105006797396112, 0.09895351587893852, 0.08850959679947479, 0.08959388332654739]}, "mutation_prompt": null}
{"id": "f95b140b-f0ba-4c13-a965-a6c732a286dd", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.chaos_factor = 0.7\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.85 - 0.05 * chaos  # Slightly adjusted momentum factor\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.05, size=self.dim)  # Refined local search step size\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum-Inspired Harmony Search with dynamic chaos-influenced parameters and enhanced local search for robust exploration and exploitation.", "configspace": "", "generation": 80, "fitness": 0.28346107461724707, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7433107167485805, 0.7361799603401135, 0.7652285662567255, 0.7577786005484717, 0.7391711400271375, 0.7504401018346123, 0.7477187750676757, 0.7486317915444425, 0.7423834020232181, 0.37162814377108455, 0.40634618973671066, 0.415018200088104, 0.3688097317316288, 0.42907813434653075, 0.40065172040687846, 0.3688415925446872, 0.40086160044081776, 0.4002093612443872, 0.5401691556769237, 0.4673653339494743, 0.48014150322175997, 0.36545380846602216, 0.4469699532174678, 0.5053324002988331, 0.45899656413131196, 0.5185756824465064, 0.49110273610668875, 0.43951522494493533, 0.40881317407430684, 0.43503946669688165, 0.4810435891453, 0.4072843255139217, 0.4149198601304134, 0.18580185598886967, 0.42423755006449315, 0.18414748027455918, 0.9574453148645357, 0.9186431174459136, 0.9282418867856159, 0.9404905832697799, 0.9421244538604084, 0.9495714257579816, 0.9420072246221378, 0.9376583201943267, 0.9261327717825107, 0.2542470663251917, 0.3790385677293133, 0.3201057583639997, 0.29062413645554486, 0.3193755623320792, 0.3932389419958048, 0.3269609373848421, 0.2498372086467633, 0.2768729077657608, 0.23753057787579168, 0.32322709513223224, 0.15387771964980734, 0.8935410932172035, 0.21593962671589628, 0.3240263674254765, 0.17361278257147572, 0.21409970637156261, 0.24711426358982458, 0.1620153065246741, 0.15761763883561597, 0.2091986862789399, 0.15738062144961262, 0.23550827163195265, 0.23248399070681247, 0.14789965329746724, 0.14591923802743934, 0.15200682430830326, 0.14394493624620375, 0.1356897286558395, 0.1489220663277805, 0.12444893221382958, 0.16462182383749135, 0.15825103671477447, 0.16744672844878983, 0.13694564574144863, 0.135499849456731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03951434676564891, 0.04369439250953833, 0.09967078105626026, 0.027492124878188084, 0.04161151107853944, 0.03737191168489695, 0.05375341604499595, 0.09007393367967576, 0.05160474131092774, 0.11444126079663441, 0.16541696999727606, 0.14926919948280715, 0.08257266726561285, 0.0886888567676315, 0.20372192131861688, 0.15156674738662945, 0.13556014307237785, 0.11015508428805354, 0.13627282563637078, 0.04891289692967371, 0.05112590756186841, 0.19545135737136954, 0.07738823682301155, 0.20437097230811085, 0.1829558270037963, 0.10444647206099167, 0.09317123292060459, 0.45717590773418537, 0.4668989816190521, 0.45087282550509034, 0.44325237462567857, 0.47546991444754516, 0.422033318381026, 0.44804002681708033, 0.4993142275703639, 0.4529238156540105, 0.11231488090654462, 0.1085793961369349, 0.06585483130117631, 0.11356363902575284, 0.15946210992095444, 0.11113446787447423, 0.0811880674936798, 0.17050981552744215, 0.11049987286204266, 0.20458199821222445, 0.19995146485525694, 0.17384282266972984, 0.16385992505896863, 0.1321054291294428, 0.15502479840339622, 0.38706811571561417, 0.1353942577947186, 0.12801720521497373, 0.29546515666415074, 0.2397095626400053, 0.27148016114977147, 0.27621404560548923, 0.3367161735354819, 0.3853357966401376, 0.4268295775451125, 0.33439322246624836, 0.2845559770557786, 0.22787193815715645, 0.2679169021552288, 0.239523845686068, 0.24889248538389808, 0.23927461505746161, 0.26614221874240995, 0.2586687231031122, 0.31399216955292686, 0.17519893834909983, 0.19919536165739438, 0.2620761799903919, 0.20378555594193148, 0.20761698623786284, 0.222130182227103, 0.24079031488436609, 0.2082578455979589, 0.2147629899026099, 0.20510099777433244, 0.20222126515836358, 0.25088607492592085, 0.1992095677942456, 0.2293518194454779, 0.4954479187692984, 0.20906938926173602, 0.21760127024135567, 0.2114157795963878, 0.20255442388151013, 0.47305376765810137, 0.1885765623679475, 0.18417987270946223, 0.7036980493331064, 0.6311436800472214, 0.6374911668430318, 0.16499140327845163, 0.15734796444683885, 0.1659854070347394, 0.22318982554492073, 0.16837799284953003, 0.2795838980719251, 0.2051731049136981, 0.2078514372410143, 0.21059490642508427, 0.10423083558718627, 0.16744016571685438, 0.13084890415341255, 0.17425625940896972, 0.18901436813948236, 0.1957582003080266, 0.18153228560427004, 0.18389785132123748, 0.17531304880541376, 0.1885979308781428, 0.1818078915304414, 0.17828657141233273, 0.09779236813315206, 0.08450631182318724, 0.08445594290828995, 0.07341580880061627, 0.08748895076388019, 0.10372689861014484, 0.09094019441529999, 0.07974248106211912, 0.09495035805662577]}, "mutation_prompt": null}
{"id": "cff58423-97ed-4bd3-bd0b-4f5ef9470317", "solution": "import numpy as np\n\nclass DynamicMultiPopulationQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Slight increase in harmony memory size\n        self.hmcr = 0.85  # Adjusted harmony memory consideration rate\n        self.par = 0.25  # Slightly decreased pitch adjustment ratio\n        self.bw = 0.015  # Narrower bandwidth for local search precision\n        self.mutation_prob = 0.1  # Reduced mutation probability\n        self.elite_fraction = 0.2  # More focus on non-elite harmonies\n        self.theta_min = -np.pi / 3  # Increased rotation angle range\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Reduced momentum factor\n        self.local_search_prob = 0.1  # Increased chance of local search\n        self.chaos_factor = 0.9  # Higher chaos factor for dynamic tuning\n        self.num_populations = 2  # Multiple populations for diversity\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.num_populations, self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([[func(harmony) for harmony in population] for population in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.25 + 0.1 * chaos\n        self.bw = 0.015 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=(1, 2)).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size * self.num_populations\n        max_iterations = self.budget // (self.hm_size * self.num_populations)\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            for population in range(self.num_populations):\n                elite_indices = np.argsort(harmony_values[population])[:num_elites]\n                elite_harmonies = self.harmony_memory[population][elite_indices]\n\n                for _ in range(self.hm_size):\n                    new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                    for i in range(self.dim):\n                        if np.random.rand() < self.hmcr:\n                            new_harmony[i] = self.harmony_memory[population][np.random.randint(self.hm_size)][i]\n                            if np.random.rand() < self.par:\n                                new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                        else:\n                            new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                    if np.random.rand() < self.momentum_factor:\n                        new_harmony = self.quantum_rotation(new_harmony)\n\n                    if np.random.rand() < self.local_search_prob:\n                        new_harmony = self.local_search(new_harmony, func)\n\n                    new_value = func(new_harmony)\n                    evaluations += 1\n\n                    if new_value < np.max(harmony_values[population]):\n                        worst_index = np.argmax(harmony_values[population])\n                        self.harmony_memory[population][worst_index] = new_harmony\n                        harmony_values[population][worst_index] = new_value\n\n                    if evaluations >= self.budget:\n                        break\n\n        best_value = np.inf\n        best_solution = None\n        for population in range(self.num_populations):\n            best_index = np.argmin(harmony_values[population])\n            if harmony_values[population][best_index] < best_value:\n                best_value = harmony_values[population][best_index]\n                best_solution = self.harmony_memory[population][best_index]\n\n        return best_solution", "name": "DynamicMultiPopulationQuantumHarmonySearch", "description": "Dynamic Multi-Population Quantum Harmony Search with chaos-driven adaptive strategies for enhanced global exploration.", "configspace": "", "generation": 81, "fitness": 0.21823270652704038, "feedback": "The algorithm DynamicMultiPopulationQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.5106699873466112, 0.49656672498462817, 0.49810426728896773, 0.4770653616623166, 0.4529539796360684, 0.45619127987185826, 0.4830488147338128, 0.4702312369977101, 0.50048418572721, 0.2058025559032962, 0.22839141312349864, 0.21407336133579669, 0.19523688325650201, 0.19589493487522625, 0.22723865213980776, 0.26600030328037416, 0.20759234419262218, 0.2547400188926443, 0.2525492270676969, 0.2793605843054029, 0.19133770790717708, 0.3268063543428801, 0.18156325317195865, 0.20275349173791768, 0.1716855097461486, 0.19590260322263564, 0.2585787094503891, 0.2469391611708076, 0.17929207520619805, 0.1867059523389416, 0.19196161125479294, 0.16683613454028723, 0.16643739197986707, 0.19848720567086686, 0.32488835895924517, 0.2090584571699231, 0.8723101653709862, 0.8870410672391118, 0.8642199312558084, 0.8623649288812087, 0.8996091231178209, 0.8803303319534784, 0.8569484151381325, 0.8579234659135829, 0.847028443805651, 0.234380822995218, 0.19021692678773228, 0.2021030485036749, 0.1936846772294647, 0.2023713691691883, 0.18047591136119812, 0.151526929079132, 0.1621203466638481, 0.18181615885047797, 0.2016338471922824, 0.22349140944636647, 0.19847469236306936, 0.26433259371475815, 0.20801066811756863, 0.28078475050169105, 0.21137828107176826, 0.22449208587192948, 0.18456822616304802, 0.1742009205495233, 0.12939033839329372, 0.14532781615257395, 0.15699717250301926, 0.13553633718864788, 0.14426110995888608, 0.13886409466440341, 0.23173302761095205, 0.14256916102130157, 0.13177014918971364, 0.11756408821372555, 0.12706187697671034, 0.1389172516121433, 0.2154620155402598, 0.1478770751070142, 0.12568631796067198, 0.12869871985298853, 0.13363631445362967, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012661634818752598, 9.999999999998899e-05, 0.018564565916052378, 0.00880383506037219, 0.029960671308909892, 0.06888225308720508, 0.075283037073275, 0.07362082224215516, 0.04518972694328893, 0.0605386364797561, 0.0883362287324464, 0.09646341418822013, 0.07933923854140357, 0.05887042542618237, 0.005508986644342406, 0.06258869938932299, 0.02991741685689353, 0.0059578213766684485, 0.02583842964315719, 0.0072781408576471085, 0.005703837897702901, 0.06644638284773319, 0.007170311414351094, 0.10236229460235613, 0.0721778546160522, 0.10874273457326944, 0.13848013855211228, 0.08660607315780833, 0.10946801845857412, 0.10080011643964737, 0.09601704302507374, 0.14833156564477723, 0.4009803266311792, 0.4276701602470544, 0.43778653884353924, 0.3844626991247211, 0.4128427362828555, 0.3863664204488694, 0.3642252137935633, 0.397613825702097, 0.3945771128170914, 0.10380509030126084, 0.11223225697367312, 0.11070896061650382, 0.09014747638091358, 0.09370810310701894, 0.0845314927059877, 0.10051700853862422, 0.11533060458357136, 0.09640326714120162, 0.1511753018770976, 0.15120149318800646, 0.1378447067156967, 0.14960011597625322, 0.1536270807902802, 0.1467459029836211, 0.16198504000630276, 0.12049669273658492, 0.11744529205906162, 0.2717657390307562, 0.29344852170698754, 0.29043443663275326, 0.30395028505819044, 0.28541890145761273, 0.2911873438368138, 0.23532483163390938, 0.2668492727791607, 0.2813697571576026, 0.16895214281688808, 0.20980964532479962, 0.18907553334874605, 0.1969860604735333, 0.21133226980904818, 0.2113923528336792, 0.21643671021742894, 0.20269290019512842, 0.2580450659490803, 0.2096689381273925, 0.19318523624977046, 0.22273858426234383, 0.24733782574790453, 0.1939211460997925, 0.20117099313340125, 0.19771657907738338, 0.2050390587469454, 0.19892898796519887, 0.21443434599842737, 0.20523384248914966, 0.20458108104552353, 0.2851343950958405, 0.20285354856885662, 0.28101947955329176, 0.2147439927652517, 0.19961006151382177, 0.2001231562843545, 0.18224544554519384, 0.184980099924546, 0.4451160244831407, 0.4547693992360199, 0.33627340797463867, 0.3144215696533037, 0.15671182514456472, 0.16623550055895886, 0.1604060869465559, 0.3460780883303879, 0.16712732483885906, 0.18179061225475068, 0.20450413835508252, 0.22997202505066772, 0.20081689807553915, 0.20766945876620435, 0.19882554936246144, 0.1832548549626305, 0.1799196021864855, 0.19127937025226815, 0.18453150022077436, 0.17308326443092825, 0.1790224732242377, 0.1953322640467946, 0.19059226051830025, 0.1792674244479957, 0.19114265270883368, 0.08661464562730237, 0.07735290623331437, 0.07963077612539093, 0.09178543834787833, 0.07580087201256425, 0.07875219515887655, 0.08347025951012232, 0.07624954997889022, 0.0802620467716102]}, "mutation_prompt": null}
{"id": "15016a6b-f54b-49ee-a8ce-f010196220e6", "solution": "import numpy as np\n\nclass QuantumSpiralHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.35  # Slightly higher pitch adjustment ratio\n        self.bw = 0.03  # Adjusted bandwidth for improved local tuning\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.2  # Adjusted elite fraction for diversity\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Adjusted for better exploration\n        self.local_search_prob = 0.1  # Increased local search probability\n        self.spiral_factor = 0.5  # Spiral dynamics factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.spiral_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.05 * chaos\n        self.par = 0.35 + 0.05 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def spiral_dynamics(self, harmony, func):\n        r = 0.1  # Spiral dynamic radius\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                harmony[i] += r * np.sin(self.spiral_factor * 2 * np.pi * np.random.rand())\n                harmony[i] = np.clip(harmony[i], self.lower_bound, self.upper_bound)\n        return harmony if func(harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.spiral_dynamics(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumSpiralHarmonySearch", "description": "Quantum-Inspired Harmony Search with adaptive spiral dynamics for enhanced exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.26953609101055265, "feedback": "The algorithm QuantumSpiralHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.684875832576957, 0.6590033866418841, 0.7240772277353977, 0.7056946645394753, 0.6929241279704015, 0.6771591571798259, 0.6617232376320318, 0.6907043498810279, 0.6831582119316053, 0.3073637956563626, 0.3486692798946064, 0.28891449937447855, 0.2831080221999259, 0.33332688419503576, 0.2810781887983177, 0.29902156198915886, 0.3669011229539231, 0.27661844857943296, 0.4035737873611176, 0.2814028538185176, 0.37590841454462354, 0.3827597701322435, 0.3416435622399344, 0.42859015790517163, 0.34001964229447956, 0.37073644147285534, 0.39506059717820363, 0.40384828061129285, 0.3401991761450196, 0.32705255689876145, 0.3822340990100681, 0.3150893906180039, 0.3705319431269659, 0.31802266386388667, 0.3446872979048653, 0.3016589351222174, 0.928799103935378, 0.9114976196547738, 0.9283676505851677, 0.9416708733628296, 0.9179171380047156, 0.9203150438936322, 0.9454446394492279, 0.9485767862256576, 0.9063934543810548, 0.32521336942111523, 0.24490576951888388, 0.31573967200905617, 0.2364856412006825, 0.2673004449632932, 0.41294581393747576, 0.28133250704247525, 0.25194752749555205, 0.35070166902126954, 0.17013777716722833, 0.16878242587745484, 0.17875706016072923, 0.28001699153609494, 0.343271665583599, 0.2779344280037255, 0.2140566843233065, 0.15198551314319597, 0.19429293596516406, 0.18551744371550394, 0.17387379775654643, 0.37638084371820213, 0.30672996485560156, 0.20345797177674663, 0.18707191660122258, 0.16037634696620995, 0.20307568097423523, 0.16463645282218653, 0.14662066053125888, 0.19162238870954473, 0.13843896966640823, 0.1450152662558758, 0.16011571819588444, 0.16311479318279032, 0.13984089434146085, 0.15945315624630074, 0.1864036543459523, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010236879061200632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01431404443554729, 0.06030552142204104, 0.06187033098940442, 0.060441043130610494, 0.04623540428935757, 0.0633292017607393, 0.024651834248654136, 0.07269736359245749, 0.0945685802938584, 0.05716627049963663, 0.0344326906311091, 0.033610881644459134, 0.13396150866889078, 0.07348790058354149, 0.070054558779722, 0.09169991372585684, 0.15495112175477865, 0.09617138464925612, 0.10745553397577545, 0.1723100547042452, 0.1577643215613923, 0.13042974316114342, 0.18047105892223203, 0.21863864669284516, 0.08389988392325198, 0.19438244403657523, 0.2185419120821439, 0.08143215738028198, 0.4629374276697428, 0.47016518029892285, 0.4244370586216032, 0.4716713544259843, 0.4257676803333236, 0.48678246352172094, 0.4404031850634921, 0.4664634843384773, 0.4792253883658595, 0.09421587750750349, 0.13867864487454373, 0.12160554917493083, 0.14118527528153768, 0.10927113917784814, 0.08717921285539965, 0.09574634574242902, 0.14126914826895176, 0.11645899343221411, 0.15459715045361155, 0.21273257089714093, 0.2930500838984368, 0.2141132344630743, 0.1689246550636233, 0.11764007588070713, 0.15650003364549703, 0.20595218150535644, 0.17601236307944024, 0.28287772768669095, 0.330479354235658, 0.25580763436025145, 0.34507891017022674, 0.2852237533884199, 0.2771084319329138, 0.391799656103639, 0.26242021592998155, 0.3997314678544661, 0.15750237468216077, 0.22087176741321424, 0.14574891484268626, 0.15859864487018693, 0.31756377948887426, 0.3018722964413231, 0.21876467364356367, 0.17522012066648074, 0.2498565008132858, 0.21771625936481032, 0.20806655789232742, 0.22414408216485437, 0.215462414934125, 0.2129466087331271, 0.21707215563195537, 0.19911698135353872, 0.18736952732607137, 0.36182839523131904, 0.2064545322636937, 0.244834059207662, 0.20351759266959601, 0.25101802128485784, 0.22919645710650116, 0.18897651282185157, 0.20458886834026402, 0.22075116608682432, 0.246635530617214, 0.565823298163477, 0.18773822736546975, 0.18728499092953776, 0.6399293189939763, 0.16870871446364322, 0.7518037949553825, 0.1425266215189056, 0.16477340293538234, 0.3820917317903577, 0.35530791850165233, 0.1263423585615865, 0.22203253189129413, 0.2108752488747727, 0.22950540440276868, 0.2118255890946461, 0.11807218253217266, 0.7235378948687894, 0.09932191848483851, 0.18101375982130252, 0.17523443800813532, 0.18046687097480574, 0.1870464782008745, 0.1785423232069543, 0.18148640248668613, 0.18730098271052276, 0.18984384586688363, 0.18717284892645203, 0.09894386527676158, 0.09811793030532645, 0.0925138750612634, 0.08190903762757973, 0.09991521900957945, 0.07983610370862448, 0.08673799441375563, 0.08698363312302149, 0.07593130872244913]}, "mutation_prompt": null}
{"id": "4ad24955-2666-4323-a48b-c259e47a2865", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearchEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Slightly reduced harmony memory considering rate for broader exploration\n        self.par = 0.35  # Slightly increased pitch adjustment ratio for more exploration\n        self.bw = 0.03  # Increased bandwidth for broader adjustments\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.2  # Adjusted elite fraction to retain more diverse solutions\n        self.theta_min = -np.pi / 3  # Further expanded rotation angle for increased diversity\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8  # Slightly reduced momentum factor for more frequent updates\n        self.local_search_prob = 0.1  # Increased local search probability for better local refinement\n        self.chaos_factor = 0.8  # Enhanced chaos factor for more dynamic parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.15 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.1 * (0.15 - diversity)  # Increased adjustment based on diversity\n        self.momentum_factor = 0.8 - 0.2 * chaos  # More chaos-influenced momentum\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Slightly larger perturbation\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearchEnhanced", "description": "Quantum-Inspired Adaptive Harmony Search with stochastic parameter variation and enhanced chaos for improved global search capabilities.", "configspace": "", "generation": 83, "fitness": 0.2641906328860036, "feedback": "The algorithm QuantumAdaptiveHarmonySearchEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.6833014939921549, 0.6768766278975077, 0.6799095696683342, 0.6628733587899696, 0.6717529946473644, 0.7187081905558305, 0.6867340977451741, 0.6719779486252739, 0.7001500468804519, 0.30043410861595143, 0.3292254417185695, 0.3141509639684664, 0.3680819964086105, 0.2751392398391015, 0.3012613593771898, 0.2964275306381202, 0.29874020412649793, 0.36768351913046926, 0.43208845743284474, 0.42258569920621336, 0.450879414769788, 0.4186352234240097, 0.41690091173559296, 0.2739724561391498, 0.42174387602311025, 0.42664408716651125, 0.412727238038162, 0.34503524162204857, 0.3253487444677896, 0.19223779656394435, 0.30639638760992727, 0.3747792146355561, 0.2366144676978218, 0.3580288706688075, 0.3289589019785454, 0.18094783369845158, 0.918585728712706, 0.9281641241938134, 0.9276517656718353, 0.9381973822060455, 0.9399754762544157, 0.9242636161331929, 0.9355201636660974, 0.9185400975693405, 0.935052856462361, 0.21472864381432477, 0.19881670482548008, 0.21742660790901847, 0.2421943329706845, 0.19702912576866327, 0.22618433136082317, 0.25224685743979536, 0.1961436947044234, 0.2386621938604473, 0.1821929350987489, 0.16350744085757574, 0.23061500506703092, 0.19274262325609104, 0.20155464918991428, 0.2725379885964666, 0.20134045926782085, 0.3834330632083449, 0.28699559603317026, 0.3467119864320386, 0.21334824419719012, 0.1348222163308912, 0.1688677382762238, 0.14189905908886247, 0.14480899998221508, 0.1601204950490901, 0.21550342678186185, 0.16075356864061763, 0.1480898170432049, 0.1261932793956725, 0.1706275179798662, 0.1440211821521712, 0.15078027548972006, 0.16481012721420174, 0.12988163651331275, 0.12765599484500567, 0.1263917123431998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016740988735509554, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07900288022477653, 0.04307244956122702, 0.05735519603019146, 0.07183867403639232, 0.0467931958161536, 0.03584889611398667, 0.044570811074924666, 0.07679248640816605, 0.05919380633638338, 0.07556611279623326, 0.12647460119894915, 0.1294554321525202, 0.09438583655280086, 0.06095061751667219, 0.059742972600358546, 0.0901846946320598, 0.19723275045736843, 0.07680526901598628, 0.1334521653822478, 0.14259055625775896, 0.058902721099294064, 0.18171991712536129, 0.11517972131967835, 0.1903363444707612, 0.06905959752402302, 0.08412745695287993, 0.2171048667672969, 0.08067798962012984, 0.4159379405480621, 0.4527774503923221, 0.41668335290865, 0.38865306229206353, 0.417706062405533, 0.5155355711990268, 0.4487687873885664, 0.4136662970473942, 0.4214219593211955, 0.10951973736981313, 0.0994014826018127, 0.11502686886509805, 0.14693815918559883, 0.11206320869910613, 0.09811608908681702, 0.14737357188764322, 0.12770152765406984, 0.1268447389925259, 0.14678846052783834, 0.1564569000940903, 0.14649369771001708, 0.14627284117394834, 0.13174438987615544, 0.16316449346552586, 0.22626159066178075, 0.14463480027308762, 0.13127771458036952, 0.31784402398851963, 0.3312541652742923, 0.2230560030665062, 0.20869443524835662, 0.2978851386429562, 0.29519399334056007, 0.40079204729054363, 0.3097602959944121, 0.3812556299486938, 0.2613947601912192, 0.22806625280950388, 0.2115293965097278, 0.20245909299095188, 0.2752458866089954, 0.31398723955504015, 0.21380599277772527, 0.2949633981864709, 0.22879407060949142, 0.19578865409927526, 0.21319184091707166, 0.20443351589709702, 0.19432108438097684, 0.2183557800745869, 0.2410895282288541, 0.19168695028685967, 0.2026793131796948, 0.22710064087449655, 0.5488980735812673, 0.1860199583617379, 0.5330524116811322, 0.20690961827434462, 0.2286530118775334, 0.2221556965619137, 0.20959007645115513, 0.48972685746903943, 0.2280736856791391, 0.40629546112217363, 0.2001856290636621, 0.3500746262217178, 0.5147976415972502, 0.171104645131265, 0.8264148860275513, 0.14081516922948323, 0.3933122883598962, 0.16757758874346762, 0.1684027402688163, 0.1687910465334349, 0.23007642546379325, 0.20772666939466178, 0.20840307130800173, 0.20917768792008373, 0.10466560316405737, 0.45126959929362054, 0.10515042960312859, 0.18633850932823182, 0.1897439727292225, 0.18662333256217978, 0.17888310063137502, 0.18628544126880875, 0.18859137108379664, 0.17309299166462133, 0.20745748115145402, 0.1808788883650181, 0.08994677766153092, 0.08574680224569498, 0.08717422276467446, 0.08273576632904933, 0.07873526180498724, 0.10891445859127724, 0.07796330845741395, 0.07160169449865095, 0.09187957153708215]}, "mutation_prompt": null}
{"id": "6bd36f44-b9cc-4fc5-9bf6-ccd7120fc030", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearchEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Slightly reduced HMCR for increased random exploration\n        self.par = 0.35  # Slightly increased PAR for more aggressive pitch adjustments\n        self.bw = 0.025  # Slightly increased bandwidth for more diversity\n        self.mutation_prob = 0.12  # Slightly reduced mutation probability\n        self.elite_fraction = 0.2  # Reduced elite fraction to encourage exploration\n        self.theta_min = -np.pi / 6  # Adjusted rotation angle range for new diversity\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.9  # Increased momentum for faster convergence\n        self.local_search_prob = 0.08  # Increased local search probability\n        self.chaos_factor = 0.75  # Adjusted chaos factor for parameter tuning\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.025 * (1 + chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.9 - 0.05 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearchEnhanced", "description": "Quantum-Inspired Adaptive Harmony Search with chaotic parameter dynamics and probabilistic elite enhancement for improved optimization.", "configspace": "", "generation": 84, "fitness": 0.2574390742761946, "feedback": "The algorithm QuantumAdaptiveHarmonySearchEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.6096483600804177, 0.6970235012830471, 0.6280291610642645, 0.6558626038362463, 0.6721919237705176, 0.6672084702575956, 0.6238376296364155, 0.650976379274785, 0.616366527265756, 0.2672580771252163, 0.3159125412658922, 0.30482758931093035, 0.1912953899372597, 0.22442238530301062, 0.3364300361267528, 0.29181888427838787, 0.28689829743870576, 0.2813044633363494, 0.3155346905778833, 0.23304375731602833, 0.38663743372370396, 0.3116989459686236, 0.2852151333566504, 0.22705254920381868, 0.36194291615339147, 0.3489772340834645, 0.31578300247232416, 0.202784477865962, 0.2286493406448018, 0.22505045822568503, 0.2601789931974686, 0.17971477181285134, 0.17060433042908985, 0.18083544685508246, 0.2895440210788255, 0.2716502900219364, 0.9338501346754735, 0.9197095403194961, 0.9172671980578191, 0.9186482824956567, 0.9458381036346889, 0.9348158602922152, 0.9449314655442671, 0.9168837888779404, 0.9374758083819857, 0.3153671752266227, 0.2628713522876651, 0.28590943996781193, 0.327583859071377, 0.35207444409289224, 0.27928720191125633, 0.2524526015062023, 0.2543929366558283, 0.23367303108237714, 0.19463383437984327, 0.20890665618471793, 0.16313301190037988, 0.2718791866761716, 0.21134385601117256, 0.3316182785508296, 0.16281718743352758, 0.2290242468389273, 0.3030721198516385, 0.18040515077008024, 0.1848202455260619, 0.1453483089894677, 0.3072502862503913, 0.16529274569765562, 0.22433962872791813, 0.1503563272449544, 0.19876488583562157, 0.1943750806507919, 0.15300466891242936, 0.12600080308721973, 0.3745183208195544, 0.13872870619504152, 0.12836484235180956, 0.15915113924763813, 0.12834104329938967, 0.1275066570104616, 0.16394229938438698, 9.999999999998899e-05, 0.0013165119755738086, 9.999999999998899e-05, 0.007332594163511397, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020545889356035074, 0.06877933093220823, 0.051341350527695395, 0.05639107106069552, 0.050349953783203505, 0.06854286054371728, 0.050620550789918894, 0.08309326894929747, 0.06808262658839426, 0.13112952991618443, 0.053753685124575123, 0.06410062752313095, 0.07458998427906915, 0.05633296355573969, 0.04877172977357591, 0.0767638735471422, 0.09059082369559635, 0.07276203864566377, 0.09312973848780659, 0.14277607107445878, 0.20002128357907045, 0.1844177049865653, 0.1317648123396461, 0.20945234156596648, 0.07823631507240958, 0.1849618083424076, 0.12889420775687155, 0.09117121318233334, 0.4013236453122291, 0.46594310589857035, 0.4600649462094769, 0.48726660985043635, 0.4706069894944318, 0.504350598619485, 0.4723472818548343, 0.469111789722786, 0.5055503955700777, 0.07712528240499028, 0.11341338688660252, 0.11012256545270016, 0.11384418885681502, 0.13738648483168125, 0.1402451125351275, 0.0908416229217468, 0.14781950952580758, 0.0932168510714868, 0.15257007255952226, 0.19745424561242086, 0.2127263962103766, 0.16641626171479362, 0.18836888352025027, 0.12546945932110298, 0.14811769202511915, 0.1353278436531664, 0.1595275716077642, 0.27336876957371115, 0.3120984500161148, 0.2872359189384246, 0.2920645582323357, 0.3018041014151225, 0.2838438775111204, 0.3709564564101834, 0.3687936250471222, 0.22850517624737732, 0.19386244290802246, 0.1997593103324854, 0.1264337703479943, 0.21016856999998224, 0.21189274426126192, 0.2529814638418667, 0.2209781051325207, 0.2773442898540428, 0.1803208111100314, 0.19896043237508532, 0.19284861589569502, 0.2140751751061637, 0.18814281832409774, 0.21857842945444095, 0.19265974191206903, 0.21631960671528816, 0.2142154688715262, 0.2288416349040151, 0.2153066214924727, 0.22466997421873636, 0.21530873300477138, 0.48284004581530227, 0.5031237188068947, 0.4129004990162415, 0.20071282528710743, 0.214056565495094, 0.21316319424020425, 0.47561716459242853, 0.18657789012357007, 0.15663747685502216, 0.6013895334436778, 0.16879864125389954, 0.6128947383510015, 0.5514257525261789, 0.6160385286937753, 0.1674274198575717, 0.16732256668181866, 0.18338290464196327, 0.3096147162045171, 0.2049901137792841, 0.3117155345129171, 0.20970710070877507, 0.10465248311482633, 0.16845122168685045, 0.0945453212783437, 0.18825298661908918, 0.17386635586394983, 0.1750854229923814, 0.18026224991684736, 0.1881597200564965, 0.17208068783021024, 0.1840300868293484, 0.1759935012278394, 0.18116628488561648, 0.09388216535560823, 0.08550807661877224, 0.08601598768904517, 0.09477608439044638, 0.09498218098212496, 0.10118205326268015, 0.08962613741006731, 0.08365415841897172, 0.08312424345656344]}, "mutation_prompt": null}
{"id": "09dec144-7420-417d-85fb-38d6c232f7a1", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.85  # Slightly reduced to improve exploration\n        self.par = 0.35  # Increased to allow more adjustments\n        self.bw = 0.03  # Increased bandwidth for broader local search\n        self.mutation_prob = 0.12  # Slightly lower mutation probability\n        self.elite_fraction = 0.2  # Reduced elite fraction for diversity\n        self.theta_min = -np.pi / 3  # Expanded rotation angle range\n        self.theta_max = np.pi / 3\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.8\n        self.local_search_prob = 0.1  # Increased likelihood of local search\n        self.chaos_factor = 0.65  # Adjusted chaos factor for balance\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.15 * chaos\n        self.par = 0.35 + 0.1 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.2 - diversity)  # Adjust par based on diversity\n        self.momentum_factor = 0.8 - 0.1 * chaos\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Increased perturbation magnitude\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum-Inspired Adaptive Harmony Search with self-adaptive mechanisms and stochastic perturbation for dynamic exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.26306131841975416, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.663714960704242, 0.6782044411329871, 0.6553996025581647, 0.6548858899609957, 0.69962903947983, 0.6962995330554431, 0.6832041286451453, 0.7029243914546341, 0.6597285738750718, 0.3272425315100347, 0.3149603826875692, 0.32331788597196376, 0.2956424702758401, 0.3349173810399867, 0.3215304773174834, 0.2629645498757145, 0.31123779853350675, 0.33882454445892285, 0.32871838935940845, 0.41865842299677514, 0.43968819416898464, 0.34353995070370835, 0.40267583217012803, 0.4114412873849175, 0.4367359575817583, 0.3603022883572651, 0.390214204789189, 0.21561681748272032, 0.3520639288438755, 0.18532598696624814, 0.3677397198895267, 0.17567490215964243, 0.35596667920559766, 0.2617118576618438, 0.3174207258331333, 0.1868689052980229, 0.9170597479986112, 0.9289297926201097, 0.9379507145057928, 0.9315152337373912, 0.9159000676128327, 0.9231180624444733, 0.9565619834316794, 0.9330253569456171, 0.9332181427553837, 0.17430268289137074, 0.24360987945126422, 0.20488095892376146, 0.3427091751615048, 0.28220372460339593, 0.27322477255673716, 0.21802552655194063, 0.2289310876581535, 0.21484536845449898, 0.15965751554591967, 0.1781186708611815, 0.17834089786322926, 0.21520209299327264, 0.3537171773588099, 0.20050873648060386, 0.23600942056374263, 0.23683629155897334, 0.21920094335575235, 0.15542370488081136, 0.1961691500614019, 0.1311095523059641, 0.19035583369783415, 0.15967682155003038, 0.18292290746237028, 0.15198502025702887, 0.15853017416822568, 0.3483133295393185, 0.12690383735884858, 0.1474381584981389, 0.14240513683253553, 0.17407170726472943, 0.19080951851247951, 0.14834968635679802, 0.14780722303879046, 0.13331563457917894, 0.13590109608131973, 9.999999999998899e-05, 0.0020237070852424655, 9.999999999998899e-05, 0.021017333513596137, 9.999999999998899e-05, 9.999999999998899e-05, 0.01078709595482219, 9.999999999998899e-05, 9.999999999998899e-05, 0.07116584370772638, 0.05809806903537451, 0.08100033544408924, 0.03568827812730613, 0.05273208844884125, 0.08070034932118231, 0.058133766457803326, 0.07080154226518176, 0.08957423463981018, 0.08862116111570739, 0.11342108857461719, 0.15990679617613257, 0.0673032066471112, 0.07424873483869598, 0.09429202731459552, 0.1004691576287916, 0.0926684186711535, 0.10805599559992662, 0.19832340039113838, 0.08169355289217417, 0.13128297676574552, 0.17953389678961207, 0.008986522412125275, 0.0875934428990085, 0.19821763028974237, 0.14496779293747708, 0.08120464755706691, 0.45237898035178514, 0.44020009983814234, 0.42191488851804804, 0.44081451664995275, 0.4310580955783112, 0.47350948826846917, 0.4666027129102235, 0.4385321045104361, 0.4207620103413411, 0.09665021735071555, 0.10717267947726616, 0.12739279208422905, 0.10725065937300116, 0.11988534243480975, 0.1589259717114777, 0.13228877487533808, 0.12295120164765627, 0.09283915724187541, 0.17383650205607226, 0.16558139310586317, 0.2347528938973944, 0.1409741850932953, 0.14901487613429254, 0.1489397718733546, 0.14985691850516558, 0.1573164565642019, 0.14971298540913014, 0.32535471705798225, 0.29371157807701653, 0.20732824859082943, 0.28689341563852533, 0.37003078531355005, 0.25919750258300656, 0.4004646885510308, 0.3967431093124666, 0.3942752041698909, 0.19350260965652621, 0.27082237069704673, 0.13602280119046894, 0.2302767601868101, 0.29140158968575236, 0.21709649793533592, 0.1848784487262003, 0.25059851020313884, 0.34619764627016225, 0.17820861240241104, 0.21278291621367285, 0.19881732671856212, 0.19769980399924247, 0.20743645790877685, 0.23454703433954538, 0.2135460403024686, 0.19586801804629694, 0.19488014181589497, 0.22338615982125754, 0.4706288885021691, 0.22701507937516652, 0.3680576663501901, 0.19995353905885738, 0.520671482641975, 0.19694203888339823, 0.22341194729193137, 0.24140572205982125, 0.1619910638726726, 0.8309931469751883, 0.4860052368010428, 0.5724962472137843, 0.16917449102364335, 0.397874757153745, 0.172281390304038, 0.17985425993517745, 0.16376822567883575, 0.39859163768208117, 0.14987582518958575, 0.1956056360359848, 0.16854460507248004, 0.21152203757122834, 0.21276594581858144, 0.1047546929150831, 0.3855870164831846, 0.19713943304930348, 0.17184973432635342, 0.1997880063260098, 0.18536487731511808, 0.21410335205094, 0.20075697370056111, 0.193201079719183, 0.19106249123668717, 0.1709403267256333, 0.18231846845676192, 0.08946520659563995, 0.07889921035211467, 0.09923301088563985, 0.08071218931547997, 0.08088478271305122, 0.11532537168815249, 0.0904003852391978, 0.07033093779661415, 0.08941344584499944]}, "mutation_prompt": null}
{"id": "e456f53c-af9c-46f7-b8a2-738078329098", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearchWithResonance:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.02\n        self.mutation_prob = 0.15\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 4\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.momentum_factor = 0.85\n        self.local_search_prob = 0.05\n        self.chaos_factor = 0.7\n        self.resonance_intensity = 0.05  # Introduced stochastic resonance intensity\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.1 * chaos\n        self.par = 0.3 + 0.1 * chaos\n        self.bw = 0.02 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n        self.momentum_factor = 0.85 - 0.05 * chaos # Adjusted with stochastic resonance\n        self.resonance_intensity *= (1 + 0.1 * chaos)  # Dynamically scale resonance\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def stochastic_resonance(self, harmony):\n        noise = np.random.normal(0, self.resonance_intensity, size=self.dim)\n        new_harmony = harmony + noise\n        return np.clip(new_harmony, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if func(new_harmony) < func(harmony):\n            return new_harmony\n        return harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.momentum_factor:\n                    new_harmony = self.quantum_rotation(new_harmony)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                if np.random.rand() < 0.1:  # Chance to apply stochastic resonance\n                    new_harmony = self.stochastic_resonance(new_harmony)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n                \n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearchWithResonance", "description": "Quantum-Inspired Adaptive Harmony Search with stochastic resonance and chaos-enhanced diversity control.", "configspace": "", "generation": 86, "fitness": 0.28219115288115, "feedback": "The algorithm QuantumAdaptiveHarmonySearchWithResonance got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.7552264313029785, 0.7543330537921185, 0.7766709590846591, 0.7527917580720045, 0.7722645122709967, 0.7667721904206388, 0.7699301092035782, 0.7339834406281447, 0.7629813282972595, 0.3296989291500857, 0.43357176680809484, 0.40396503515473015, 0.39308710872881525, 0.3686206368244632, 0.39093226728043806, 0.3562099835643735, 0.42899788164456776, 0.3779968022015904, 0.47657885416176715, 0.48413854937745815, 0.49170688430861376, 0.18355876805211913, 0.408522295614285, 0.43021753878223157, 0.4741754665734629, 0.48335181123253446, 0.4774116655153191, 0.24971566166801207, 0.26786315924555104, 0.34357334437922105, 0.3044032653562816, 0.22986271304908257, 0.3550281836536259, 0.23116810988219771, 0.2360784263632667, 0.28541504782284277, 0.925497021706904, 0.9530510414560798, 0.9266087808545587, 0.9577208531391248, 0.9416528022519209, 0.9550253300244887, 0.9468675258883915, 0.9565207821556604, 0.9511682086985013, 0.23521999806007066, 0.28151280634301, 0.24352030805095526, 0.3953982247700496, 0.3027270662968471, 0.35646520727163833, 0.29820636372203757, 0.2311267509621645, 0.3105962691283507, 0.21039698163641996, 0.23209597730601095, 0.1968701823406157, 0.21232979492431558, 0.26987621608975687, 0.27639838766564906, 0.17148248082891404, 0.36963073870404617, 0.23006929431201772, 0.4329377655786646, 0.16336416652453667, 0.1808828177943601, 0.27693292529711466, 0.2178556099694856, 0.1792291452586332, 0.18416234692751177, 0.16749060035236285, 0.18925817911228637, 0.1394427308694245, 0.13578665820229963, 0.13288435146643574, 0.16147615370522528, 0.13595821480315629, 0.15467957440953928, 0.19055589941862405, 0.1304673190556852, 0.16675568753823378, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04961444266284876, 0.06635996891274154, 0.05974905926396823, 0.03780593053567516, 0.020004822354197538, 0.04869784373673813, 0.03614880812052812, 0.12125626628069963, 0.10563563623333483, 0.04005848319703931, 0.18831134726858123, 0.06313207187005243, 0.14602825545321307, 0.08268528559889587, 0.07061204382708297, 0.10715423607991725, 0.1362947352095023, 0.18941784778172988, 0.0652302397651583, 0.09736645821784806, 0.031379422698039505, 0.09221438941748894, 0.03042617637861511, 0.06277018708434567, 0.24081111572632607, 0.127021248058084, 0.13078653749389324, 0.08254255493167073, 0.4361155761478057, 0.47546096759853196, 0.48462145754370745, 0.40563561248848246, 0.5430455030649453, 0.3903234249916172, 0.4752601199919476, 0.45913349737863607, 0.44844643170825027, 0.14667015177891096, 0.13496284973243766, 0.1444114778694673, 0.11042300463506949, 0.1471111089710757, 0.126777894305398, 0.15870629325756758, 0.07942642549573264, 0.09719485440599818, 0.1607305175822299, 0.18542061672084986, 0.2551997856747126, 0.14343692922650242, 0.2011069581857109, 0.1601388311011036, 0.21297650255036993, 0.14119750724238134, 0.1583629976158556, 0.2720491843453443, 0.37688558597288924, 0.29833860017203273, 0.3429504263227222, 0.3409340930447976, 0.44938156236745774, 0.3045470820057131, 0.4344061921273237, 0.4243743288660362, 0.18003926430169992, 0.2767675088750875, 0.15719304555780378, 0.2814897248792255, 0.15737249736368686, 0.24146753560237866, 0.24419769148166837, 0.2554921365225009, 0.29785682211252107, 0.18856993272195055, 0.21135262068229443, 0.19081836136006425, 0.22625946385770535, 0.22394113169829977, 0.24829099758181084, 0.18241840341182025, 0.2501424750168869, 0.2138414727368667, 0.21531069633899547, 0.1981423347480623, 0.21327014822766832, 0.5889614111214072, 0.2272480357251082, 0.22800215683957603, 0.5984096483907286, 0.2525073784414935, 0.20091054606037728, 0.5127344517394017, 0.8767661737117902, 0.1695582006576929, 0.20057877618539321, 0.8385334114543823, 0.7189890498964229, 0.17586848425220547, 0.16707829664521834, 0.16187565785514513, 0.17222627557816728, 0.16886484396956025, 0.14231781547343958, 0.20924166222655716, 0.16874730757146594, 0.20928263326251928, 0.10481658878906108, 0.4228323556643513, 0.1474052488534251, 0.18695068794470804, 0.18565885863839238, 0.19417530274795458, 0.17567557047915383, 0.1908649501773575, 0.19435594192304428, 0.1889162421821613, 0.18942548563900996, 0.1972439287329002, 0.1084569494457226, 0.08920030804625878, 0.09693268976045422, 0.08841079613359049, 0.09371039338145126, 0.1116279153421812, 0.09479552561125715, 0.08903197421935916, 0.08442557949222995]}, "mutation_prompt": null}
{"id": "db626508-c1e5-4e10-a96f-b6c7b746da33", "solution": "import numpy as np\n\nclass HybridQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.25\n        self.bw = 0.03\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.7\n        self.differential_weight = 0.5\n        self.local_search_prob = 0.2\n        self.chaos_factor = 0.6\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.25 + 0.15 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n                \n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "HybridQuantumHarmonySearch", "description": "Hybrid Quantum-Inspired Harmony Search with Differential Evolution enhancements for improved global search capability.", "configspace": "", "generation": 87, "fitness": 0.31749993193105325, "feedback": "The algorithm HybridQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "0cfa641d-26d7-4384-99de-72c76162ce03", "metadata": {"aucs": [0.8383792601500053, 0.8911043841518682, 0.9264193009532339, 0.825344727396578, 0.8997153727016649, 0.8591817779501637, 0.8991574246193822, 0.7964302736200026, 0.8936029988611238, 0.5207427619391208, 0.5219812295891859, 0.5442307383161437, 0.5377224286107631, 0.4718283184396691, 0.47950338287345007, 0.6688750346773978, 0.4799372467217299, 0.6442782989594842, 0.5748406515365092, 0.572722240015564, 0.43018692968366645, 0.5020939555127538, 0.19204767774039833, 0.5573703880424971, 0.42746677859689497, 0.27215597616604004, 0.4601780869376445, 0.2405031854416244, 0.16407136933509192, 0.19057217900941414, 0.4052668136955545, 0.17456294270139494, 0.31055132877010205, 0.40111814254630485, 0.2540396306244115, 0.45498756112068794, 0.8785233567465442, 0.9172582264817252, 0.892620383341092, 0.9501874537334819, 0.8953132451637369, 0.9393327618222294, 0.9046751933521757, 0.8955617939016149, 0.9322173443744929, 0.37983350365826385, 0.3698109629936783, 0.4016213603950395, 0.4562656659854907, 0.3372672238782024, 0.35768021468504707, 0.32687703594359196, 0.3494349974081985, 0.3190726861331984, 0.2224961260420084, 0.22740034018851696, 0.15063543352036957, 0.2157006670368009, 0.8257143998195974, 0.27770572340070854, 0.17801310691160666, 0.23819354603464016, 0.17545169092950108, 0.18086620163843925, 0.20226452151659702, 0.1437430916549467, 0.1414639202951261, 0.1432510379770967, 0.17742104722408747, 0.17503955971528462, 0.15541085375449548, 0.18937641363040392, 0.15868194841516192, 0.22627812923871304, 0.1291500075128248, 0.18951632390645223, 0.1482497618573978, 0.1515172904345563, 0.17466154193108574, 0.1383581314468162, 0.17111329294219613, 0.026392355775928467, 9.999999999998899e-05, 0.03117849420401997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000384865082396213, 9.999999999998899e-05, 9.999999999998899e-05, 0.09238293069593329, 0.07836219534236899, 0.03601854395731097, 0.0983069913609419, 0.09944083625349254, 0.030251554083577492, 0.13671822028048342, 0.23353989745992698, 0.06601564340707045, 0.1569542204192459, 0.2529979515041586, 0.13197612676885873, 0.149264389192445, 0.20998126124812755, 0.15158488143830473, 0.09285220579479969, 0.17017868787648693, 0.10523535125802241, 0.1867196281325203, 0.18346394660045373, 0.2831568072192929, 0.04956695453182658, 0.21157343472839152, 0.114569368299698, 0.22448589385258066, 0.2619643920657355, 0.27927553813088923, 0.4646570297725455, 0.45816085970588094, 0.452176389129874, 0.46693808495565514, 0.47486047376777074, 0.45749978204805, 0.47104319275507067, 0.475048178765607, 0.4489135040891391, 0.15502218450906513, 0.15064533705878624, 0.1235819269861479, 0.10260195890391055, 0.37396649058690057, 0.13834882171036456, 0.12948912273953173, 0.10706657299322775, 0.0812949848761031, 0.18541013382981486, 0.1597968659036163, 0.3088930848605336, 0.29112137671757643, 0.15879504292590862, 0.14504366771574329, 0.19536415360106518, 0.2168246066020142, 0.19379298322141691, 0.4361307754291539, 0.30900981280947437, 0.30017471257422534, 0.37517529347080203, 0.3737532265612311, 0.4181256128150648, 0.38152683564714585, 0.5057681513118459, 0.2711458468558242, 0.2451729257363936, 0.178324479633719, 0.22043792761675307, 0.27571392042720577, 0.2651364566599922, 0.36197119138884004, 0.20801000343266496, 0.216271236266394, 0.4120128946741548, 0.19769096039632628, 0.200979561096586, 0.2433594802045319, 0.20251287799059436, 0.24843149019935407, 0.20348302730498946, 0.21780523289078269, 0.20664403305202883, 0.21975754806527104, 0.7736867351987846, 0.33059017414811054, 0.5365999180589638, 0.6432962729308151, 0.22259102816338738, 0.6693267196009212, 0.21089336115298996, 0.22246002151624678, 0.20411439613768667, 0.8005841920043497, 0.11652235435468516, 0.15133108624431657, 0.8287092090325425, 0.19974308306310762, 0.19635548754127785, 0.14536507280897326, 0.7890644147896413, 0.7410007018418066, 0.5121555354508307, 0.2054680391865663, 0.1551364750735562, 0.6543572266915627, 0.1279422637636437, 0.21021969901548387, 0.21160195375126956, 0.21239009840912182, 0.4445775162163198, 0.1813710186447337, 0.21449483764946253, 0.1926338392671647, 0.21121944775456536, 0.1838707969470289, 0.1877736559199693, 0.20264341721938794, 0.21315043131268463, 0.19533074547330853, 0.08481108745600108, 0.09341302110828076, 0.08916642746697212, 0.07804898198203014, 0.08259158738640726, 0.07297332859022776, 0.08903461291532, 0.09070788505403182, 0.0799929296242402]}, "mutation_prompt": null}
{"id": "5e66c1de-7c9b-4cfe-9b68-f533d5d1e43f", "solution": "import numpy as np\n\nclass HybridQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 25\n        self.hmcr = 0.9\n        self.par = 0.25\n        self.bw = 0.03\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.7\n        self.differential_weight = 0.5\n        self.local_search_prob = 0.2\n        self.chaos_factor = 0.6\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.25 + 0.15 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n                \n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "HybridQuantumHarmonySearch", "description": "Hybrid Quantum-Inspired Harmony Search with Differential Evolution enhancements for improved global search capability.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "db626508-c1e5-4e10-a96f-b6c7b746da33", "metadata": {"aucs": [0.8383792601500053, 0.8911043841518682, 0.9264193009532339, 0.825344727396578, 0.8997153727016649, 0.8591817779501637, 0.8991574246193822, 0.7964302736200026, 0.8936029988611238, 0.5207427619391208, 0.5219812295891859, 0.5442307383161437, 0.5377224286107631, 0.4718283184396691, 0.47950338287345007, 0.6688750346773978, 0.4799372467217299, 0.6442782989594842, 0.5748406515365092, 0.572722240015564, 0.43018692968366645, 0.5020939555127538, 0.19204767774039833, 0.5573703880424971, 0.42746677859689497, 0.27215597616604004, 0.4601780869376445, 0.2405031854416244, 0.16407136933509192, 0.19057217900941414, 0.4052668136955545, 0.17456294270139494, 0.31055132877010205, 0.40111814254630485, 0.2540396306244115, 0.45498756112068794, 0.8785233567465442, 0.9172582264817252, 0.892620383341092, 0.9501874537334819, 0.8953132451637369, 0.9393327618222294, 0.9046751933521757, 0.8955617939016149, 0.9322173443744929, 0.37983350365826385, 0.3698109629936783, 0.4016213603950395, 0.4562656659854907, 0.3372672238782024, 0.35768021468504707, 0.32687703594359196, 0.3494349974081985, 0.3190726861331984, 0.2224961260420084, 0.22740034018851696, 0.15063543352036957, 0.2157006670368009, 0.8257143998195974, 0.27770572340070854, 0.17801310691160666, 0.23819354603464016, 0.17545169092950108, 0.18086620163843925, 0.20226452151659702, 0.1437430916549467, 0.1414639202951261, 0.1432510379770967, 0.17742104722408747, 0.17503955971528462, 0.15541085375449548, 0.18937641363040392, 0.15868194841516192, 0.22627812923871304, 0.1291500075128248, 0.18951632390645223, 0.1482497618573978, 0.1515172904345563, 0.17466154193108574, 0.1383581314468162, 0.17111329294219613, 0.026392355775928467, 9.999999999998899e-05, 0.03117849420401997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000384865082396213, 9.999999999998899e-05, 9.999999999998899e-05, 0.09238293069593329, 0.07836219534236899, 0.03601854395731097, 0.0983069913609419, 0.09944083625349254, 0.030251554083577492, 0.13671822028048342, 0.23353989745992698, 0.06601564340707045, 0.1569542204192459, 0.2529979515041586, 0.13197612676885873, 0.149264389192445, 0.20998126124812755, 0.15158488143830473, 0.09285220579479969, 0.17017868787648693, 0.10523535125802241, 0.1867196281325203, 0.18346394660045373, 0.2831568072192929, 0.04956695453182658, 0.21157343472839152, 0.114569368299698, 0.22448589385258066, 0.2619643920657355, 0.27927553813088923, 0.4646570297725455, 0.45816085970588094, 0.452176389129874, 0.46693808495565514, 0.47486047376777074, 0.45749978204805, 0.47104319275507067, 0.475048178765607, 0.4489135040891391, 0.15502218450906513, 0.15064533705878624, 0.1235819269861479, 0.10260195890391055, 0.37396649058690057, 0.13834882171036456, 0.12948912273953173, 0.10706657299322775, 0.0812949848761031, 0.18541013382981486, 0.1597968659036163, 0.3088930848605336, 0.29112137671757643, 0.15879504292590862, 0.14504366771574329, 0.19536415360106518, 0.2168246066020142, 0.19379298322141691, 0.4361307754291539, 0.30900981280947437, 0.30017471257422534, 0.37517529347080203, 0.3737532265612311, 0.4181256128150648, 0.38152683564714585, 0.5057681513118459, 0.2711458468558242, 0.2451729257363936, 0.178324479633719, 0.22043792761675307, 0.27571392042720577, 0.2651364566599922, 0.36197119138884004, 0.20801000343266496, 0.216271236266394, 0.4120128946741548, 0.19769096039632628, 0.200979561096586, 0.2433594802045319, 0.20251287799059436, 0.24843149019935407, 0.20348302730498946, 0.21780523289078269, 0.20664403305202883, 0.21975754806527104, 0.7736867351987846, 0.33059017414811054, 0.5365999180589638, 0.6432962729308151, 0.22259102816338738, 0.6693267196009212, 0.21089336115298996, 0.22246002151624678, 0.20411439613768667, 0.8005841920043497, 0.11652235435468516, 0.15133108624431657, 0.8287092090325425, 0.19974308306310762, 0.19635548754127785, 0.14536507280897326, 0.7890644147896413, 0.7410007018418066, 0.5121555354508307, 0.2054680391865663, 0.1551364750735562, 0.6543572266915627, 0.1279422637636437, 0.21021969901548387, 0.21160195375126956, 0.21239009840912182, 0.4445775162163198, 0.1813710186447337, 0.21449483764946253, 0.1926338392671647, 0.21121944775456536, 0.1838707969470289, 0.1877736559199693, 0.20264341721938794, 0.21315043131268463, 0.19533074547330853, 0.08481108745600108, 0.09341302110828076, 0.08916642746697212, 0.07804898198203014, 0.08259158738640726, 0.07297332859022776, 0.08903461291532, 0.09070788505403182, 0.0799929296242402]}, "mutation_prompt": null}
{"id": "e65c240f-819e-4446-9493-26b3146f7e9a", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Increased harmony memory size\n        self.hmcr = 0.9\n        self.par = 0.3  # Modified pitch adjustment rate\n        self.bw = 0.03\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.15  # Reduced elite fraction for broader exploration\n        self.theta_min = -np.pi / 8  # Adjusted theta range for diversity\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.75  # Increased crossover probability for better exploitation\n        self.differential_weight = 0.7  # Adjusted differential weight for diverse trials\n        self.local_search_prob = 0.25  # Increased local search probability\n        self.chaos_factor = 0.5  # Adjusted chaos factor for balanced exploration\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.25 + 0.15 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)  # Adjusted diversity influence\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n                \n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Improved Quantum-Inspired Harmony Search with adaptive parameter tuning and chaos-enhanced exploration.", "configspace": "", "generation": 89, "fitness": 0.29348389175177264, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "db626508-c1e5-4e10-a96f-b6c7b746da33", "metadata": {"aucs": [0.7513531782242081, 0.8781146784204534, 0.7390809046208795, 0.8284102871318023, 0.8278446469576295, 0.868151979131728, 0.8320725364235939, 0.8084213570353468, 0.8378694841166826, 0.4592293954729525, 0.4319207483566959, 0.4182131622322921, 0.42268838878090353, 0.5179749758242411, 0.4935607810890539, 0.3944982042041324, 0.4956008743748238, 0.42643520715629446, 0.26415255800941007, 0.2796074561451153, 0.4779973876072656, 0.3204079525046075, 0.17855899306217438, 0.5233585670275943, 0.42567610846405246, 0.4238552656157336, 0.17813027120922342, 0.1849360019548233, 0.17012883396024503, 0.1778530899463372, 0.44562203273335166, 0.30722359207050465, 0.3966475345787792, 0.16271431460475794, 0.4131883261987367, 0.44959859908446753, 0.9539605146608272, 0.9528613834325109, 0.9193414209796357, 0.9267622867474685, 0.9077654695547739, 0.9532394852329877, 0.9166316170145868, 0.9479940393814351, 0.9333365016063032, 0.4138685564212031, 0.339687581090356, 0.3762090088078588, 0.4623796793386502, 0.44481992458561137, 0.3104308494203548, 0.40174383499285105, 0.32524833906950823, 0.4428992102513738, 0.22823696503779278, 0.22726103731638492, 0.20206824197173268, 0.19512814496137043, 0.27566910837128056, 0.2758745516255301, 0.22185983164723888, 0.36441763984820064, 0.1728314509299944, 0.17069371488240637, 0.15817748078002747, 0.18157474768366222, 0.16179396201494078, 0.143059931121298, 0.15662183370006078, 0.16153059390893154, 0.15746601799799664, 0.297138180167974, 0.14732395976703705, 0.16533326833857642, 0.15806183858629608, 0.294296810380547, 0.10118089718152645, 0.18197926278088117, 0.14578586422390982, 9.999999999998899e-05, 0.05620289591054606, 9.999999999998899e-05, 9.999999999998899e-05, 0.02172115186160828, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035619466987197868, 9.999999999998899e-05, 0.050691410592795694, 0.06099605982174616, 0.0856463495581391, 0.05961218107466759, 0.11307442735159368, 0.05121953150995451, 0.04385947619451758, 0.054699926228098605, 0.06964761431209321, 0.12784356433914634, 0.14093487081408607, 0.08564141308003603, 0.06319884899726036, 0.1503269856538345, 0.21165278944459687, 0.08790858616619612, 0.32343055680670096, 0.1663167346511375, 0.11737707990456892, 0.09077962014144125, 0.2518347969604169, 0.05163673238733013, 0.015580413981417074, 0.08450109898476221, 0.2571690472645447, 0.3005167215812973, 0.2830377971087943, 0.09158649126561735, 0.08434893346036076, 0.4687669105166983, 0.5393170545323298, 0.4717852545091722, 0.4918529667765259, 0.538378082479882, 0.49322610334433303, 0.5210378855908647, 0.47449628042993885, 0.48953320511916765, 0.10911001229404427, 0.10534427653194711, 0.11088410954273664, 0.14751386767020247, 0.15886804002028954, 0.12862624674502798, 0.12013614059530975, 0.14853469320205837, 0.1081590662862647, 0.1708244663236781, 0.2451950045502781, 0.18675143508816427, 0.17598181508619093, 0.15663158155267465, 0.21511421867187863, 0.14817673579895185, 0.2002738286104494, 0.19526006670000462, 0.2826068088916296, 0.20852707385025993, 0.25674440241721996, 0.31089420620899666, 0.3274665269692183, 0.3218255196434062, 0.47928194008857095, 0.3495508114263407, 0.3669117456610883, 0.23633843547370648, 0.3120664526332737, 0.20849198262058732, 0.32319023339095543, 0.3473475595836939, 0.22436255081458312, 0.18312018612539216, 0.3850307926390114, 0.29705333585664506, 0.21372821582955315, 0.20462447289675634, 0.18629209270717229, 0.23168775267175434, 0.19644721084107075, 0.21558590476006223, 0.18877839112805128, 0.19754442811114137, 0.1876129497148803, 0.44562784265840916, 0.2089091658728689, 0.2541070396009961, 0.24770483923878928, 0.2005159650023851, 0.2080082994060658, 0.25353365776643555, 0.24082595862713996, 0.2439168652725121, 0.16525083038707367, 0.16768952509125845, 0.1643230887903484, 0.871432593856549, 0.23637362503881953, 0.8151017140099241, 0.12345643909321458, 0.1684259800639225, 0.9108970916887656, 0.4722117912895445, 0.20790858586976346, 0.37758608035215957, 0.16920749082704567, 0.3519038874919297, 0.20732166537628205, 0.10440751795831094, 0.21274131858327783, 0.4671765366099271, 0.22348344147637544, 0.20388663302692855, 0.17021603070287328, 0.18511962359032863, 0.19537695668241006, 0.1942993377114658, 0.25308388325551057, 0.18602042458021595, 0.17696490026508616, 0.07326893122254219, 0.08431837654833019, 0.1321560755661021, 0.08050044024103431, 0.07462016313124675, 0.10266149378053191, 0.07707955466141592, 0.08483181967414044, 0.09237703866573943]}, "mutation_prompt": null}
{"id": "2cbfd033-bb96-445b-b2cf-d74369a232f4", "solution": "import numpy as np\n\nclass AdaptiveChaoticQHSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Changed size of harmony memory\n        self.hmcr = 0.9\n        self.par = 0.25\n        self.bw = 0.03\n        self.mutation_prob = 0.1\n        self.elite_fraction = 0.2\n        self.theta_min = -np.pi / 4  # Increased quantum rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.8  # Increased crossover probability\n        self.differential_weight = 0.6  # Adjusted differential weight\n        self.local_search_prob = 0.2\n        self.chaos_factor = 0.7  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2  # Used sine function for chaos\n        self.hmcr = 0.85 - 0.1 * chaos\n        self.par = 0.25 + 0.15 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)  # Slightly increased diversity control\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveChaoticQHSearch", "description": "Adaptive Chaotic Harmony Search using Quantum Rotation and Differential Evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 90, "fitness": 0.3228458837608455, "feedback": "The algorithm AdaptiveChaoticQHSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "db626508-c1e5-4e10-a96f-b6c7b746da33", "metadata": {"aucs": [0.8935005201581393, 0.841701058227446, 0.9224100831741078, 0.9213152040372846, 0.8846070351514691, 0.8971430047430292, 0.9233955951197607, 0.9326468742267988, 0.9258200212823013, 0.31998594231659394, 0.8534530155576502, 0.7475721023433556, 0.5654090913724922, 0.5760167853650212, 0.46509835456213355, 0.6603266802475833, 0.5617707776043379, 0.5634327784744171, 0.48281334737016546, 0.5411250080531382, 0.5004803773603673, 0.6065648040699394, 0.19478954134042126, 0.19813117533445768, 0.16838663133665377, 0.6045576519832058, 0.7683884088436456, 0.47866359600461617, 0.15738042980329048, 0.1537873211199885, 0.4120877085865947, 0.4301171166970308, 0.1641805994285438, 0.4875027716964665, 0.40058792763907003, 0.18159836689304343, 0.9633738247089535, 0.9460251609712307, 0.9482289736353839, 0.9495028558964148, 0.949141351456802, 0.9619341616117876, 0.9592112570334558, 0.951537415598793, 0.9652050471658072, 0.4654752152336905, 0.41258833243914983, 0.43186417833496993, 0.4701657472477092, 0.3843169637848898, 0.4529995360720158, 0.39607869316294386, 0.36703028854893405, 0.43203068254823407, 0.38805764500154316, 0.21409073074034457, 0.3917639825668634, 0.19241901711355802, 0.9309837973990949, 0.3829938890729745, 0.4080224642437731, 0.23340966980691114, 0.23464604865007788, 0.1544297607863293, 0.24860979455426746, 0.23752647642193858, 0.18719106540353003, 0.16198628029112971, 0.17576759263060682, 0.17799871663842404, 0.20606935571284457, 0.17551213244138708, 0.165070871599041, 0.14127790671582374, 0.1543809675101283, 0.1632023696198177, 0.16741883125164347, 0.1983433961625748, 0.19760609266307672, 0.20690087160057224, 0.1746203658982216, 0.028794347717476354, 0.005631179184401147, 9.999999999998899e-05, 9.999999999998899e-05, 0.06504916252258286, 9.999999999998899e-05, 0.02898544047233953, 0.060987356914192214, 0.22640403453624736, 0.1032659406012082, 0.07881086141222493, 0.05575917763181826, 0.13247691222444824, 0.050703580039891505, 0.0679442116653115, 0.09224270607307994, 0.2319531148576892, 0.15103344240390548, 0.12782864308918473, 0.09345185755198404, 0.2340203471571457, 0.11588511741913465, 0.13175796652565963, 0.0904071269531147, 0.17048976510002978, 0.20053112412512997, 0.12989593203498973, 0.1530208773926781, 0.09936447682187277, 0.11188302341824297, 0.18508226352276025, 0.1037064131775649, 0.055405930244772805, 0.16872333452285582, 0.2770185036947376, 0.12719630045552854, 0.5546269689703749, 0.4678428361157718, 0.515954807139035, 0.4939011931772056, 0.5134514422054786, 0.5168633022641627, 0.4816893150665861, 0.5306222067125465, 0.5790820635357806, 0.14983455171579285, 0.11092904625230349, 0.1443245491100974, 0.11432608741664785, 0.16106230103716623, 0.06826274037179192, 0.12281635402577573, 0.12247603833821208, 0.14466915528307944, 0.16994819030648, 0.13962164514509312, 0.13422028081472004, 0.18456963106052438, 0.32663308403230185, 0.15347643222968232, 0.19603768991899517, 0.13445002090213043, 0.1759350931621373, 0.39495836620537006, 0.4303415844447428, 0.4158238226669515, 0.4319829954094675, 0.44485791825748644, 0.4534575538318505, 0.49587251655587083, 0.515538197943652, 0.417494427120499, 0.35227123870726496, 0.2216294342690155, 0.26036021724491054, 0.273350258184075, 0.3260202541916447, 0.29001081443942456, 0.2784699228651726, 0.3371365106187163, 0.2662049945490663, 0.20369330097919747, 0.1805662537870112, 0.22517186593390592, 0.19360678639713058, 0.22294114361217754, 0.19198833511663171, 0.18414146047130553, 0.21076440354899573, 0.2242960959788537, 0.25374757877147336, 0.20830561949813875, 0.23942527127204583, 0.1889696115229691, 0.22331999562677363, 0.7245018054567894, 0.20946965651825045, 0.2254929136280026, 0.1934453328604453, 0.206270966397742, 0.1629121040771111, 0.16577458047104043, 0.9029294606684505, 0.8594741549236091, 0.19903559122874703, 0.13061103483975822, 0.16717072922655118, 0.2056968122515327, 0.5984593131982217, 0.2100242334040776, 0.16797244369106012, 0.36778540346841915, 0.16912317121213383, 0.21229600828757478, 0.20939933613464823, 0.4115974014455287, 0.11292166067720477, 0.17967544621375275, 0.18641472011824267, 0.2130550128165739, 0.23498445976451954, 0.18846316583545353, 0.18481908526297597, 0.17391079635849271, 0.17418158834619213, 0.19388869661102548, 0.07808345505672587, 0.09269348243547759, 0.08348836522941705, 0.09255487985148736, 0.10095053146230526, 0.09245469058874167, 0.09586405887906291, 0.07836838478055597, 0.09438222539664876]}, "mutation_prompt": null}
{"id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32  # Slightly increased size of harmony memory\n        self.hmcr = 0.92  # Adjusted harmony memory considering rate\n        self.par = 0.27  # Adjusted pitch adjustment rate\n        self.bw = 0.05  # Adjusted bandwidth for pitch adjustment\n        self.mutation_prob = 0.12  # Slightly increased mutation probability\n        self.elite_fraction = 0.25  # Increased elite fraction\n        self.theta_min = -np.pi / 6  # Extended quantum rotation angle range\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.85  # Further increased crossover probability\n        self.differential_weight = 0.7  # Further adjusted differential weight\n        self.local_search_prob = 0.25  # Increased local search probability\n        self.chaos_factor = 0.75  # Further adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.88 - 0.1 * chaos\n        self.par = 0.22 + 0.15 * chaos\n        self.bw = 0.04 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Enhanced Quantum Harmony Search with Dynamic Differential Evolution for improved adaptability and exploitation.", "configspace": "", "generation": 91, "fitness": 0.35939863795143845, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "2cbfd033-bb96-445b-b2cf-d74369a232f4", "metadata": {"aucs": [0.8959439205432503, 0.8973405112804258, 0.8956829134968151, 0.8902645852416514, 0.8935523394154878, 0.8971604420937922, 0.8976326664534731, 0.903583008541316, 0.8957172639444413, 0.3989611778907225, 0.8331966474799872, 0.8241459126731565, 0.8360498198495494, 0.8197548651313351, 0.814594552290044, 0.789386103998015, 0.6659183536407164, 0.8435750527329775, 0.1806829806515028, 0.48188479252679706, 0.18854167242306974, 0.17359174012945788, 0.15561953500162162, 0.17946928212924318, 0.5353668685979236, 0.1782664015173464, 0.1691954237727743, 0.1442554555344232, 0.43263843160190474, 0.18045723880203224, 0.17174799629358273, 0.15535876919446345, 0.16973220202694772, 0.4550101763805018, 0.1583387976730739, 0.15065640739171082, 0.9476152420926588, 0.9566129347883412, 0.9607417890109503, 0.9431661528673377, 0.9405911146965198, 0.9607405309140934, 0.934888551259614, 0.9794485960788631, 0.9453227970871706, 0.4426561263649057, 0.4981421553083203, 0.49708590068324654, 0.478296704731637, 0.5100317402956074, 0.28895336651044534, 0.45303159786481484, 0.37080105013750886, 0.425082195686571, 0.9014734278136128, 0.6944095421482425, 0.3366383201727249, 0.9417691429723891, 0.9009696619884321, 0.8835346972297634, 0.22637541294892072, 0.23545601966767926, 0.37041681974268625, 0.17852932119986598, 0.422625164275086, 0.17169476598405053, 0.18401784973664836, 0.22486245659971216, 0.16450711193061418, 0.18802244617880526, 0.2091556649750611, 0.22712715899675773, 0.15971839463958548, 0.1908232187522806, 0.1585582724036556, 0.15053356953639963, 0.14928242832279415, 0.16215870475319938, 0.21010411714655508, 0.2945011658045872, 0.12904466944258497, 9.999999999998899e-05, 0.010210263654662599, 0.036814599549325644, 0.029187880733020588, 0.11799160622089677, 9.999999999998899e-05, 0.06479911900509483, 0.1298375183533852, 0.35114039920638307, 0.16364211194066103, 0.19870447619802412, 0.21868842655099174, 0.11615710385892764, 0.012258738482184173, 0.07108530462303386, 0.3039049232179635, 0.10233761984949685, 0.31553298652825157, 0.23279936052865124, 0.2223936813107651, 0.1371955002098021, 0.0948388899042284, 0.09182156259393559, 0.11300935311249927, 0.2773390542064552, 0.10316871256475102, 0.1407734813224264, 0.2596353991073793, 0.24391859768487234, 0.19160821771084946, 0.3619144403253428, 0.32742954588363027, 0.24556083284629593, 0.10739337845096475, 0.2107960937471588, 0.4660482313364427, 0.6869651608867922, 0.8272789002218626, 0.6468556369880534, 0.553868092686607, 0.7034680964794684, 0.6461834134540341, 0.6898924234811127, 0.5711046185867006, 0.5310377240247499, 0.10536047165463402, 0.13030414224540932, 0.145416363409959, 0.1473814198505199, 0.1103807559643517, 0.10289805495922688, 0.12682417993703732, 0.08152086949489679, 0.10712013074289184, 0.17851798352200654, 0.440599323055314, 0.24066143216174163, 0.16876252476565823, 0.15479705394339327, 0.3753725391001468, 0.17837750611836034, 0.3395828321707831, 0.2119073838797968, 0.4753979854619602, 0.5430993992149387, 0.3555701920683617, 0.6983251589844526, 0.4480464605567325, 0.4838256014976504, 0.5354405971573359, 0.5288882648591716, 0.5088173233645604, 0.34104260313575807, 0.37657510227296653, 0.2761144647004471, 0.327186866197943, 0.5040860163188676, 0.2678713812631268, 0.3464687174360641, 0.37959405531990353, 0.2529385476421835, 0.19156238319739505, 0.22546184846288608, 0.20325687834917794, 0.1982450650473052, 0.2654233359653726, 0.2384064276380825, 0.18809700827636666, 0.21850273680444976, 0.18021617263874357, 0.21654330059363458, 0.21988497015944275, 0.2412172170168274, 0.18783286197667637, 0.2478064498175908, 0.20911308057191613, 0.6645484608388953, 0.19239275780656517, 0.5500139650777995, 0.1866654779106086, 0.1668308352528629, 0.15353705591726607, 0.8951226549303501, 0.1961278719373296, 0.8442659606379543, 0.11291181705277797, 0.8833376746130706, 0.1579906864615105, 0.9089959035950723, 0.21098865472397488, 0.12585588086360056, 0.4162051592606081, 0.16502882113921025, 0.3265184556331603, 0.38773079176339, 0.3882576085685878, 0.21063240213160328, 0.21031163764233873, 0.20103840265535977, 0.19023379560587483, 0.1819614227323566, 0.17575827581329317, 0.17316247372696503, 0.17651621182113342, 0.19664128029451922, 0.23777224666310726, 0.08838301257223757, 0.09159869132236764, 0.09292911879507959, 0.10258547739376322, 0.08707615595696239, 0.08963255318568641, 0.09999947748643623, 0.0870123285383726, 0.09730704052927974]}, "mutation_prompt": null}
{"id": "59b5cf49-dd25-45ca-9427-15a1757c4524", "solution": "import numpy as np\n\nclass AdaptiveQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Adjusted size of harmony memory\n        self.hmcr = 0.89  # Adjusted harmony memory considering rate\n        self.par = 0.25  # Adjusted pitch adjustment rate\n        self.bw = 0.06  # Adjusted bandwidth for pitch adjustment\n        self.mutation_prob = 0.15  # Adjusted mutation probability\n        self.elite_fraction = 0.2  # Adjusted elite fraction\n        self.theta_min = -np.pi / 8  # Extended quantum rotation angle range\n        self.theta_max = np.pi / 8\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.8  # Adjusted crossover probability\n        self.differential_weight = 0.65  # Adjusted differential weight\n        self.local_search_prob = 0.2  # Adjusted local search probability\n        self.chaos_factor = 0.7  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.2 + 0.1 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with Enhanced Parameter Control and Dynamic Memory Exploration.", "configspace": "", "generation": 92, "fitness": 0.3273399602728683, "feedback": "The algorithm AdaptiveQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.9177566004820377, 0.8343590688489018, 0.8369121846807154, 0.9163041364736749, 0.9063078815892571, 0.9181062739098927, 0.9273117298550303, 0.9210245026594144, 0.8625563982221518, 0.8572055050088859, 0.8135095667360014, 0.7051739588031143, 0.7110873001899064, 0.4764159788415455, 0.6733741672543855, 0.5973112677825987, 0.4110842704478881, 0.4216638212643088, 0.18592663557456057, 0.3501564816912748, 0.561370313874366, 0.4158016260660775, 0.4227986563206422, 0.1910742253582618, 0.18413427167655205, 0.18978648632075246, 0.49612715979854516, 0.1734694612900548, 0.3446940057039105, 0.1401302955887921, 0.2865449296475132, 0.17148905242721613, 0.17257503861748902, 0.17140086884707417, 0.18142856007176977, 0.17021665144235487, 0.953673948967835, 0.9379918522099536, 0.9710210281685517, 0.9727558029437794, 0.9784601895700832, 0.949449230067029, 0.9619443968116175, 0.9581702248285378, 0.9640180918285477, 0.4230408043639079, 0.4719526551308735, 0.447534895311095, 0.4051404985440705, 0.49324493899521227, 0.41334876142201293, 0.38395692385757163, 0.41232832510681183, 0.4205376032505094, 0.22859725919978868, 0.13813009605016158, 0.17060633211050935, 0.38621432708347214, 0.2771677612734422, 0.21181290990045165, 0.34719714467238916, 0.9108507740980581, 0.20029574177581677, 0.17751203546557992, 0.3148018702348252, 0.19936537008722977, 0.16087362686714912, 0.1985330215461243, 0.25550872851609474, 0.16276778608774745, 0.16749540208458236, 0.17103996566613566, 0.15951652691811014, 0.15895523145543777, 0.2112551257121631, 0.20048646215195853, 0.15972399968428286, 0.14722448026244783, 0.13386598496997426, 0.11436808309429414, 0.15970837371033375, 9.999999999998899e-05, 0.0011163057982230828, 0.04207625792484326, 0.022838356375350477, 0.0029019501466693853, 9.999999999998899e-05, 0.0044396030408117015, 9.999999999998899e-05, 0.08531564979447326, 0.10033166971456775, 0.07046540757969522, 0.09875560941735761, 0.11533618902379783, 0.06476474529231369, 0.07082086656255271, 0.09375033332417315, 0.09732480820579914, 0.18206793730368986, 0.060364495121275286, 0.23588305511712881, 0.11862895868811507, 0.08291888774109446, 0.16084760922586305, 0.16543037324713272, 0.2116522929513791, 0.10565129594036937, 0.11586403178270321, 0.09465667115220944, 0.15413653612292255, 0.311943463561694, 0.08803123613463615, 0.19488656411211291, 0.05739839721446083, 0.15658995395510833, 0.21001301824971175, 0.10880517150594005, 0.6414205855128614, 0.5479715623787825, 0.5611180970626152, 0.5253098065418771, 0.5874173657664012, 0.539004751185971, 0.4875315917268489, 0.47891048666334934, 0.5651184426843325, 0.08780495385358011, 0.10846923575496403, 0.11067467959169375, 0.13347522430497616, 0.16179019670296768, 0.09701024451447993, 0.15451827947908336, 0.10538326791653674, 0.11547428634641255, 0.1602498796599492, 0.24938089757059878, 0.17867475018016632, 0.26307623706841543, 0.360189453852505, 0.23437176163625106, 0.37891446503233384, 0.1671305151513609, 0.25157401518243183, 0.22955804014889114, 0.5217765414660933, 0.4334806528071272, 0.4714178450798413, 0.373324546413886, 0.4512586347877342, 0.2826959443531537, 0.46737875121538774, 0.34652667985983976, 0.39510879716240566, 0.2635379415416388, 0.1856994100262378, 0.36537496487765764, 0.3590430331261011, 0.3009855245076567, 0.3239750430627074, 0.3066502040006053, 0.2863826135615911, 0.1891407485204487, 0.18507774572539026, 0.19258195576749082, 0.22436820947450598, 0.22848507423302122, 0.21484040893682455, 0.19228324970351263, 0.20705065145896584, 0.2242624838325935, 0.21176187629754517, 0.57121152840558, 0.19761197281498166, 0.22550556245206876, 0.24840688261869803, 0.8721035510026885, 0.20162759927850216, 0.20871663318950884, 0.20256243589940193, 0.16504675513073586, 0.864950932359821, 0.15346281934257333, 0.8772193519455402, 0.19914993295203953, 0.171283964235185, 0.16620658929925503, 0.909185261818447, 0.9029777051469557, 0.7045692645365662, 0.20507206907288023, 0.21059561275961292, 0.3781032840231534, 0.1673561704528722, 0.21159839255792567, 0.20957799362381357, 0.7989225559937074, 0.48911653535684885, 0.184070548888687, 0.20474578080709094, 0.19360845973432805, 0.23915603045813771, 0.17702071035587874, 0.23925423268194335, 0.2141449897121338, 0.17851361965584622, 0.17156632541401962, 0.10100010830009909, 0.07941803075914011, 0.14714853730228883, 0.08961054926620671, 0.0968750479603615, 0.0782300931159059, 0.06816533143517356, 0.09034362960059716, 0.10908380520011729]}, "mutation_prompt": null}
{"id": "e1c01ae2-e958-4ae0-a612-c33731965fe5", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32\n        self.hmcr = 0.92\n        self.par = 0.27\n        self.bw = 0.05\n        self.mutation_prob = 0.12\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.85\n        self.differential_weight = 0.7\n        self.local_search_prob = 0.28  # Increased local search probability\n        self.chaos_factor = 0.77  # Slightly adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.88 - 0.1 * chaos\n        self.par = 0.22 + 0.15 * chaos\n        self.bw = 0.04 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)  # Increased perturbation strength\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Adaptive Quantum Harmony Search with Chaotic Variations and Enhanced Local Exploitation.", "configspace": "", "generation": 93, "fitness": 0.35426780956769294, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8963240637279318, 0.8959345856877359, 0.896808771173332, 0.8756624782548343, 0.8829060536882496, 0.882677239175913, 0.8872087317673303, 0.8909021982374117, 0.9026819883369321, 0.41585752207223314, 0.8224647941454459, 0.780655693399071, 0.8150327030330881, 0.7569255562411571, 0.42986635430648124, 0.8361221226662808, 0.8008546723463077, 0.8064899983234413, 0.15527152030063607, 0.20864731050414398, 0.6415374655117432, 0.696540691847765, 0.18197124309817259, 0.16249931048540533, 0.14943961151014495, 0.6457761141433072, 0.604307531600626, 0.1473218699767529, 0.14939783062710488, 0.18057317183935884, 0.17008175475375975, 0.17924188720652234, 0.1715058096751807, 0.15259312220312515, 0.3934149533761354, 0.5085161389904129, 0.9577025296588401, 0.966858888554124, 0.9660104149870963, 0.9641990965747929, 0.9503441928025376, 0.9483100248154254, 0.9598923547424763, 0.9703642617125893, 0.9606852119684266, 0.4776234386888427, 0.4694063317734726, 0.49768768981415656, 0.4281706803067008, 0.43050685768402464, 0.36748495450299823, 0.4507988244761998, 0.4240221385561418, 0.42632797619757234, 0.22957071630508408, 0.35120307093181746, 0.890480241594949, 0.7280500374455807, 0.8783259900951724, 0.7187388532325227, 0.5386357004161445, 0.8496845221961455, 0.23275464036037485, 0.16443597841169066, 0.19008354802902727, 0.16847506947273816, 0.17247313351371663, 0.18538881860767675, 0.21911541559213832, 0.24618036336665006, 0.19273768167996108, 0.1716426989537666, 0.2085993405455241, 0.1303162569991304, 0.15059624715970443, 0.15212347389183156, 0.1515233975801371, 0.15395413026429994, 0.1773388080308549, 0.18871273581352355, 0.1432194343264429, 0.12560364969633941, 0.009900493375368025, 0.00220110632199777, 9.999999999998899e-05, 0.009243679323990173, 0.05236615423434199, 9.999999999998899e-05, 0.08126290130496361, 0.011098357536032943, 0.18996659717018716, 0.09883937383673225, 0.057169664185747204, 0.0966256725128174, 0.06012918865114658, 0.055280702334123855, 0.2513303327352552, 0.1704928786494756, 0.3317968823206968, 0.17980930411046303, 0.07756350282610425, 0.18383711893840216, 0.2955388208057532, 0.13791500495416475, 0.10187536876331382, 0.12399951027857037, 0.3018029915569659, 0.25846793825563064, 0.1291380844053599, 0.08978525759998446, 0.21463517343026683, 0.24501439385208046, 0.2136611925194971, 0.17417701215707926, 0.21234708189651075, 0.2404845449825671, 0.3718575828434687, 0.5267712986047781, 0.6150648797935858, 0.6450983827309794, 0.6089442241484598, 0.5837172265801529, 0.6009820499445037, 0.5053661435841262, 0.5882055278598421, 0.631704779298522, 0.1475166147889837, 0.14041875114271296, 0.1766985174649519, 0.12365809698999275, 0.10123127246682084, 0.1679627924795879, 0.13063835494929155, 0.10863098393547665, 0.133401592756609, 0.18749886164741214, 0.17657861053526758, 0.1978771444410199, 0.3180043802818412, 0.26695107215324954, 0.3645303408123931, 0.3458873728356291, 0.2341967700833827, 0.28991673481126523, 0.6082825964094589, 0.43624781130810353, 0.5019304382978629, 0.41823799199497613, 0.43655161008940824, 0.45271855654142346, 0.5789416025357159, 0.5019889752209661, 0.4802254160639695, 0.3146660311948062, 0.25720906083088246, 0.2541033726834716, 0.3394941801546075, 0.4006067737296888, 0.24256359512214742, 0.3478937063588352, 0.4607612467852754, 0.2737918351799261, 0.19177712061999963, 0.18604598570227693, 0.22689458186921752, 0.2074847105961477, 0.184616561615501, 0.23303773462602828, 0.19238925580623822, 0.22925756519575213, 0.1715942297913935, 0.2406847093952862, 0.24980555899338486, 0.19906054808197327, 0.2225678789712947, 0.6679078507840919, 0.6869480430427378, 0.24592525460905656, 0.19597911189497375, 0.6471749698908233, 0.8358960299830722, 0.1861253052899159, 0.1538141884163755, 0.9221882072360489, 0.18735016537484395, 0.1747813421510369, 0.13496034878544705, 0.16406257573931948, 0.16531314264560792, 0.7734973823147204, 0.2103821921837522, 0.1271055973792261, 0.8611238992277565, 0.16446584075630433, 0.20851232225957306, 0.21226735988432355, 0.4424110294820057, 0.21107558186554343, 0.1786960055952861, 0.22148667236408492, 0.20697979811921507, 0.2025605729178822, 0.2150230871812815, 0.23220973710632165, 0.2359136185646037, 0.1833843890761886, 0.17761683855713417, 0.08188735373292966, 0.10307386959549936, 0.07788971465152239, 0.08529115767361362, 0.09742785762141115, 0.07987847460594877, 0.0927411258545402, 0.08451933448535587, 0.09692894360354298]}, "mutation_prompt": null}
{"id": "6d020111-0891-4b6a-87fd-566f986f6139", "solution": "import numpy as np\n\nclass QuantumHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 30  # Adjusted size of harmony memory\n        self.hmcr = 0.9  # Harmony memory considering rate\n        self.par = 0.25  # Pitch adjustment rate\n        self.bw = 0.1  # Bandwidth for pitch adjustment\n        self.mutation_prob = 0.1  # Probability of mutation\n        self.elite_fraction = 0.3  # Fraction of elite harmonies\n        self.theta_min = -np.pi / 4  # Quantum rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.9  # Crossover probability\n        self.differential_weight = 0.8  # Differential weight\n        self.local_search_prob = 0.3  # Probability of local search\n        self.chaos_factor = 0.7  # Chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.9 - 0.09 * chaos\n        self.par = 0.2 + 0.15 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.15, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumHarmonySearchAdaptive", "description": "Quantum Harmony Search with Adaptive Differential Evolution and Chaotic Local Search for enhanced exploration and exploitation.", "configspace": "", "generation": 94, "fitness": 0.3543674941561233, "feedback": "The algorithm QuantumHarmonySearchAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8441264710512982, 0.8648251015521323, 0.8726314141202777, 0.8600618684163579, 0.8823638438827995, 0.8610344247627466, 0.8944375191821368, 0.8799578810499463, 0.8663935378542862, 0.7080607225457418, 0.7672167493126958, 0.7649641268571563, 0.7991692963421692, 0.7825895409523347, 0.7945454709542434, 0.7599420354063317, 0.7917749237043474, 0.7893527418487551, 0.17227979614944466, 0.1874566744767473, 0.15253971815081768, 0.14159144203294405, 0.14492572204923182, 0.18448624351891718, 0.2433537315667189, 0.15485460085626912, 0.7083851245026, 0.15317486984471596, 0.41570671349321264, 0.14066492734523273, 0.16539458160976717, 0.16831421792485157, 0.15312777275637257, 0.15364812736782585, 0.170612300863477, 0.1625854139697187, 0.9311463461861551, 0.9687289092802975, 0.9286351506423041, 0.929132410226602, 0.9697166429889446, 0.9111609620633605, 0.9471667148363189, 0.9748456935813886, 0.9327245322706922, 0.4887224021932143, 0.4770311734930922, 0.5857534603259164, 0.5145951228724944, 0.5033639845407517, 0.556322085987937, 0.521176707934299, 0.4142405953504359, 0.46503952499277323, 0.8625748244221384, 0.8758578954417975, 0.37857604248821275, 0.2761911506586955, 0.37736845752705406, 0.8147688108757827, 0.8786676068980415, 0.8664163832606027, 0.36748882671731364, 0.17123733136215613, 0.18631732662307154, 0.19373144162945766, 0.21325030230654407, 0.22033716743941356, 0.7077092242899465, 0.2120578606396767, 0.20030966781884396, 0.2007316300733385, 0.1576879923083303, 0.1227230855849819, 0.12978631207576474, 0.19708578874991622, 0.19064957104989066, 0.17960884839582636, 0.20954622319970773, 0.2058705951366483, 0.2053821349924576, 0.19868251301873674, 0.09550887830703703, 9.999999999998899e-05, 0.11111043864355541, 0.08389275368219973, 0.13894761835993197, 0.2353995390029353, 0.06863599297658896, 0.21161686639207744, 0.36879639608428827, 0.2356489337233425, 0.07760400354074515, 0.06779170976891402, 0.1256382860930918, 0.10655970198157227, 0.15591541831465716, 0.3368938935625223, 0.23407928081355966, 0.12712420051795725, 0.06846934906873958, 0.19212158137807078, 0.23283111118980238, 0.09223119311937611, 0.1084514102206382, 0.09547851655365391, 0.07637020655008875, 0.3631069318970567, 0.09467931704816235, 0.27217455128243595, 0.07605090853599628, 0.32493850026858984, 0.3070542308877252, 0.23464827682604228, 0.3227643126701506, 0.311332512095021, 0.24796495481585368, 0.7620199922231301, 0.5993918748063711, 0.5237909965063225, 0.7434150431398214, 0.5892636695034326, 0.577818987035099, 0.5726389262035393, 0.5342297684021049, 0.5174829856174382, 0.09905714044308811, 0.09167184375644033, 0.14603805761431143, 0.12578446703063495, 0.09458577988364936, 0.09175281620033005, 0.10656737593935284, 0.15074563664982432, 0.08879481282721458, 0.3615811493917086, 0.14275726141674094, 0.14826526108687998, 0.2685813430290911, 0.2566867339250012, 0.2357894310501858, 0.1877153597888942, 0.1478743808475801, 0.1888521723141674, 0.44589055870700245, 0.3870533234623196, 0.5292136456699676, 0.4308245752653138, 0.5352932296018991, 0.38266735431914634, 0.5209761846413412, 0.5276268906861279, 0.5523064141310973, 0.3394212803216142, 0.3748648716577996, 0.24850092953738112, 0.2596129746498378, 0.310252573930206, 0.264279806607018, 0.3294633009304486, 0.38082462882000745, 0.36535324812020376, 0.23079788960910663, 0.19386583923003187, 0.15102409305607922, 0.203172995613896, 0.18009994722358547, 0.19486110297483006, 0.15417726815268873, 0.2321760468009736, 0.2301886472499931, 0.7477422131028101, 0.6244414011168955, 0.20668464678996956, 0.2078428628701754, 0.2206099572934419, 0.22067316866440656, 0.2251861168575796, 0.24813030442929962, 0.7301413104828749, 0.1879003695802116, 0.16207674257566473, 0.1535922951929649, 0.17496418290793048, 0.1979132610565355, 0.17236675321774397, 0.7195015835498475, 0.18386048614468087, 0.1853256789299439, 0.9214444276938081, 0.1547971988310457, 0.3702797020799098, 0.45537517781804693, 0.16862333339369984, 0.8446481440655478, 0.36337466270054974, 0.10408905045758088, 0.15372517918685003, 0.2048648925790808, 0.204442895638427, 0.19960290183862073, 0.2054491058061757, 0.19423782428194714, 0.19689534419137622, 0.17615492689338919, 0.22044825376215826, 0.18683931062714332, 0.07505680132365178, 0.08938570285083902, 0.08320758898702829, 0.08803058757034266, 0.09522792746959807, 0.09380473146952317, 0.07028238361462757, 0.07517338910428084, 0.09242221192381472]}, "mutation_prompt": null}
{"id": "47ad9389-b5ac-4b4e-b353-f4c3c68fcdba", "solution": "import numpy as np\n\nclass EnhancedQuantumHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 28  # Slightly adjusted harmony memory size\n        self.hmcr = 0.93  # Modified harmony memory considering rate\n        self.par = 0.26  # Adjusted pitch adjustment rate\n        self.bw = 0.06  # Modified bandwidth for pitch adjustment\n        self.mutation_prob = 0.13  # Adjusted mutation probability\n        self.elite_fraction = 0.20  # Slightly adjusted elite fraction\n        self.theta_min = -np.pi / 5  # Modified quantum rotation angle range\n        self.theta_max = np.pi / 5\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.83  # Adjusted crossover probability\n        self.differential_weight = 0.6  # Modified differential weight\n        self.local_search_prob = 0.30  # Increased local search probability\n        self.chaos_factor = 0.70  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.abs(np.sin(self.chaos_factor * np.pi * iteration / max_iterations)) ** 2\n        self.hmcr = 0.89 - 0.09 * chaos\n        self.par = 0.23 + 0.14 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.06 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "EnhancedQuantumHarmonySearch", "description": "Quantum Harmony Search with Dynamic Differential Evolution and Adaptive Chaos Incorporation.", "configspace": "", "generation": 95, "fitness": 0.283947637287393, "feedback": "The algorithm EnhancedQuantumHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8001639913267588, 0.7825252485825199, 0.8977308977505138, 0.8077193585952173, 0.7644492900018545, 0.8729719266221834, 0.8175073138537912, 0.8238783250312196, 0.897916792856575, 0.3560172448815131, 0.40459102696825955, 0.4111785831575052, 0.4191431997297467, 0.5993158245942567, 0.4871463083497266, 0.7128689794663788, 0.5588003563734474, 0.4196427309825662, 0.16876878080657642, 0.1754813712519575, 0.21232369535083673, 0.18595525489189235, 0.16113815416214816, 0.46621679890152123, 0.19211470864430114, 0.16287501754617917, 0.15316308702829662, 0.3880109044089012, 0.17452194874999727, 0.1516273823515124, 0.1576559721407419, 0.1507925981067496, 0.13242732155597237, 0.1602233528346786, 0.18076780558191918, 0.15641434158470857, 0.9710279908333397, 0.9364176064157095, 0.9360568576136468, 0.965858304275637, 0.9453244007499788, 0.946357700350892, 0.9177032012205855, 0.9658824654149896, 0.9545157934984005, 0.47618523921849243, 0.40496486190172454, 0.4630292389465084, 0.40701830602504074, 0.344567583978859, 0.40331062228916215, 0.4048705963933704, 0.35331275147616636, 0.39979768648478153, 0.2181787312394703, 0.15654955724333053, 0.1408622943711031, 0.21443195271910687, 0.8016077748976638, 0.27994019110209367, 0.16349047751558177, 0.18327377140457524, 0.9332387966957787, 0.08627492436342943, 0.19466811921534954, 0.1539983997835791, 0.3658318696279127, 0.12279889300680136, 0.26949984108101777, 0.31814579887078676, 0.17962900117599745, 0.16357762558897282, 0.2348477403705812, 0.14219007841891185, 0.16120122604883547, 0.161660440426736, 0.1690223253979417, 0.18138622471232824, 9.999999999998899e-05, 0.14567973472430695, 0.20209567200826362, 0.004749499987058314, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015662095933870468, 9.999999999998899e-05, 0.010323186769173875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14905833381010203, 0.039685449546304374, 0.09217236272781115, 0.08435675586864766, 0.040596073093766116, 0.016419703811208053, 0.0981392137750623, 0.09936552704526036, 0.11526616828990577, 0.12582941960944938, 0.1847367617887673, 0.04940123680767561, 0.20655317615762092, 0.3135616739838517, 0.13116217665429541, 0.1060790226395999, 0.07367899411069356, 0.3308890433854932, 0.1618015793036196, 0.10665479886649987, 0.13921817744188925, 0.11270458527834759, 0.09163212987498137, 0.27025548517010156, 0.14103702547983044, 0.17331986874724048, 0.19614136905377144, 0.4536706649058989, 0.4437648178938056, 0.48145684144790024, 0.46145628700900865, 0.4477132063259922, 0.4476548684585345, 0.494383065973531, 0.4557447669905107, 0.4931007086113728, 0.10043440223499223, 0.16092870260593717, 0.1580972376154246, 0.12875823695122057, 0.11338102280293749, 0.09284776051180765, 0.16150891810500378, 0.07956893280633903, 0.12823887262348654, 0.16375496313994686, 0.16468482318676148, 0.13501110878911526, 0.34479279780101946, 0.21616262982795964, 0.2909050361482973, 0.19080530353769531, 0.14987260979996442, 0.2921249977858211, 0.3068313343765977, 0.349047274037832, 0.4314563409208514, 0.29779173306575035, 0.2954662944533012, 0.25148945737052086, 0.22836903657667373, 0.42890559939291517, 0.4281619741263487, 0.19001595570979302, 0.21986139640941116, 0.27931707972967357, 0.24167002657497771, 0.16541461329478735, 0.21812900963502457, 0.2982409271110059, 0.2068429669032117, 0.1863766663486769, 0.17932978912476083, 0.23566575108491805, 0.22559335649730972, 0.2001995722620883, 0.20302096819620152, 0.21780354245257372, 0.1915184945888786, 0.19889796661628512, 0.19331449759760433, 0.25550334652588924, 0.2131311679495197, 0.19883643429300069, 0.2509138281614198, 0.2127262359944182, 0.22331648200297638, 0.20799087267059768, 0.21618287663825209, 0.25049769780049036, 0.1657614707023889, 0.1324482131365401, 0.14675099130335134, 0.1728067296115401, 0.20091398960021, 0.8909534523376805, 0.7440927892430184, 0.2067265464923429, 0.16713527784231152, 0.5846779594324942, 0.1543240200260363, 0.49291812573168325, 0.2046292242980422, 0.12720446915334538, 0.1661533750941533, 0.16684679951645087, 0.15474385551787273, 0.20871634875037892, 0.1810218162662599, 0.18513601207474895, 0.1950655320461726, 0.2148107181251364, 0.2102027508559705, 0.22205519651489547, 0.17606809724602968, 0.17416636154233278, 0.191513078871826, 0.09852690595461222, 0.08631513231470855, 0.06465856181308649, 0.09495859543499063, 0.09988509567096993, 0.09715220585243001, 0.05935883030593192, 0.08827329899843717, 0.08568010322159336]}, "mutation_prompt": null}
{"id": "47cdf9ec-7635-402b-a91e-258d512b9a53", "solution": "import numpy as np\n\nclass QuantumEnhancedHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32\n        self.hmcr = 0.90\n        self.par = 0.28\n        self.bw = 0.06\n        self.mutation_prob = 0.11\n        self.elite_fraction = 0.20\n        self.theta_min = -np.pi / 5\n        self.theta_max = np.pi / 5\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.87\n        self.differential_weight = 0.6\n        self.local_search_prob = 0.30\n        self.chaos_factor = 0.78\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.85 - 0.05 * chaos\n        self.par = 0.25 + 0.10 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.03 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumEnhancedHarmonySearch", "description": "Quantum-Enhanced Harmony Search with Adaptive Differential Evolution and Dynamic Local Search for diverse exploration and refined exploitation.", "configspace": "", "generation": 96, "fitness": 0.3070520666944048, "feedback": "The algorithm QuantumEnhancedHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8935358037363926, 0.8399500741324571, 0.9260495066786159, 0.8902522951549772, 0.8057060253898534, 0.8983153080170947, 0.8825380867284687, 0.8097083274954392, 0.8855823474388368, 0.3611994289062511, 0.8269501310389054, 0.6817032429365498, 0.551614349731649, 0.4632680214454211, 0.3654084352542334, 0.45122825247302967, 0.5833570852657459, 0.3358263083229337, 0.171619996404743, 0.1658304908860846, 0.30477597083625796, 0.15779914422327934, 0.14336055285191107, 0.3486701054423935, 0.1543892311985795, 0.27948555711221734, 0.37515681856719574, 0.16878963245767897, 0.10763582895045931, 0.16799938655442836, 0.16760011748286707, 0.41667598777429826, 0.15225575533143587, 0.15750313520250525, 0.2418864069089014, 0.13500407102550638, 0.9192111366985166, 0.9051667417382854, 0.8801478170101353, 0.9414402886304699, 0.944811505639055, 0.9414073747508667, 0.9237361326335102, 0.9230013701705676, 0.8954136638251367, 0.2918677574350421, 0.3658207172148663, 0.36975126838776073, 0.40759737896857307, 0.3928418786702086, 0.3573429367209866, 0.379170678891949, 0.35014641827790915, 0.3226962620119713, 0.22844765144390533, 0.3769326014993699, 0.15669290871968566, 0.21357779711133884, 0.2792636300990997, 0.3762474686506927, 0.3543449103866093, 0.23431238309840086, 0.4707259910347118, 0.3351696583375041, 0.22510746479411448, 0.3329000763217881, 0.21056116618178944, 0.1926947607493541, 0.16580976583455398, 0.2670263963278455, 0.13223336279018671, 0.17768776513730167, 0.23231759932756957, 0.198246183297067, 0.21205469715734482, 0.1700383946279751, 0.1345894656652099, 0.14397925185492044, 0.21200915907751172, 0.2048336136297706, 0.2296510059490926, 0.024345835800404503, 9.999999999998899e-05, 9.999999999998899e-05, 0.12964582048867868, 0.07389748483528258, 9.999999999998899e-05, 9.999999999998899e-05, 0.03996890958909516, 9.999999999998899e-05, 0.1892299984150968, 0.03846299038265055, 0.19993693336265583, 0.06269635224874326, 0.04714123385266644, 0.12490962820809381, 0.11964225409376139, 0.09405942057886096, 0.317205840529441, 0.22372474948545984, 0.036450021556209355, 0.11569206487333994, 0.3212687950826556, 0.15386416286485782, 0.26214619078800516, 0.0856084069526507, 0.09168648400726342, 0.25015299498049526, 0.1275190450274376, 0.13949761191194343, 0.12902141814041757, 0.1933956814258565, 0.23274645238426706, 0.10709833398990976, 0.15221329389256133, 0.14749659740465326, 0.08347062048890908, 0.4532554039428436, 0.5095913588127082, 0.4430320664914704, 0.463494922917971, 0.44932769774919434, 0.5402838146068802, 0.45777753790803066, 0.6293622288749804, 0.48927785511829125, 0.11985364447433278, 0.061411916501186714, 0.101967970937897, 0.1291633922350658, 0.13479760027100296, 0.10042776012558319, 0.14430341612310427, 0.09481848291096628, 0.13458862948241546, 0.17895987682894687, 0.23207147553981244, 0.17719051458584056, 0.30365702742193423, 0.3494922455368905, 0.4067413363600796, 0.1878827170618108, 0.17065899164211185, 0.1896440642540831, 0.2117732750685798, 0.27607550216050425, 0.18911483212887747, 0.3942635473504079, 0.39472105710586214, 0.28827871162404917, 0.40134995321425615, 0.4901230249764753, 0.402772880131968, 0.3039346122372122, 0.33957225702370275, 0.3005237801035714, 0.39763309903439137, 0.3475084076716609, 0.2626691856090859, 0.2845746625166452, 0.3875627691049732, 0.3217552100541038, 0.20427718740895628, 0.19397500078664587, 0.2565614391257357, 0.22036659145260296, 0.24247792686977532, 0.2169583204884704, 0.1975457565251929, 0.27453960904779595, 0.19235239737044063, 0.19370926628756557, 0.20847577095370284, 0.20779165841844804, 0.22056008244081193, 0.6750139246729691, 0.20822981082622305, 0.20363317642622292, 0.226064858332496, 0.2072524942827847, 0.16520113884928578, 0.17366013783884604, 0.15425072298903109, 0.2982761306380539, 0.9393380747008239, 0.7840045559127, 0.9372569194160592, 0.1650661940455389, 0.8352383284196492, 0.8988931388210148, 0.2116888467013559, 0.15494916439870798, 0.19885331925444594, 0.2114385928725886, 0.2090933843506656, 0.16716904029905744, 0.16670726576681516, 0.500387141069388, 0.1759160447952398, 0.21024136315618291, 0.19079596531937537, 0.19176235186023294, 0.2130615608526093, 0.18361510378282841, 0.1821952738174899, 0.2233272955995459, 0.20144543087270117, 0.07924798324221682, 0.0776768660937851, 0.12998835830672417, 0.08447559674797789, 0.0871069608684567, 0.09758618579000744, 0.09385636035005551, 0.08978417397880789, 0.08031214288412214]}, "mutation_prompt": null}
{"id": "b9966370-f583-45b7-8f62-715ef86d24bd", "solution": "import numpy as np\n\nclass QuantumAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32\n        self.hmcr = 0.9  # Adjusted harmony memory considering rate\n        self.par = 0.3  # Updated pitch adjustment rate\n        self.bw = 0.06  # Updated bandwidth for pitch adjustment\n        self.mutation_prob = 0.1  # Updated mutation probability\n        self.elite_fraction = 0.2  # Adjusted elite fraction\n        self.theta_min = -np.pi / 4  # Extended quantum rotation angle range\n        self.theta_max = np.pi / 4\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.8  # Updated crossover probability\n        self.differential_weight = 0.8  # Updated differential weight\n        self.local_search_prob = 0.3  # Increased local search probability\n        self.chaos_factor = 0.7  # Updated chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.abs(np.sin(self.chaos_factor * np.pi * iteration / max_iterations))\n        self.hmcr = 0.85 - 0.15 * chaos\n        self.par = 0.25 + 0.2 * chaos\n        self.bw = 0.05 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (c - b)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.08, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumAdaptiveHarmonySearch", "description": "Quantum Adaptive Harmony Search with chaotic learning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.33215830205517777, "feedback": "The algorithm QuantumAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8842112516458742, 0.8934346849827199, 0.8780745512422279, 0.8762910913835568, 0.8882049248452879, 0.8779698350719192, 0.8606959439805907, 0.8426379160381802, 0.82866574209123, 0.8036685409468816, 0.5403521793147157, 0.4868235017264604, 0.6832757705711037, 0.7808032272903631, 0.6918143331169271, 0.7529703541333987, 0.8121223561669245, 0.8056055007277415, 0.4866010092104064, 0.19437409100610303, 0.17253157141955544, 0.16622756457372778, 0.17334426784453516, 0.746442774934511, 0.5521056847593424, 0.5799140975235135, 0.48724275083145296, 0.17324919116948712, 0.5737375627648202, 0.4333334723262323, 0.6648104989129473, 0.46734385887252905, 0.1380722078839557, 0.15295934126762623, 0.1734774542811499, 0.35541529461772925, 0.9622675715500895, 0.9619449079072235, 0.9558621147757911, 0.9518040044274879, 0.9545349185764864, 0.9766366487850374, 0.9537158285490779, 0.9347963142479673, 0.9710363967214277, 0.45399918570642117, 0.5170900476923344, 0.5766443709289684, 0.5458634467338841, 0.4789678405776403, 0.45921811598389406, 0.4119091212637923, 0.38127396760280086, 0.4671299264549381, 0.35818477775750046, 0.16840441329906697, 0.22546876461344512, 0.21301628108951987, 0.2138560386820627, 0.9146743902269108, 0.39413774730803675, 0.3902264520023254, 0.8323833479064107, 0.17233859807622998, 0.4358240231909226, 0.17125182083374058, 0.16061678049549177, 0.1763291644892543, 0.167441275325674, 0.20082094760659386, 0.20896188818795258, 0.22425029008767883, 0.1825867810616375, 0.18452005897054868, 0.1726755281272686, 0.21507311115831418, 0.17136167474962494, 0.18626348774689572, 0.1831625977436362, 0.1042066220978024, 0.11681543743572365, 9.999999999998899e-05, 0.1264842219036193, 0.08886048532857749, 0.11182280493993824, 0.03796551096356182, 0.07633995825361617, 0.09317349900919347, 9.999999999998899e-05, 0.11862090322040875, 0.061251383421002226, 0.07569189087127015, 0.10813018700051547, 0.10029165208194901, 0.09694612428956229, 0.023963003140278438, 0.10624926180025474, 0.20978427621310103, 0.15802456000664789, 0.18400629290757153, 0.04238682702078134, 0.14646483703640512, 0.11542722313400677, 0.10603680074109578, 0.07791185223494668, 0.09723190773969148, 0.21173409205189508, 0.27374412354776556, 0.25132793884100635, 0.13698101092421444, 0.11689693880821617, 0.31913699033343734, 0.1298176112231253, 0.19993924591889056, 0.3195897848700996, 0.20306854473305946, 0.2005666908240189, 0.5509811349427962, 0.6883986374206149, 0.5419711573981991, 0.45962514745197414, 0.550611695212154, 0.5375520339214231, 0.5364268216010576, 0.5794387462370014, 0.6170114967651827, 0.10396470639392519, 0.1154813814569643, 0.10395317256745706, 0.14759726438827014, 0.13742843093753943, 0.10704501758111018, 0.10483831420609402, 0.11417131879939679, 0.12227034647037982, 0.2002958590462003, 0.33854025193488757, 0.17664677067159718, 0.15250642924730784, 0.18459408286110657, 0.21866176997059605, 0.21375945215595116, 0.16010636913800302, 0.21933492340300642, 0.3528923972579371, 0.5352045156699989, 0.41254620988368174, 0.3228908265628323, 0.49078781385954773, 0.41720647874171735, 0.4549546969375299, 0.4051960918014571, 0.4321668082675775, 0.2915052057194688, 0.2540989184254103, 0.2979442943680808, 0.2680381320062576, 0.22192787642300504, 0.35638350710940003, 0.3806955813182955, 0.29524521740977594, 0.23621467582354594, 0.18427027932094808, 0.19898603776716495, 0.17481311375608166, 0.20810982423989888, 0.2012143984382776, 0.2002183676457806, 0.21183461941679693, 0.19274792264488183, 0.19618793502286858, 0.23218338228845226, 0.20135594222527275, 0.20783939976080568, 0.23657897667281558, 0.6869223592530993, 0.20009716777309106, 0.24083157342032646, 0.24662047712849833, 0.19047277409454377, 0.18374327668460289, 0.1657801720454949, 0.15312938440289303, 0.17968186694872423, 0.1992402636587396, 0.1646143022016202, 0.16860345196876247, 0.1260001884882831, 0.20797407495640652, 0.5828503762979531, 0.20919281566605663, 0.20886902310564848, 0.5805702423430987, 0.20914377169442455, 0.20486003908940753, 0.2119148529313165, 0.5986437447848003, 0.6623949508689122, 0.19679418629721945, 0.1883360840261864, 0.17717970155462992, 0.18994358030469338, 0.20438636130220866, 0.18254239741002154, 0.17528455284704303, 0.17884290959346616, 0.20429001797407798, 0.07543181233403973, 0.07638464779236764, 0.08543411706034787, 0.08237702302168382, 0.0797025072214892, 0.0673608128245039, 0.09283560805429825, 0.09990115136850397, 0.08714258059416757]}, "mutation_prompt": null}
{"id": "eb59aad5-350b-4482-9399-8337501c1159", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32\n        self.hmcr = 0.92\n        self.par = 0.25  # Slightly adjusted pitch adjustment rate\n        self.bw = 0.04  # Slightly adjusted bandwidth\n        self.mutation_prob = 0.15  # Adjusted mutation probability\n        self.elite_fraction = 0.20  # Adjusted elite fraction\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.80  # Adjusted crossover probability\n        self.differential_weight = 0.8  # Adjusted differential weight\n        self.local_search_prob = 0.20  # Adjusted local search probability\n        self.chaos_factor = 0.70  # Adjusted chaos factor\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.cos(self.chaos_factor * np.pi * iteration / max_iterations) ** 2  # Cosine function for chaos\n        self.hmcr = 0.90 - 0.1 * chaos\n        self.par = 0.20 + 0.12 * chaos\n        self.bw = 0.03 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.04 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search with Quantum-Inspired Differential Evolution enhanced by chaotic oscillations and adaptive parameters.", "configspace": "", "generation": 98, "fitness": 0.35229411107521913, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8886276679672405, 0.881757931887801, 0.9044001051566729, 0.8837528777275692, 0.8853183453432304, 0.8697705769445109, 0.9054055640345807, 0.8621011005852579, 0.8914185997093348, 0.7792455738784874, 0.8422948881916462, 0.8564249820450935, 0.7570266940019433, 0.6959413127894324, 0.8117780818087051, 0.7949128879052735, 0.730671318257919, 0.8435214827675319, 0.16616176586782716, 0.4168647927869804, 0.1871677546822843, 0.721560627825472, 0.4362053380677313, 0.7055815391402078, 0.17746557880942104, 0.5616288773803224, 0.6524006750396714, 0.18282328785594404, 0.1780357584418958, 0.1736770851494901, 0.47816985983887095, 0.16415164328371556, 0.1610752002266379, 0.49605172802784814, 0.16788706891926564, 0.48239871664568423, 0.947629899350572, 0.9178184075072877, 0.9403415385026067, 0.9591977845388557, 0.9591107011385303, 0.9601840088247535, 0.9590402089972799, 0.9424114314923253, 0.9601512880135706, 0.37992182345578585, 0.4861030537196087, 0.48881450187360187, 0.52193182737423, 0.6271968743928769, 0.4739360849426223, 0.42253348990163186, 0.3814961895158199, 0.46420577411946773, 0.3979645667986538, 0.6688647097148024, 0.22504804030287773, 0.8991187564373692, 0.7483778258926956, 0.20935942797689278, 0.35942045918786236, 0.8981706314723998, 0.2762050161074082, 0.19460490890588622, 0.15825974160658407, 0.27998279435612217, 0.16003720687219614, 0.16325245188943083, 0.28562771558714495, 0.19266734482010683, 0.20036141622197534, 0.18264782041499383, 0.17901968415268932, 0.16907815516218894, 0.13213455806016805, 0.15247521577596568, 0.18824779238584133, 0.1268342200733894, 0.21669793970223605, 0.25374555876972915, 0.23881531305795767, 9.999999999998899e-05, 0.014709559886872059, 0.10029583133045306, 0.1322399722140124, 0.08767378644380475, 0.06965952753390336, 0.017947954806657562, 9.999999999998899e-05, 0.01645648162888247, 0.04925606735700039, 0.1412094659633384, 0.0907168847355666, 0.08776513138957143, 0.033338214892915885, 0.0736912395726258, 0.13891134465977883, 0.17808754643517843, 0.20392004499087257, 0.13873040573556628, 0.035841158400575335, 0.05182742173358201, 0.0823471356193306, 0.09666643667018726, 0.26120166002205747, 0.14435046373559524, 0.2711859950783235, 0.3498032764640142, 0.18134096586695791, 0.18227784358501986, 0.2242950521087571, 0.11987270379690818, 0.2033734316868555, 0.170128389684443, 0.22747431098354132, 0.07515382409130689, 0.13112047730087362, 0.547573978476604, 0.5654404142401006, 0.48984010515264165, 0.47152934740161523, 0.5488371503302291, 0.5197068801771318, 0.5195078847707041, 0.6473765149904956, 0.5296723416338114, 0.15409536407019764, 0.09593073297012433, 0.13045479010939887, 0.18094279415045744, 0.12325587235256386, 0.3201314622181136, 0.14080694239823965, 0.09199888605107209, 0.12613531931095623, 0.39802516627467055, 0.2855183593613675, 0.19326149170577434, 0.21277132436981117, 0.16101715236695235, 0.18839005408559717, 0.16904774758876906, 0.1346039556328964, 0.17829533357570249, 0.5732140727919295, 0.45334750406557267, 0.3715971674402231, 0.49883303490190667, 0.4474499142567, 0.39160388109642974, 0.3797859428092275, 0.49547721992766836, 0.4991900999932539, 0.34068655767871137, 0.30502357719148254, 0.2142482623919213, 0.34130343190329016, 0.24513284624338205, 0.32685399393674386, 0.23928023968445, 0.33319457563806576, 0.3062305689768656, 0.23137310957367963, 0.2296407762084527, 0.21559250712662026, 0.1979659349814188, 0.18854205524113476, 0.16944913169997655, 0.19986871315883747, 0.1796730266684181, 0.19347263325126196, 0.2227723360684727, 0.7433229084961169, 0.21867265747578235, 0.19530802528099434, 0.22798067585202075, 0.2488328248780345, 0.24718722781413138, 0.21234193571462145, 0.7255073508006442, 0.2080467728858454, 0.16877079523770444, 0.20485428733095956, 0.17314680827907336, 0.1984553652319988, 0.8675772411950794, 0.9015754391829334, 0.20278480708897872, 0.8128306697318303, 0.8959145262455014, 0.16724628130357255, 0.5685073395074189, 0.20656636394842587, 0.1647554694530372, 0.1655457674075702, 0.16494640850355824, 0.15234096430692257, 0.6046656980635396, 0.20863214802044616, 0.23272259858145272, 0.1751518975056362, 0.17862716116432986, 0.177619883905206, 0.1891704004796234, 0.27487044332935806, 0.20501294375877677, 0.18753196238698466, 0.09454438757559547, 0.08309208833191173, 0.08053542531282798, 0.10723921337677311, 0.08341828413774088, 0.07158524295461954, 0.08947036402197295, 0.08052320325566709, 0.08733379749618819]}, "mutation_prompt": null}
{"id": "5bedd288-017a-4c73-8346-d603be93476c", "solution": "import numpy as np\n\nclass QuantumHarmonyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hm_size = 32\n        self.hmcr = 0.92\n        self.par = 0.27\n        self.bw = 0.05\n        self.mutation_prob = 0.12\n        self.elite_fraction = 0.25\n        self.theta_min = -np.pi / 6\n        self.theta_max = np.pi / 6\n        self.adaptive_diversity_control = True\n        self.crossover_prob = 0.85\n        self.differential_weight = 0.7\n        self.local_search_prob = 0.25\n        self.chaos_factor = 0.75\n\n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.hm_size, self.dim))\n\n    def evaluate_harmonies(self, harmonies, func):\n        return np.array([func(harmony) for harmony in harmonies])\n\n    def update_parameters(self, iteration, max_iterations):\n        chaos = np.sin(self.chaos_factor * np.pi * iteration / max_iterations) ** 2\n        self.hmcr = 0.88 - 0.1 * chaos\n        self.par = 0.22 + 0.15 * chaos\n        self.bw = 0.04 * (1 - chaos)\n        self.theta = self.theta_min + (self.theta_max - self.theta_min) * chaos\n        if self.adaptive_diversity_control:\n            diversity = np.std(self.harmony_memory, axis=0).mean()\n            self.par += 0.05 * (0.1 - diversity)\n\n    def quantum_rotation(self, harmony):\n        new_harmony = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_prob:\n                rotation_angle = np.random.uniform(self.theta_min, self.theta_max)\n                new_harmony[i] += rotation_angle\n                new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def differential_evolution(self, harmony, elite_harmonies):\n        if len(elite_harmonies) < 3:\n            return harmony\n        indices = np.random.choice(len(elite_harmonies), 3, replace=False)\n        a, b, c = elite_harmonies[indices]\n        mutant_vector = a + self.differential_weight * (b - c)\n        trial_vector = np.copy(harmony)\n        for i in range(self.dim):\n            if np.random.rand() < self.crossover_prob:\n                trial_vector[i] = mutant_vector[i]\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def local_search(self, harmony, func):\n        perturbation = np.random.normal(0, 0.1, size=self.dim)\n        new_harmony = harmony + perturbation\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony if func(new_harmony) < func(harmony) else harmony\n\n    def __call__(self, func):\n        self.harmony_memory = self.initialize_harmony_memory()\n        harmony_values = self.evaluate_harmonies(self.harmony_memory, func)\n        evaluations = self.hm_size\n        max_iterations = self.budget // self.hm_size\n        num_elites = int(self.elite_fraction * self.hm_size)\n\n        for iteration in range(max_iterations):\n            self.update_parameters(iteration, max_iterations)\n            elite_indices = np.argsort(harmony_values)[:num_elites]\n            elite_harmonies = self.harmony_memory[elite_indices]\n\n            for _ in range(self.hm_size):\n                new_harmony = np.copy(elite_harmonies[np.random.randint(num_elites)])\n                for i in range(self.dim):\n                    if np.random.rand() < self.hmcr:\n                        new_harmony[i] = self.harmony_memory[np.random.randint(self.hm_size)][i]\n                        if np.random.rand() < self.par:\n                            new_harmony[i] += self.bw * (np.random.rand() - 0.5) * 2\n                            new_harmony[i] = np.clip(new_harmony[i], self.lower_bound, self.upper_bound)\n                    else:\n                        new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.crossover_prob:\n                    new_harmony = self.differential_evolution(new_harmony, elite_harmonies)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_harmony = self.local_search(new_harmony, func)\n\n                new_value = func(new_harmony)\n                evaluations += 1\n\n                if new_value < np.max(harmony_values):\n                    worst_index = np.argmax(harmony_values)\n                    self.harmony_memory[worst_index] = new_harmony\n                    harmony_values[worst_index] = new_value\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(harmony_values)\n        return self.harmony_memory[best_index]", "name": "QuantumHarmonyEvolution", "description": "Quantum-Inspired Harmony with Adaptive Diversity and Dynamic Differential Evolution Control.", "configspace": "", "generation": 99, "fitness": 0.35939863795143845, "feedback": "The algorithm QuantumHarmonyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "d3add8a3-aa0b-4d83-a889-40ad961c6750", "metadata": {"aucs": [0.8959439205432503, 0.8973405112804258, 0.8956829134968151, 0.8902645852416514, 0.8935523394154878, 0.8971604420937922, 0.8976326664534731, 0.903583008541316, 0.8957172639444413, 0.3989611778907225, 0.8331966474799872, 0.8241459126731565, 0.8360498198495494, 0.8197548651313351, 0.814594552290044, 0.789386103998015, 0.6659183536407164, 0.8435750527329775, 0.1806829806515028, 0.48188479252679706, 0.18854167242306974, 0.17359174012945788, 0.15561953500162162, 0.17946928212924318, 0.5353668685979236, 0.1782664015173464, 0.1691954237727743, 0.1442554555344232, 0.43263843160190474, 0.18045723880203224, 0.17174799629358273, 0.15535876919446345, 0.16973220202694772, 0.4550101763805018, 0.1583387976730739, 0.15065640739171082, 0.9476152420926588, 0.9566129347883412, 0.9607417890109503, 0.9431661528673377, 0.9405911146965198, 0.9607405309140934, 0.934888551259614, 0.9794485960788631, 0.9453227970871706, 0.4426561263649057, 0.4981421553083203, 0.49708590068324654, 0.478296704731637, 0.5100317402956074, 0.28895336651044534, 0.45303159786481484, 0.37080105013750886, 0.425082195686571, 0.9014734278136128, 0.6944095421482425, 0.3366383201727249, 0.9417691429723891, 0.9009696619884321, 0.8835346972297634, 0.22637541294892072, 0.23545601966767926, 0.37041681974268625, 0.17852932119986598, 0.422625164275086, 0.17169476598405053, 0.18401784973664836, 0.22486245659971216, 0.16450711193061418, 0.18802244617880526, 0.2091556649750611, 0.22712715899675773, 0.15971839463958548, 0.1908232187522806, 0.1585582724036556, 0.15053356953639963, 0.14928242832279415, 0.16215870475319938, 0.21010411714655508, 0.2945011658045872, 0.12904466944258497, 9.999999999998899e-05, 0.010210263654662599, 0.036814599549325644, 0.029187880733020588, 0.11799160622089677, 9.999999999998899e-05, 0.06479911900509483, 0.1298375183533852, 0.35114039920638307, 0.16364211194066103, 0.19870447619802412, 0.21868842655099174, 0.11615710385892764, 0.012258738482184173, 0.07108530462303386, 0.3039049232179635, 0.10233761984949685, 0.31553298652825157, 0.23279936052865124, 0.2223936813107651, 0.1371955002098021, 0.0948388899042284, 0.09182156259393559, 0.11300935311249927, 0.2773390542064552, 0.10316871256475102, 0.1407734813224264, 0.2596353991073793, 0.24391859768487234, 0.19160821771084946, 0.3619144403253428, 0.32742954588363027, 0.24556083284629593, 0.10739337845096475, 0.2107960937471588, 0.4660482313364427, 0.6869651608867922, 0.8272789002218626, 0.6468556369880534, 0.553868092686607, 0.7034680964794684, 0.6461834134540341, 0.6898924234811127, 0.5711046185867006, 0.5310377240247499, 0.10536047165463402, 0.13030414224540932, 0.145416363409959, 0.1473814198505199, 0.1103807559643517, 0.10289805495922688, 0.12682417993703732, 0.08152086949489679, 0.10712013074289184, 0.17851798352200654, 0.440599323055314, 0.24066143216174163, 0.16876252476565823, 0.15479705394339327, 0.3753725391001468, 0.17837750611836034, 0.3395828321707831, 0.2119073838797968, 0.4753979854619602, 0.5430993992149387, 0.3555701920683617, 0.6983251589844526, 0.4480464605567325, 0.4838256014976504, 0.5354405971573359, 0.5288882648591716, 0.5088173233645604, 0.34104260313575807, 0.37657510227296653, 0.2761144647004471, 0.327186866197943, 0.5040860163188676, 0.2678713812631268, 0.3464687174360641, 0.37959405531990353, 0.2529385476421835, 0.19156238319739505, 0.22546184846288608, 0.20325687834917794, 0.1982450650473052, 0.2654233359653726, 0.2384064276380825, 0.18809700827636666, 0.21850273680444976, 0.18021617263874357, 0.21654330059363458, 0.21988497015944275, 0.2412172170168274, 0.18783286197667637, 0.2478064498175908, 0.20911308057191613, 0.6645484608388953, 0.19239275780656517, 0.5500139650777995, 0.1866654779106086, 0.1668308352528629, 0.15353705591726607, 0.8951226549303501, 0.1961278719373296, 0.8442659606379543, 0.11291181705277797, 0.8833376746130706, 0.1579906864615105, 0.9089959035950723, 0.21098865472397488, 0.12585588086360056, 0.4162051592606081, 0.16502882113921025, 0.3265184556331603, 0.38773079176339, 0.3882576085685878, 0.21063240213160328, 0.21031163764233873, 0.20103840265535977, 0.19023379560587483, 0.1819614227323566, 0.17575827581329317, 0.17316247372696503, 0.17651621182113342, 0.19664128029451922, 0.23777224666310726, 0.08838301257223757, 0.09159869132236764, 0.09292911879507959, 0.10258547739376322, 0.08707615595696239, 0.08963255318568641, 0.09999947748643623, 0.0870123285383726, 0.09730704052927974]}, "mutation_prompt": null}
