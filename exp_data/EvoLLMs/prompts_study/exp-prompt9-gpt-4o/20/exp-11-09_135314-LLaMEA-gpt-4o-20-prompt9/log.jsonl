{"id": "233b38be-6435-42ee-85c1-79997aa37084", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a39753be-4086-4ab6-96eb-a188834bd85f", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "233b38be-6435-42ee-85c1-79997aa37084", "metadata": {}, "mutation_prompt": null}
{"id": "a5bc5b57-5b31-4786-bd4f-63849ed72748", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + 0.8 * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "HybridOptimizer", "description": "A multi-strategy optimization algorithm that combines Random Search and Differential Evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 2, "fitness": 0.2835983708152401, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "233b38be-6435-42ee-85c1-79997aa37084", "metadata": {"aucs": [0.6302048835894745, 0.5846469338296421, 0.6456983331487594, 0.6316614454404769, 0.59155636209516, 0.6191484140322371, 0.6091913370634509, 0.6132320708865746, 0.5984518582302443, 0.44634199090103455, 0.46300250465255754, 0.42953209503262013, 0.4488162900873256, 0.4502310361598304, 0.47268853487732687, 0.46238938688338493, 0.4274743388424098, 0.4772743963057752, 0.08120852504940745, 0.10246378570063575, 0.10143109328701139, 0.08511560134267915, 0.07583499439462593, 0.08250676099464949, 0.09382975322388953, 0.07969866393309766, 0.09806819958154178, 0.07612542088707064, 0.07043549195391374, 0.07431163041503863, 0.08708477279328908, 0.08208597658975614, 0.07099245282662436, 0.0724088296368478, 0.08526833108857756, 0.08321107806414707, 0.8037001987290694, 0.7936974664662636, 0.784325605904963, 0.8089187425391773, 0.7924159252644585, 0.7637912569909493, 0.7912378493304396, 0.7685879693099518, 0.7736291064644378, 0.29259925334922743, 0.2974749074933337, 0.2773193571181566, 0.29174440948286096, 0.27282205935274095, 0.3042270470292098, 0.28969384361901407, 0.2962876842467459, 0.30565470522806126, 0.44020859993949557, 0.4870487518960934, 0.46441103636510217, 0.5892219346751117, 0.5282075050441031, 0.6166019236084177, 0.5106424943280903, 0.5055075162308924, 0.528367642779214, 0.3111433241442211, 0.19153290962045144, 0.25466517421495327, 0.2227501920070023, 0.27974456794603975, 0.23309345155980576, 0.26956545065890536, 0.24110868149527476, 0.20220089323374502, 0.3099069180622328, 0.18348412015897142, 0.22357894314168847, 0.27408181566331424, 0.19804755510584104, 0.21621842481371922, 0.2879720988632467, 0.24476254608783432, 0.2709614247436597, 0.16643451636499706, 0.16659365844075325, 0.16625809445188333, 0.19596558698208166, 0.2099912908601259, 0.1723787442364605, 0.22133763936513473, 0.21514250493806408, 0.16194416148105806, 0.3005165030819088, 0.36010398557026013, 0.3745069340182624, 0.274110022213206, 0.3370262022705691, 0.34899786494124596, 0.386397421613095, 0.3576644270446607, 0.3244581886374568, 0.09256771185530166, 0.07589639589160158, 0.05868191558754554, 0.042919287983212207, 0.059628255412042974, 0.10262895268722438, 0.06533439134665509, 0.0676329020624753, 0.08249619170526967, 0.17052946827510385, 0.1624050314036345, 0.1844543216628639, 0.17072771010925392, 0.17580197537295172, 0.1794227661228266, 0.16506928442130653, 0.19847183422523662, 0.1694008503013802, 0.5078360464115452, 0.47513779051305405, 0.5582099538894917, 0.4832931748073094, 0.4731159814414476, 0.4866781707451078, 0.5484540480336023, 0.49429283363034626, 0.5330449220536984, 0.07548991703824326, 0.08951764084071856, 0.06690868078438583, 0.08860174083766137, 0.06617020703971632, 0.08354858797061882, 0.07408285252201308, 0.0821649659084196, 0.06668427379240527, 0.13924963717953398, 0.18501515087498832, 0.1597062457344458, 0.227234334413964, 0.1670218801854355, 0.15329965634623055, 0.17736914498589196, 0.14921676937334283, 0.14644893381225665, 0.2549930922884127, 0.24231092152568368, 0.2873276639957505, 0.260750161271772, 0.2603175223898293, 0.26151251728114444, 0.2691030693075146, 0.3083441693482728, 0.29359654476321617, 0.19599879651215668, 0.19019558912208934, 0.1995843648332417, 0.1978346895308345, 0.21438459264243848, 0.17790272758944192, 0.19616175973828398, 0.24292311775693964, 0.21134411758773508, 0.17117898727959413, 0.1851519119061742, 0.18839520433589452, 0.19011569531851458, 0.1533134695245535, 0.15982093295284372, 0.1836170201214291, 0.16396014770229483, 0.1692011743139814, 0.15563817735373464, 0.15738198139209347, 0.1889340201366243, 0.185750149293056, 0.15128291600259558, 0.1700522139178121, 0.1663074412346085, 0.17685393798370863, 0.15605703037082408, 0.5224510225074365, 0.5224854413901647, 0.5463209469862905, 0.5784646985218802, 0.5226756964215862, 0.5639628843727222, 0.1659153838821874, 0.3881466869292074, 0.4921158321353285, 0.5593338230548958, 0.18832930999362074, 0.4744393280265543, 0.5069275350543337, 0.4543099092660974, 0.3053452284338509, 0.5179072953818651, 0.5652045271681817, 0.1855808397423342, 0.2044686232500751, 0.18010122551492969, 0.17847970007023628, 0.18698295792775388, 0.17867343104462374, 0.17753275506150434, 0.1908069185245025, 0.19774676790792878, 0.18154947607504857, 0.06062499912099106, 0.059755021789542284, 0.05968150683344775, 0.06388258152825932, 0.0729499727425067, 0.05810827331187307, 0.06458575184385229, 0.061167155536412054, 0.06415936788417398]}, "mutation_prompt": null}
{"id": "56ac73e3-ef49-4983-a45a-1d1a394d931e", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + 0.8 * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "HybridOptimizer", "description": "A multi-strategy optimization algorithm that combines Random Search and Differential Evolution to efficiently explore and exploit the search space.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a5bc5b57-5b31-4786-bd4f-63849ed72748", "metadata": {"aucs": [0.6302048835894745, 0.5846469338296421, 0.6456983331487594, 0.6316614454404769, 0.59155636209516, 0.6191484140322371, 0.6091913370634509, 0.6132320708865746, 0.5984518582302443, 0.44634199090103455, 0.46300250465255754, 0.42953209503262013, 0.4488162900873256, 0.4502310361598304, 0.47268853487732687, 0.46238938688338493, 0.4274743388424098, 0.4772743963057752, 0.08120852504940745, 0.10246378570063575, 0.10143109328701139, 0.08511560134267915, 0.07583499439462593, 0.08250676099464949, 0.09382975322388953, 0.07969866393309766, 0.09806819958154178, 0.07612542088707064, 0.07043549195391374, 0.07431163041503863, 0.08708477279328908, 0.08208597658975614, 0.07099245282662436, 0.0724088296368478, 0.08526833108857756, 0.08321107806414707, 0.8037001987290694, 0.7936974664662636, 0.784325605904963, 0.8089187425391773, 0.7924159252644585, 0.7637912569909493, 0.7912378493304396, 0.7685879693099518, 0.7736291064644378, 0.29259925334922743, 0.2974749074933337, 0.2773193571181566, 0.29174440948286096, 0.27282205935274095, 0.3042270470292098, 0.28969384361901407, 0.2962876842467459, 0.30565470522806126, 0.44020859993949557, 0.4870487518960934, 0.46441103636510217, 0.5892219346751117, 0.5282075050441031, 0.6166019236084177, 0.5106424943280903, 0.5055075162308924, 0.528367642779214, 0.3111433241442211, 0.19153290962045144, 0.25466517421495327, 0.2227501920070023, 0.27974456794603975, 0.23309345155980576, 0.26956545065890536, 0.24110868149527476, 0.20220089323374502, 0.3099069180622328, 0.18348412015897142, 0.22357894314168847, 0.27408181566331424, 0.19804755510584104, 0.21621842481371922, 0.2879720988632467, 0.24476254608783432, 0.2709614247436597, 0.16643451636499706, 0.16659365844075325, 0.16625809445188333, 0.19596558698208166, 0.2099912908601259, 0.1723787442364605, 0.22133763936513473, 0.21514250493806408, 0.16194416148105806, 0.3005165030819088, 0.36010398557026013, 0.3745069340182624, 0.274110022213206, 0.3370262022705691, 0.34899786494124596, 0.386397421613095, 0.3576644270446607, 0.3244581886374568, 0.09256771185530166, 0.07589639589160158, 0.05868191558754554, 0.042919287983212207, 0.059628255412042974, 0.10262895268722438, 0.06533439134665509, 0.0676329020624753, 0.08249619170526967, 0.17052946827510385, 0.1624050314036345, 0.1844543216628639, 0.17072771010925392, 0.17580197537295172, 0.1794227661228266, 0.16506928442130653, 0.19847183422523662, 0.1694008503013802, 0.5078360464115452, 0.47513779051305405, 0.5582099538894917, 0.4832931748073094, 0.4731159814414476, 0.4866781707451078, 0.5484540480336023, 0.49429283363034626, 0.5330449220536984, 0.07548991703824326, 0.08951764084071856, 0.06690868078438583, 0.08860174083766137, 0.06617020703971632, 0.08354858797061882, 0.07408285252201308, 0.0821649659084196, 0.06668427379240527, 0.13924963717953398, 0.18501515087498832, 0.1597062457344458, 0.227234334413964, 0.1670218801854355, 0.15329965634623055, 0.17736914498589196, 0.14921676937334283, 0.14644893381225665, 0.2549930922884127, 0.24231092152568368, 0.2873276639957505, 0.260750161271772, 0.2603175223898293, 0.26151251728114444, 0.2691030693075146, 0.3083441693482728, 0.29359654476321617, 0.19599879651215668, 0.19019558912208934, 0.1995843648332417, 0.1978346895308345, 0.21438459264243848, 0.17790272758944192, 0.19616175973828398, 0.24292311775693964, 0.21134411758773508, 0.17117898727959413, 0.1851519119061742, 0.18839520433589452, 0.19011569531851458, 0.1533134695245535, 0.15982093295284372, 0.1836170201214291, 0.16396014770229483, 0.1692011743139814, 0.15563817735373464, 0.15738198139209347, 0.1889340201366243, 0.185750149293056, 0.15128291600259558, 0.1700522139178121, 0.1663074412346085, 0.17685393798370863, 0.15605703037082408, 0.5224510225074365, 0.5224854413901647, 0.5463209469862905, 0.5784646985218802, 0.5226756964215862, 0.5639628843727222, 0.1659153838821874, 0.3881466869292074, 0.4921158321353285, 0.5593338230548958, 0.18832930999362074, 0.4744393280265543, 0.5069275350543337, 0.4543099092660974, 0.3053452284338509, 0.5179072953818651, 0.5652045271681817, 0.1855808397423342, 0.2044686232500751, 0.18010122551492969, 0.17847970007023628, 0.18698295792775388, 0.17867343104462374, 0.17753275506150434, 0.1908069185245025, 0.19774676790792878, 0.18154947607504857, 0.06062499912099106, 0.059755021789542284, 0.05968150683344775, 0.06388258152825932, 0.0729499727425067, 0.05810827331187307, 0.06458575184385229, 0.061167155536412054, 0.06415936788417398]}, "mutation_prompt": null}
{"id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.3372026865933285, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "a5bc5b57-5b31-4786-bd4f-63849ed72748", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "7cc6bd65-69fb-4983-a788-85478cbdb411", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 10)\n        self.strategy_switch = 0.3  # Switch strategy later in the budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            -0.5, 0.5, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Particle Swarm Optimization approach\n                inertia = 0.7\n                cognitive_coeff = 1.5\n                social_coeff = 1.5\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    velocities[i] = (\n                        inertia * velocities[i]\n                        + cognitive_coeff * r1 * (personal_best[i] - population[i])\n                        + social_coeff * r2 * (best_solution - population[i])\n                    )\n                    population[i] += velocities[i]\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(population[i])\n                    evals += 1\n                    if candidate_fitness < personal_best_fitness[i]:\n                        personal_best[i] = population[i].copy()\n                        personal_best_fitness[i] = candidate_fitness\n                    if candidate_fitness < best_fitness:\n                        best_fitness = candidate_fitness\n                        best_solution = population[i].copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.9 - 0.4 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "Adaptive Hybrid Optimizer with Integrated Particle Swarm and Differential Evolution Balancing for Enhanced Convergence.", "configspace": "", "generation": 5, "fitness": 0.3192756470775373, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.8881888827280849, 0.8834448673026273, 0.8889544185240171, 0.8806155746917121, 0.877660906791328, 0.8856690181909397, 0.872450264644092, 0.8790734039555975, 0.8749760591024671, 0.4669914102267211, 9.999999999998899e-05, 0.5445694900737347, 0.5444585011252676, 0.44079466106758913, 9.999999999998899e-05, 0.42831655869962637, 0.37662526384192485, 0.047584406011802693, 0.09145199876016774, 0.12543981797968917, 0.06853321313177807, 0.09712623229089545, 0.14546988450862497, 0.07408331893511766, 0.09312697488439592, 0.12603581367735273, 0.11660228232402603, 0.11160639442598441, 0.07254987492677245, 0.05884567122657902, 0.11074526705971821, 0.08531412019830475, 0.05554704111683517, 0.042382800741160964, 0.11730892267231519, 0.12454257215060482, 0.9915108891428747, 0.9937654139361627, 0.9948557227953945, 0.09969360558769913, 0.9861165144084046, 0.09964986532444453, 0.9905593645220034, 0.9866226935253648, 0.9925643240017649, 0.5698525083799277, 0.49286458384712983, 0.5307212641352206, 0.5968425283429519, 0.22069277838898693, 0.39134716292564153, 0.5220804002510324, 0.5725121858455229, 0.08340085390015062, 0.7805658141209243, 0.2287888885987267, 0.3302706916092141, 0.19573500815850198, 0.1933296408284999, 0.19165700976324018, 0.21166170474724044, 0.1318203378116104, 0.17617549402848132, 0.4042865285718985, 0.5214795249751512, 0.1146423083495205, 0.30804875803993836, 0.13464992420558008, 0.5741262362172883, 0.5334197395396414, 0.5310936012162684, 0.48941610599515395, 0.5023405518065369, 0.5111771365372204, 0.38891499396463336, 0.5875193811285119, 0.5705672024434406, 0.5685078920250631, 0.13241371349350994, 0.41286015750661076, 0.13416031751327606, 0.17211186795972322, 9.999999999998899e-05, 0.08192307077465488, 9.999999999998899e-05, 0.2751158020961204, 0.04824060291143217, 0.17730915597473174, 0.0086167046091159, 0.4285631851149986, 0.36808993113989663, 0.3571495877129358, 0.3735934614665235, 0.31142810593726933, 0.25466671550457975, 0.27805326146843745, 0.07479381135861363, 0.3820352611050323, 0.3795561240962253, 0.14444331962419987, 0.22716447819841956, 0.14097502358101377, 0.23563122421961202, 0.4171516781685587, 0.07721980309095944, 0.1868000978597405, 0.07371380795722438, 0.07242538166477896, 0.2593231975128638, 0.21222021362466015, 0.3883478195955581, 0.0066197909243217445, 0.2024538522209226, 0.25005571037563346, 0.08266635233817632, 0.3801474555930655, 0.08255450966634359, 0.7017905873243295, 0.6937814317069988, 0.7390079117685359, 0.7368477735340654, 0.7436624241714842, 0.20879027977034326, 0.6682942870597803, 0.6904653892918855, 0.6754433254355199, 0.11035258270905612, 0.06427632024824559, 0.06060708765525924, 0.09680664959130592, 0.06507287146468443, 0.10153090604817372, 0.14809905972485904, 0.09169835779923308, 0.16103352021327677, 0.2796168708088217, 0.2006521375210253, 0.22199440875836984, 0.35432565710278485, 0.20253396707568905, 0.1577597712744433, 0.18870250583807258, 0.20418529346655256, 0.18827453768963698, 0.34078539659140583, 0.324603828642704, 0.39036701289694276, 0.44289570244051846, 0.34066243811446584, 0.26252150632679305, 0.23536488598630745, 0.2630271371813122, 0.2346708425662648, 0.20690883104606195, 0.39037340543773913, 0.23504167901827444, 0.27905978128947295, 0.2507059988391076, 0.23012913394293633, 0.21769394826063992, 0.23584282575664295, 0.30556018462632595, 0.20899370620725843, 0.20622341482540418, 0.19833219515018985, 0.20002219767750262, 0.22614228483956467, 0.20680012228734346, 0.1945720175824015, 0.2235952290557338, 0.2304942866114581, 0.19117921010613592, 0.17555818366308562, 0.1911377673713971, 0.4443442077128624, 0.1775556218552763, 0.1911049871169549, 0.18057976522329777, 0.17696410983666433, 0.1906829816109189, 0.912296178349626, 0.2068989465721185, 0.15454745422960625, 0.9158627361108865, 0.2017590166089539, 0.20167807292705364, 0.14343223128052363, 0.17017976080799746, 0.2132436851550501, 0.9385645959066631, 0.21421858864008358, 0.9099910354060445, 0.10511560590718128, 0.16944568771197355, 0.15550084423696298, 0.9065534805878113, 0.9092800416154171, 0.32279595537154104, 0.18110363413254527, 0.2146276149817261, 0.18358902037977187, 0.21353940483407263, 0.19338649405363018, 0.19599937132568068, 0.18634715021564785, 0.19071786917113243, 0.2494907340708794, 0.10267865066345971, 0.07669353420001845, 0.07756152008730621, 0.09072645750139396, 0.08176811493331915, 0.07005856653129017, 0.09010650821779276, 0.10181144502753636, 0.07193944235499916]}, "mutation_prompt": null}
{"id": "2f6f0f9d-283a-4581-bb89-1632d028e111", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "6c82d0b4-3a9c-4ffd-bc84-b33b25e4c6c6", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "df45766e-9bb4-47e6-94b3-18a26122bfb5", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "46a81298-b112-4381-9e8b-2d64f2394b11", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Increase switch point to 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and adaptive elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    acceptance_chance = 0.1 if candidate_fitness >= fitness[i] else 0.02\n                    if candidate_fitness < fitness[i] or np.random.rand() < acceptance_chance:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling and crossover probability\n                scale_factor = 0.6 + 0.4 * np.sin(np.pi * evals / self.budget)\n                crossover_prob = 0.8 + 0.15 * np.sin(np.pi * evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "A hybrid optimizer integrating Random Search, Differential Evolution, and adaptive elitism using a dynamic adjustment strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.23561333779472504, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.5284903718473702, 0.5352371292994074, 0.5752636119159937, 0.5173381426925263, 0.5231113906009042, 0.5171109660011015, 0.5279377276294241, 0.5456693940934987, 0.5235993314330164, 0.2521686851867143, 0.24506792799525123, 0.27247475612299754, 0.227037873327958, 0.24642156337153365, 0.20188374664513153, 0.22476838458067894, 0.24361440611162166, 0.2346807449257884, 0.08496282041463343, 0.08476301195772451, 0.1574381438404031, 0.09286849289240584, 0.09998224355767837, 0.080096907468861, 0.08826627845929302, 0.0889990294823012, 0.08711109369481584, 0.09409602763518488, 0.0698401714232838, 0.0796159629108939, 0.07864906567437535, 0.07363068237441384, 0.08443030644274474, 0.09299221102774113, 0.07209526767424435, 0.11353925765060524, 0.726644352144026, 0.7306956037676222, 0.6763236930850675, 0.733181473004431, 0.7250757030755994, 0.6971772420110286, 0.7160265988301926, 0.7223177955336245, 0.7199520119309601, 0.2497825588270769, 0.23667947946520884, 0.24344703649100174, 0.25115770944350024, 0.21828911038717247, 0.23389225700081262, 0.2258791412062937, 0.21042240725587746, 0.2616433553082541, 0.4155909159648876, 0.40962242895674006, 0.42212817711193495, 0.5043946550515241, 0.36163401883184354, 0.32482964533386927, 0.4717059267297363, 0.41856872846020254, 0.43091282058493785, 0.163307173383322, 0.1872043615922906, 0.1925118189448245, 0.198883962666204, 0.17287901612137468, 0.17865495725748914, 0.2056747769033277, 0.16293760860421247, 0.2127141763230619, 0.21674066497630762, 0.20165779114970106, 0.20540662974297974, 0.19000601477737888, 0.2077548117094229, 0.17115379737060543, 0.20138818543645676, 0.1628553379487495, 0.2038663339840745, 0.10350909153349386, 0.08522050055200359, 0.07747834679752763, 0.09583131937867206, 0.06914367455764181, 0.09535369597609333, 0.11126563311084958, 0.11725410721780427, 0.07862147486410398, 0.19975897820860344, 0.22648362486543405, 0.2261660295574045, 0.2557606023334481, 0.20635178262180265, 0.23983345743082396, 0.24618789677490183, 0.23276771492362214, 0.2403524705564346, 0.017294448601704593, 0.020259493360115677, 0.024226098573403743, 0.0507429407195219, 0.026258828834268333, 0.022211822369780698, 0.01988029713734707, 0.035133125897538586, 0.023901266712526015, 0.10353981500934606, 0.12058483444401957, 0.11914415432281333, 0.1328034319040753, 0.12138515138709649, 0.13087364572102633, 0.11620580570761563, 0.1287605651585696, 0.12567987870941577, 0.44781385571488397, 0.4384830290049876, 0.4143974503164465, 0.461745777164995, 0.4093904067292943, 0.446227928797877, 0.4495072260870522, 0.45027999776956307, 0.42908388345874005, 0.07651671849582786, 0.08663591847483987, 0.07662994263986544, 0.07341804595214985, 0.09330129686568778, 0.08335170512491519, 0.06808729551993564, 0.06653229743860922, 0.0767088777399717, 0.14422247092585372, 0.17907120043567648, 0.3035946092963163, 0.1818975957424558, 0.22280399090695124, 0.17944064675280746, 0.17826053494341954, 0.1389481991840732, 0.20017485825235504, 0.20406711856232773, 0.2313200227976473, 0.21592953914721835, 0.21262829856546528, 0.21275613157669326, 0.20912768361790413, 0.22914845431895392, 0.25481041113977676, 0.22191694684746976, 0.16960132575087505, 0.1743093622059656, 0.17594414906075473, 0.18150649086420512, 0.1684658405172742, 0.14904303654792417, 0.17454195694012165, 0.18599221084238338, 0.1573828506166003, 0.1814479787224238, 0.15585614070947595, 0.18018908612709927, 0.17247206766732492, 0.16457154005556873, 0.1828494190155504, 0.1608947057600557, 0.16697125775264432, 0.17343992441405587, 0.17325749755445452, 0.17124633035262837, 0.21969579614222612, 0.19634997162512846, 0.17366064777930712, 0.17299252187474667, 0.22660590718439722, 0.17289062879504768, 0.1844148320413288, 0.1903848706609842, 0.4661576862306043, 0.5618730847174362, 0.505947727988229, 0.1887826395635286, 0.4869066482841726, 0.17808375158739786, 0.46384074521277374, 0.18439840541209174, 0.42672855471356386, 0.4507993321848246, 0.49015716926908703, 0.42413471275754955, 0.4071371076201874, 0.48495655502208523, 0.40778882052087695, 0.4171066093490189, 0.20077653862405664, 0.17938640588702892, 0.1776318596580626, 0.1965128199609688, 0.18433240177097254, 0.18607933681810707, 0.1915115100855158, 0.19236158246613655, 0.183740950027091, 0.18595952386853343, 0.05622849973440258, 0.057623857246210664, 0.06168983428384367, 0.05713282821201482, 0.06582395126365048, 0.06088556803355949, 0.07039117182666577, 0.061003002274849005, 0.06834965841737284]}, "mutation_prompt": null}
{"id": "6195f1de-f257-4061-b3ef-4c526ef5c625", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "67af795d-e95c-4fa5-a81f-3ba99e6c30fc", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "2b7c61de-5e14-4d30-a2e2-6e368a087668", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "f98d2d7a-ae42-4123-b45e-00a7aa488811", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "feb3c347-4d62-4c27-9a7e-5e6304a178dd", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "724bf322-7e63-41fa-984d-17ffcbe907f8", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "e62fba8b-453a-4de1-aa61-9b8c0da442af", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "caf1ba56-d9cb-454f-89e3-5e522a18423b", "solution": "import numpy as np\n\nclass AdvancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = min(30, budget // 10)\n        self.population_size = self.initial_population_size\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.1:  # Increased chance for elite acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor and hybrid crossover\n                scale_factor = 0.7 - 0.4 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_rate = 0.85\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n            \n            # Dynamic population adaptation\n            if evals % (self.budget // 5) == 0:  # Every 20% of budget\n                self.population_size = max(5, self.population_size - self.initial_population_size // 5)\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return best_solution", "name": "AdvancedHybridOptimizer", "description": "An advanced hybrid optimizer leveraging dynamic population adaptation and hybrid crossover for improved convergence speed.", "configspace": "", "generation": 17, "fitness": 0.3216119837581812, "feedback": "The algorithm AdvancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.7081055807701016, 0.7050521896891048, 0.7128369356830416, 0.6844239838957666, 0.6976839050921424, 0.7063981384533105, 0.7074441724229112, 0.6917137645742977, 0.7020237280724868, 0.5564372107051292, 0.5576436637201799, 0.5453500141593313, 0.5478362475815934, 0.5382637798123527, 0.5360688730507466, 0.5639815623330211, 0.5458192727645585, 0.5473982813655978, 0.1056433460109707, 0.3266128774601036, 0.10854557098268192, 0.32420831672957295, 0.10459194074828249, 0.11068126774849585, 0.10324910482852123, 0.09641221994490512, 0.1078823564382172, 0.09089513644653013, 0.09245544017654317, 0.10997927299305099, 0.10368616146338339, 0.09391594747348808, 0.09806686604650838, 0.11449631267388627, 0.14277615463424442, 0.10195703451311133, 0.6871293463096217, 0.7309937018305142, 0.6908244335044531, 0.7008328149619767, 0.7225391663704055, 0.732912349888013, 0.7480585546011779, 0.7257334098016673, 0.7414839914302077, 0.42895852599722406, 0.3202357864702292, 0.4115619743134974, 0.40933385790067756, 0.33506685321021323, 0.3745097943521105, 0.36172970091236256, 0.361417602425367, 0.43364201476040676, 0.6528232349499936, 0.5943892219569018, 0.5961972526010052, 0.6433352273911758, 0.6443671974196995, 0.5856592524553084, 0.6159052988011071, 0.6273628452022747, 0.6389603925214689, 0.1505034461159661, 0.19187414497894073, 0.13748920333550974, 0.23777894161344804, 0.1871901573813024, 0.16644323853061638, 0.200342955389188, 0.12289236010858262, 0.20823269082768447, 0.20014533327493622, 0.1332114875340078, 0.15501131863380357, 0.23783398667893574, 0.1437772638529421, 0.2100572125731346, 0.18244436368506745, 0.18108083054842994, 0.16940586614710573, 0.25315961903215545, 0.2894156895493314, 0.15312820601621957, 0.2821907634107611, 0.22797747247214317, 0.1672339577723937, 0.28465789352878246, 0.3112208735030565, 0.31576152273627744, 0.33978649182492127, 0.3783063076274896, 0.4477838812911168, 0.43875934854585985, 0.2510485203906525, 0.4289868334576842, 0.4907601163750438, 0.49503033930846874, 0.4881405779035388, 0.13686375971434683, 0.188973527589554, 0.09836537534411949, 0.11724751472265793, 0.23851625611941252, 0.12978377293757637, 0.13606696582103361, 0.10006753441394634, 0.10191724982093675, 0.22810277915680122, 0.2549232296898172, 0.2895250766269045, 0.2954798316463475, 0.27606696132893116, 0.2485904533629446, 0.2462930128203482, 0.23238806209496465, 0.24664955025376345, 0.6545316575687823, 0.6027893661733412, 0.6329638517923044, 0.6053071462624287, 0.5050851465482984, 0.5633798313903038, 0.6424952490898199, 0.5482746843186604, 0.537978180427922, 0.09078686257197244, 0.08092895448212056, 0.07465805266901093, 0.08132917785921967, 0.0810919484516397, 0.09896708941255261, 0.07870347331425087, 0.0827311180311231, 0.0900890544016354, 0.17148973676165913, 0.18384485800639572, 0.1945182002640634, 0.16943783730177842, 0.14896641790335163, 0.1462750412980629, 0.16959287940210777, 0.1539678035183879, 0.1413101789199056, 0.401029485469911, 0.4066862190205407, 0.3612538626631072, 0.42419489243004915, 0.3681736136867304, 0.4018766442514179, 0.40720964936770776, 0.42873599524647577, 0.3766129718007364, 0.3007561880497013, 0.29455908119609664, 0.26797602236837925, 0.3044203691840649, 0.28083186222260803, 0.2983746834440315, 0.2738967268776965, 0.36101171946409705, 0.30603212040069994, 0.18746052418223647, 0.19656907954154135, 0.1845489445941113, 0.20267005407605054, 0.1784410378672635, 0.21147843078435125, 0.18891405335852884, 0.1833615164311474, 0.18212332490655647, 0.296064059835755, 0.17637498231996118, 0.21144704497076172, 0.42748454332511465, 0.19268774435506753, 0.19432732137995856, 0.2831962162423284, 0.19273896010642222, 0.22344969738229215, 0.6718888184813617, 0.5116430006725288, 0.6864919876765501, 0.688376773224074, 0.3012044711185855, 0.6412819197139323, 0.17519082440126554, 0.4908101017958093, 0.18362667866267124, 0.6257801647234127, 0.5658707283500459, 0.21533472162759493, 0.557787704915625, 0.2620352683057793, 0.15464034387131864, 0.37927237245104994, 0.21207922036610383, 0.2569409362989452, 0.18115145689231316, 0.17363375403774484, 0.18684328632109803, 0.18346489009023426, 0.1866748530341571, 0.18533232425829138, 0.18370043477546283, 0.18149779468755955, 0.1754164965416214, 0.07008737608288651, 0.061122893797097455, 0.0743457740692769, 0.07201137015915937, 0.06293677056653246, 0.07238325503288068, 0.06375426703482157, 0.06873940044746418, 0.064988053120139]}, "mutation_prompt": null}
{"id": "2f34382c-b4be-4feb-b74c-bb3c04bed4e6", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "db11da19-d0f8-44f4-882e-c5da918ca548", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian perturbation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    elif np.random.rand() < 0.05:  # Elite individuals have a small chance of acceptance\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive scaling factor\n                scale_factor = 0.8 - 0.5 * (evals / self.budget)\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach integrating Random Search, Differential Evolution, and a strategic elitism mechanism for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.722948878669055, 0.6731157940942466, 0.7224832673154842, 0.6946625064880234, 0.6542989731552061, 0.6683055025686675, 0.6816640405727308, 0.6890759568391451, 0.6890127303853555, 0.5457920631106308, 0.5441125451933595, 0.5330806110580752, 0.5291415005186456, 0.5464925949863889, 0.540321619212575, 0.5091469346930827, 0.5594485508518108, 0.5331738812089124, 0.08454169918054744, 0.09138319836588105, 0.09148759884655133, 0.09137973264022292, 0.0866942740997576, 0.1219818142312381, 0.1116232995504608, 0.08706174014928147, 0.10452618417913873, 0.09156736776778873, 0.08273882873025273, 0.09952005607315217, 0.10379120517159846, 0.08541033486290639, 0.09767688441334488, 0.11185158410481022, 0.08931754877582221, 0.08567959373131395, 0.7419859395699452, 0.7486893382838627, 0.7047068878252427, 0.7295566777370343, 0.7521896473861365, 0.7469232938891919, 0.7453944115755768, 0.7491795211127291, 0.7680645501002609, 0.45061505772775845, 0.4466221390821935, 0.42101647046541446, 0.5026249820568552, 0.3368922481668951, 0.4682555571990712, 0.4496726265566795, 0.35084370307370394, 0.43268346475105934, 0.5925549757407047, 0.6097538452366578, 0.5626983030874575, 0.6320020267181772, 0.6235005226510711, 0.624155017308702, 0.6233777846637678, 0.5947606130338106, 0.649866618488645, 0.23104885306853584, 0.13507139062364681, 0.17470175524781206, 0.1278590856257097, 0.15329774087792758, 0.16039750669547448, 0.17627072649175846, 0.27823372760113974, 0.15218886351594008, 0.26935293965202245, 0.18817106557053886, 0.2532474916873383, 0.2299488771141911, 0.20608960372163543, 0.1513393024030496, 0.17254828178953407, 0.16534064069876186, 0.1948867521688359, 0.2996231482061269, 0.35729654022704316, 0.4164492182126174, 0.3486036686329841, 0.3001788559081755, 0.37976140296224725, 0.4113825312824275, 0.3762216615144037, 0.23540038858957368, 0.47454592394019124, 0.26588974533344356, 0.42566875513531044, 0.4783432206947775, 0.48353937734950836, 0.53097572207994, 0.5362189061407888, 0.5172740703380823, 0.48442784241357606, 0.13086218859817167, 0.08311627033891689, 0.1552184674567123, 0.14631920311470237, 0.22314208675385716, 0.1323523748003287, 0.11549199320402637, 0.18252410148193243, 0.14236032494325934, 0.29055273391474934, 0.315619785774481, 0.2871973193990328, 0.2935430084391695, 0.28243985333455934, 0.27168341863893475, 0.2856112560166919, 0.2986414467852334, 0.27034654673174074, 0.6428923787988514, 0.6377695322640426, 0.6384023760776383, 0.6180703754271749, 0.6058547785174062, 0.6209362512606438, 0.6524500614567421, 0.6283157988143062, 0.6234541579357, 0.08024372837091265, 0.07564501408079272, 0.08007270860776972, 0.07814453545787603, 0.08137958549894209, 0.0827717712647611, 0.09008958187294847, 0.07243592789824582, 0.09048468288007405, 0.20593789995729328, 0.1695480328994856, 0.16412775151621806, 0.19723728523656103, 0.16169449132053648, 0.14661020343244513, 0.1711552285614596, 0.1915778277154162, 0.15159042177977278, 0.3444597054544861, 0.36831241713924523, 0.3717806496968902, 0.3639046694817827, 0.3540677599539388, 0.37145499938097915, 0.4172481983663159, 0.3959807276410099, 0.4035096982057823, 0.24612224191472187, 0.2577486941658076, 0.27692242012392165, 0.26880526256046, 0.25544155819279535, 0.27335778299880653, 0.3227678764488434, 0.36146332371326106, 0.28669655543567574, 0.17801579043455218, 0.17106388776925707, 0.1980003938564444, 0.1909927254840863, 0.17317258831603954, 0.17606888626963935, 0.17449922761670056, 0.1687540160956421, 0.175668285970481, 0.18401988998920893, 0.2090793275671845, 0.21028602767162352, 0.23513142940156118, 0.1765535269720333, 0.18432207972565617, 0.20005785344297133, 0.21631924426363436, 0.20309628100212307, 0.664871638953106, 0.5713882792119162, 0.6459963481430158, 0.6625010696750917, 0.19422608805058184, 0.6907686322129778, 0.18191990548382642, 0.5813118926777557, 0.5170568677366314, 0.671064533517677, 0.5815039177868512, 0.6210211063427331, 0.6166619187149682, 0.5737640036935319, 0.30438461768606484, 0.6321951261803471, 0.5670293856308005, 0.5106975288049405, 0.18230723122948256, 0.19969237780776317, 0.1948672725182684, 0.1715814338863998, 0.17552337782781668, 0.17651271893895537, 0.19871453680523132, 0.18337784618670916, 0.17997119482460622, 0.06722543771280831, 0.07033269539678344, 0.06769643353381105, 0.066156171001716, 0.06744556879562513, 0.0622692768366353, 0.06960151162883665, 0.06477834530819748, 0.06341053926327966]}, "mutation_prompt": null}
{"id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 20, "fitness": 0.35605437587000643, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.22.", "error": "", "parent_id": "77448570-4353-4eef-a275-f3cfcc34a0e9", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "78af8709-0f63-40cd-ae10-27214cc1f2ab", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.15  # Switch to Differential Evolution after 15% of budget\n        self.annealing_prob = 0.1  # Probability of simulated annealing step\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and simulated annealing\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    elif np.random.rand() < self.annealing_prob:\n                        temperature = (self.budget - evals) / self.budget\n                        acceptance_prob = np.exp((fitness[i] - trial_fitness) / temperature)\n                        if trial_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing an adaptive mutation step in Differential Evolution and simulated annealing for enhanced convergence.", "configspace": "", "generation": 21, "fitness": 0.3447594784675232, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7064643230869325, 0.6861565330363416, 0.7243522211302593, 0.710632294318265, 0.6836546625546094, 0.7181425088802992, 0.6949698894592691, 0.7271941477082351, 0.7029139490584169, 0.5881066070962648, 0.5775996877658442, 0.5641258599132456, 0.5587871586154036, 0.5772857950625836, 0.592113041246132, 0.5615355987241205, 0.5587423789412782, 0.5874181422534119, 0.09756660670248352, 0.09568100462724183, 0.10074412506749408, 0.10184033004545634, 0.09695770077515009, 0.1952028685578403, 0.09616350354676706, 0.11422464553207379, 0.10636755542339449, 0.1336488448786164, 0.08488992657612038, 0.08885692245952215, 0.10433632955448813, 0.09792701115013991, 0.08526816371693058, 0.11853474669762454, 0.08563245766276628, 0.09360887586071753, 0.8396093022873178, 0.8127692142630814, 0.800603263155974, 0.7931860689848116, 0.83697893126116, 0.8063815446393933, 0.8370046839575802, 0.8127191758826986, 0.7698107681893867, 0.4268493098413133, 0.3770765537613342, 0.43345690631951417, 0.4123468143274148, 0.3918740984104059, 0.3897048058223168, 0.3916804509471563, 0.38625037617235325, 0.41019738102974035, 0.6619577954370942, 0.6763288043628974, 0.6853988578447083, 0.6852633336283469, 0.6962170173500245, 0.658245748545849, 0.6853228341095298, 0.7091243933815318, 0.640771882994318, 0.3992425186215425, 0.2961821166030342, 0.2678964150267761, 0.2835265593300542, 0.2742744847560109, 0.2789579660009007, 0.3029417870012675, 0.37958247168664305, 0.32632548453413124, 0.3571766712668839, 0.3199697944972234, 0.29560586431159397, 0.3193205574011331, 0.36556887543682826, 0.40334059509746867, 0.35699212093628685, 0.3236506858683068, 0.2724676594468881, 0.38021051635899883, 0.36991095556316533, 0.3376387541445469, 0.34169557127744266, 0.32003417080801355, 0.34663789390937294, 0.36034741019553795, 0.3053508948797137, 0.3374202291362046, 0.4457475444897717, 0.46431964096474676, 0.4821101939823458, 0.4871866355700539, 0.4290105007871535, 0.44115219220611623, 0.5091148094949309, 0.48629946711808114, 0.5361811286019158, 0.19957576295018997, 0.1321025048330302, 0.19136879200014822, 0.1341702657434526, 0.23079354446443745, 0.11460697422518584, 0.10578508575878864, 0.0919374217883846, 0.14069772140503245, 0.293372396305128, 0.2755529563113871, 0.28403179973300263, 0.28657527745238154, 0.29314687785122007, 0.2709109776427675, 0.26792872937307877, 0.27585916867524385, 0.274472723741241, 0.47619768946787966, 0.5410864925500742, 0.5279758857902779, 0.51708658762775, 0.4860379977642244, 0.468615691666906, 0.5288998857591403, 0.5078038000571767, 0.4881847514409786, 0.08434040012468935, 0.0783055707142164, 0.10476312917134079, 0.09348656890488904, 0.088778261183322, 0.09180454734571175, 0.0758137393132915, 0.08604027673800851, 0.0935467803070058, 0.1643803466027428, 0.1910920958254957, 0.17346765254294583, 0.19193515750521228, 0.18732934685409464, 0.18868390568959537, 0.19171380705156704, 0.15274373192857926, 0.14238139822942508, 0.33078631455951757, 0.3402911865358408, 0.3080542705603171, 0.2979230964504831, 0.29524668044456703, 0.3154832377322927, 0.31453616840303933, 0.36022253802048143, 0.341694175778939, 0.24541176521872454, 0.26918639244875053, 0.24569399664721514, 0.24533045148863952, 0.25584525986798967, 0.25647683252242026, 0.2717768836492813, 0.30361306198300286, 0.2796533709452699, 0.19498919585582275, 0.1763668142079159, 0.17804307570453948, 0.18065623674322084, 0.17136630189902224, 0.17697942403579014, 0.19550279285968708, 0.18329674303242482, 0.17320350497769976, 0.3142082284806412, 0.2087134722117292, 0.22055180751226722, 0.36551767992521866, 0.2150548336247039, 0.18513779482006287, 0.1773898293468794, 0.19614493597062077, 0.16517490249447542, 0.5432636664484304, 0.640017891549441, 0.6074159028542818, 0.6081176394427972, 0.19937226986709133, 0.6111311413916785, 0.17267827265796054, 0.4682555054241121, 0.5439427085967429, 0.732032119002247, 0.5059181869967868, 0.5754743839455715, 0.6609535299883835, 0.1890996879166491, 0.19309120507376676, 0.19533880692741323, 0.6004183144620354, 0.700666504438763, 0.18915792898528339, 0.1786797273902655, 0.19156641661226348, 0.19475448393763695, 0.1719488226200634, 0.17395452157530833, 0.20660930602235494, 0.18991935579850838, 0.1827437987120003, 0.07129487946415702, 0.07486468290884096, 0.06906788137246589, 0.06123638933311926, 0.06944238148273163, 0.08974858279141229, 0.0726174147250227, 0.07655281051589968, 0.06762462047931572]}, "mutation_prompt": null}
{"id": "e6d5b050-4408-49bd-9eed-0c967d42f0b8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "0506f5bc-d6f7-489b-b1df-58ceee00826b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "7ab21517-f33e-435d-bce3-7931f757267d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedChaoticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Adjusted switch to Differential Evolution after 30% of budget\n        self.chaos_map = self.logistic_map  # Using logistic map for chaotic initialization\n\n    def logistic_map(self, x, r=3.99):\n        return r * x * (1 - x)\n\n    def initialize_population(self):\n        chaotic_vals = self.chaos_map(np.random.rand(self.population_size, self.dim))\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_vals\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    scale_factor = 0.5 + 0.3 * np.random.rand()\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_rate = 0.7 + 0.2 * np.random.rand()  # Adaptive crossover\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedChaoticHybridOptimizer", "description": "Hybrid optimizer enhancing population diversity using chaotic maps and integrating adaptive crossover for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.2812724105262206, "feedback": "The algorithm EnhancedChaoticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6616583643634182, 0.6651087511942912, 0.6436327178100286, 0.6107147543124134, 0.6549890603548638, 0.5971863612658439, 0.6083129208285769, 0.5993911447037115, 0.610499679187547, 0.465704211945426, 0.4722322976151301, 0.49497855019985604, 0.46995559357308125, 0.46149150979276954, 0.4545356953757288, 0.48326532727501337, 0.44744335188110207, 0.4543752715824386, 0.10000138871965114, 0.095386863347245, 0.09895498699928562, 0.11302258561186973, 0.10747969557572268, 0.07944788276906334, 0.10763194639528573, 0.09202414189380526, 0.08779212229420685, 0.08756315038990092, 0.08749531992950965, 0.10351727292283852, 0.09503444014482487, 0.09430276452456166, 0.1158037086618704, 0.08949212548305874, 0.09464366705710092, 0.09350290902056002, 0.878838349682038, 0.7142217564275004, 0.8902198405816831, 0.7875685119779453, 0.9234586973222871, 0.6875100848596688, 0.7146312822079649, 0.7182699931729664, 0.6673735326921044, 0.3643888832836433, 0.36232940192673213, 0.3441785629686859, 0.3545753867398648, 0.36361237142223046, 0.30519991321880446, 0.3346259521508036, 0.3807728390592924, 0.302998849159438, 0.5229876236323756, 0.5074979615104535, 0.5199297003990458, 0.4912294870729361, 0.4858353754638485, 0.5237179908537768, 0.53893762490848, 0.47870561540991996, 0.5296505171643211, 0.181599802106171, 0.19484062012339398, 0.23166706263905712, 0.22361054067644737, 0.11949142222212317, 0.16859518338443324, 0.22155459282424828, 0.2332319959766468, 0.20323292612831623, 0.20412744502713198, 0.20286425333949965, 0.18326519075614356, 0.2109325783915985, 0.14988530067085526, 0.221526633170808, 0.16862001776235758, 0.17949322714846438, 0.19424739556685966, 0.13778265713968119, 0.14695100041493991, 0.1494879297987043, 0.12981539867533698, 0.13092948645975322, 0.1382027843146465, 0.1520555283649192, 0.16233217566144853, 0.13555711443000873, 0.27793775868406834, 0.27375061657538247, 0.25245812173212256, 0.2859349209025288, 0.26743041564145986, 0.27831194023155503, 0.2915739924815719, 0.3020173105532098, 0.28689935855906723, 0.055352063311212785, 0.05544647456020679, 0.08366299585596482, 0.09107300738358448, 0.05144796087642878, 0.08797517428924073, 0.031332395123672696, 0.05277676983435775, 0.06468534524245606, 0.15088461815849075, 0.14519330565758992, 0.14217787034076934, 0.196064163109556, 0.1668696016138369, 0.17912216838536876, 0.13733268069247495, 0.1369026050517096, 0.14625647125322794, 0.4938801459721128, 0.4683627483086781, 0.4832178150619073, 0.5125874602987597, 0.5109722931804714, 0.524651796256772, 0.5144080888132353, 0.4984360263570059, 0.5043920049705034, 0.08562575618213342, 0.10034642192637588, 0.073076950309934, 0.06797495728650282, 0.07889041316708878, 0.05870667794596718, 0.07888470580607532, 0.08425902394558649, 0.06151418512939477, 0.2400107388303846, 0.2552784927710732, 0.17597370936519852, 0.16737707239028354, 0.23363546892302056, 0.20927381092990305, 0.1477786819007495, 0.19117812016071567, 0.18429353549553862, 0.28929317395890775, 0.27379871423684377, 0.27649676368687615, 0.27384052271209225, 0.26401616969911923, 0.28080971831521395, 0.2955292464470154, 0.2930213783360197, 0.28907956048071115, 0.19735938383142715, 0.19114043291268423, 0.20808977583330712, 0.18348519799489504, 0.18659991837129808, 0.17607088990028874, 0.21945326499950402, 0.21554061127227975, 0.1929582407560454, 0.16668056137840925, 0.17627771193341724, 0.18677925497061387, 0.17766980041482916, 0.17731937972494083, 0.17049251352945338, 0.18193912229833908, 0.1882053326896349, 0.1749093608861897, 0.18753441393755588, 0.17699086956688048, 0.16690285823437256, 0.17147092397459673, 0.17486726306944733, 0.16238483292970518, 0.2030057512892045, 0.18699295123131632, 0.19566380651709248, 0.37737069164580195, 0.1845093946479427, 0.37619674675419423, 0.5180207722252607, 0.5040574993763208, 0.5427084778704017, 0.689073500990562, 0.5140051629754399, 0.7132418662706781, 0.49083355568779663, 0.4726959875249295, 0.5860793982530108, 0.16182748857349982, 0.49841208365352363, 0.15769141563011912, 0.5182542136713918, 0.6112065303265807, 0.49423519570389585, 0.1788684159279792, 0.18527439167389326, 0.1859295348091461, 0.18967723179184126, 0.2045174023282692, 0.1805191953441616, 0.17453416720748804, 0.19443425382309165, 0.19024080008923283, 0.059838257342408774, 0.07556982455075922, 0.06214472100981894, 0.06206388543191055, 0.06427569501681463, 0.059642687067781086, 0.05857741693085683, 0.06571854103907504, 0.056328486946345624]}, "mutation_prompt": null}
{"id": "ab8564d6-b040-4319-b96b-a4595a2fc6de", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "baa5a268-b68c-4369-bf4d-d17a4cb54458", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Adjusted to switch strategies after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with adaptive local search\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2 * (self.budget - evals) / self.budget, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with stochastic adjustments\n                scale_factor = 0.4 + 0.4 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_probability = 0.8 if evals / self.budget > 0.5 else 0.9\n                    trial = np.where(np.random.rand(self.dim) < crossover_probability, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "An enhanced hybrid algorithm integrating adaptive local search with stochastic perturbations, optimizing exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 26, "fitness": 0.31052619000789783, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7025519225802523, 0.6461860136352243, 0.6781443137918808, 0.6867989548771304, 0.64593575203298, 0.6776159405413456, 0.6679939591974557, 0.6791240820042825, 0.670411478789382, 0.4990954002101292, 0.4926494014254851, 0.47608994708766106, 0.49276572793788287, 0.5063946011297586, 0.5025585264633876, 0.4851477482515907, 0.4892818516340931, 0.5066330487019093, 0.10524204037212481, 0.09409058004704474, 0.10247244316445903, 0.09945323149993113, 0.08775422552172363, 0.10490284604118494, 0.08734762578905542, 0.10272092734898675, 0.09899053504528688, 0.09026371490152996, 0.08218697642412098, 0.09206568703583962, 0.10058055941601218, 0.10340803543414057, 0.07414754475148055, 0.09624205647574235, 0.07534302671871851, 0.08281678381710367, 0.6994458147819929, 0.819596925271421, 0.6969064105682574, 0.6987534502634261, 0.6656200590258057, 0.7037251622057028, 0.7111636320299698, 0.6356275396988087, 0.6937547200312191, 0.4081908896943859, 0.38935329926845996, 0.3816646202373206, 0.4178121833130056, 0.3545607544937981, 0.3808225442450438, 0.3787740166181497, 0.42168897147525053, 0.3820644851654502, 0.5794897241009942, 0.582137956380339, 0.5720991665691495, 0.6489624519488413, 0.610896600050503, 0.5857456154305662, 0.5774777568755828, 0.5849425641091945, 0.5773901846499591, 0.1936992925354829, 0.19774920715875732, 0.14951341087177517, 0.15459824548567014, 0.15195377927173181, 0.20500518527021105, 0.1637276162246506, 0.16529699140830034, 0.20549853300951726, 0.20833581533371048, 0.15330028848211386, 0.17907533498417594, 0.3202160171509396, 0.1921780393460818, 0.16088359462532786, 0.2447060096459862, 0.15998895120131307, 0.2913820046968605, 0.2572827704779026, 0.22908585450125118, 0.21421761826527996, 0.25945997212437943, 0.2552809861598765, 0.20042767937562356, 0.22615078058862903, 0.2410557063125095, 0.2164688266302377, 0.40419359436509106, 0.4164205724344011, 0.4014523792209368, 0.37236731816151036, 0.4038414355997386, 0.4101351152437869, 0.4519158956783962, 0.41207516348994855, 0.35197434547700046, 0.08552729289991934, 0.11040202684364053, 0.05828523197562996, 0.20394218537525044, 0.15922089777302229, 0.13892304220869622, 0.11329098542871985, 0.08810460295888567, 0.12567815848519004, 0.2101754026514423, 0.21313636451343088, 0.226704324057024, 0.20736520497876532, 0.22696003966611822, 0.21469264725001236, 0.18513022093014075, 0.20915482913699723, 0.17842417855819825, 0.5715455672833856, 0.6058676877793384, 0.612472500377915, 0.5294185632279171, 0.5095067327655751, 0.5352428140818531, 0.5557564686644034, 0.5296917887158912, 0.5711686819291134, 0.08185785842437909, 0.0708877853764891, 0.06448780130038467, 0.101673012354905, 0.06842541504959831, 0.08369741336449787, 0.08053884626858598, 0.07270483087311008, 0.08184166168956764, 0.17056203182413587, 0.21494203118286537, 0.17872186354747777, 0.20975728830194873, 0.2023043021800347, 0.17620086777477317, 0.231428887688931, 0.17005405746320845, 0.22174287183621166, 0.28485510156153016, 0.3179231577216409, 0.2919945179849728, 0.27825765821615756, 0.30525703461645737, 0.2903994723650538, 0.340659518947953, 0.3529742781842752, 0.3310292106036411, 0.22975079383226626, 0.2149612571153332, 0.23005036928297062, 0.2450589965793626, 0.2295652918338189, 0.21677367554335047, 0.24344318960094136, 0.27721484634868077, 0.24491024111915127, 0.16828604814820725, 0.1587951671688641, 0.18359891160136965, 0.17334040868439693, 0.1598246286270647, 0.19070139922885576, 0.17248628017909307, 0.17004442621152505, 0.18424591024609116, 0.20302550377537065, 0.222071501122576, 0.23950361872148707, 0.27292510438403106, 0.16906040628765573, 0.19146878856080685, 0.17030290104784018, 0.20494841760894555, 0.1747454756029534, 0.4858027887267249, 0.6133026306884812, 0.6904569802649123, 0.5985887713576441, 0.19933268164299678, 0.5339224495524166, 0.1742768478431611, 0.6266978881115461, 0.5733651771800314, 0.6499383586519032, 0.5830949033508869, 0.5754047447539203, 0.6225129286436476, 0.5647461364611364, 0.19429683900189088, 0.6186171166769106, 0.4651434087735792, 0.6032987663159757, 0.20769307826238337, 0.174405046337061, 0.18564255156982445, 0.17926727155725275, 0.20754446746091382, 0.21990029054508686, 0.18461280407408664, 0.18907045240004494, 0.1725715193219055, 0.07199654593525606, 0.06408468154464131, 0.07663095391867114, 0.06441724610030164, 0.07197131908225762, 0.0638815557576643, 0.06669501367444408, 0.06848693540351647, 0.07492577567256453]}, "mutation_prompt": null}
{"id": "dc790fcb-0fc0-4d49-9ee9-95b289e2d8b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "6a74bd32-f5c8-4a5a-8bce-ff4332c37444", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom sklearn.mixture import GaussianMixture\n\nclass AdaptiveStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Adjusted population size\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian Mixture model\n                gmm = GaussianMixture(n_components=2, covariance_type='full')\n                gmm.fit(population)\n                samples = gmm.sample(self.population_size)[0]\n                samples = np.clip(samples, self.lower_bound, self.upper_bound)\n                for i in range(self.population_size):\n                    candidate_fitness = func(samples[i])\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = samples[i]\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = samples[i].copy()\n                    if evals >= self.budget:\n                        break\n                # Local refinement with Nelder-Mead\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with stochastic weight adjustment\n                scale_factor = 0.5 + 0.4 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_prob = np.random.rand(self.dim)\n                    trial = np.where(crossover_prob < 0.85, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveStochasticHybridOptimizer", "description": "Adaptive Stochastic Hybrid Optimizer using Gaussian Mixture Models and Dynamic Strategy Switching.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "a394e7cf-bea0-4787-8a1f-204847b63c1e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "a8e0babe-c43a-4922-a482-14c9c318b4e8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Switch strategy after 30% of budget\n        self.temperature = 1.0  # Initial temperature for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Simulated Annealing with elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, self.temperature, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    accept_prob = np.exp((fitness[i] - candidate_fitness) / max(self.temperature, 1e-10))\n                    if candidate_fitness < fitness[i] or np.random.rand() < accept_prob:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                self.temperature *= 0.95  # Cool down\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.4 + 0.5 * np.random.rand()\n                crossover_rate = 0.7 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = np.clip(a + scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "An enhanced hybrid optimizer that integrates Simulated Annealing with Differential Evolution, introducing dynamic parameter tuning for adaptive exploration and improved convergence.", "configspace": "", "generation": 30, "fitness": 0.306983041424038, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7102142949737569, 0.6759924078994795, 0.6814481483303092, 0.6842114602360261, 0.6765620654782929, 0.6829857553535039, 0.6833100409026591, 0.6801923463982432, 0.6686698514997123, 0.49738870443870176, 0.48776899861938894, 0.46963955950481395, 0.48052579778999016, 0.48345551313707236, 0.4550833112178707, 0.4892757670225202, 0.49244287022080524, 0.4645877868449181, 0.097381964467815, 0.14579067045814387, 0.10093212605744772, 0.11756366376165084, 0.12161112040416211, 0.11142803035232629, 0.117100688614036, 0.0997441905668569, 0.10134702810221696, 0.10388996063906886, 0.10891268915296914, 0.1085358511107326, 0.10390663500402586, 0.10299827652430227, 0.08529358745592674, 0.09597183808950172, 0.10303898764777697, 0.10364201659961125, 0.7230038883189545, 0.7704306461086985, 0.9069252616114803, 0.7223323042457261, 0.8846478690935811, 0.7812461939201585, 0.8886087630391124, 0.8347701092797156, 0.8779755677865267, 0.4051605009493121, 0.35002145000339613, 0.3101824901599297, 0.43789733469616776, 0.39463077896642806, 0.3710463916316926, 0.4078600491237996, 0.3370049615751609, 0.39033590303221033, 0.5959569959518198, 0.4771391967578442, 0.5326613252935928, 0.6442364395723449, 0.5143472904674682, 0.5778621285350845, 0.5706235288774679, 0.5293447731403251, 0.5507111164488467, 0.18782434847052865, 0.17420914018881706, 0.2671730426687847, 0.2979102461404707, 0.27129462803285864, 0.2568318758815248, 0.21905662586107189, 0.3539264259295837, 0.3093600693692391, 0.2694423257276537, 0.30179438881885723, 0.18871312961128328, 0.38196390847918915, 0.26759948435803804, 0.27399652926782525, 0.2713895206581015, 0.25818961993104517, 0.18566154384586475, 0.0978857776112334, 0.16300807381172744, 0.15030405846200645, 0.13937448735176006, 0.17171883905450436, 0.17519429900786532, 0.22536930258285504, 0.21642206073660541, 0.15040559242734708, 0.32614105436262697, 0.2769921960447571, 0.30744932008128256, 0.342857839783401, 0.33602880738928875, 0.32758411692704037, 0.33551501372067694, 0.3445398329193906, 0.33181306572575897, 0.04700033820733607, 0.05367799579903754, 0.04808556202232872, 0.11249132963506214, 0.10455912191338013, 0.10217138836776996, 0.08764020967890573, 0.042384413983972635, 0.08718675469918946, 0.18741562482611485, 0.18512589417004943, 0.1827700818505127, 0.18353327838055078, 0.20192465781324986, 0.20482203962548173, 0.17719168645152783, 0.1714862894381527, 0.18503375215511564, 0.535862611032577, 0.4872251316888182, 0.5273489655119589, 0.5363985920726829, 0.507865735411563, 0.5190500045504733, 0.5142667565104508, 0.4883053785963303, 0.5288963534863589, 0.08904360058094296, 0.08224437452628064, 0.07450776145451543, 0.0828328708918783, 0.08481359731956473, 0.09138928932714185, 0.07954392065266114, 0.07486176591588023, 0.13249194649121365, 0.19649967808711422, 0.21152478025258692, 0.19590736909981254, 0.252360956724222, 0.2653796034592859, 0.18812190785782323, 0.2117466802550232, 0.2558166579186233, 0.17759545827037204, 0.28738370200490304, 0.2757415333351334, 0.2683844292482531, 0.29986180725106504, 0.2756672928026864, 0.30282612721795077, 0.3075161121398172, 0.34644904259893117, 0.32928358079135456, 0.2526325220067016, 0.20101728381866346, 0.2082622556101713, 0.22333419820506928, 0.1836483342139511, 0.23135040678286833, 0.20568304997192643, 0.27500636145008306, 0.24050485081385953, 0.18044916509246345, 0.2149790309602897, 0.16658736024225074, 0.20295409665597297, 0.17947898150760588, 0.18398272036487973, 0.22294409412048055, 0.19226438518506228, 0.20359180792077414, 0.18999447907559963, 0.20485871614374918, 0.1811715050044459, 0.19115466158317573, 0.18817039851961748, 0.21034881280113726, 0.2319850695464939, 0.19481699203996994, 0.21918071483651513, 0.4642184430333218, 0.4762710725900865, 0.653323115114482, 0.6058837512735824, 0.1971917586620895, 0.6617876921486593, 0.5602871999967363, 0.38339531940419136, 0.3977039979522068, 0.5681644949913676, 0.4987325406620997, 0.4860069496790951, 0.3998883946074018, 0.46839337432427475, 0.48697393251714716, 0.5935124473387232, 0.4163386209617602, 0.2002654887371781, 0.20510411056850675, 0.18406226239639822, 0.19229310395916477, 0.18703223816315306, 0.182321506979361, 0.19535694694305328, 0.19129085470449714, 0.1861741253746262, 0.23973609020763065, 0.06626174299065446, 0.07077912700381128, 0.07605097547136397, 0.07060512066679603, 0.07991328458113234, 0.08032787321730661, 0.07042868184765416, 0.07330785118615457, 0.0743365538044245]}, "mutation_prompt": null}
{"id": "38649e12-6332-4082-803b-bc6b5cd5d32a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Increased population size for diversity\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with adaptive Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)  # Reduced step size\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': int(self.dim * 1.5)})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive crossover probability\n                scale_factor = 0.5 + 0.2 * np.random.rand()\n                crossover_prob = 0.8 + 0.1 * np.random.rand()  # Dynamic crossover probability\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "A hybrid optimizer utilizing adaptive Nelder-Mead for local refinement and adaptive Differential Evolution with dynamic crossover rates for enhanced global search efficiency.", "configspace": "", "generation": 31, "fitness": 0.2539066400057712, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.5952374551169879, 0.5690856605640708, 0.6082409002548375, 0.5777897702084286, 0.5789505328903453, 0.5809818051667865, 0.5723672417891459, 0.5665789899852554, 0.568919776649446, 0.3929605685682289, 0.4093232303950688, 0.41756050521320975, 0.4223694057747014, 0.4177358815179758, 0.4044471877096555, 0.4206256933962572, 0.4040088482572981, 0.41588409141022853, 0.07508435908601563, 0.08623373719788141, 0.07912128804522578, 0.08011545108786211, 0.08492926702890347, 0.08341814422938965, 0.08483818495090545, 0.09996430747768592, 0.08413630468296363, 0.07851483110050117, 0.06825856006406006, 0.07393031094902747, 0.10407960011560247, 0.07786791624485889, 0.07129518990349237, 0.07021506649535825, 0.08931632970629344, 0.07454844579071485, 0.6766869032114685, 0.7643577490607469, 0.7028079828719571, 0.6578311788190654, 0.7192352219910152, 0.713620145088017, 0.6694546371547636, 0.6603826955073018, 0.7388305954514637, 0.33469295253212494, 0.26088976313097845, 0.25874198333713117, 0.32150089437361806, 0.26642195177908157, 0.29784961196164517, 0.2810260390735342, 0.2813285982320507, 0.28991109473363863, 0.4340383722277553, 0.4342084795309623, 0.4504164604254599, 0.5100020321357228, 0.48598789343590265, 0.453731406675281, 0.43362185997432545, 0.45213405426688213, 0.5012779787435471, 0.27044821315940526, 0.19152637885647694, 0.14311830499005407, 0.10741679963908335, 0.1503579224984789, 0.14924893746949364, 0.1391174217537624, 0.1531024367281656, 0.14847982858760023, 0.2092540971984561, 0.18224671452078012, 0.192377723145154, 0.20901083986836078, 0.15300038577445463, 0.141404183967358, 0.2498696260070702, 0.17854757931539644, 0.1782904053218619, 0.13185583401767653, 0.14134088646862275, 0.1252617044310984, 0.14623928905499706, 0.1513495452673742, 0.11672118916502039, 0.14311126580760702, 0.12024244545371443, 0.15437659602614862, 0.3233133983276547, 0.25452621950151255, 0.2877535991716069, 0.2646047163744556, 0.2186361925826502, 0.26246181741364594, 0.2845000028261079, 0.2666171039978953, 0.25249583970537315, 0.03663255699617474, 0.054863914520130286, 0.03482152962628604, 0.08154484032248221, 0.06353811964480593, 0.05489977227031739, 0.05133926548563028, 0.048040531874020576, 0.06521831589407445, 0.14341600152805, 0.14751026043322635, 0.14524482582421483, 0.16684538053370868, 0.17161935451316657, 0.15984070541406215, 0.13151057340835703, 0.14772839267668292, 0.1489145050344598, 0.503115574695576, 0.5056545025939019, 0.5214414161996772, 0.47637593113746124, 0.43716608569218174, 0.4176727072938138, 0.5248844474657647, 0.4607409553037254, 0.48869013847672493, 0.08229780630834482, 0.07183658448912411, 0.08304528234622843, 0.07949627632050982, 0.06557798242909396, 0.0797431816304428, 0.10506170777382573, 0.06121698575569212, 0.08585904790640797, 0.16483780131587755, 0.14917767249294722, 0.13847128986673451, 0.17243703739657867, 0.17764658226209717, 0.1527287781234743, 0.19742115228631052, 0.12719623895072985, 0.15576417646790197, 0.2505060665107074, 0.23707696153647762, 0.27628645405891916, 0.2598407564680235, 0.26261688860014465, 0.2611126875764449, 0.3090672482591268, 0.2888783489484881, 0.2852749058616033, 0.19614408098564573, 0.16193539570223892, 0.17369124315067386, 0.210523584275915, 0.17954323444774267, 0.18997734825785095, 0.2158294354013529, 0.23435399415979796, 0.20474427459351408, 0.19191161934106327, 0.17048284359461396, 0.17226365739463978, 0.19924587466920796, 0.16483915553837158, 0.19237067858635282, 0.19718979321868835, 0.15153713138913538, 0.178457403910524, 0.1872018594300171, 0.17480985898087398, 0.19048228913003407, 0.19271080042951694, 0.17811348552654604, 0.17648691904088554, 0.17397892451991304, 0.17700981539852256, 0.16310002823439185, 0.48090571837084284, 0.40107990384396686, 0.5856911417112671, 0.4930794236464877, 0.19625575285680774, 0.44846406335467237, 0.4094415145468331, 0.2863039177654685, 0.30001847426376704, 0.4967398468521511, 0.4101414619440087, 0.3725618526498804, 0.44559064876634646, 0.2554093337866853, 0.21373659798086586, 0.41513133792333123, 0.17264581753824293, 0.18992715479486766, 0.18024621807562546, 0.1805840767473499, 0.19920153540717178, 0.18573531520302555, 0.21425439033899096, 0.1791082390179406, 0.1806910689858784, 0.17989402494661366, 0.1848826390910393, 0.05841465764710663, 0.07955801802568763, 0.05882258998565815, 0.06377998237887372, 0.06993865158035228, 0.06575330344126218, 0.06170292101063246, 0.06262736752257314, 0.06468522399064713]}, "mutation_prompt": null}
{"id": "0df67195-5f34-4136-b7ab-dd4bea611b0d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "23de0437-8582-4562-a525-6f7515d1548a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "1b19f30b-dbd8-4532-b1b2-42cbc36d61f9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "c0d10888-069f-4728-895f-d9c66c0b3fa1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "1da2f251-ce6c-4c6c-97c5-39f2684e0bb1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Now switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)  # Adjust mutation strength\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    scale_factor = 0.3 + 0.7 * (best_fitness - fitness[i]) / (best_fitness + 1e-6)  # Fitness based scaling\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "Introducing a self-adaptive mutation strategy with fitness-based scaling to enhance convergence in the hybrid optimization process.", "configspace": "", "generation": 36, "fitness": 0.1893784422716578, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.5794966181724563, 0.33051206820228995, 0.688303933316823, 0.4928765472450406, 0.6033468625627825, 0.4161039744516536, 0.3833914553836695, 0.45187728887019396, 0.6412847809682738, 0.005295187288592573, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1233920724367632, 0.24396487865659855, 0.12285751000151102, 0.5308951119248897, 0.09505888505826732, 0.1381554082075429, 0.11011573570286959, 0.1279429542039292, 0.09145537602802489, 0.10735562176435165, 0.09727444993345236, 0.10318560255823472, 0.13107520418047747, 0.08283131539967048, 0.10734995564043004, 0.10636751192152938, 0.060529103188806443, 0.09621709811917101, 0.7134451574711962, 0.819596925271421, 0.7121196753292457, 0.6286844358297465, 0.5858779428435674, 0.6050391217944331, 0.7048150363455374, 0.15802746912317722, 0.15459774366570367, 0.17534531524558383, 0.15460927124259594, 0.15134332345311252, 0.19815109842858458, 0.07854021292063118, 0.17729890676210158, 0.0742962808644193, 0.13492487756337923, 0.162873102615962, 0.1949274876613657, 0.46978101787097104, 0.16565681006617483, 0.19457701967310115, 0.5952749355883833, 0.14235988114622633, 0.10929337983578857, 0.29549376969215924, 0.1435178119173779, 0.13041846665762402, 0.009853590149186076, 0.07849545842348382, 0.024771631172816, 0.0768162777542275, 0.031224700744648337, 0.053650011557009214, 0.089500241387093, 0.11847642588845775, 0.13834283085367316, 0.06871802362745605, 0.09296417131019041, 0.0864473731857075, 0.005589673011022422, 0.06841854519996593, 0.11986271161634177, 0.04050649723894617, 0.1058137582347548, 0.003712837418367254, 0.0005430398589445495, 0.030398071510858937, 0.07124349492942506, 9.999999999998899e-05, 0.009967324748819895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10798968741647164, 0.0866165062595714, 0.19122428210847542, 0.18451015231574464, 0.13260173213845539, 0.062338500130689645, 0.26291386308026854, 0.1461949734157173, 0.09152718307030627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021935626838088806, 9.999999999998899e-05, 9.999999999998899e-05, 0.09245778995459863, 0.035665161088699104, 0.08640458906920467, 0.05095740433126428, 0.008740669685979419, 0.09229691064848844, 0.0982543604538394, 0.1330475412220209, 0.21185617112889554, 0.49242914072069466, 0.41692523380161095, 0.4235938314917186, 0.44132307080682953, 0.31575228295534674, 0.364436039792877, 0.4141124603014794, 0.38943836950112387, 0.3214061596342562, 0.12001126472771262, 0.08094151674466243, 0.08445894255639053, 0.09078848816687346, 0.10207692221722209, 0.13126109772733907, 0.03365244756415686, 0.050829153809444305, 0.07042896995911796, 0.18780235590964056, 0.24732998338246637, 0.21917796844962545, 0.23620007042426183, 0.16732068339460893, 0.14890572550834147, 0.25975329230811517, 0.19433842997258566, 0.14814011320351295, 0.377611633659108, 0.33294574387043874, 0.44766587004725433, 0.3489914397598558, 0.1912780939880674, 0.48625165896522626, 0.3841939580425122, 0.4291670765362031, 0.40698043232727577, 0.07944603692950225, 0.1384463877790546, 0.11260303742081745, 0.36167675656707265, 0.15834020043728614, 0.26872069732736104, 0.19702280957934803, 0.24324722418650058, 0.17228024747941617, 0.19509410830745622, 0.1748446188362921, 0.1892819706255967, 0.2229640211447761, 0.19306507573365128, 0.17203818731956544, 0.19278390752392915, 0.18390489223300133, 0.17340327850007853, 0.1537151637134948, 0.14728216787279236, 0.19064365357062352, 0.18709766425508845, 0.21342920040436175, 0.23019276097907393, 0.16468896467837002, 0.17569810396671126, 0.1284615820347801, 0.2570248608162733, 0.33240856105958805, 0.40105117640994403, 0.26370672042794774, 0.1992895439916289, 0.247955008168239, 0.16637793736520923, 0.3379674187690319, 0.168801120502716, 0.43968924305565127, 0.3755422186611994, 0.20224941305879052, 0.27936833396334126, 0.2093078371207734, 0.16634524589936572, 0.1786202659793633, 0.2363215975586329, 0.1909602808269406, 0.22365517520170675, 0.1798131889345279, 0.17637216621468466, 0.19374511588394494, 0.18059900564201103, 0.18459984500742166, 0.18992535872231087, 0.18576197025649865, 0.18060910352750037, 0.09549477165697395, 0.061069454096970954, 0.07622396541936283, 0.06825328022391752, 0.08063413464284475, 0.07328613023871988, 0.07337942446119783, 0.07348638478211744, 0.07304891220501486]}, "mutation_prompt": null}
{"id": "d7a77391-896e-4bd5-a576-59e9478daec5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "55631a0c-2d1f-4c1a-8cb6-7eb638103c71", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "0ee0faf9-9072-47bd-ae8b-fc46939fde0b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "9efbbfea-4946-418c-8caf-fbf23c584d98", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "fc45cf1d-7214-4164-918f-a6acc2604227", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "bbd021df-ec4a-45af-a35b-d084c94fad6b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "2e562ed9-fff6-4235-8406-41894d233a00", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "ab38ddbb-9e7e-4af2-9914-da8c183825e9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2\n\n    def simulated_annealing(self, func, x0):\n        temperature = 1.0\n        cooling_rate = 0.95\n        current_solution = x0\n        current_fitness = func(current_solution)\n        evals = 0\n\n        while temperature > 1e-3 and evals < self.budget:\n            candidate = current_solution + np.random.normal(0, 0.2, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_fitness = func(candidate)\n            evals += 1\n\n            if candidate_fitness < current_fitness or \\\n               np.exp((current_fitness - candidate_fitness) / temperature) > np.random.rand():\n                current_solution = candidate\n                current_fitness = candidate_fitness\n\n            temperature *= cooling_rate\n            if evals >= self.budget:\n                break\n\n        return current_solution, current_fitness, evals\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                for i in range(self.population_size):\n                    candidate, candidate_fitness, sa_evals = self.simulated_annealing(func, population[i])\n                    evals += sa_evals\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                crossover_rate = 0.8 + 0.1 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "An improved hybrid optimization by incorporating Simulated Annealing for better exploration and refined Differential Evolution with adaptive crossover.", "configspace": "", "generation": 44, "fitness": 0.27797773287006705, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6713054810311969, 0.6701328252046302, 0.6824565698652838, 0.6531250032422279, 0.656862676333575, 0.6411096293586835, 0.6685533808089061, 0.6584367854191415, 0.6644300629221358, 0.36729596184334645, 0.3660584693847547, 0.39687575875414527, 0.3643431430761994, 0.38499250819489905, 0.3789733818804002, 0.36778813283037237, 0.3606250398891885, 0.3828548517679271, 0.09142557968935294, 0.0707888890042665, 0.07303051905988722, 0.09253353947341203, 0.07193850063799034, 0.08749207826323324, 0.08979202540663322, 0.07169502651112125, 0.08593921561378759, 0.07455810012541098, 0.06421467902666189, 0.07507383895338227, 0.07616713179427204, 0.07584670461572063, 0.07131274913448216, 0.07577828365020489, 0.06735734762720369, 0.07589775229225126, 0.6282612712163989, 0.6046360981623955, 0.5979040888536153, 0.6171678255331761, 0.6516816575612671, 0.6218760615742062, 0.6057153621733192, 0.6110570415969381, 0.6177996044330158, 0.3941830621759066, 0.34245579389145664, 0.3316979911746425, 0.3687788457190543, 0.36751105875326817, 0.39566805707627695, 0.3539162837640819, 0.28850267446490985, 0.3715663017349047, 0.501270112252117, 0.4445381500407667, 0.48997011934415347, 0.5416718071395092, 0.4966597592264259, 0.5081818610773821, 0.5008721398351326, 0.4818675263884932, 0.4705361665522221, 0.2071775087565394, 0.21202554737035395, 0.20116356215781994, 0.2601689166353347, 0.3082087790510474, 0.22987300585916093, 0.2879599027398917, 0.2987090207496078, 0.22646659526682877, 0.26583965090796213, 0.28553533165873757, 0.23556153430814963, 0.2488289113350186, 0.27229537973026074, 0.24035283716831135, 0.2647106152358898, 0.20985686154591354, 0.2251641547548503, 0.12839887269798222, 0.17247423348808422, 0.10590540717235486, 0.17904320143671937, 0.1466577065285385, 0.11889715489633712, 0.15602447683906628, 0.1584843625176492, 0.1477494882657152, 0.26127191105637926, 0.25849520321312136, 0.29414397390917724, 0.2835154399939156, 0.28567191268094805, 0.2584730709997429, 0.30439138446272906, 0.30084504807796697, 0.31402792695214066, 0.032537966881122204, 0.03576127191548806, 0.06035342650624387, 0.07999450669673824, 0.05997346941884496, 0.08184545508974539, 0.06020851253404147, 0.10144765016430646, 0.06907844292337595, 0.17497699996775207, 0.16021202515444477, 0.17487860344942585, 0.18531433313456092, 0.1863044500363843, 0.19985457039941235, 0.16848071937977038, 0.1527020386249497, 0.1792574516401192, 0.5676045662846354, 0.5329433846855893, 0.5766744136247, 0.4986608170357706, 0.523420534403022, 0.5323757165111132, 0.5517696463613865, 0.5631316473988488, 0.5366292847775931, 0.0691625173864604, 0.06912240029823447, 0.059707282517099, 0.06760752224967925, 0.0600709545813668, 0.07612457856833532, 0.06623367774055855, 0.06711022168780312, 0.0684054835278457, 0.2027225645428682, 0.1951326326161974, 0.21212000017482135, 0.2268754562759303, 0.18692895466616155, 0.19824006093994928, 0.19547086327370589, 0.1612196899570556, 0.20719297932743674, 0.23796482595424695, 0.23623120835109357, 0.24707015975829916, 0.25129636046258796, 0.2517151307275599, 0.2381593169536803, 0.26047421295795714, 0.2921423397304652, 0.2528413831463645, 0.16730682898860172, 0.1709047811730663, 0.174296002954203, 0.19413352341556833, 0.1686034031821404, 0.18099128381383067, 0.19800682433467198, 0.19422026802004877, 0.18923844306971283, 0.16208982361879576, 0.1586931083450125, 0.17347469792988235, 0.18385970214233682, 0.16529771679583283, 0.16461233363455463, 0.19589496164269737, 0.15960134753843103, 0.17135145192029522, 0.18620459680232337, 0.21372176319212066, 0.19780481205989553, 0.19796326129744446, 0.2095419652309759, 0.209442532728784, 0.18384708674802464, 0.20104580791317728, 0.1843473689022721, 0.5733196451044298, 0.4409452406409182, 0.6272356731532251, 0.6498152555460931, 0.2062832991340824, 0.44084199594164797, 0.18774412805861007, 0.4775217432333846, 0.5344113350985567, 0.5545683594072701, 0.5917870856286862, 0.5461801020082786, 0.5025264391634396, 0.5803779155815618, 0.5540427739386475, 0.5577098245113767, 0.5613629213190308, 0.31313903889649697, 0.183521520758414, 0.18339282598984274, 0.19126026562162157, 0.18638698128958087, 0.1814094591819011, 0.18806078573256724, 0.1896119027615314, 0.1943238751332811, 0.19361141216439337, 0.0500640431875472, 0.05168027063313496, 0.058485721861462614, 0.052251898284259135, 0.06109900136307389, 0.0591459803128811, 0.06183635166235202, 0.05733393834759204, 0.052293673693888154]}, "mutation_prompt": null}
{"id": "5995483f-c72a-4f20-bf3c-d32b0e9cd743", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_population_size = min(40, budget // 10)  # Increased initial population size\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.init_population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.init_population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.init_population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)  # Adjusted noise level\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.6 + 0.4 * np.random.rand()  # Adjusted scale factor range\n                for i in range(self.init_population_size):\n                    a, b, c = population[np.random.choice(self.init_population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])  # Adjusted crossover rate\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "A balanced hybrid optimizer combining Random Search with Nelder-Mead, adaptive mutation, and dynamic population size adjustment for enhanced convergence efficiency.", "configspace": "", "generation": 45, "fitness": 0.21912398047439308, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.5623452227949195, 0.5314262456300736, 0.5743317636040557, 0.5617949677322908, 0.5091223448373641, 0.529844278822944, 0.5043223866085451, 0.516575053347843, 0.5055363620379559, 0.29000904901132685, 0.3147734329522316, 0.30612737582362937, 0.32908095358357115, 0.3240706949447054, 0.32850230204879394, 0.29688255814669195, 0.29292301850162716, 0.29850437957576725, 0.08915359083614471, 0.08506104464723396, 0.08075015549609799, 0.10458001690822472, 0.08613587778505238, 0.082667999182502, 0.07819301709588167, 0.11257106538380535, 0.08946074369569468, 0.06877422446756609, 0.06996452605840353, 0.07290883538687776, 0.09977830849689073, 0.07343887931402027, 0.07128959992225226, 0.08124335492258272, 0.0772339396201609, 0.08064175492167847, 0.7464180223851737, 0.7479489411366993, 0.7194620857475877, 0.7285154642749042, 0.7169250274575577, 0.7525264819176261, 0.7491068422554479, 0.723023013411829, 0.7509790703638977, 0.2658935976455147, 0.19415621803407446, 0.21543633863554912, 0.26111161751924694, 0.2381941967028176, 0.21766995458790883, 0.22427384105037795, 0.21372700555104218, 0.2503919137833849, 0.40342067221276423, 0.29660450080367795, 0.21887461873165903, 0.44503998641691, 0.3249433045059106, 0.3703216291348461, 0.36477268139301755, 0.37796669318317955, 0.45973005973563674, 0.16793124342551657, 0.13760482953069386, 0.1354912275262231, 0.13865196565824955, 0.13099082287095443, 0.1401909760917437, 0.14467942121801536, 0.12322022761402474, 0.17400927939667032, 0.1641848124338119, 0.14361414443393894, 0.16214881861976227, 0.19157830550516564, 0.1309076339081654, 0.1300063099259714, 0.1872252704365044, 0.12975097202222163, 0.16823752390299163, 0.08670619735378027, 0.05743442875136184, 0.07577690731736186, 0.07532491584081868, 0.059903172322781195, 0.04530722681934618, 0.06854948247785064, 0.04980935419154864, 0.07913927361992623, 0.21535381340895743, 0.21318383090106008, 0.2530493661558366, 0.22023821935148813, 0.17366491263646733, 0.2108483320153175, 0.24733344971460502, 0.21928056919371752, 0.2030123067695364, 0.004433214573579036, 0.010706887363271411, 0.010527668678273594, 0.010936445156929597, 0.022757230895195768, 0.017733754517539113, 0.008624115092985662, 0.01092977070620349, 0.010891703363593241, 0.1104103118973635, 0.11207832823931163, 0.10424763505033807, 0.1128051723795912, 0.12427512456828482, 0.11888963350386517, 0.10068615244623647, 0.11353363572439756, 0.11174205034721851, 0.40922934711116354, 0.4199711726294266, 0.45774592078101706, 0.40769466969321344, 0.3794035370383564, 0.37390776583514385, 0.48107485393123206, 0.42058612246424565, 0.42496898969574337, 0.07245924000505843, 0.07071508722484232, 0.07589790777991579, 0.07183609439557348, 0.06710210262999283, 0.07949708986610671, 0.07766122916738571, 0.05752824145975266, 0.07829241876520776, 0.15342536702788334, 0.14972760283979347, 0.1738468202722111, 0.16069882844081307, 0.1777916844253019, 0.15281178215265812, 0.1976117966358879, 0.13023474947767266, 0.13191062549192356, 0.2404635074990742, 0.2330263625650757, 0.23256019128368377, 0.23412644412277728, 0.21120156249292577, 0.23510339992882512, 0.2568713749685645, 0.2617791274791622, 0.25182111375691596, 0.1648696656558244, 0.14658478614503123, 0.15440433116408525, 0.17078491628023817, 0.14519458427510612, 0.15851176176078674, 0.18174948272508795, 0.19602686055182716, 0.18196372815859252, 0.17618520362851742, 0.1576548857132135, 0.17236291760575473, 0.19938698281433775, 0.17781855219139597, 0.17122067555445597, 0.16945094686301454, 0.15166704955454346, 0.1801592250928481, 0.1689283179800365, 0.14590296237043365, 0.18255085553548278, 0.1808750322358842, 0.15631586988446255, 0.17721253527425762, 0.1687891883928534, 0.17576155920457004, 0.16612081094984044, 0.3117803066346041, 0.4393599531687078, 0.47278451264565236, 0.39127836960654316, 0.19619081994406007, 0.3828457038059754, 0.26553904540399265, 0.22357704801467548, 0.25707784313200777, 0.385486845634887, 0.3533802958401262, 0.1840554453330333, 0.36761634875543736, 0.1663290682859795, 0.17279691970015432, 0.18078524776955152, 0.1800589313951153, 0.18895297403970468, 0.2015080463990636, 0.18516931713282725, 0.20397524584470617, 0.1859842905130148, 0.18081847074215984, 0.18070462395196063, 0.17645602459044474, 0.1797450217719021, 0.17293739540245356, 0.061278168985251846, 0.061563285548514646, 0.061763606052501197, 0.06308938531885888, 0.05713827783952197, 0.05483418452761912, 0.06050166203786633, 0.04941455812089679, 0.05696323909190837]}, "mutation_prompt": null}
{"id": "ff0b825c-6589-4232-a759-6cc8b1f0c9b6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedOppositionHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population with opposition-based learning\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        opp_population = self.lower_bound + self.upper_bound - population\n        combined_population = np.vstack((population, opp_population))\n        combined_fitness = np.apply_along_axis(func, 1, combined_population)\n        evals = 2 * self.population_size\n        indices = np.argsort(combined_fitness)[:self.population_size]\n        population = combined_population[indices]\n        fitness = combined_fitness[indices]\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.6 + 0.2 * np.random.rand()  # Modified scale factor\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.8, mutant, population[i])  # Adjusted crossover probability\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedOppositionHybridOptimizer", "description": "An enhanced hybrid optimizer integrating opposition-based learning with adaptive differential evolution for accelerated convergence.", "configspace": "", "generation": 46, "fitness": 0.2522569559479257, "feedback": "The algorithm EnhancedOppositionHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6236187518352568, 0.5796439166875722, 0.6717819613908881, 0.6075620712194922, 0.5999005468772367, 0.6519007349857384, 0.6513162853031775, 0.5995299320991707, 0.5826218165411301, 0.430800342101304, 0.4260042539402791, 0.4458528213405145, 0.42626983739086044, 0.45621957196982243, 0.42988480067381785, 0.44404475192556814, 0.4527493527625719, 0.44502374494763686, 0.08656188628910344, 0.0861842263663739, 0.08558398260922495, 0.09840887479329685, 0.0865604719949633, 0.10843880838998232, 0.10081085477682095, 0.08225304097919306, 0.09627920913562171, 0.07266233588971083, 0.08575877482105276, 0.08161433759253633, 0.1073426984943604, 0.08322944380433273, 0.06761215616765748, 0.07346010292685223, 0.0870811955138604, 0.07394764410621013, 0.6885193573991246, 0.9122675947173661, 0.6807195536107706, 0.6981934602639341, 0.7352970186336389, 0.671336878752453, 0.7121443554845654, 0.703124799982376, 0.6894630802215984, 0.28657629140307506, 0.282986613408547, 0.29153305161886567, 0.30328130755225524, 0.3132578424479606, 0.287453407805247, 0.27557461296088437, 0.29661534241554555, 0.3166873223402904, 0.43447022452364403, 0.4567035294708549, 0.4284145028719809, 0.45841229503512493, 0.4632650582115402, 0.3644113770370645, 0.3384747439887046, 0.4360873351702128, 0.44425987935288136, 0.16343556603643317, 0.12699067737971004, 0.22433241840172546, 0.19099530929740927, 0.20536246554720994, 0.17279776226153443, 0.2013240927173282, 0.17659952204756424, 0.18390805766898388, 0.196855659902209, 0.14993497225981922, 0.18751991556424807, 0.20935898895020078, 0.17481079548598555, 0.16983691375373822, 0.22135813289411976, 0.13537213243838508, 0.2186804394233729, 0.06611056497762768, 0.08151777227038126, 0.08398224366193485, 0.1245723991347093, 0.1261889002675054, 0.08719780146709055, 0.10845319115197039, 0.09038683391414892, 0.10543260150111111, 0.26178157677977687, 0.26829862583293873, 0.23558584318922537, 0.25724929497762494, 0.23139192197571734, 0.1946678109735942, 0.3100756769674461, 0.28291883702555665, 0.26221460984283607, 0.03521559830487109, 0.022747371792773086, 0.014870344084354614, 0.041068390814998024, 0.04205394312942701, 0.04467967612461454, 0.01698808361642712, 0.04237238851207581, 0.045911261599287045, 0.1547071649802345, 0.11666182492302835, 0.15078558982467694, 0.11973550296321178, 0.14480071285486862, 0.14889415640417847, 0.12425822895599326, 0.1255095530626581, 0.14847966467687257, 0.4585928693164043, 0.47208390397716726, 0.47442034238729014, 0.45157950362085164, 0.4503361104575816, 0.42076312401329885, 0.5034689410792783, 0.45262826442408, 0.4379279463893838, 0.07907411923858254, 0.0771483486762019, 0.07103308603712644, 0.07359963797822677, 0.08092776637762977, 0.0750557842819135, 0.06320964298929632, 0.06650363705718887, 0.08989065150773079, 0.1542199560996913, 0.2016795446465175, 0.2043279272939329, 0.2133059924444718, 0.18923201870400275, 0.17255992640478268, 0.19899658692283095, 0.17755660466675327, 0.1582125573330857, 0.2616872730925416, 0.24972293562697834, 0.26395259436957486, 0.24076719494120669, 0.23833705066810762, 0.24826787915401438, 0.26441634665859526, 0.2946061594869688, 0.2641263405854357, 0.18956970365888814, 0.1697742750404736, 0.19433113630480325, 0.18386213834308296, 0.17075017644433943, 0.1872563645292773, 0.18437477715642525, 0.21678115362581418, 0.20047256325567397, 0.17865375054082744, 0.1563298202207063, 0.16550323525868083, 0.18771564078964498, 0.16125533369210676, 0.17452917145617264, 0.18892984092529053, 0.1724808584644073, 0.15810391742036844, 0.16967326609557276, 0.15845018219863483, 0.19635166447342722, 0.17179578567941511, 0.18356550830259666, 0.19607516112139023, 0.2196663017952788, 0.16890421894154972, 0.19060537682359113, 0.4191041137441054, 0.26127960575925024, 0.36474774827612544, 0.4309556379988462, 0.19521884623496966, 0.6861801631403699, 0.16953994590387433, 0.1802274365617248, 0.16962886307185832, 0.563757932271489, 0.4393535848938722, 0.4623960448829024, 0.48645696758524726, 0.4638272944937675, 0.4358894041124278, 0.19523886482805564, 0.403891979794587, 0.1731691969879694, 0.1970662992330251, 0.18670481160065078, 0.18248407659287103, 0.19182945479875435, 0.1782357352397037, 0.1709531741879473, 0.17695338759860246, 0.19210188543596096, 0.18403461749221783, 0.06429426962182028, 0.05961775170900396, 0.06252729426956705, 0.06437999657354465, 0.06245747472182883, 0.06553436169696092, 0.05939674501845915, 0.05788747412892603, 0.054913992934067735]}, "mutation_prompt": null}
{"id": "ac971545-dcd4-4705-b1f9-92841a9448b6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, max(10, budget // 5))  # Adjusted population size\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n        self.mutation_prob = 0.7  # Mutation probability factor\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3, self.dim)  # Adjusted mutation strength\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 2})  # Slightly increase maxfev\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                scale_factor_range = (0.5, 0.9)  # Broaden scale factor range\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    scale_factor = np.random.uniform(*scale_factor_range)\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < self.mutation_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "A hybrid optimizer leveraging enhanced mutation strategies and dynamic population sizing for accelerated convergence.", "configspace": "", "generation": 47, "fitness": 0.26377130085178474, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7129893211871654, 0.695384146592352, 0.7171108232301807, 0.693713179964699, 0.6810262420810158, 0.687186286332917, 0.6923933598332543, 0.70139797964919, 0.6827045891608391, 0.47446712565290305, 0.49134184230699784, 0.47497907429007924, 0.5143615685314926, 0.5142987493024482, 0.5219384653062611, 0.5093278147030453, 0.5036084239229688, 0.5025664657912081, 0.10735319915474795, 0.1555656138432041, 0.15678605330764261, 0.11833168217645185, 0.10677647170594717, 0.11662508039574004, 0.11643242601413184, 0.14037600126281236, 0.16194821495394007, 0.11621862506960756, 0.1296522850755396, 0.10402058299153427, 0.10902908868518257, 0.11620560102197286, 0.11342061069112774, 0.12655708485004302, 0.10715051919910079, 0.1298310052387569, 0.7546768090319995, 0.8247586350885123, 0.7297410109015752, 0.7551472026412882, 0.7514117576627319, 0.7614592898365342, 0.7676723384927067, 0.7468141790294347, 0.7592170668914004, 0.38440202572890003, 0.3257113715515598, 0.32832180227922614, 0.34419790196937616, 0.29496422956162327, 0.35777482843750574, 0.314968909082723, 0.31864460997968636, 0.3422951275728313, 0.4349060692995914, 0.43216237036712946, 0.437043938856263, 0.545410096176983, 0.5091779365411474, 0.43162875245091437, 0.4588679836965782, 0.38380477486021425, 0.44190301590788617, 0.1888030987591246, 0.18155839081928538, 0.1793049826858747, 0.19956609630612143, 0.166497348295506, 0.18687561037248013, 0.18401885551343078, 0.16305984476932867, 0.1939962657380816, 0.18796133214742905, 0.1615165350264839, 0.17757259252008062, 0.19636738003228937, 0.19280651517944936, 0.191559123898851, 0.19138827869586672, 0.17067165641457793, 0.1973425338541308, 0.0425668267281466, 0.05294119925375684, 0.061066379388031056, 0.03305736682680249, 0.0389268961010919, 0.022821928414159864, 0.06670381488453403, 0.06217188636740212, 0.04273962216843796, 0.16899318544895126, 0.15397099352807997, 0.21256629740732325, 0.18501278309211744, 0.17957404803724353, 0.12826919018037897, 0.21683283992312707, 0.19539862304246958, 0.18246094538973623, 0.013423357062746999, 0.021907255872121834, 0.019012554962956507, 0.0032875354707186943, 0.009198875864707579, 0.012362377939320268, 0.0015567941070663283, 0.016659160656824268, 0.018723183706383706, 0.13367154042206109, 0.12202800570669259, 0.15151506354608968, 0.15102210765390933, 0.14072624403397094, 0.12857683258324237, 0.09701833248552161, 0.1368024839474017, 0.1310746182755398, 0.45610734877116543, 0.4863679233482566, 0.49366324896679303, 0.4574693487472866, 0.4590531447859153, 0.46108667124320446, 0.48337470333585975, 0.45547878378203277, 0.48936418420734884, 0.0816424884601582, 0.0748037671625329, 0.0713026021183727, 0.08337770187402715, 0.07569069455378663, 0.08396516594932013, 0.0848784474012928, 0.07943019170134158, 0.08276151689944522, 0.16395695959842438, 0.22960151003929152, 0.17002540671519184, 0.19190937727695856, 0.15612357549857547, 0.1956344432623689, 0.17144126673209192, 0.1557690138623815, 0.14977871778633056, 0.27245809720542613, 0.25237044888343807, 0.27154548445213755, 0.25400693576440836, 0.24328896365122943, 0.27148032935620836, 0.29882079136569295, 0.31533437239034245, 0.2865564002696016, 0.16678443658183495, 0.17971790670096033, 0.16972529437131356, 0.1792339978889389, 0.15653057584633367, 0.1778124879128793, 0.20568182456338813, 0.2356265821679815, 0.21446121453252032, 0.1677304997794401, 0.1743021384206097, 0.17529811318977917, 0.2101286526821936, 0.18049981898385448, 0.17163717679635193, 0.1699129097833464, 0.17964929642766092, 0.1700836635633718, 0.19207566726903447, 0.20716140799184446, 0.19491701259926153, 0.18276566699057395, 0.22150176322465276, 0.18394807750746456, 0.18074490748666683, 0.1837462996146385, 0.1812505354549978, 0.38335940749111796, 0.34847606657490215, 0.6234535100308477, 0.5057842725022501, 0.19315217863525147, 0.4583625054009294, 0.3489413078340823, 0.43244933084615655, 0.3373878608816965, 0.5359309532750394, 0.41455923855704646, 0.33659610619310953, 0.3714773279487268, 0.3047964012728117, 0.33654603354988255, 0.45496752787975325, 0.288381037857915, 0.3955472769967787, 0.18687216932860662, 0.1816542251322194, 0.18380042456429435, 0.18004417364591374, 0.18343610808566635, 0.1803916427415868, 0.2120202608938433, 0.1822342826764859, 0.1784179856307102, 0.06285323155437617, 0.057566824091054514, 0.06960545081539238, 0.08330207546568069, 0.07135256301680415, 0.060889569494212314, 0.06993210850479914, 0.0682778733724062, 0.06326648661273593]}, "mutation_prompt": null}
{"id": "7d95b680-0c45-4c1c-844c-1f4f4e0cb75d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveLevyPSOOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 10)\n        self.strategy_switch = 0.25  # Switch to PSO after 25% of budget\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (np.abs(v) ** (1 / L))\n        return step * 0.01\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        velocity = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        pbest = population.copy()\n        pbest_fitness = fitness.copy()\n        best_idx = np.argmin(fitness)\n        gbest = population[best_idx].copy()\n        gbest_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Lvy flight for exploration\n                for i in range(self.population_size):\n                    candidate = population[i] + self.levy_flight()\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < gbest_fitness:\n                            gbest_fitness = candidate_fitness\n                            gbest = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Particle Swarm Optimization\n                for i in range(self.population_size):\n                    inertia_weight = 0.729\n                    cognitive_const = 1.49445 * np.random.rand(self.dim)\n                    social_const = 1.49445 * np.random.rand(self.dim)\n                    velocity[i] = (inertia_weight * velocity[i] +\n                                   cognitive_const * (pbest[i] - population[i]) +\n                                   social_const * (gbest - population[i]))\n                    population[i] += velocity[i]\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                    new_fitness = func(population[i])\n                    evals += 1\n                    if new_fitness < pbest_fitness[i]:\n                        pbest[i] = population[i].copy()\n                        pbest_fitness[i] = new_fitness\n                        if new_fitness < gbest_fitness:\n                            gbest_fitness = new_fitness\n                            gbest = population[i].copy()\n                    if evals >= self.budget:\n                        break\n\n        return gbest", "name": "AdaptiveLevyPSOOptimizer", "description": "An adaptive hybrid optimizer integrating Lvy flight for exploration and local search refinement through Particle Swarm Optimization.", "configspace": "", "generation": 48, "fitness": 0.21947850340315952, "feedback": "The algorithm AdaptiveLevyPSOOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6310318043882877, 0.6010783627937635, 0.6099490435202123, 0.6076740830542142, 0.15882225847314235, 0.6220732657068874, 0.5922904729667475, 0.6097356616159743, 0.5895082446491897, 0.3925987358517121, 9.999999999998899e-05, 0.349609112621299, 0.04310206968603347, 0.032189021415948815, 0.032306224841558984, 0.39458989418684587, 0.03791589051032185, 0.36619033904787446, 0.0853645922473183, 0.09963904621676689, 0.1261178298417731, 0.10412265163220269, 0.10104040648689339, 0.0850789830516967, 0.08512216108148751, 0.13399188676504403, 0.11940024129629367, 0.07901914173863411, 0.080534932481093, 0.10728886124428483, 0.09426979422612514, 0.11676666772146382, 0.1046460615006658, 0.07790248171485692, 0.1006448158515606, 0.08184245334202767, 0.7560691441371448, 0.7586755888049763, 0.7521268577254269, 0.7554284339565562, 0.7543787106817946, 0.7529367471029565, 0.7592580765422836, 0.7541495431364305, 0.7510368111406491, 0.3671146515248732, 0.33103949923721143, 0.36772844267700455, 0.3702384079952361, 0.34898061173821715, 0.3399861304585746, 0.06651200743451624, 0.0717213217661491, 0.349869305539528, 0.1943562155348435, 0.13921027753908188, 0.14186709932110697, 0.42579689306181145, 0.5671713112844647, 0.14669232025584966, 0.190109246823157, 0.19196479268328126, 0.18728297585948062, 0.22494782898447052, 0.13825756503210396, 0.08917879794029848, 0.13512864916453893, 0.09437116296284387, 0.09468600615912515, 0.14832856765241487, 0.12920213899666944, 0.136648650702343, 0.09435368141277778, 0.1501085160651675, 0.19263254192805424, 0.09647021452180216, 0.09197676018106726, 0.1387394802279005, 0.12740884791935436, 0.09836503738650226, 0.08315728061489502, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041279288804207726, 0.010309552217806273, 9.999999999998899e-05, 0.030783602694499868, 9.999999999998899e-05, 9.999999999998899e-05, 0.11152291267932746, 0.04892670144238309, 0.1237998141852007, 0.0687345556467237, 0.046893654479833846, 0.04366186940757366, 0.13825395580921618, 0.059701608330475775, 0.07353796756890374, 0.03152206832965898, 9.999999999998899e-05, 0.0814965891967766, 0.05900670526134433, 0.06005142692355092, 0.14855331359100088, 0.06245679653086467, 0.04819901147630501, 0.10975972369205789, 0.03172649283902251, 0.12276593556240989, 0.06703345721642306, 0.004533370471581977, 0.07644519111727333, 0.06737421699882817, 0.03999872747548727, 0.040326545778425316, 0.06054194281301262, 0.43608391156900483, 0.3928050435412662, 0.41566316617922394, 0.38959996013258047, 0.3983919181659812, 0.3983985954736937, 0.4504893910229839, 0.4277147496395042, 0.44690217280862754, 0.10151951929771363, 0.11310584637236987, 0.12090822648435973, 0.08848604910218605, 0.0731604388189655, 0.09570617486862099, 0.06490316936474483, 0.07356675442020355, 0.12227639720217487, 0.1919874173327648, 0.21399595553846262, 0.2083032443467283, 0.32350729783538046, 0.2363163413916176, 0.3325555140115791, 0.22302465556722662, 0.2158137311444881, 0.13610613373492597, 0.22660767826979478, 0.2621134587470929, 0.3845711018033293, 0.28054758387309175, 0.3555769856927472, 0.2613947235229308, 0.2274432571561159, 0.35952384029426787, 0.3577403799919907, 0.26106043307376503, 0.14534120456927102, 0.1624610605895488, 0.17272013999495117, 0.17808027017483075, 0.19154123933270484, 0.1858646501458705, 0.2268207358106984, 0.21409678264372622, 0.20485559801375242, 0.1718962148630202, 0.18745930539283695, 0.18510255177248247, 0.15927730098386095, 0.17480990504495986, 0.17329709987223163, 0.16593719950246755, 0.21464935497168736, 0.16071266573488574, 0.4294634565285689, 0.39108191412850957, 0.1654458493322436, 0.4930593654823724, 0.14781857648083008, 0.16511620366157298, 0.2583008151101258, 0.1841609269993959, 0.1163445028369059, 0.16930140917467873, 0.151858602165434, 0.6737905737664074, 0.1896654863871381, 0.6601012045924738, 0.1355698356046452, 0.15677779610777431, 0.16816846221900072, 0.44062119661822585, 0.1886405044439653, 0.3544051428313383, 0.49361023030041884, 0.14159463362817037, 0.13443001635149832, 0.48882872494571894, 0.30025990232093713, 0.4128366584952953, 0.22567731155826454, 0.20260477975805447, 0.1991273375392455, 0.2086691826428736, 0.22735885444796156, 0.20324253672569192, 0.21277815392390198, 0.21521382112443765, 0.2356151818890161, 0.07350375846974933, 0.07459740846227991, 0.12286482353671013, 0.07044212931032379, 0.07130954322125638, 0.06652000788839363, 0.07309377585900456, 0.0743342990489515, 0.07723969783109119]}, "mutation_prompt": null}
{"id": "f6dd260e-78d2-4c68-8362-596b7f24f7a5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Increased population size\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population with diversity\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive local search with Covariance Matrix Adaptation\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Powell', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and crossover\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                crossover_rate = 0.8\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization approach incorporating adaptive local search with covariance matrix adaptation and improved population diversity for faster convergence.", "configspace": "", "generation": 49, "fitness": 0.20785311862368322, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.5449416888666481, 0.5174070567106431, 0.5268199714784019, 0.547531164749216, 0.5133186012169333, 0.5289860444341239, 0.52099148664558, 0.5272326506732999, 0.5184499111101312, 0.3448355894777425, 0.3173334129254183, 0.34493212660895733, 0.361463460820478, 0.34810060797559517, 0.32491982737791414, 0.3380311014703885, 0.3284167373015484, 0.33996559359635103, 0.07769976888540275, 0.07975130901526095, 0.07569010649728702, 0.08407052584348729, 0.07942882355020897, 0.08944883672374648, 0.0802765594116005, 0.10038966963689422, 0.087316593934893, 0.0799519165807816, 0.06697035332392776, 0.06666788584734618, 0.08379101317017901, 0.06655221151132995, 0.07300545977466533, 0.0753949916737392, 0.07134904216337112, 0.06536414909785249, 0.6969741704263425, 0.7046444916946866, 0.6868565576074364, 0.6798204562501192, 0.6946936766851792, 0.7054844000703556, 0.6781056808106405, 0.690541418580845, 0.6899588354615946, 0.2307402816846611, 0.20993873896437631, 0.20941778834290614, 0.25572224134425336, 0.21557086180928908, 0.2233898060402909, 0.22088985389169102, 0.2204449652924051, 0.21604650403525627, 0.3773981936344105, 0.33794241200327824, 0.2731812064210696, 0.39479437260557193, 0.383821395947729, 0.2761012104944056, 0.31344683516084815, 0.35936583996737104, 0.36928041335246453, 0.13758327908724655, 0.11941360874994356, 0.1233894526796464, 0.11458798298350903, 0.12633472803568313, 0.10213393536139559, 0.1074976848992455, 0.11035023423941315, 0.11664472897993217, 0.15940661747089124, 0.10189497038702444, 0.0815219636017036, 0.13324680015260948, 0.1404327753538357, 0.12756391178882154, 0.14852354653829136, 0.11693816605072804, 0.11503358247959894, 0.0430930017005805, 0.0440983631344285, 0.03400435012884573, 0.05489768790307736, 0.025318950954302477, 0.043041302084613764, 0.07288141691228667, 0.041360131864963345, 0.04023227677498109, 0.1817548208858889, 0.18401521478854754, 0.20729847617868113, 0.16998169422075193, 0.146555133429369, 0.14400848567718372, 0.21696861316149463, 0.18721416599601426, 0.16537757501976158, 0.012963953464053546, 0.015367553308545556, 0.006113433209413266, 0.016464660420664745, 0.007412193133332079, 0.014469243384293118, 0.008165554868716729, 0.022709301188386433, 0.02478226961047514, 0.096354128369876, 0.08554273491188158, 0.10104923395474508, 0.10807009185345484, 0.10093881386094394, 0.10975548474211627, 0.10524907875148981, 0.09611018396562176, 0.09306977639737946, 0.3791328882637385, 0.4313997127616598, 0.41642678741155326, 0.3849471099753764, 0.3923379207037079, 0.3832225246916, 0.4442193135223562, 0.4030795006091844, 0.39451686444521694, 0.06887575448657934, 0.061090830121776185, 0.07345992113026756, 0.07370731462454827, 0.05791642503457006, 0.06894780881048024, 0.05677392824466354, 0.06435858209661816, 0.0679585546474335, 0.15392920191518622, 0.16348534145906957, 0.1475270067065665, 0.21203377336636553, 0.18031510425627473, 0.14876449808903236, 0.22814396165781858, 0.1369163654899861, 0.14514226425997456, 0.22208084960102448, 0.21283043403643043, 0.2444723219959406, 0.22646119326647063, 0.20958109300982464, 0.232428033047257, 0.2793572609659096, 0.27062626554066016, 0.2528467292894958, 0.1541482373321169, 0.1533860297518771, 0.15620839687248478, 0.16284880041019656, 0.1487532059182256, 0.14222392404237272, 0.1692994152217081, 0.18896348922182382, 0.1820901144234751, 0.18733380064569916, 0.15560128390514893, 0.17689503083596114, 0.18377829020533343, 0.16602191093087748, 0.16041171807830557, 0.17093174105474063, 0.16914681528216646, 0.16228105195166953, 0.17344250595472732, 0.14398975268978265, 0.1791793170992262, 0.19613523774444774, 0.17182036697101843, 0.154252923835563, 0.17138074867576036, 0.16359683607571718, 0.15627800802346192, 0.19941640243283987, 0.2858407887883264, 0.29526442298274325, 0.3545100855004789, 0.2186223179221023, 0.38186908705114875, 0.28856306068027004, 0.1905738693457839, 0.17599830077556522, 0.3433481943056972, 0.25466886086546514, 0.25037375269679174, 0.21206508299573612, 0.28753310008809163, 0.20355923530799913, 0.16817177326599175, 0.2538035023095362, 0.1773373290017114, 0.20413248990757704, 0.19307345415504007, 0.18286651619805128, 0.18446714884875048, 0.1865833075548835, 0.18674737026849597, 0.19453929152221527, 0.18664366172358182, 0.18157810995094292, 0.055433632474390704, 0.05269044919091792, 0.0627220245943998, 0.05626938328005493, 0.06751617090494166, 0.060575338553301994, 0.06162074196997869, 0.060709585691437806, 0.06631720921032425]}, "mutation_prompt": null}
{"id": "2e78f14c-38ad-4274-a561-31c9368eec65", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "6afab25a-2542-4daa-af9b-cc0a430b990c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "5e57ef8c-908f-4c13-ad7d-16fafebc684a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "7b50796e-b269-4480-ad87-ff15f8e5a3b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "7766bd0b-90ae-45a8-b6d9-97aebbb95611", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_population_size = min(50, budget // 8)\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        population_size = self.max_population_size\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive Nelder-Mead with elitism\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n                for i in range(population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Differential Evolution with adaptive mutation and population reduction\n                population_size = max(5, int(population_size * 0.9))\n                scale_factor = 0.4 + 0.4 * np.random.rand()\n                for i in range(population_size):\n                    a, b, c = population[np.random.choice(self.max_population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.8, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveMultiStrategyOptimizer", "description": "Adaptive Multi-Strategy Hybrid Optimizer: Combines self-adaptive Nelder-Mead and Differential Evolution with adaptive population sizing for improved convergence.", "configspace": "", "generation": 54, "fitness": 0.1660976651558768, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.3655613907013473, 0.3291931383622575, 0.33614789946735535, 0.3071638458926288, 0.329795342806914, 0.33689984796329175, 0.3633880457371984, 0.33557661151074836, 0.30622461849288896, 0.034005983395177686, 0.04947234911063225, 0.026417591251545303, 0.04282682714753261, 0.036391284518625056, 0.06244468911149237, 0.012021747602349753, 0.036020734016746436, 0.03462864934341814, 0.0792437915911538, 0.07982848299141843, 0.07123280588089476, 0.07228326717630773, 0.08128565773651686, 0.0818741795853768, 0.08530758735306065, 0.08449827310633662, 0.08763706017899187, 0.06726836139995107, 0.07506099708753577, 0.09217912263740091, 0.07384788166660661, 0.07369062249879021, 0.06911625891058482, 0.07134354688140554, 0.07999658528854758, 0.06401645796837052, 0.7095505773623605, 0.7095059109466462, 0.6903999795687741, 0.7289779951431499, 0.6949109970339109, 0.6988936596145674, 0.70879625735744, 0.6937275282124189, 0.7141346719780759, 0.18591012231027415, 0.13895875874117825, 0.14401910717447353, 0.1935519155260742, 0.1144692869999484, 0.14868276777036793, 0.14464441650981485, 0.15655782587425782, 0.16222016623614055, 0.19396452741446024, 0.2058501652365956, 0.2316173814000202, 0.18725952178271243, 0.19765250234164156, 0.1652811783866731, 0.17849358583462926, 0.17490368920301136, 0.21725277847204694, 0.14254346521443806, 0.09753692605954889, 0.10759908683545527, 0.09507885911253744, 0.09616187371812446, 0.08329463981170226, 0.0932887870749548, 0.09332580485217168, 0.11088156014279249, 0.10721232531285674, 0.1221039421683161, 0.09502106197232607, 0.09679590496362578, 0.1072158865345797, 0.10318257515942297, 0.11544687025554434, 0.09215552550283557, 0.10495314631685482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03752117027962054, 9.999999999998899e-05, 9.999999999998899e-05, 0.1101029241413346, 0.10328588472963984, 0.11735738427059716, 0.11046566542707081, 0.11918590105728544, 0.10572770252681729, 0.1204402177719176, 0.1304951417893644, 0.11068836148183325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06486948618772714, 0.02992152335325149, 0.058970611230475645, 0.03753069506928386, 0.034563367005841394, 0.04527772361491733, 0.022778522986341754, 0.03603613266469419, 0.04796854654863414, 0.3033086820511157, 0.33705504159044297, 0.3409877299702624, 0.29290558120607024, 0.27665892205894915, 0.29907688355924733, 0.30915582522104845, 0.2706019274374617, 0.3283990769654701, 0.053641241424225106, 0.06428051800969825, 0.06558384397734263, 0.06379976749003857, 0.06483938349025942, 0.06429866395569228, 0.057656080375316554, 0.06778367135201113, 0.07897330863624907, 0.1801851830611042, 0.15907383149580634, 0.19518471441031116, 0.19621065110249192, 0.16271121159635726, 0.14216352189493442, 0.16511345208907546, 0.18781626892842218, 0.17559635693641418, 0.18030229872874537, 0.18066457310913797, 0.19008147421613664, 0.1892995155074486, 0.1604655174256221, 0.22339565906359005, 0.19347059194862248, 0.20734771970855959, 0.20376043833673518, 0.1303722855454087, 0.16850881351999047, 0.13625468937619756, 0.14342829122039968, 0.1272159684115557, 0.13120618268580253, 0.14557840786778475, 0.17247583350735962, 0.13591661087597573, 0.1790205973269534, 0.1633149651230511, 0.16755240496656842, 0.17850821373484138, 0.17825690942336425, 0.17464958809537579, 0.1712404703121605, 0.17058190294296038, 0.16675534631558242, 0.18220360363217936, 0.19061867132777544, 0.17792038934690824, 0.1921237992801219, 0.1592935650532552, 0.17355142145228586, 0.17599157207530647, 0.17049443374193163, 0.17701880709539486, 0.2756857149977644, 0.546111494688256, 0.43552063017545073, 0.28987133590141523, 0.180005481253249, 0.3045188621365231, 0.31068115535723906, 0.29222744727903804, 0.320739003136131, 0.2694323772900038, 0.21948051987124872, 0.17350391511184093, 0.33030946316766097, 0.2063463873437814, 0.2592385735367281, 0.2964755685414081, 0.17912831544325758, 0.21149957416035403, 0.180489846284819, 0.18032160022192767, 0.18511810698931663, 0.18472242478464918, 0.17447719060957056, 0.1893555010986646, 0.18238500177914152, 0.176104495028217, 0.18212996058733077, 0.052957537042385594, 0.05220521125576105, 0.06224652461195035, 0.06493425889126359, 0.059613637351434545, 0.057342020202123645, 0.0684895108588005, 0.058035444011342086, 0.0607246961346356]}, "mutation_prompt": null}
{"id": "fb809980-464c-414b-a71e-f6428bcf78ff", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "90e93a23-6789-435f-b915-087e58be246c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "d8c318bc-99ae-4a63-9d69-702eeaed9e3c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, budget // 8)  # Increased population size\n        self.strategy_switch = 0.25  # Switch after 25% of budget\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)  # Reduced noise for precision\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                scale_factor = 0.4 + 0.4 * np.random.rand()  # Increased mutation range\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_prob = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n                    trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "A novel adaptive hybrid optimizer blending Random Search with Adaptive Nelder-Mead and adaptive mutation in Differential Evolution for enhanced convergence.", "configspace": "", "generation": 57, "fitness": 0.24807710336719627, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.610939482354683, 0.5647992504459773, 0.5821022862116646, 0.5838227334901378, 0.5695958201196275, 0.6014164479334227, 0.5969471780252534, 0.5527529622857837, 0.559354088590428, 0.39811459659273096, 0.38163129024309306, 0.3801135073530082, 0.3825989156242384, 0.3799161779222965, 0.3805475332869851, 0.33651609168968966, 0.39820116965736074, 0.3717441871543682, 0.07781347541547334, 0.08625982061520154, 0.08275853370565256, 0.08973356092319351, 0.08658569958472895, 0.08368968892285777, 0.08482718536764677, 0.10304607624590156, 0.09372013754237418, 0.07698671838281357, 0.06541738537828656, 0.08082529088488932, 0.08186631704797365, 0.09170982696768659, 0.08926916995140677, 0.07686575985326438, 0.08725589900183872, 0.07756260643838175, 0.7274608860023943, 0.7197319645684498, 0.6914714032108662, 0.7129793313727368, 0.7232637194346718, 0.7207375717701852, 0.7632744136738944, 0.7436554444532971, 0.7432393089999493, 0.2797342907746927, 0.24003629081609745, 0.25667238915554924, 0.27801450383681947, 0.24944264202085042, 0.282491087605488, 0.24860634327069686, 0.2651468023856669, 0.266696078185934, 0.5137032289283796, 0.5258624311750013, 0.42549567534621435, 0.5359700210663049, 0.5356278977198723, 0.4326451227016723, 0.4677655029737472, 0.48242394078817763, 0.4036714867655202, 0.1845746470989268, 0.1682695225720232, 0.1844302427868818, 0.13804430147510416, 0.15468412314592406, 0.12742454909906686, 0.1555875913369369, 0.22710734230103558, 0.17049655601098113, 0.14740710575098914, 0.14999521352475054, 0.14625752001974235, 0.15151729558693783, 0.18401331424795042, 0.13206397589102947, 0.15241140531714614, 0.16706300650415018, 0.1255837093613711, 0.12977665141363848, 0.12351091232318778, 0.1036511991568817, 0.13892375524898148, 0.12029923440505952, 0.10437280199431243, 0.126079647400137, 0.11563935390539681, 0.11826279341800106, 0.24874450431377626, 0.2586313899567244, 0.2594243906462548, 0.23961874445560938, 0.23196582996054727, 0.23177224409647668, 0.31824958435667117, 0.30175135926439767, 0.23061470067559153, 0.03956465868684356, 0.04250132439513776, 0.027180297685074795, 0.05865528125182862, 0.04263893313486855, 0.03298249473349446, 0.03200707877054487, 0.05402745079687887, 0.033184426747178586, 0.1372676548229963, 0.13551766155674627, 0.13635934650534842, 0.15479279975311433, 0.14826235593999804, 0.13084747382397854, 0.1430222231989866, 0.13930462825617596, 0.1280547572179137, 0.4436705141575118, 0.4760603418143705, 0.45797257951773884, 0.43421043623461686, 0.45342490119957146, 0.4418324221946679, 0.507972244489606, 0.4438230577493396, 0.48877651623073837, 0.07665878656944602, 0.0698686347002313, 0.06966878710705338, 0.07570981834954948, 0.08082890493567807, 0.07763442388224029, 0.08251105818006998, 0.07177425776121948, 0.0765036459518913, 0.13727770674576134, 0.156632865328576, 0.2428338370469929, 0.22728568458956, 0.18137299441875354, 0.15098234980283431, 0.189134056865772, 0.14362592056588785, 0.15088172520940368, 0.25547613196873087, 0.2613082129148697, 0.25262172660571036, 0.26432231544251183, 0.24863650508683555, 0.25435779785833146, 0.28521907475621244, 0.2955505939092925, 0.272495286663722, 0.1933376458164504, 0.18082618483571378, 0.18775563677419982, 0.19910616155533334, 0.1825653723062446, 0.19035551419151842, 0.20673524477045502, 0.21248844145681656, 0.20700109174301717, 0.19715955267123741, 0.1662974922692032, 0.1720094213333001, 0.1976756964930414, 0.20079997596687538, 0.17709615162344783, 0.18314540508939814, 0.17928038220931575, 0.16499267060015077, 0.169298183155703, 0.17360010300581374, 0.16810140340974722, 0.15701201796235031, 0.15323989007106953, 0.15309717259677147, 0.1768653521768827, 0.15307345653877058, 0.16709843757431686, 0.37022719417738204, 0.19160397782069405, 0.40226357179304706, 0.4437071406369246, 0.286434115440904, 0.35325106580810084, 0.366481020377329, 0.20811182623870683, 0.28106589184381914, 0.5799126540265631, 0.3632534861430219, 0.3610976391494576, 0.33219998022800024, 0.36805227660568574, 0.26775379024488966, 0.4547471509081572, 0.36857364662493886, 0.33381025989974034, 0.18117678487022026, 0.19520124840611963, 0.1905251449981339, 0.19653146139901267, 0.1902148198402036, 0.18934001525396094, 0.19253510661436646, 0.17630963410315492, 0.2056197752139194, 0.06272021312666132, 0.07974938776558338, 0.0738102821750477, 0.06098863728977144, 0.06355593092897127, 0.06103952093739695, 0.06689418395179869, 0.06998512780342958, 0.05946217315368052]}, "mutation_prompt": null}
{"id": "cc844312-049c-404e-a74b-5018dc169292", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "19174dd3-3f84-446a-b2cf-ca5375634241", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, budget // 8)  # Increased initial population size\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Enhanced Random Search with adaptive Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 2 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 2})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with enhanced mutation strategies\n                scale_factor = 0.6 + 0.4 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_prob = np.random.rand()\n                    trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n                # Dynamic resizing of population for exploration\n                if evals < self.budget / 2:\n                    self.population_size = int(self.population_size * 0.9)  # Gradually reduce population size\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "An improved hybrid optimization algorithm combining adaptive Nelder-Mead with dynamic population resizing and enhanced mutation strategies for accelerated convergence.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "47c1e5a8-3a90-4059-8b1d-586e05c62d4c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "d708560e-3f3c-41ce-a421-c9197096d74d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Adaptive Nelder-Mead\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1, 'adaptive': True})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with Covariance Adaptation\n                scale_factor = 0.5 + 0.2 * np.random.rand()\n                crossover_rate = 0.8 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer integrating covariance adaptation for differential evolution and an adaptive Nelder-Mead strategy to improve convergence.", "configspace": "", "generation": 61, "fitness": 0.3221251511970135, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6796728208214213, 0.6196252227697006, 0.6748188674895528, 0.6680029682140411, 0.651551095920985, 0.6356190842514936, 0.6606655958479588, 0.6496454387841237, 0.6538907987416719, 0.4755711207342156, 0.48699393907505373, 0.4856319388819118, 0.5065389247335705, 0.47507478816903315, 0.5024666982536485, 0.48748731993927374, 0.4930054771767808, 0.5029231895633288, 0.09655528631851829, 0.08278878772328369, 0.08371745035435729, 0.09285832428730478, 0.07954282761295584, 0.10738086211595654, 0.09467889146190789, 0.09412910569691502, 0.10965380175317985, 0.07278259283222455, 0.09161803432294169, 0.09514898131103111, 0.08497167157047292, 0.07829302157403395, 0.0867117858811356, 0.09017455622103732, 0.07410447601651815, 0.07701334731612164, 0.6957712487636166, 0.819596925271421, 0.6808719293750707, 0.6954296814976197, 0.6882938446478674, 0.7003960326687189, 0.6862460640231016, 0.6894738215714806, 0.6999286352000589, 0.390394853240015, 0.4139279069456082, 0.33219504376237097, 0.42962541722030545, 0.43983147028527936, 0.38444435571773805, 0.35728732566597554, 0.3976918260933484, 0.4001475799308303, 0.5608598280478394, 0.5744682468119242, 0.5208175223367496, 0.602641416161471, 0.5485041302798344, 0.5255435375139528, 0.545082840299806, 0.6156385406874285, 0.5661563084903345, 0.21063749234918383, 0.2487980635035446, 0.14817232944731806, 0.21415697154733693, 0.27666742517437193, 0.18223031447823856, 0.19185081608902887, 0.15266257811499706, 0.22540737643316866, 0.256057286658012, 0.2352291739895226, 0.20468797050829968, 0.1502915911751468, 0.35568382489869, 0.19248566015875423, 0.19530314711070074, 0.26056371961981284, 0.3246344921212526, 0.31351683205317027, 0.31135399752930415, 0.2342380848431097, 0.33212954942387796, 0.3606955627303662, 0.27589505185780494, 0.36284514599016715, 0.3434595178513621, 0.33890171797140534, 0.47170667405519406, 0.45068792406467806, 0.45501442985119633, 0.4837008130753001, 0.4463335448214568, 0.461241086926405, 0.5012711852522966, 0.48642441529850744, 0.4261108513777051, 0.059869586174161715, 0.09377425138393114, 0.18405683320119848, 0.23527824518070706, 0.1926089420398669, 0.16997699415256595, 0.1081060352467812, 0.1169129039563217, 0.18119369481215886, 0.2464237224825947, 0.2581282124461125, 0.2687347920914286, 0.23376523546158678, 0.2641511723432015, 0.262325113232435, 0.24669208571243284, 0.25140075884875523, 0.2701482114473256, 0.57612851519655, 0.6141115635281424, 0.6125793433484386, 0.5727799197207715, 0.5572911717312695, 0.5630769823056649, 0.6305802933225761, 0.5600492647899759, 0.5961493105689961, 0.07942079886313735, 0.07438857179317582, 0.07180246557556058, 0.07744727406151108, 0.07426643044251391, 0.09554076905282904, 0.09019050836908404, 0.0787278214235475, 0.08772826484591911, 0.16143979306689749, 0.17738810499472835, 0.1756245663467071, 0.22291657228364825, 0.19087934427507447, 0.20945494557074607, 0.20172420892718812, 0.2241435258040576, 0.17520214808247347, 0.31326039843884423, 0.31970824565577916, 0.3022099322676428, 0.3100016935730986, 0.28568360200140963, 0.31298660372345277, 0.3227235732859073, 0.36301514876918095, 0.33085395245556415, 0.248428134186235, 0.2118602243683494, 0.229067165853298, 0.2326498386611361, 0.24084046457001718, 0.2582195737963088, 0.24956672609967478, 0.287048057777478, 0.24040418068351987, 0.18794726247450777, 0.17990273941029022, 0.19407020684446818, 0.1825002353284383, 0.16779914427960974, 0.17295733843797212, 0.18517811278421614, 0.1570849721356402, 0.18023667227557094, 0.17333770347985478, 0.2742233360081512, 0.21792601123298228, 0.21536906936972078, 0.1812350315284994, 0.17385570873252343, 0.20244325991376977, 0.1935336568441639, 0.16536177978147792, 0.5133506690678484, 0.6425673440047419, 0.6629335402133132, 0.571540198278191, 0.5273144141776147, 0.6344376276484247, 0.17270350648230526, 0.6128469282363682, 0.49160179659684133, 0.7081974982857113, 0.5355092922855587, 0.5538797472236885, 0.5700701877115913, 0.1813804891252706, 0.4620277340346467, 0.5664201359593479, 0.5185205892566385, 0.6080934320002659, 0.1823816925505376, 0.18032469777150817, 0.1837912126091812, 0.20442146172267817, 0.17793576385699694, 0.1745519103887353, 0.1878730887832708, 0.18211046340227433, 0.1877922969855117, 0.06427659101139105, 0.06791533495381974, 0.06460361147182792, 0.06825232347154797, 0.0628290948079826, 0.06595041821256709, 0.06352452499319294, 0.05739041573181436, 0.06802155511010566]}, "mutation_prompt": null}
{"id": "3f8ac10a-930a-45ef-b13a-1a51e8b4c0d5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Increased population size\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with adaptive Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)  # Reduced noise\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim * 2})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with dynamic scaling\n                scale_factor = 0.4 + 0.4 * (1 - evals / self.budget)  # Dynamic scaling\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach integrating adaptive Nelder-Mead and dynamic scaling in Differential Evolution for enhanced convergence.", "configspace": "", "generation": 62, "fitness": 0.28447210859797917, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6257861964056516, 0.6069838942572925, 0.619890763646688, 0.6133329310064031, 0.6191285835070233, 0.5994668128774655, 0.6022671500702074, 0.5923420982113212, 0.6017119541371648, 0.44123034422475405, 0.44497581518918927, 0.42847303382411595, 0.43574422772487187, 0.44121757313432386, 0.432614693376165, 0.4353635568827481, 0.43970710231673216, 0.437961386699802, 0.08336728757960576, 0.0911757683698704, 0.09023688456349721, 0.09082331405899113, 0.08429920366208354, 0.09048157651835032, 0.09260701481743383, 0.09836732343141708, 0.0931433426592494, 0.09203482337171065, 0.07780813764352135, 0.07812256844721999, 0.08871446429673546, 0.08642577721651978, 0.07357043780259576, 0.0723477799624741, 0.07957399916037267, 0.07879870630324293, 0.7361533630909786, 0.76346015543669, 0.7197411766545406, 0.729847055696788, 0.720584052164708, 0.7154289869964241, 0.7060404989984974, 0.6496853149203594, 0.7410872988132029, 0.3583620464892009, 0.32635261276665306, 0.3124419555534158, 0.3526793760755399, 0.32485795874074763, 0.318293117693925, 0.28692143048261853, 0.32610738467692, 0.3277144250693015, 0.5345560122471398, 0.5069077528492778, 0.5700296476311022, 0.5402551755380525, 0.5294803225614853, 0.5208293427848696, 0.5491521994455127, 0.48297092161695887, 0.5628120651527895, 0.1981349178312558, 0.1792912390747099, 0.1922300737626491, 0.1798153821840176, 0.15941238100291588, 0.2854880134354717, 0.13143098146688914, 0.20616511451526764, 0.14690777992686488, 0.31413801685152964, 0.1558921272831496, 0.2715931746344531, 0.17143313654071413, 0.18473645792542526, 0.1637937805315539, 0.29678499710527817, 0.14669564434044335, 0.15087866853040977, 0.2306498115838732, 0.2308784599512036, 0.2130724706506547, 0.24938313680239987, 0.26105967195706303, 0.20563527641602763, 0.2702891865868653, 0.2432371093355975, 0.23180195270360582, 0.4064964070212427, 0.38213365527054677, 0.4195474475790776, 0.38175260910564124, 0.3650168504196052, 0.392685514465835, 0.4142063931389607, 0.43858104930305275, 0.41904428673943717, 0.0984248054637441, 0.07339518041356641, 0.08246861621306034, 0.15120203961093015, 0.1254778155449381, 0.15039788483747796, 0.09632481483090727, 0.14855401684393343, 0.11391187745125442, 0.2119118606918563, 0.21448916933585738, 0.20653243692470225, 0.20288172256377868, 0.20601975853264143, 0.21802757855710575, 0.1839865553708121, 0.1959699257325247, 0.19019966238798602, 0.5294294616047444, 0.5256562613338545, 0.5769140983219752, 0.5009857290668243, 0.5118768154088714, 0.5160555379908867, 0.5986107794477475, 0.4976959969971041, 0.5600667501781498, 0.07661981456230371, 0.06780189388156055, 0.09174321007234554, 0.08513276068231901, 0.07793496639688746, 0.0792720076675072, 0.08021082248408096, 0.062135436722060344, 0.08114541224534988, 0.14947018063770778, 0.14859547116702576, 0.1633283425789025, 0.20925317936070487, 0.1706720686514751, 0.18561606709941647, 0.1987472100601504, 0.14444682554817445, 0.1385812431476554, 0.2825047273566028, 0.2728731444271397, 0.30720109561356146, 0.2846517385557067, 0.28801636515365714, 0.28554699190184407, 0.3182629008123884, 0.33079124387988057, 0.3081080092970303, 0.19951348481685138, 0.21197220600525857, 0.2229165599023133, 0.21467881008577683, 0.20583021541933055, 0.20872822464510044, 0.24168253997775724, 0.25574311270855155, 0.22933864133380932, 0.16944317748677873, 0.1693659349559482, 0.1716062124622325, 0.19932721668933706, 0.17662079952224397, 0.1676373197478268, 0.1891104971258193, 0.17399603825755672, 0.18146586330162173, 0.20992563479744486, 0.15712738693286865, 0.21532122506586715, 0.20851201352559934, 0.16182470705159924, 0.179904379671029, 0.1771432855512015, 0.19197431052736724, 0.17900799929066957, 0.474301735651284, 0.3416110289174138, 0.6153537776446447, 0.47838842858922803, 0.19825793096764965, 0.5514073655991576, 0.4896715658573325, 0.3356844586909373, 0.19821126119138877, 0.6317185365230131, 0.4763029596803038, 0.4337932100095854, 0.4713883733839591, 0.17415662316871716, 0.20289066800731648, 0.18336716151421906, 0.47787943441605363, 0.19100057368891177, 0.18140661748180942, 0.17997071125681063, 0.19910311930516023, 0.18597190044141643, 0.182707980509632, 0.17887385144366852, 0.17871349257163527, 0.17340174281248177, 0.1692480473280843, 0.06560044014055888, 0.06699815872960058, 0.07085753095913516, 0.0626945037391402, 0.06921488072077331, 0.06510293976399839, 0.06288344061989248, 0.06241181540191554, 0.05643975848004412]}, "mutation_prompt": null}
{"id": "e2319b06-b6f5-425a-a2c2-2e70b40a9c17", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def levy_flight(self, L):\n        return np.random.normal(0, 1, self.dim) * L ** (-1.0)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Lvy flights and elitism\n                for i in range(self.population_size):\n                    L = np.random.uniform(0.01, 0.1)\n                    candidate = population[i] + self.levy_flight(L)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and crossover\n                scale_factor = 0.5 + 0.4 * np.random.rand()\n                crossover_prob = 0.9\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = np.clip(a + scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "An enhanced adaptive hybrid optimizer blending Lvy flights with updated differential evolution strategies for improved convergence speed.", "configspace": "", "generation": 63, "fitness": 0.2991839620733153, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6435010913880497, 0.6366602837507513, 0.6643064885057124, 0.6722364830832109, 0.719310345949505, 0.6622084617855301, 0.653564280451832, 0.6503831771493499, 0.6752292584781658, 0.4875388568992852, 0.49015164620734875, 0.5081865423713253, 0.5311201280036346, 0.5122823951558428, 0.5113654264783355, 0.4967440497474831, 0.522511559312179, 0.49449797133972284, 0.08567327001229408, 0.0949694536225536, 0.08956336060634962, 0.09564273199539386, 0.0824482695920058, 0.0873984468959823, 0.10086212321380428, 0.09108015563407079, 0.08787554506232209, 0.08185127565470263, 0.08991666544762134, 0.07938403448157738, 0.08299921632482998, 0.08518671680421575, 0.08899671338709103, 0.08184729518771605, 0.08039129251078336, 0.09212631594440135, 0.9967471566765154, 0.9928358242515716, 0.9882471370004089, 0.988181297658823, 0.9930815228670963, 0.9891936124854424, 0.9885853885153691, 0.9917161257688966, 0.9927478436691114, 0.4174220661085476, 0.38481370729648456, 0.37866664921980153, 0.4439957847765279, 0.3759263916384521, 0.3816469170510154, 0.0740204295918857, 0.40560860959823475, 0.0691154587669831, 0.5481988678538332, 0.6123156540769092, 0.5847628333754027, 0.6550317890527149, 0.6330107071506863, 0.6677727371730898, 0.5948351789856432, 0.5879838452852787, 0.5964793711476497, 0.2580409509478785, 0.21594353199280014, 0.25485431839687256, 0.2153576439186068, 0.2607644663410482, 0.09614246084050315, 0.3274774472404951, 0.27222131921972603, 0.25996254184003553, 0.24714107177912947, 0.4283103073552532, 0.36951712219564936, 0.28573319355521776, 0.2717046419283944, 0.2680197740487328, 0.4059802231509744, 0.3092719805788875, 0.27834918120603735, 0.26486680458492307, 0.05152094089781245, 0.2929174520420894, 0.0005040710881468735, 0.30365871079660756, 0.2739027736276436, 0.25391272965753553, 0.299075781821561, 0.263067797611665, 0.3791599364771313, 0.39652228764444863, 0.45442900919615703, 0.3832766576422222, 0.3710418545701244, 0.3601684882406252, 0.445351795091531, 0.46170856501076596, 0.48528275208446425, 0.10176950254376493, 0.11146586913205825, 0.06075866873335212, 0.0916153927589477, 0.13571351095751016, 0.11458726583921375, 0.1390844470031639, 0.1130866566250277, 0.18954771550464988, 0.25001891045866564, 0.2567974140223529, 0.23964887624710396, 0.2500344625168506, 0.25915321154769877, 0.25308267168600307, 9.999999999998899e-05, 0.23412018579285032, 0.23398410377917633, 0.5655482803786488, 0.5587510527633432, 0.5822819555707527, 0.5774654986605257, 0.5771796258949767, 0.5486312375741342, 0.5731916014843716, 0.598399872815284, 0.5828039351170257, 0.08884701232747827, 0.07698128494705603, 0.07551376756498906, 0.08514718622649375, 0.07761981933008832, 0.08828554077230255, 0.07009973846833673, 0.08473358360549155, 0.0767791531464107, 0.14088326808422602, 0.13650672600470315, 0.1498270169545891, 0.14891068978918842, 0.19947087274506947, 0.15991159089582474, 0.1343793739594723, 0.15560847457571914, 0.1302660300235866, 0.3058656146675105, 0.3212087451434742, 0.3253929154800511, 0.3046859431098472, 0.32615242003815714, 0.29648393866419964, 0.3329424249162525, 0.34715333192622844, 0.3616570863418279, 0.22378279368581733, 0.23977268930074647, 0.22748755083877037, 0.22530206229944794, 0.23040052704753633, 0.22984085069612037, 0.26586040397894384, 0.2762865797463995, 0.25496398555651634, 0.1679473558399175, 0.1611136932182644, 0.1752491597799466, 0.180649058064567, 0.17533854659723147, 0.1631747070835068, 0.19659167079804452, 0.1857676191375205, 0.1752306626936001, 0.1816983105748412, 0.1484989914261874, 0.16735019813948326, 0.14898591451468945, 0.1876099443810555, 0.17859357131317444, 0.1521570309085517, 0.357171781947077, 0.15935366443455223, 0.1243575630780509, 0.15996327684786715, 0.1570577946437849, 0.17062844362465335, 0.1804954208016859, 0.16593404434360803, 0.16669800433420956, 0.15273009590858477, 0.1763246521960915, 0.3411564548570012, 0.1541490044581988, 0.1531444916767274, 0.16921462080453398, 0.6152207808339494, 0.17042617893140688, 0.1877760956423543, 0.18785554532629845, 0.18584406548305765, 0.19229316324720602, 0.1732766277819141, 0.1869238484026562, 0.16259166537465686, 0.16458609032098537, 0.1834557351545636, 0.18520066999620732, 0.16862452175132225, 0.16684091439368132, 0.05893406951926394, 0.062066602634045176, 0.0685132493916184, 0.06545698534380573, 0.0742776247027237, 0.0605727702048694, 0.06618327664881085, 0.059459968848439515, 0.06107187110968626]}, "mutation_prompt": null}
{"id": "7c95270d-b6d1-44ae-b4c7-28de9c7e857c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = min(30, budget // 10)\n        self.population_size = self.initial_population_size\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive Nelder-Mead with elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Self-adaptive Differential Evolution with dynamic population\n                scale_factor = 0.5 + np.random.rand() * (0.9 - 0.5)\n                crossover_rate = 0.7 + 0.2 * np.random.rand()\n                new_population_size = max(5, self.initial_population_size - (evals // (self.budget // 10)))\n                for _ in range(new_population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizerV2", "description": "An enhanced hybrid optimizer combining adaptive Nelder-Mead with self-adaptive Differential Evolution, incorporating dynamic population resizing for improved convergence speed.", "configspace": "", "generation": 64, "fitness": 0.14244647854825468, "feedback": "The algorithm EnhancedHybridOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.14.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.24815595007620894, 0.19183189335482675, 0.2819883974227382, 0.28350365067850214, 0.22252728337060135, 0.2387094030219249, 0.21168331595546452, 0.22914949315958522, 0.23519065807917638, 0.005791344843121604, 9.999999999998899e-05, 0.019519791368588613, 0.03959664836756238, 0.010413028695461124, 0.030037065816809427, 9.999999999998899e-05, 0.004999290968177084, 0.05057302999002222, 0.06793306790363562, 0.06593792186180158, 0.05981917480523258, 0.0694998742792361, 0.07064227257142497, 0.06268734672053111, 0.07606224168330067, 0.08022673250128942, 0.06794951916947445, 0.059366725134462284, 0.0565444929026897, 0.05160758522286346, 0.07421880297561856, 0.07428780247386346, 0.053566631727184344, 0.059908054836097846, 0.05597221296828703, 0.049574174842137664, 0.6739097315981712, 0.819596925271421, 0.700070309767429, 0.6556193213125172, 0.6494551708101561, 0.6500216665538636, 0.6873965549459826, 0.7089752871541817, 0.6960693193286787, 0.13756000593156692, 0.10987827079759394, 0.086984688871105, 0.15499121530521276, 0.08512847411300117, 0.11331302580385127, 0.10606628923294814, 0.11141927362632176, 0.12172108177029184, 0.14836018242668925, 0.13010500464805141, 0.11071089362430575, 0.1755526679972239, 0.14820414824739125, 0.11713251874153308, 0.12484119974773622, 0.13774785294934866, 0.15994798988458792, 0.07304670718794037, 0.039198129087672506, 0.07980968680069922, 0.05649555727142741, 0.0865018092080827, 0.041790509941802334, 0.07768313455650278, 0.05040623159261082, 0.11521235150320586, 0.11718765133045272, 0.029346317803231825, 0.07513479981837168, 0.10722013240932138, 0.054315376914532476, 0.06841854519996593, 0.11986271161634177, 0.0383903819894833, 0.10509409774639988, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00631974725628881, 9.999999999998899e-05, 9.999999999998899e-05, 0.13032493231712983, 0.07796908278864356, 0.102526221656561, 0.10759501657175863, 0.09207492826787234, 0.08580225289807186, 0.1865308209188261, 0.10593676350582515, 0.07607189847002793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029926109446077653, 0.035665161088699104, 0.08078631267795555, 0.010321839624128581, 9.999999999998899e-05, 0.044059927518079856, 0.006802420455030211, 0.036686933885790474, 0.05678526197688394, 0.23696587050209106, 0.3120328676456291, 0.3156625625978493, 0.20828581972762517, 0.21757098955263987, 0.25570033719227125, 0.3375634675369493, 0.20753120594884078, 0.24587372423102716, 0.041230868090332606, 0.04197526919444661, 0.03496078414985859, 0.0580087444723133, 0.03697440915562855, 0.07297917313140334, 0.052539628839350594, 0.047546999074655316, 0.06921046022383437, 0.1439244801067151, 0.19605771882843492, 0.19125302782616393, 0.22714880497319778, 0.16239731457999718, 0.14090663085323418, 0.20229764171834708, 0.1728272851630558, 0.157074165435221, 0.1558006660803416, 0.17604964693036895, 0.1635526033432534, 0.16991358166598802, 0.1697250732401071, 0.189133960684301, 0.16764308895889357, 0.19851383535252642, 0.1639301713945439, 0.09965348708449728, 0.09523613975175271, 0.11163069880862897, 0.113577756931458, 0.09960306266410168, 0.1306481892594864, 0.1137233881752231, 0.16579812637641922, 0.10294020612785904, 0.15910213346751445, 0.14919387469515644, 0.17233248563585435, 0.18888234804287252, 0.1523928989571507, 0.16917661817929042, 0.18459270069004097, 0.13914081515919552, 0.15729641989016052, 0.15717142016303842, 0.14372369659309825, 0.18783484413773543, 0.174599398861091, 0.16180421133336043, 0.17292844317866551, 0.16576100145101258, 0.17569810396671126, 0.14008516166772156, 0.1910738040258999, 0.2616387736934769, 0.31459051514741576, 0.2983475886576772, 0.1992895439916289, 0.2620175636074086, 0.21411989916067387, 0.28178032213630233, 0.1770585183419442, 0.35433926087373924, 0.2659093929118912, 0.20026544723649897, 0.2089880595903587, 0.17938112085203806, 0.18175731101106263, 0.15730387432807258, 0.1923347248909525, 0.18481852849477598, 0.203670668155696, 0.17585784865379028, 0.18155818784924804, 0.19842423744434412, 0.1779120333708042, 0.18725856709197275, 0.17757496625454716, 0.18576197025649865, 0.18225785785692328, 0.04329754986955958, 0.03881563537801935, 0.060982004724729255, 0.053119269502058364, 0.06017393555797845, 0.048746181790383925, 0.04772836189204843, 0.047190284777197444, 0.05825133388410708]}, "mutation_prompt": null}
{"id": "b264bd0b-3766-4b85-a394-ac1c3d4cf4a6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and modified crossover strategy\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                crossover_rate = 0.7 + 0.2 * np.random.rand()  # Modified crossover rate\n                for i in range(self.population_size):\n                    idxs = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[idxs]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_vector = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_vector, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n                # Dynamic population adjustment\n                if evals % (self.budget // 10) == 0:  # Adjust population size every 10% of budget\n                    improvement = np.std(fitness) / np.abs(np.mean(fitness))\n                    if improvement < 0.01 and self.population_size < self.budget // 5:\n                        self.population_size = min(self.population_size + 5, int(self.budget / 10))\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "Introducing a dynamic population size adjustment based on convergence speed and implementing a modified crossover strategy in Differential Evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.3009973343648993, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7128334151636344, 0.6591550982490961, 0.6905347873202263, 0.7029695979574848, 0.6543296352057945, 0.6841713274411041, 0.6999187906132772, 0.6786200499605621, 0.6773512802252796, 0.5265164607368312, 0.49693159587163704, 0.5108837528890156, 0.5221692484677111, 0.5257134199839606, 0.5210875375773723, 0.5247139821410296, 0.5067544274784055, 0.5150771648464673, 0.09572347677597481, 0.0969033372363649, 0.09874791599996957, 0.11094033459037711, 0.10875672350534638, 0.11002195637647705, 0.10561799251375159, 0.09924173044180551, 0.09446780145037137, 0.0932416160782017, 0.09738000483120701, 0.0997700578888927, 0.11607412263234618, 0.09044158138510716, 0.08905041916019651, 0.10896630167587207, 0.08552046924268686, 0.07708939881810839, 0.7539557180331626, 0.819596925271421, 0.7348471711215041, 0.739089793652055, 0.7397406215602207, 0.7639455979980273, 0.724056316326593, 0.7255989637411502, 0.7629696423689935, 0.4057024527152737, 0.40440700562161735, 0.3784606190498735, 0.37399408829587133, 0.3716944469405292, 0.38349853677249923, 0.4185813289102226, 0.3560352872363919, 0.3696546607350263, 0.5889362099668225, 0.5868568920995472, 0.544320368130507, 0.5878298480599513, 0.5473060486480403, 0.4617036136283418, 0.5888760472575925, 0.5307528095179954, 0.6350619367632104, 0.23249441260152903, 0.21256763578601845, 0.20011148209068763, 0.18156684332349393, 0.23226819433967616, 0.21010304118163237, 0.22955998950032686, 0.28183366191219306, 0.2268242352663462, 0.20806756739186583, 0.21767329159657456, 0.19578634170305442, 0.28359017363098915, 0.20763661097135466, 0.21879089129078222, 0.22853657055452625, 0.21320106687486762, 0.2201055049772308, 0.14032031778935394, 0.14276319196633758, 0.1682633632366557, 0.185021563292453, 0.12920159614954863, 0.14273489098996184, 0.18372709519209063, 0.14029239682229944, 0.1545078961005809, 0.35302671323286683, 0.3230640922114888, 0.32152364727174987, 0.3086504663823064, 0.34880707245714393, 0.30128215674188896, 0.33756214869506074, 0.3245640235999574, 0.32716965663352626, 0.053239189670591935, 0.06377393911167384, 0.08511182567030084, 0.1708016569777212, 0.09318145885990237, 0.10829895232959807, 0.09989957440776231, 0.10340914256386091, 0.06958893838823699, 0.18546463723371165, 0.18687184580842509, 0.19304956781768579, 0.20849549254055189, 0.1619585012360254, 0.2005805299822807, 0.16995566474101576, 0.19838614704322877, 0.18313250674442294, 0.5459093949611646, 0.5611747832904774, 0.5675358555965991, 0.531800883643341, 0.5011542003179952, 0.5063028371032463, 0.5785962271768703, 0.5244224587292814, 0.5215704284098953, 0.07900819684075011, 0.0754206947463083, 0.08148869460355967, 0.10155093935954373, 0.07174602202958036, 0.08227188375105854, 0.08116142659927628, 0.07267207809193699, 0.08299866396965083, 0.1643803466027428, 0.1910920958254957, 0.1654192479328449, 0.19193515750521228, 0.18732934685409464, 0.19030453679841586, 0.2081088266798694, 0.16585057919538082, 0.17009316834959842, 0.305587308725917, 0.2933738947714305, 0.3086181751091899, 0.2974560293770925, 0.2801850068549673, 0.284757620331911, 0.3252115497443808, 0.3654665322435361, 0.34648783181509246, 0.23377017858189908, 0.21552390818207734, 0.19849975736399705, 0.22714589564496812, 0.18790281808865472, 0.18122087578042845, 0.25917229303331757, 0.24453136067218717, 0.22508305758359903, 0.18479980458765966, 0.16464495740685148, 0.16515044381067312, 0.1866908374322246, 0.1769478346221527, 0.18014999830166067, 0.18342920326390066, 0.1608647081166913, 0.16950322925153782, 0.2729814236535387, 0.29895623978580366, 0.1905148237976878, 0.21455126761396592, 0.2279342015713932, 0.1828381619879449, 0.17199157634730977, 0.1999824546342721, 0.1728860786384665, 0.5712444323121564, 0.5448315333568792, 0.6375199785144607, 0.6566930948793515, 0.19907829957026912, 0.5946996958487056, 0.1770942344220584, 0.4437823891189516, 0.3945132190597266, 0.6638399091042566, 0.4818298187538882, 0.4570844927483576, 0.5673164600463005, 0.43654375300347625, 0.18659502082169654, 0.6312826123057096, 0.5212585154003717, 0.3602093111157608, 0.18706961944928646, 0.17251827048258472, 0.17861125885687124, 0.1753655571092455, 0.18590494939621283, 0.18425721307452436, 0.1945388849415196, 0.17628922673422365, 0.1879203416171451, 0.05895825039935332, 0.06705993440518354, 0.07145960899066683, 0.06709687332785474, 0.07569992943300807, 0.06536867236539223, 0.06733602346466672, 0.07272455269330635, 0.06215883396244881]}, "mutation_prompt": null}
{"id": "9f7d693b-5237-4031-b1f0-b8dc4adafdfe", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom cma import CMAEvolutionStrategy\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Earlier switch to Differential Evolution\n        self.cma_init_sigma = 0.5   # Initial sigma for CMA-ES\n\n    def __call__(self, func):\n        # Initialize CMA-ES\n        es = CMAEvolutionStrategy(self.dim * [0], self.cma_init_sigma)\n        evals = 0\n        best_solution = None\n        best_fitness = float('inf')\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # CMA-ES phase\n                if not es.stop():\n                    solutions = es.ask()\n                    solutions = np.clip(solutions, self.lower_bound, self.upper_bound)\n                    fitness_values = [func(s) for s in solutions]\n                    evals += len(solutions)\n                    es.tell(solutions, fitness_values)\n                    es.logger.add()\n                    es.disp()\n                    best_idx = np.argmin(fitness_values)\n                    if fitness_values[best_idx] < best_fitness:\n                        best_fitness = fitness_values[best_idx]\n                        best_solution = solutions[best_idx].copy()\n            else:\n                # Modified Differential Evolution with adaptive mutation\n                if best_solution is None:\n                    population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    fitness = np.apply_along_axis(func, 1, population)\n                    evals += self.population_size\n                    best_idx = np.argmin(fitness)\n                    best_solution = population[best_idx].copy()\n                    best_fitness = fitness[best_idx]\n\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer combining CMA-ES with adaptive Nelder-Mead and modified Differential Evolution for enhanced convergence speed.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'cma'\").", "error": "ModuleNotFoundError(\"No module named 'cma'\")", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "ec32dc9a-2c23-4ad0-ad64-131097c59388", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = min(30, budget // 12)\n        self.max_population_size = min(50, budget // 8)\n        self.strategy_switch_ratio = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch_ratio * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and dynamic population size\n                population_size = min(self.max_population_size, population_size + 1)\n                scale_factor = 0.5 + 0.2 * np.random.rand()\n                for i in range(population_size):\n                    a, b, c = population[np.random.choice(population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An improved hybrid optimizer combining Nelder-Mead and Differential Evolution with dynamic population size and adaptive strategy transitions for enhanced convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "b4e83f2e-d84d-4ba1-b392-56e34e22ad6c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Increased Threshold for Strategy Switch\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.laplace(0, 0.15, self.dim)  # Laplace mutation\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Powell', options={'maxfev': self.dim + 1})  # Powell method\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                scale_factor = 0.5 + 0.5 * np.random.rand()\n                crossover_rate = 0.9 - 0.1 * (evals / self.budget)  # Dynamic crossover rate\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedAdaptiveOptimizer", "description": "Introduced adaptive local search and dynamic crossover probability in Differential Evolution to enhance convergence speed and solution quality.", "configspace": "", "generation": 68, "fitness": 0.28773389501590013, "feedback": "The algorithm EnhancedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.668712773112468, 0.6594953594559293, 0.6935861952562512, 0.6708053732867102, 0.6356986281708851, 0.6389570005546719, 0.6512034070253881, 0.6539725612577604, 0.6502369125767854, 0.49696530379785886, 0.49074214746372047, 0.42608736235421396, 0.4865530692209863, 0.4783906458783226, 0.4714929068589424, 0.49000078358893284, 0.47340940683354726, 0.4709458585218843, 0.09362434601871905, 0.09853467580762443, 0.10640203215609856, 0.13575206347124713, 0.08821442402840007, 0.0891652447261353, 0.10261102149755241, 0.08720663549470431, 0.09674388968985981, 0.08836950610057193, 0.07632453318562382, 0.08148468292864286, 0.09694734971656382, 0.08069125855494363, 0.09180232926755794, 0.08712626385384759, 0.08393725204816693, 0.08242837263780622, 0.7442048484122848, 0.759221079250822, 0.745408333546483, 0.7468824039591915, 0.7655894083748875, 0.7329674554830454, 0.7613855945453639, 0.7501562492388361, 0.7564004521345248, 0.3574210132125636, 0.3456748378266482, 0.3006390214830921, 0.3672197059310226, 0.3126382807759527, 0.3254442080092723, 0.37249114010692164, 0.3210746370787838, 0.32266160210627115, 0.5898513893826716, 0.5421670478617956, 0.5128243526448308, 0.5948823575361613, 0.5577267307529152, 0.5222271513063382, 0.5989121842179856, 0.521011113729513, 0.5932787059032144, 0.2286865097742493, 0.24747517035019417, 0.22398508688933005, 0.2259680311372143, 0.25969826755740855, 0.21598825586315773, 0.2014707393360693, 0.26420683143271817, 0.2666513502431812, 0.2612770914824877, 0.20615702371162548, 0.21440547630749196, 0.249487143366819, 0.20169209753772, 0.25035634262491013, 0.2947163006590132, 0.2308542437338389, 0.29051145172461, 0.1384349616803645, 0.13616521580164098, 0.15518014613440756, 0.19177804652411945, 0.1527786050620833, 0.15875733361667577, 0.2051258880333321, 0.17948288243205246, 0.16541256671680316, 0.3459269599860788, 0.291747686565086, 0.32380615704239857, 0.34950696870223097, 0.2958971001934082, 0.31398508004967185, 0.3961459485189951, 0.33377364766273254, 0.33763667826183985, 0.027923162504941534, 0.06126771804587283, 0.02286930446539026, 0.12250005823686805, 0.0496933815068995, 0.06299098314695206, 0.05533390950681949, 0.06443053647783892, 0.04929398510764027, 0.16435988497753207, 0.16304530892064506, 0.15510929435234377, 0.1795637980916701, 0.17866699430156818, 0.17322478877429925, 0.161588050551853, 0.1733441277688642, 0.16954274623753485, 0.5424512462432953, 0.49685194476252104, 0.526255889619262, 0.5322689578020966, 0.5127048420072293, 0.5018550456066068, 0.5433249885897078, 0.4720687440720567, 0.5212941996970782, 0.07183683697677445, 0.07803449517623617, 0.07562304774962159, 0.08262562205561919, 0.06811132508336026, 0.07183427226390382, 0.08626159911571085, 0.0699472904429067, 0.07702168134654042, 0.168439894837622, 0.21966597667324606, 0.1699672413751223, 0.17070469420677237, 0.19555337858377475, 0.1466170413821466, 0.20564446629223854, 0.14022922879849498, 0.1585490099974466, 0.2766488995031767, 0.2783369656201796, 0.2625739954189328, 0.2715747584278504, 0.2525449569789958, 0.25411090621994203, 0.3121869533791122, 0.32909801749430234, 0.2654072803957348, 0.20192865550777062, 0.19407447162484337, 0.20671057849610674, 0.2079622639879839, 0.21327114495902166, 0.175353078559916, 0.23175573831660679, 0.24430043244683175, 0.19658622490489375, 0.1849951807716903, 0.1673851439051326, 0.16895942649605455, 0.17331719816797353, 0.1686479275406635, 0.18137858685645325, 0.17689904841735915, 0.17668407153749943, 0.17719188199251035, 0.21615563731148757, 0.17655818487703823, 0.18310688866461733, 0.18672484278291823, 0.17751669307643947, 0.18794785860339958, 0.18663133661162756, 0.1801597351138926, 0.17349361407058062, 0.5161277071282088, 0.5001877989526413, 0.5773340578815402, 0.6524392140765267, 0.19584398209174325, 0.4919311826007575, 0.6188054916176202, 0.28312261108804815, 0.4865712580935727, 0.5781741968936182, 0.5647685534084179, 0.4249686331942274, 0.469704382246668, 0.4546871506256319, 0.1834013181995896, 0.19797468307761956, 0.45740492463503946, 0.19387358938444144, 0.18577565975228438, 0.18845902554748084, 0.18488583215988097, 0.1789451067301563, 0.1846228214354464, 0.1789532600976187, 0.1817743680684376, 0.2166462896721857, 0.18490204073905903, 0.07030923434137837, 0.06935200814460063, 0.05472672765733, 0.05942157491765154, 0.05790430471555641, 0.06009009349720196, 0.0643037471697957, 0.05812542614092586, 0.06522132675238246]}, "mutation_prompt": null}
{"id": "769408db-0f64-4b66-a384-42a2a8865d81", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "1a0566c5-d3df-4a7b-b0c8-dac0a6abd6f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "794b922d-a0f1-4c40-a978-0b2acbd29f65", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "958656bf-7a70-4623-ab2d-56624fcd7dd9", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "a5bc03b2-8f9e-431b-87d0-996897cfd59a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "19b0e228-a39d-47e5-9f8e-5a1f52f7dd35", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "93849581-c475-4060-b692-908f1f6f415e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass FusionOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(35, budget // 9)  # Slightly larger population\n        self.strategy_switch = 0.25  # Switch strategy after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive Nelder-Mead with randomized restart\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.15, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 2 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 2})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Enhanced Differential Evolution with leader selection\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    leader = population[np.argmin(fitness[indices])]  # Select better leader\n                    mutant = leader + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "FusionOptimizer", "description": "FusionOptimizer employs a dynamic balance of diverse global-local search strategies, integrating adaptive Nelder-Mead and differential evolution with progressive leader selection for accelerated convergence.", "configspace": "", "generation": 75, "fitness": 0.23157386067641053, "feedback": "The algorithm FusionOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6158934984528239, 0.5833847859309365, 0.6542388092528588, 0.5887616136429434, 0.6179246299211589, 0.5992396532091335, 0.5807142963196152, 0.6015701105160289, 0.6346983582807357, 0.45198363190741686, 0.3786539074156321, 0.41203003413710204, 0.34822513699032664, 0.07227375458340157, 0.4438724834342135, 0.42866403591135827, 0.42226811623765614, 9.999999999998899e-05, 0.10106245660706625, 0.08387301321351537, 0.08593402337943667, 0.09930301823649812, 0.09655179361187582, 0.09436277189456177, 0.0858449494592829, 0.11723196941857206, 0.09275990592479466, 0.08773238515248372, 0.06102518500357257, 0.07636665307730583, 0.08189354062120169, 0.09177694786558255, 0.07186678442151406, 0.09800488036789357, 0.11261829116688804, 0.0944087693671507, 0.7295696111491636, 0.7862930007349833, 0.6262002167709558, 0.6701885301689293, 0.7093569368871036, 0.6601818063086351, 0.6783990145781171, 0.7057400954635726, 0.6378582006204097, 0.21166923296141305, 0.13865245915680258, 0.22527479518690774, 0.30761361345084104, 0.11438649595471762, 0.30937357863704396, 0.20690435401611207, 0.19777179197908357, 0.18556483112469035, 0.4290020123428071, 0.4656042816194307, 0.414813637318433, 0.5164322521720113, 0.48496413693878926, 0.16129661924890537, 0.20763724675241524, 0.35641330504802193, 0.44126180350317146, 0.3123882597221872, 0.15349493081989296, 0.14103023026806127, 0.2740672353500224, 0.1256033878467484, 0.17170832287051985, 0.11678385834668881, 0.1322417418945322, 0.12202024214952767, 0.16071970039236694, 0.10871062889768857, 0.14868697624290128, 0.13531651539501977, 0.10096274420809781, 0.11287664711268186, 0.1330654173789344, 0.14530342589021528, 0.10894444258302916, 0.08712661468176341, 0.07614482537856526, 0.10310245362332848, 0.1146310325394081, 0.03000447094499381, 0.05979238536598208, 0.11477288690938425, 0.04804186450311121, 0.1052435893478374, 0.17082693424970408, 0.251045654543535, 0.22846249498610882, 0.1498555614053697, 0.14482498801328636, 0.10674872026027482, 0.3537271780488077, 0.18485869101089647, 0.14614801339114092, 0.07830727010191585, 0.10176898242741028, 0.09628086878352793, 0.09905597834718816, 0.05531783664574652, 0.05249825673088382, 0.07842311065005614, 0.12818792688470237, 0.04523351869205472, 0.11627085571134199, 0.0594718631529666, 0.15393459369903573, 0.1847036225992027, 0.1116427555982702, 0.11263880993495023, 0.06768120034253755, 0.09828612374670143, 0.11528611529393074, 0.4160950263410389, 0.4121691383203513, 0.4184726650805989, 0.3755807777843829, 0.41923095801225196, 0.38270379853212433, 0.4755832788706498, 0.4257558969118016, 0.4218035248095129, 0.07187494562312968, 0.1079909998841525, 0.06325620183765224, 0.0761389191821269, 0.06707858438249825, 0.06981427148718433, 0.08205157538561636, 0.07740627537416711, 0.08633488953283408, 0.1668627727805433, 0.16786586398967263, 0.16254425446089948, 0.19873099075028156, 0.17001340825711142, 0.16982370921921663, 0.19235951522900085, 0.16243408304437812, 0.17172734581599292, 0.25967093128800367, 0.2898776032492837, 0.2723579234810033, 0.2809596681230201, 0.2576544527380521, 0.29667813660182096, 0.25358241002073567, 0.2531279610211987, 0.2927841510765634, 0.18806490307410428, 0.1662916124958589, 0.16156635742095404, 0.1687849406884523, 0.16059702683669963, 0.21609873088591924, 0.1727948306120607, 0.2660473963693456, 0.22591311741535158, 0.1724930316164196, 0.17439029033481346, 0.16417929283270238, 0.18317699174690205, 0.19331285913548268, 0.1731086936813585, 0.16592474568299498, 0.17660819415136975, 0.16481794587385246, 0.16845475508201813, 0.18216765936482537, 0.2017690698782063, 0.22060580772704586, 0.17627480326204947, 0.17390041748691198, 0.16425351828711487, 0.1977819248594367, 0.36812478932139614, 0.14708187303527664, 0.22712865834138274, 0.6666401800580065, 0.6830575424035996, 0.19408408229525498, 0.24577381836179057, 0.17863409572130584, 0.2052317263622273, 0.21655611623900084, 0.6972975384994338, 0.2527946767167141, 0.37645758641761606, 0.5781861528328611, 0.17844770876544558, 0.18953813504989125, 0.16887318802650475, 0.19727986093825844, 0.19237069408352103, 0.17842967103779772, 0.18270862051110603, 0.18327361263893094, 0.1871696416311024, 0.1761137121040165, 0.19154307381024704, 0.1861827175650438, 0.1722471656227086, 0.1735278731064287, 0.0659008683782566, 0.061122360706476364, 0.0685402238073679, 0.07085601141674602, 0.07205896033767878, 0.06441797494649382, 0.0734922640129877, 0.0604786231639739, 0.060745471595680334]}, "mutation_prompt": null}
{"id": "ddd031ce-1924-4e0e-abf6-79a24d68f287", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nfrom cma import CMAEvolutionStrategy\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n        self.cma_eta = 0.5  # Proportion of evaluations for CMA\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.cma_eta * self.budget:\n                # Use Covariance Matrix Adaptation\n                es = CMAEvolutionStrategy(best_solution, 0.3, {'popsize': self.population_size})\n                solutions = es.ask()\n                for sol in solutions:\n                    if evals >= self.budget:\n                        break\n                    sol = np.clip(sol, self.lower_bound, self.upper_bound)\n                    sol_fitness = func(sol)\n                    evals += 1\n                    es.tell([sol], [sol_fitness])\n                    if sol_fitness < best_fitness:\n                        best_fitness = sol_fitness\n                        best_solution = sol.copy()\n            elif evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid optimizer that integrates Covariance Matrix Adaptation (CMA) with Differential Evolution to improve convergence speed by dynamically adjusting search strategies based on the exploration phase.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'cma'\").", "error": "ModuleNotFoundError(\"No module named 'cma'\")", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "7b9abe4e-eb7d-43f9-a540-9b25b9d5b1bb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "4c3e453a-7a23-4ab8-90e0-01814939ad29", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n        self.CMA_eta = 0.15  # Learning rate for covariance matrix adaptation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and rank-based selection\n                population_fitness_pairs = list(zip(population, fitness))\n                population_fitness_pairs.sort(key=lambda x: x[1])\n                scale_factor = 0.5 + 0.1 * np.random.rand()\n                for i in range(self.population_size):\n                    candidates = np.random.choice(self.population_size, 3, replace=False, p=np.linspace(0.1, 0.9, self.population_size))\n                    a, b, c = [population_fitness_pairs[idx][0] for idx in candidates]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.8, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n                # Covariance Matrix Adaptation for mutation rate tuning\n                mean_solution = np.mean(population, axis=0)\n                deviation = np.std(population, axis=0)\n                self.CMA_eta = np.clip(self.CMA_eta * (1.0 + 0.1 * np.random.randn()), 0.05, 0.3)\n                population += self.CMA_eta * np.random.multivariate_normal(np.zeros(self.dim), np.diag(deviation), self.population_size)\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "Introduce a stochastic rank-based selection in Differential Evolution and employ a covariance matrix adaptation for mutation rate tuning, enhancing convergence.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {}, "mutation_prompt": null}
{"id": "f71889f3-3ed3-4580-93d7-836edde52043", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Gaussian mutation and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation scaling\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    scale_factor = 0.4 + 0.5 * np.random.rand()  # More adaptive scaling\n                    mutant = np.clip(a + scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.8, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer integrating Gaussian mutation with enhanced elitism and adaptive mutation scaling for improved convergence in diverse landscapes.", "configspace": "", "generation": 79, "fitness": 0.3085397873598162, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7168664433501342, 0.7143781764535686, 0.7226951301985407, 0.7067458733731722, 0.6819561401118335, 0.7093841575402221, 0.7060779329404789, 0.7130990584196792, 0.7030075690519377, 0.5096510558066657, 0.5070625597731171, 0.5144105322359769, 0.5246314001170367, 0.5360242381330537, 0.5168269893757551, 0.5249276715669227, 0.5189881118795554, 0.5281766406422397, 0.10679983233207535, 0.10216606427275476, 0.11198991178698503, 0.10465278964801417, 0.14338996994984388, 0.10551928122519838, 0.09735857840773954, 0.11678928340493278, 0.10952148610166146, 0.10348056597895083, 0.08224836302312344, 0.09008588550754881, 0.11619903441281854, 0.12345201217728585, 0.1039435234368451, 0.09361629433725649, 0.1094896421216408, 0.10449437602897182, 0.7728671912469548, 0.8293168292684984, 0.7302980826311514, 0.7501813236903413, 0.7788887184884947, 0.7663235560313013, 0.735702509602925, 0.7616170520304177, 0.7670762657411693, 0.4308286272744568, 0.401365427159625, 0.41983433688507643, 0.39893307526620014, 0.358758471654977, 0.4117367062176839, 0.41240707846923186, 0.41425923248821506, 0.395463272563937, 0.5430735633280941, 0.5730588610608165, 0.5571988534477204, 0.6508421874105083, 0.593781358828795, 0.55178012425605, 0.6247124462546476, 0.6394650975348393, 0.6002782259960876, 0.24237076556702264, 0.20088269525404445, 0.23880562766522218, 0.22496603138893057, 0.21921805204985545, 0.23635868829865125, 0.18565642477216637, 0.28586045453715603, 0.24763591310486854, 0.17311321594444018, 0.2071323331429985, 0.19162624997515476, 0.2662933515422403, 0.30205676872349496, 0.19798844530458948, 0.19786414732874502, 0.19196935165776874, 0.2183955286966256, 0.14011528531848294, 0.14201145167787943, 0.13729649719239678, 0.1487254652330079, 0.14786172805599285, 0.13898641300045766, 0.1361761216942068, 0.21174205059566553, 0.15144140580166476, 0.3168842928905595, 0.3024766375033585, 0.33610869242818164, 0.31991587437122015, 0.2812911299844395, 0.29498154618986383, 0.3695607438463332, 0.32629256797753303, 0.2912111422837945, 0.06650217279488191, 0.05344177530254124, 0.07872619719747964, 0.04286951950102269, 0.10660747847617169, 0.07486837913971445, 0.09950184058888245, 0.0990755918197248, 0.10942267686915763, 0.17868827517856212, 0.1855396384491056, 0.1877002554322107, 0.2003063523757308, 0.21572620720731972, 0.20959115434699793, 0.1621200106103695, 0.19371965184668083, 0.18542225441157367, 0.5307317549535966, 0.5848434892072398, 0.5663074273890858, 0.544016035107532, 0.5393703577327966, 0.5392760655556799, 0.5868413869706967, 0.5334811267475209, 0.5596876769341026, 0.08387173874574239, 0.07361299900545926, 0.08518614231983934, 0.08038665667572242, 0.07182138383196712, 0.10299489179882126, 0.08258147821522066, 0.0857154744294345, 0.07975136656697956, 0.1641639616894055, 0.21176430978488414, 0.17017322870639384, 0.19192495907260854, 0.1613181517541321, 0.1945714124239889, 0.16789364251598893, 0.14817882454147602, 0.14573544906287172, 0.3088173976440519, 0.2888963398025636, 0.30244541823916693, 0.306068735455849, 0.28426376313795343, 0.3223933484982524, 0.32552837359210773, 0.3601083717626481, 0.3155004512203713, 0.21486483098633835, 0.2285983957520491, 0.23266840065822902, 0.22843584291953156, 0.21270032474358402, 0.20464524515253246, 0.2228578333743616, 0.2814247814242241, 0.2733963993042551, 0.17670935689597067, 0.17149733287540025, 0.19500971407265288, 0.20723494473201076, 0.1715175189215744, 0.18156229272749902, 0.18216322860472933, 0.17156603022667827, 0.199886911950371, 0.1803044963465329, 0.2480701236655759, 0.17690049695102095, 0.18748136301408214, 0.3412749685428652, 0.17780542398968568, 0.17479635619343337, 0.1986420564671737, 0.1758209676939848, 0.5935777670579436, 0.6040266829225289, 0.6276027165400344, 0.5970239685559059, 0.19289307069076866, 0.5878570628565352, 0.1793574290072898, 0.5023720638034084, 0.44820593187541247, 0.676912893758713, 0.6002944772323631, 0.5139401462395605, 0.5866835315595025, 0.5476918680047995, 0.4804089386118954, 0.6040113604120954, 0.19691527444612233, 0.5665601157287925, 0.1916945488682259, 0.183930726764036, 0.18710738715923259, 0.19511040413969483, 0.18245997464007246, 0.18519617965979607, 0.20264038622861902, 0.1773033156736752, 0.1884062426014651, 0.06797864511527074, 0.06377974704529876, 0.0651254970050048, 0.071683440068669, 0.07890252913604379, 0.06051609784696976, 0.0645975344449462, 0.061771768772699964, 0.07073754346951477]}, "mutation_prompt": null}
{"id": "f7a86cd8-5a99-4b96-9a78-1d3f4cff3c7a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Simulated Annealing Inspired Search\n                temperature = 1.0\n                cooling_rate = 0.95\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, temperature, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    temperature *= cooling_rate\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with enhanced mutation\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                crossover_rate = 0.7\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = np.clip(a + scale_factor * (b - c), self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "AdaptiveHybridOptimizer", "description": "AdaptiveHybridOptimizer utilizes a blend of Simulated Annealing and modified Differential Evolution for improved convergence and exploration.", "configspace": "", "generation": 80, "fitness": 0.25656658671471294, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.665417966464958, 0.6732981944416008, 0.6530872943161986, 0.6454654418778243, 0.6393356317048137, 0.657642745171804, 0.6493945119036438, 0.6544703884891816, 0.6709949375043234, 0.4378727285444426, 0.44016018308703764, 0.4434607297683024, 0.4369878047472001, 0.44437180353306016, 0.45488105443738835, 0.4649438901603098, 0.45625138217487893, 0.46281960196058713, 0.14009404694348015, 0.13666405225788947, 0.11577278257698109, 0.10607089662953384, 0.14484461864874953, 0.12542868069582014, 0.174548225102916, 0.24682288869101143, 0.12426954826892034, 0.12669846492276415, 0.10366338016702015, 0.09105352729723926, 0.11690891053097552, 0.1388780345059173, 0.10536882584838692, 0.11375920573712939, 0.10464158265161272, 0.10872065459663316, 0.8724808064948902, 0.8573991050376735, 0.9076152201729434, 0.9060495825379047, 0.8348705378103957, 0.8551916418776768, 0.833041311932037, 0.8806313013971501, 0.8183220321558972, 0.30888716801573224, 0.30419621703549515, 0.30049329333618147, 0.3191031545886792, 0.30516428791279326, 0.29601222380398007, 0.32043703401127566, 0.3914486878305986, 0.3425295645325438, 0.4630706901097903, 0.42737218558709267, 0.36727946015808655, 0.48490682632703075, 0.43294160592964925, 0.3914855422916841, 0.45174742233913, 0.5181794625621072, 0.43752028135572607, 0.1559166552019713, 0.17250048023089803, 0.16623149916212954, 0.18494258256533547, 0.18142386569366742, 0.17805497710071927, 0.1611115389205412, 0.1692204520781777, 0.1757427454576267, 0.16280849970360245, 0.14782924881777526, 0.2554870750585526, 0.15493469921480862, 0.16015415120165521, 0.18467024260854492, 0.21300204306361448, 0.16894052164474727, 0.17554882294542473, 0.025258530927956047, 0.028760574626898183, 0.013993060046123773, 0.051506487331916095, 0.017082727586250956, 0.043512937392986006, 0.02984727451994207, 0.038446490121601506, 0.059545175101086034, 0.16050848354613023, 0.13487584740007297, 0.14084611567739158, 0.16058827731580638, 0.20206700087447993, 0.15703280567947164, 0.16954060104670243, 0.16088167921263852, 0.16165918493447007, 0.011874956881118837, 0.010142426286806727, 0.005444157623089474, 0.0015652863785057258, 0.011712266937039972, 0.003428956708391162, 0.011089155317868471, 0.0069795444049990385, 0.020428004754880047, 0.11432745248428533, 0.1085920453483794, 0.11592151338299972, 0.13117890908980168, 0.14027162763855905, 0.14333090158958672, 0.12023005196489867, 0.11829751409086753, 0.13085054555883324, 0.43335955351575084, 0.46229790828700745, 0.46799923085245165, 0.4418439298494977, 0.4561312720705296, 0.4359978950170734, 0.45697754371291044, 0.4305080376482704, 0.4641427660631442, 0.08761386253304004, 0.10869408439506334, 0.07513009939872406, 0.0885782865400393, 0.09666003311755633, 0.07305533239762374, 0.0812864044405629, 0.0954929639996519, 0.08541619862926686, 0.20002602447942652, 0.17085253030293968, 0.18134904887438252, 0.17094614193665947, 0.15186892304053468, 0.1929076713390918, 0.17782784367644822, 0.18474213268026685, 0.19397019820173078, 0.26623857749170066, 0.27869673377866366, 0.2509018446480804, 0.2743308283834066, 0.2555548986810945, 0.29340507432581064, 0.29764563927279186, 0.3126171422966769, 0.2886911547266654, 0.1822362444754153, 0.18650494214270352, 0.23350083700335666, 0.19122583680694882, 0.18675474681543813, 0.16287685403742902, 0.22389494527773945, 0.21406901203627493, 0.18935276609749108, 0.1993880161224464, 0.1681843148276725, 0.2030727944499794, 0.18986709992960749, 0.18557532033253155, 0.18150689327340974, 0.1752237925505351, 0.2030449798248921, 0.18506484233320997, 0.17909831400958243, 0.20093613886350736, 0.2042677967182709, 0.18810197859606392, 0.1959634348195114, 0.18844990000332895, 0.20112310164633573, 0.18479343894429945, 0.18915984525394458, 0.38282826309829887, 0.3724714621050521, 0.23246621235730114, 0.45404050324667533, 0.1864642522841211, 0.5893272729805213, 0.39364096036388196, 0.28712061323728444, 0.3590702017459997, 0.44937322013305847, 0.32366367855121136, 0.3468227673361234, 0.2991179327081871, 0.1970613264626906, 0.2129169101614764, 0.29847449107885027, 0.28940222691947315, 0.20415301198533464, 0.19650466919004106, 0.17915183008696278, 0.1868784294137602, 0.18540998661483288, 0.1881923754057886, 0.18013336729981533, 0.17156025937624908, 0.1904027603402817, 0.18253721116024635, 0.07223487546632024, 0.08298879016783267, 0.0703596580159741, 0.09127690447899806, 0.0629719991055454, 0.07130450891704476, 0.08790698958009757, 0.06083148327595478, 0.06874539397294299]}, "mutation_prompt": null}
{"id": "0746e3e9-f7b4-4867-9388-3f5468a7d951", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Increased population size\n        self.strategy_switch = 0.15  # Earlier switch to DE\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)  # Reduced mutation noise\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with enhanced adaptive mutation\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    scale_factor = 0.4 + 0.5 * np.random.rand()  # More adaptive mutation\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_rate = 0.8 + 0.1 * np.random.randn()  # Dynamic crossover\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedAdaptiveOptimizer", "description": "A hybrid optimizer combining enhanced adaptive mutation strategies with dynamic switch thresholds between Random Search and Differential Evolution for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.28221076452746285, "feedback": "The algorithm EnhancedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6794609628978376, 0.6525508808085114, 0.6678284072697014, 0.6857180911638397, 0.6578275388057312, 0.6563228645388063, 0.6612311929992861, 0.666756904747839, 0.6576179348209155, 0.5224884021158094, 0.49976696327959835, 0.5113629258155716, 0.47368329451075797, 0.5365444854304472, 0.4944721500717978, 0.5221596829968791, 0.5318412595617352, 0.5466089107802614, 0.1236155363558894, 0.11465528925280011, 0.11951556573269717, 0.11020570576207755, 0.08982129185533339, 0.09766327319735923, 0.10688980249455093, 0.11747697670861923, 0.11865538449965518, 0.08468267949653296, 0.08986504889752689, 0.08561479530974447, 0.09928829910988313, 0.1024956143085719, 0.0952891639355461, 0.1114846743546728, 0.10838410261240372, 0.09094796996669918, 0.8036775510112952, 0.8293569732080728, 0.814063423465651, 0.829424961770976, 0.8420359514532347, 0.8169611130571777, 0.8341492225951976, 0.8304029034647025, 0.8365834962930401, 0.34659306072790963, 0.29703262442776546, 0.3318824988047101, 0.35751231028357955, 0.2819732706621053, 0.341561742187932, 0.35502987128826846, 0.35066371699781695, 0.35911875600220566, 0.5779407273541921, 0.49855134847311533, 0.5039265884278796, 0.5986994331368949, 0.5566192267476118, 0.6235494814698617, 0.5913744808981927, 0.5444231691859847, 0.5736137197560571, 0.1906716002399963, 0.1481220090524097, 0.1700158794143466, 0.20358077331541247, 0.20924784548598352, 0.19601695748560855, 0.18864403046853095, 0.1836415975964184, 0.23344982327409958, 0.25204682725839367, 0.1723550928405877, 0.17156295156390367, 0.2886639581636956, 0.2427999875434138, 0.1981268404887302, 0.1848993767112429, 0.23914726885124715, 0.16668093092235847, 0.1386240400594192, 0.12327764841014666, 0.12938360969478713, 0.19890610099209782, 0.14712840529553628, 0.14907736792640403, 0.15125154082897663, 0.151512183880545, 0.1367575000441621, 0.29660959674874565, 0.2310224705886107, 0.26731319011910015, 0.2647512403584805, 0.2711539618293114, 0.2636296525996321, 0.3651039019476917, 0.28589202362448396, 0.27476716521938627, 0.05148598893172007, 0.06809718294962863, 0.03960826847229837, 0.06697901016156449, 0.05913311173804647, 0.061629113519804046, 0.08105222085027453, 0.0676952342831868, 0.07650347875720487, 0.1649507652697565, 0.15540894685508722, 0.17218930287492562, 0.17659653211264326, 0.1988211485000525, 0.17934834144139145, 0.16005386621050188, 0.1542933844666945, 0.1836148463458056, 0.4785538255417201, 0.5117823292969423, 0.5204782827292329, 0.5213106652904593, 0.47555435731349394, 0.4824043400354523, 0.5122111416457198, 0.5104433934261667, 0.5241023469681498, 0.07791450503553099, 0.0852736097675626, 0.08078432046256279, 0.08262110947839352, 0.08490658540018925, 0.08301122788430515, 0.07685542619404173, 0.0810946738280196, 0.09784816709713873, 0.13187027034740062, 0.15587131814399513, 0.15883620937148935, 0.20082054833444285, 0.17813205362022488, 0.14463488763270693, 0.1684202602017334, 0.1423254359673447, 0.1448140692232711, 0.26908469932656764, 0.2866375324739502, 0.28617526854541087, 0.33223655972825294, 0.29789429330702355, 0.29892063696295446, 0.32458337661475956, 0.33471900270784105, 0.33765359336023115, 0.2009920357527042, 0.22317184959374248, 0.2086115162604768, 0.21679195637330995, 0.1790707134462416, 0.20444570132550222, 0.23046381945747696, 0.2529221384465088, 0.21245557251832692, 0.17400290649021866, 0.20471648600082126, 0.18376602096481454, 0.1920768545016075, 0.20024612543792286, 0.18292338365498195, 0.1916524438414382, 0.191620762536714, 0.180991507879379, 0.1837591753380664, 0.17608667293578495, 0.18259600412648547, 0.17538378161616475, 0.15680094920411303, 0.15371396754884248, 0.1736771354488339, 0.17356784481806609, 0.17290185646715783, 0.34967146833611795, 0.4128238846973452, 0.5288862698838863, 0.5616213113592935, 0.1959256634251838, 0.4193275150641016, 0.5688323999228023, 0.3065879169109599, 0.5267681765653108, 0.6557416804556062, 0.19261560625823615, 0.1764856688008558, 0.388978854419613, 0.2664088534975978, 0.32010346613074403, 0.18249846822604554, 0.17783039892889807, 0.1829663325846712, 0.20171652823853237, 0.1838923711333469, 0.17814450040609286, 0.1734224790566935, 0.18685249382418645, 0.1915956223947618, 0.203800747685007, 0.17875435166305143, 0.17165407610523797, 0.06511981308973358, 0.07146389128009889, 0.06542948765475398, 0.06694444962086743, 0.06757811711841455, 0.06768878523107547, 0.06501684385622142, 0.0611289968301324, 0.06224639782431585]}, "mutation_prompt": null}
{"id": "33102340-920a-441a-9984-d1eea7e0b6bc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "299d7268-6f85-41ec-b448-5aaf7b6ee034", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to advanced strategies after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive Covariance Matrix Adaptation\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.multivariate_normal(\n                        mean=np.zeros(self.dim), cov=np.eye(self.dim) * 0.2\n                    )\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n            else:\n                # Strategic Diversity Injection in Differential Evolution\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_rate = 0.8 + 0.1 * np.random.rand()\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "ImprovedHybridOptimizer", "description": "An enhanced hybrid optimization approach incorporating adaptive covariance matrix adaptation and strategic diversity injection for improved convergence speed and robustness.", "configspace": "", "generation": 83, "fitness": 0.32035994060382694, "feedback": "The algorithm ImprovedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.719850144384718, 0.702916656558632, 0.7139555881526691, 0.7169485377878089, 0.6881415059605329, 0.6983158595527861, 0.7199726841591156, 0.7098837544667762, 0.702670295227855, 0.47813190103184056, 0.49884604934071797, 0.49193748231545076, 0.49395238000975583, 0.5049946951239843, 0.4959751603166803, 0.5089026367433489, 0.5025340438426115, 0.5042238222150912, 0.09781708325922378, 0.09105243669850316, 0.10017825078637621, 0.0932066859357974, 0.09153674423025226, 0.1028674184419609, 0.10464650800003217, 0.10761493874116745, 0.09771004452193666, 0.07970984219909916, 0.09864657493584505, 0.07982252978990145, 0.09424206875576768, 0.1099273026924773, 0.1028569600764675, 0.09644094625188904, 0.09283898854142769, 0.10002213011411021, 0.7808372984021603, 0.7846261611505346, 0.7477417120262018, 0.7663281357091569, 0.7682103802082412, 0.7633602785440002, 0.7713353734246439, 0.7642567199621011, 0.7769545217324149, 0.41658127187000693, 0.379224419062124, 0.3823717099518117, 0.39339274101255906, 0.379351352746218, 0.3864534885552886, 0.43186085710566213, 0.3984589115504342, 0.39770888414444094, 0.5736221805291103, 0.6444629498665615, 0.6245761222574033, 0.5919122189385594, 0.6003505497175217, 0.6242403873108076, 0.5892275049142155, 0.5719353754760537, 0.6356034003022029, 0.2582459654381022, 0.3128304216051895, 0.32407942766544506, 0.3132735279178157, 0.3221887625796783, 0.2526292916736568, 0.3299693439363356, 0.2793737788688958, 0.24696931817133094, 0.2737542626913859, 0.2621184792948196, 0.2450426809322953, 0.22090008562304553, 0.28205234334792406, 0.25481843153893613, 0.31387726003878036, 0.2676660018457595, 0.30233727471004923, 0.23900454253228232, 0.19833155761881827, 0.2089790085089176, 0.2046268551500826, 0.21052646100278594, 0.22666637288251346, 0.19049906650385384, 0.18956523624326005, 0.19905466059101873, 0.3134495561577122, 0.3185605148937354, 0.3520057943248266, 0.3687588232797949, 0.3256037070286195, 0.31216641146340407, 0.37927649835942456, 0.32481993421836897, 0.3771215556186709, 0.06180792932747203, 0.05963995937133093, 0.11714913497293433, 0.0693229943628072, 0.1436223013749781, 0.11458768549284082, 0.1262676640310385, 0.08015539137133987, 0.0784910457196093, 0.1894947684045858, 0.1932051082840912, 0.20415431724681965, 0.2352017906452798, 0.22369006072356767, 0.1995635941257916, 0.1859417046004498, 0.1985798141442362, 0.19925245175759598, 0.5694390712581117, 0.574549674995758, 0.585829886165524, 0.6006118216649807, 0.5655562502004566, 0.5643905904910872, 0.5960665312261957, 0.5795672794977922, 0.6101760472724345, 0.08345177536940407, 0.07306098972529618, 0.08236809877555828, 0.09208858004166287, 0.07722629312691676, 0.08605415290515162, 0.0793068249142147, 0.08382101755879734, 0.08092878002963366, 0.1641075990928763, 0.1563735622563488, 0.14958740697098605, 0.14577090977675433, 0.15431145000797775, 0.17679649055789692, 0.15947460194434848, 0.16952217816047654, 0.13925494856553944, 0.30278755723368633, 0.311225133779913, 0.28677617061438565, 0.3007774630098383, 0.2837419423496982, 0.2851298886202187, 0.2986683127661528, 0.35460884415324967, 0.3165490360678155, 0.20897313735827228, 0.20947009142950035, 0.20137930352552091, 0.22049161526685035, 0.22133422278027626, 0.21406691288660618, 0.24514050047946523, 0.2421728699525234, 0.22566324911954538, 0.18827908186945064, 0.17174785234045498, 0.18491594397237743, 0.17713632695320325, 0.18116784258308982, 0.18302940739310392, 0.17305871347874868, 0.1880583173876429, 0.18289564782258216, 0.18905118562555834, 0.17459919507348676, 0.18843262814660688, 0.18276624354201132, 0.18155200642686697, 0.19073986445323232, 0.17634598383911815, 0.19188526098074732, 0.1931568423263874, 0.508146523304871, 0.625706780954257, 0.6536571064304015, 0.5647388340178936, 0.4110192722762418, 0.5841356098611908, 0.5444610144493749, 0.4874845773612425, 0.654363201308696, 0.6845995968294467, 0.5796592501809934, 0.6027386045635212, 0.5792820456952537, 0.6113016871206949, 0.5561259996886796, 0.5382844542030591, 0.5041452661880446, 0.5833137876712365, 0.1697840754492692, 0.19048000267703769, 0.18254726788998765, 0.18669143384928233, 0.1767838418972717, 0.18503569130615882, 0.17752519418597856, 0.17940663826318637, 0.21345566424055729, 0.06759021100058149, 0.06220243949272097, 0.06647137738370679, 0.06864473674110849, 0.06487810202206656, 0.06313984131767869, 0.07032041498624131, 0.0755970517485699, 0.07701567786240338]}, "mutation_prompt": null}
{"id": "880f5dfc-d9bd-42eb-a657-dc88ea7eecac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "9f694918-f370-45a0-8fa3-9b4a294f7dcf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "39be71eb-718d-456a-b8f3-ca8cdea06b51", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedPSOHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.3  # Switch to PSO after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Particle Swarm Optimization\n                w, c1, c2 = 0.5, 1.5, 1.5\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    velocities[i] = w * velocities[i] + c1 * r1 * (personal_best[i] - population[i]) + c2 * r2 * (best_solution - population[i])\n                    population[i] += velocities[i]\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                    \n                    fitness[i] = func(population[i])\n                    evals += 1\n                    if fitness[i] < personal_best_fitness[i]:\n                        personal_best[i] = population[i].copy()\n                        personal_best_fitness[i] = fitness[i]\n                        if fitness[i] < best_fitness:\n                            best_fitness = fitness[i]\n                            best_solution = personal_best[i].copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedPSOHybridOptimizer", "description": "Integration of Particle Swarm Optimization with adaptive parameters for enhanced convergence speed.", "configspace": "", "generation": 86, "fitness": 0.27272173221369733, "feedback": "The algorithm EnhancedPSOHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.696588359506245, 0.6675013820047699, 0.6999337481276802, 0.7088764807087895, 0.6830766585915116, 0.6833405741559873, 0.6934362918607452, 0.6971459842388152, 0.6796476135091771, 0.5286123312287814, 0.5550953175112509, 0.5660423593650861, 0.5604300534825373, 0.5596654546209702, 0.5527896298206594, 0.5651824199424442, 0.5725029616782054, 0.5528123534617486, 0.13624762033330629, 0.1002577354547084, 0.12006952052542907, 0.13662743060378724, 0.10205916046549024, 0.10489143926698785, 0.08580197745704021, 0.09120450480227826, 0.132990637271043, 0.10823775102265665, 0.06831583628819371, 0.0629895898986832, 0.08500010516001111, 0.07470526478921546, 0.0930102320366315, 0.10825794748586182, 0.04249743883914103, 0.10195901345360925, 0.7186404376912319, 0.8174928484488997, 0.7166323449821983, 0.7105252264401698, 0.7115512203684083, 0.7152191426063139, 0.7214070683206272, 0.7168014500522853, 0.7110038466862625, 0.6076610742363725, 0.5900911329189644, 0.5529559590480689, 0.606461291210658, 0.5653725712662891, 0.584690992101497, 0.5687389759862614, 0.5610126765417656, 0.5326999014113525, 0.198633064023495, 0.2972646843205714, 0.15668646437346068, 0.2606404011022687, 0.1168314271804245, 0.14186277067444353, 0.10774450404870717, 0.2681841966722307, 0.18686176387441578, 0.2062609755085414, 0.13494295485690733, 0.16815078182824306, 0.18327414472334513, 0.18664836510192762, 0.1671873406557043, 0.17827616264749702, 0.1461982733782481, 0.17107250254384287, 0.19679333577548264, 0.01305832131882012, 0.09786017146942416, 0.19327012849928937, 0.1945905085498344, 0.19067215067868126, 0.21474718862291853, 0.0663864493453108, 0.12958359327298696, 9.999999999998899e-05, 0.03964183138363564, 0.0009635647954113757, 0.05809940309882711, 0.041012400350047606, 0.005532906383367453, 0.050405931554910466, 9.999999999998899e-05, 0.05964112176232772, 0.1122448804437034, 0.07925633867339077, 0.0872956898902707, 0.06935221158947935, 0.08263707321116631, 0.16232903814306465, 0.2512611399932727, 0.09900053480394744, 0.06949014106726104, 0.03604584467548244, 0.12405809298387527, 0.19356193551501732, 0.23778736777468779, 0.2109888781953655, 0.06437263048067454, 0.12873482218086596, 0.13034208610282216, 0.052260824144846785, 0.13619459257600453, 0.13777956549782466, 0.1396004356664804, 0.004749943749280838, 0.04576242592325175, 0.06196967847127288, 0.1150314864585873, 0.24445230976417454, 0.06892591923866731, 0.4211097365134344, 0.444279693840155, 0.4722585573925018, 0.45962148483252274, 0.4569844205641962, 0.45605928142462004, 0.49846825300469666, 0.431337850723427, 0.4510552086885181, 0.0758282922816712, 0.08319728735257936, 0.07095380335149348, 0.07164410111359554, 0.062119998927565256, 0.07966727369862492, 0.04254884841798989, 0.07094708547302164, 0.07938445135449435, 0.17858308399681355, 0.1784101929168581, 0.22667870435478454, 0.2507493655371472, 0.3199977042522937, 0.15801528136701104, 0.26877375532176406, 0.23523542479630255, 0.1856634145617998, 0.22366901294741504, 0.15380507273587085, 0.42765861161582974, 0.24453838256040572, 0.3548671163532444, 0.21297788880995772, 0.3757019495300682, 0.34895106199443593, 0.36551674515143695, 0.19266379805026335, 0.09451279379837685, 0.20671302431541294, 0.15595052994403324, 0.13486091132938105, 0.26366754548569804, 0.19700858589957992, 0.23888514785029813, 0.1872307074727233, 0.17631128132261675, 0.13552118941765834, 0.20044712041703516, 0.24189726751239282, 0.1735780449389347, 0.1883654096503803, 0.19040476845544163, 0.1722009525068272, 0.21652103044184767, 0.1667913248696452, 0.15791080077586828, 0.20189775274379984, 0.178710306369247, 0.1426835772263063, 0.1772908633171819, 0.17015194343860307, 0.20173624536309775, 0.18728218285019826, 0.6992522694610395, 0.196025596887625, 0.726196847552436, 0.7068659498680675, 0.19731346657810978, 0.7175129578647785, 0.17185599019181041, 0.7151603680458535, 0.7047506521342475, 0.6078299332195083, 0.6483644444601051, 0.5131169919455782, 0.611259176361705, 0.18535277998001098, 0.1865804020260169, 0.6176805133835229, 0.649007311356027, 0.6186446733325689, 0.18897632328581826, 0.19387911692796245, 0.1962388098009159, 0.19748245713567636, 0.20910129941349198, 0.19473253649280153, 0.19503874163425738, 0.22092748890901226, 0.2090756427577275, 0.05686406400865529, 0.0645957682258762, 0.059379533631574444, 0.052564365333260143, 0.0688802804714127, 0.07702449657606392, 0.06061550850772923, 0.07303848706931693, 0.0668283989292735]}, "mutation_prompt": null}
{"id": "d35d1c4a-9c1d-4ce4-8a8c-3c40fcf24f27", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "18550994-c2c1-4e54-b96a-e3cae92dc023", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "ac762e8a-3a1f-4ba0-9264-f7ebc63a21e6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "979a1d62-068d-4b31-84f4-7d1cdd912107", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, max(5, budget // 15))  # Adjusted for smaller initial size with budget\n        self.strategy_switch = 0.3  # Switch to Differential Evolution after 30% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with adaptive local search\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.1 + 0.1 * np.random.rand(), self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and crossover\n                scale_factor = 0.4 + 0.2 * np.random.rand()\n                crossover_rate = 0.8 + 0.1 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer integrating adaptive local search step and dynamic population size adjustment for faster convergence.", "configspace": "", "generation": 90, "fitness": 0.3134085643294482, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.69614507227248, 0.6525831772597035, 0.6761277790106127, 0.6725439557322397, 0.6593552550876928, 0.6859423932762762, 0.6688551182061032, 0.6700327795706813, 0.6558903199956905, 0.5261516960710861, 0.5284719036489238, 0.5231483365699328, 0.5159368452975576, 0.5189839641372209, 0.5162290030643886, 0.5231965171953398, 0.5258961811727657, 0.5225219464099056, 0.09792713079606197, 0.09067006815081291, 0.13128291784487844, 0.10250707247434332, 0.09320457776854418, 0.18595288158285506, 0.12447582447415295, 0.1794499848288328, 0.09323155201597177, 0.1008504446402152, 0.08670108748550387, 0.08672241915685519, 0.11564566394287268, 0.08294172367888308, 0.070377856630787, 0.1140173160337763, 0.09311254105075606, 0.08756631726975539, 0.7382429433753007, 0.819596925271421, 0.7481831421426924, 0.6651724844350242, 0.7450227074478137, 0.7299269557385728, 0.7049900730676567, 0.6917299762705247, 0.6374719104611604, 0.3081674307270449, 0.4508735200625704, 0.3525048856330594, 0.46794350833849996, 0.43322095080061007, 0.44300913327836366, 0.43814006230229197, 0.4007848784376894, 0.3499974561050503, 0.6117809951317115, 0.6026652195216222, 0.5559654788420001, 0.6294000082449928, 0.5921954067272968, 0.54145645639034, 0.1975396813096627, 0.5934600261914222, 0.5825908349839388, 0.2020904198539618, 0.189556514816965, 0.19119430971490647, 0.1603909208515768, 0.13105626403188375, 0.16742677220113056, 0.1384859792545582, 0.13657395210642698, 0.16869114430252286, 0.20426480094507693, 0.13997136406465638, 0.3205689189526487, 0.17250887301980877, 0.1080089085522763, 0.11517923899559301, 0.21579297989590052, 0.1709719138433633, 0.16456043031755885, 0.34655798903881097, 0.24454386554263685, 0.21947161163462248, 0.13163536222012084, 0.33161879631329083, 0.26033257753940764, 0.24380869545963169, 0.14046120506781934, 0.32775776395591816, 0.4645672137166429, 0.4439050646953323, 0.44665794827405636, 0.15615418773518108, 0.4303107916490564, 0.41233471037834046, 0.5086101463412882, 0.45660701644116497, 0.39807368853014113, 0.12896092958531247, 0.12356536917797678, 0.18950303522538214, 0.1818266467518479, 0.19313287204840301, 0.1309491105823325, 0.12370224297969867, 0.1778986423620903, 0.11063554612465287, 0.26645130729500965, 0.24015674286477784, 0.25840943900460167, 0.1960125666498127, 0.23597038124098113, 0.27290792863939106, 0.18593526563470597, 0.22503617922160513, 0.25914545775149445, 0.5963147570963032, 0.6061971428173847, 0.6383200883240749, 0.5546685899355415, 0.5577827740651962, 0.5254510045768364, 0.6366742741982478, 0.5726728449451757, 0.604941359237739, 0.0952521920063144, 0.07892055396807496, 0.07555966136009962, 0.0837648262372046, 0.08316420344933906, 0.07919276934132069, 0.0711459581427587, 0.07118302843094448, 0.08534032938622726, 0.21503831464055234, 0.15093550730744354, 0.1535340685512372, 0.2111358236333012, 0.20893580701110492, 0.17397673170526706, 0.21002749071246296, 0.13759156030348152, 0.19470975451207662, 0.31340920213005397, 0.3495576856781404, 0.3256382973457176, 0.3583342055067178, 0.3579513829560308, 0.33640255822262777, 0.38980697064578085, 0.42610719893222604, 0.3593890216760991, 0.22996894597242368, 0.24792911542095264, 0.24048097667242696, 0.2627855733794864, 0.23835728502010645, 0.22369845845149716, 0.29204034590310446, 0.32122847394028375, 0.26477043349808016, 0.18237491855161703, 0.1522873180051092, 0.18392513636820296, 0.19566879255884495, 0.16989649104283966, 0.1786921901129983, 0.17127657769133298, 0.16884292273132773, 0.19652666205037272, 0.20285910582839006, 0.2346320696128048, 0.16628526552503242, 0.1975652700328545, 0.2776943775892866, 0.38636778975397656, 0.19471800604838896, 0.19050991326960065, 0.15422401438333277, 0.5073725668725568, 0.5182574005740651, 0.6830728797583788, 0.6170410330823595, 0.19954862372645632, 0.5823867356644135, 0.17825407684198125, 0.4632804405701566, 0.46058336773871167, 0.6031789785685979, 0.6078295630007744, 0.43778358356565894, 0.5266708509103123, 0.4758409225524076, 0.17489184043694805, 0.6196442086024079, 0.35836371541513967, 0.30477516734317445, 0.19923324472212522, 0.18079134091611304, 0.19102767463834203, 0.1780295505061682, 0.18536358966802402, 0.19163138858112194, 0.1801979654750192, 0.20598246608802684, 0.19338709878282634, 0.06409526534410503, 0.06303125705338009, 0.07716077486338113, 0.06674757164400347, 0.061100036465083774, 0.06689702522007135, 0.06378477055561982, 0.06450251530777928, 0.06229135726419466]}, "mutation_prompt": null}
{"id": "578c55e1-6ca3-4ab4-8e97-4ee3cc32a5af", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "5dc7dbce-49c6-4768-a896-f9a30d89d53d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizerPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.initial_population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        population_size = self.initial_population_size\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Simulated Annealing and elitism\n                temperature = max(0.01, 1.0 - evals / (self.strategy_switch * self.budget))\n                for i in range(population_size):\n                    candidate = population[i] + np.random.normal(0, 0.3 * temperature, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i] or np.exp((fitness[i] - candidate_fitness) / temperature) > np.random.rand():\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and population resizing\n                scale_factor = 0.4 + 0.5 * np.random.rand()\n                new_population_size = max(10, population_size - int(0.05 * population_size))\n                new_population = []\n                for i in range(new_population_size):\n                    a, b, c = population[np.random.choice(population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i % population_size])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i % population_size]:\n                        new_population.append(trial)\n                    else:\n                        new_population.append(population[i % population_size])\n                    if evals >= self.budget:\n                        break\n                population = np.array(new_population)\n                fitness = np.apply_along_axis(func, 1, population)\n                population_size = new_population_size\n                idx = np.argmin(fitness)\n                if fitness[idx] < best_fitness:\n                    best_fitness = fitness[idx]\n                    best_solution = population[idx].copy()\n\n        return best_solution", "name": "EnhancedHybridOptimizerPlus", "description": "EnhancedHybridOptimizerPlus leverages simulated annealing and adaptive population resizing for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.2557423432586982, "feedback": "The algorithm EnhancedHybridOptimizerPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.5990852116130363, 0.5335966654909856, 0.6130332426441356, 0.6139253257992384, 0.5833320151216708, 0.5920136835003311, 0.5710496199499264, 0.5884698333340352, 0.5848679623734008, 0.3893373436991555, 0.42596095192922634, 0.38038897707202113, 0.3844187451661595, 0.4085424681697458, 0.41198120072120514, 0.3911033260707465, 0.4039209980112257, 0.39241247826974457, 0.08753618920674511, 0.08309175737035512, 0.08836369585704706, 0.10037413325741729, 0.0823348464001199, 0.0910382515359397, 0.0853180804578233, 0.11445325257205985, 0.09128355719686954, 0.073979079542004, 0.09032663544074915, 0.08389694529813807, 0.09781913575872259, 0.08987277816662331, 0.0909623672710268, 0.07493472560437098, 0.07320827748599479, 0.07922668986640224, 0.7203601108411263, 0.819596925271421, 0.7086736913048507, 0.7375650263481888, 0.6924862349434658, 0.7226107338893375, 0.6995759476215712, 0.7057317653604576, 0.7234214047054051, 0.28531628722949776, 0.26129870298684543, 0.25340197632464145, 0.3236947897841256, 0.2618630158981964, 0.2763142672916957, 0.2960560663702916, 0.2596153067569137, 0.28855410152684013, 0.2152531234737135, 0.47075769543534507, 0.4568331081300889, 0.5367862116744098, 0.47368446522414265, 0.4495360560189985, 0.5467164006953568, 0.47196377936402245, 0.5327817346590273, 0.29034314281245854, 0.1481427312640775, 0.15437043047724452, 0.12040399668387347, 0.17361508163232975, 0.12936106070103104, 0.19008665302348404, 0.1502651144753998, 0.1484528125813871, 0.11599643073270072, 0.16297979859206502, 0.17429191343315598, 0.18708118223596215, 0.19908518759458904, 0.1725960690778775, 0.12631022434091788, 0.1624830788063577, 0.14713122294205183, 0.1374501681311351, 0.17191385699111994, 0.1463925683444064, 0.0699687046779891, 0.149244850434458, 0.11613954326610443, 0.14040425224369413, 0.13419911830147468, 0.15759848856155168, 0.29797459640161683, 0.2517094774716958, 0.35813226610095894, 0.271258912052718, 0.27889962413130176, 0.31593102894997616, 0.32254678527349756, 0.3404967932239771, 0.2766445488581969, 0.05322495359508217, 0.04985152111349922, 0.059827514068760856, 0.06194447032766004, 0.07924854069601628, 0.08407254932528063, 0.061748730686912445, 0.04223473893300944, 0.04769628250675073, 0.165940675052768, 0.1470505632939939, 0.1499016078015828, 0.14818190899231543, 0.13281196949558638, 0.15829388702373837, 0.12949309322286295, 0.1738868758229064, 0.16085883442510807, 0.46678738920417195, 0.48433899858345064, 0.4591334787897605, 0.4624943017714849, 0.4260230240938456, 0.4765793045317238, 0.44709529584987207, 0.47410013226175773, 0.4696951480616651, 0.09170288847127228, 0.06681622992654501, 0.07313337115379437, 0.07704277981159924, 0.07468429911310737, 0.07834857395898764, 0.08458372129817582, 0.058709299382247226, 0.08128645661217215, 0.16463324213423403, 0.20532353446628626, 0.20830052686430411, 0.19026071514133414, 0.19665360991724867, 0.2427047594722177, 0.16851406574462102, 0.23641862943096303, 0.17094811764933926, 0.26018560562810433, 0.24705312598991047, 0.2507788381209868, 0.2851963411816826, 0.25654881127157403, 0.25803340006620246, 0.2809430142333077, 0.30375777639625257, 0.283369404412956, 0.18550680046316748, 0.2121412296473938, 0.18330112692748712, 0.18628702210536674, 0.18315006249292654, 0.2009715837404018, 0.18860557441147052, 0.22363583035671308, 0.24480812162933363, 0.16809501466486798, 0.1559640800508676, 0.1873641469742251, 0.19795890812737416, 0.16422681735409295, 0.17031519838094467, 0.16917764948435365, 0.1643369509332937, 0.18202276378490145, 0.18439281656418272, 0.17053330281812673, 0.16831809246961515, 0.19022036428347588, 0.1736276892302382, 0.16979578560203867, 0.21011028672085286, 0.19459885671616184, 0.23424982270823802, 0.1761388572582775, 0.5341887552442965, 0.5866260664124849, 0.616134358543158, 0.2865011421621916, 0.59151359608784, 0.18275549811288272, 0.36828725891174485, 0.21879813688114058, 0.3567577289994962, 0.41089682759538815, 0.34663878900008227, 0.17960219709705072, 0.21736504692941572, 0.23321785238616788, 0.21651060791272692, 0.37578490465291825, 0.4970815283303871, 0.18789035222082195, 0.18819160398411117, 0.17810074075673388, 0.19087137775056795, 0.18534877617924417, 0.20305594468365085, 0.20528542440271136, 0.19339321798978104, 0.21394390174246258, 0.05698532261641287, 0.057741816168151106, 0.062452408446408314, 0.062204728435991785, 0.06042166580532571, 0.06153156890448097, 0.061632750368378564, 0.056737117785712665, 0.06178435591990272]}, "mutation_prompt": null}
{"id": "f1e0981a-884d-4867-be4e-577f1c98280d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n        self.pso_steps = 5  # New: Number of PSO quick steps\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n\n                # New: Particle Swarm Optimization quick steps\n                if evals + self.pso_steps <= self.budget:\n                    velocity = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n                    for _ in range(self.pso_steps):\n                        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                        for i in range(self.population_size):\n                            velocity[i] = 0.5 * velocity[i] + \\\n                                          r1 * (population[best_idx] - population[i]) + \\\n                                          r2 * (best_solution - population[i])\n                            population[i] += velocity[i]\n                            population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                            pso_fitness = func(population[i])\n                            evals += 1\n                            if pso_fitness < fitness[i]:\n                                fitness[i] = pso_fitness\n                                if pso_fitness < best_fitness:\n                                    best_fitness = pso_fitness\n                                    best_solution = population[i].copy()\n                            if evals >= self.budget:\n                                break\n\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "Integrates a local search strategy using Particle Swarm Optimization quick steps to enhance convergence speed by rapidly exploiting known good regions.", "configspace": "", "generation": 93, "fitness": 0.2904814002701519, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.8213861716136115, 0.4779887971171244, 0.814801383116549, 0.8134671078699267, 0.7463395506408451, 0.8235902717429349, 0.7741420497251004, 0.7860900791179336, 0.8304707019197209, 0.38851293573043433, 0.02084993042923866, 0.47988560231237865, 0.6206500701379473, 0.03702188139475404, 0.523318667762777, 0.5206188587385702, 0.5039049332961419, 0.48947968736630754, 0.06284398689599524, 0.0926390405514621, 0.08951637465174023, 0.10557133272880126, 0.04670294291158883, 0.03832236158250657, 0.051637394011791016, 0.09943229716729352, 0.05071820151594131, 0.020235097142185077, 0.04397212244198323, 0.05145515890765129, 0.07458437574945875, 0.04061354984912846, 0.043222381934713505, 0.05796529270134909, 0.04600863157707058, 0.0030131257757293195, 0.9833501313247606, 0.9900665447839688, 0.989661892325456, 0.96378224728491, 0.9865711148820896, 0.9838311751385732, 0.98286926203155, 0.9852408316708757, 0.9862775091404454, 0.6298631936390984, 0.30484880537607983, 0.6438777152493642, 0.6024677438881167, 0.6480325016790739, 0.594853120348658, 0.610686250239922, 0.5882713452376491, 0.6410092142512138, 0.16773011131291127, 0.08247923815987701, 0.21924597531355083, 0.21282640540339492, 0.1762052194271302, 0.15013848239560956, 0.09267430532240939, 0.10112162534359082, 0.05812330059586779, 0.3355983419650983, 0.27629023570974764, 0.3026260315535648, 0.28974015598431246, 0.4863537335695278, 9.999999999998899e-05, 0.3384585700955951, 0.11469346375420175, 0.45633725490258026, 0.13242352790405476, 0.12026672848810427, 0.33183633119916556, 0.4347105562597572, 0.11840143209654741, 0.41471840037453456, 0.27899634737752177, 0.11342298834127285, 0.16941049756146698, 9.999999999998899e-05, 9.999999999998899e-05, 0.3508424728098243, 0.27105937481011777, 0.08875075409394739, 0.23854919921652262, 0.27667026980097775, 0.2605680766444277, 0.11422245905272121, 0.29888286625817495, 0.05403781241641736, 0.18404113652759202, 0.2875716083430756, 0.08143688711550001, 0.15520650981356499, 0.5260992738543638, 0.42723533854678675, 0.14575498468342374, 0.04185534865700824, 0.04282336868753622, 0.06551998840098694, 0.07063279584982973, 0.1674087705507552, 0.18506886518931998, 0.10936811038299288, 0.0621727824372188, 0.07955888571650771, 0.37603132949732576, 0.2196961572568954, 0.26977184926223363, 0.0064310731164967105, 0.23017046045277278, 0.3382968118969968, 0.34752944843199296, 0.3083396993221399, 0.37922480800655234, 0.7255009356680506, 0.4254388658735738, 0.7564725093669231, 0.7239274884214321, 0.7374781275880544, 0.7373349178896719, 0.7564391127138734, 0.685778308265411, 0.7346743463134005, 0.06998110092699661, 0.055351114811450164, 0.04720938549768594, 0.13155705332851286, 0.11637612821234067, 0.09728758415379057, 0.04820151562624286, 0.0926200839397443, 0.10460642542623022, 0.27982319979034753, 0.17167410163418695, 0.2330395646537542, 0.6842838166207355, 0.2861824974176127, 0.18687321401677837, 0.6256373474842377, 0.16019383744359872, 0.22993657259293976, 0.48389701963330967, 0.22649778012204924, 0.29965945341985, 0.22101197901062797, 0.1294679437000903, 0.18666047858625257, 0.2289420316801558, 0.29666336075345456, 0.19023468824449696, 0.0565764719643852, 0.04094719507488376, 0.13905357953683906, 0.10351959286142609, 0.23945616534634295, 0.23142761212980945, 0.16219897747224565, 0.16300718216067966, 0.18128910944403476, 0.20711124067513897, 0.1333697824581055, 0.202605276081122, 0.16250058024501213, 0.12625193204593566, 0.20325668166128497, 0.18709167123322912, 0.14432964822443095, 0.18755242873093592, 0.18802295257292068, 0.1698405750375589, 0.18052976074250293, 0.16928003486166654, 0.1747421774249689, 0.19938252326857442, 0.17848323658575205, 0.17837775284362156, 0.2078214764574956, 0.1258115744835101, 0.1269641163363402, 0.15341433285610895, 0.1720339076702454, 0.20157960060754254, 0.1992247895148438, 0.09993054401656642, 0.16975439106155132, 0.21266001696807046, 0.8461400767952986, 0.15683069723420762, 0.7215076021225468, 0.10502686039783116, 0.16747587706769695, 0.21049276009449402, 0.09361659439616665, 0.10464748950997405, 0.7128854967673641, 0.19502600371029943, 0.249671711023134, 0.21583272264572806, 0.20619210747946715, 0.2085121005611562, 0.26784604688870717, 0.2821117245998407, 0.30091080025098293, 0.3755902191093191, 0.09241170744518201, 0.08379021653940677, 0.07272675850061372, 0.059426045362442115, 0.053358352713382184, 0.06060920107308443, 0.05566663037861286, 0.030983852198681383, 0.025888237868759045]}, "mutation_prompt": null}
{"id": "48b1bf67-4df2-46f7-a3d5-6fd73468f293", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "ac80218f-7ee1-46fb-884d-4aae0f46748f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, budget // 8)  # Increased population size\n        self.strategy_switch = 0.3  # Switch to new strategy after 30% of budget\n\n    def adaptive_random_search(self, func, population, fitness, evals):\n        for i in range(self.population_size):\n            candidate = population[i] + np.random.normal(0, 0.3, self.dim)  # Adjusted variance\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_fitness = func(candidate)\n            evals += 1\n            if candidate_fitness < fitness[i]:\n                population[i] = candidate\n                fitness[i] = candidate_fitness\n        return evals\n\n    def cma_strategy(self, func, best_solution, evals):\n        if evals + self.dim + 1 <= self.budget:\n            result = minimize(func, best_solution, method='Powell', options={'maxfev': self.dim + 1})  # Changed to Powell\n            evals += result.nfev\n        return evals, result\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Adaptive Random Search with elitism\n                evals = self.adaptive_random_search(func, population, fitness, evals)\n                if evals >= self.budget:\n                    break\n                evals, result = self.cma_strategy(func, best_solution, evals)\n                if result.fun < best_fitness:\n                    best_fitness = result.fun\n                    best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation and crossover\n                scale_factor = 0.6 + 0.2 * np.random.rand()  # Slight adjustment\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])  # Adjusted crossover rate\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A refined hybrid optimizer blending adaptive random search and covariance matrix adaptation for efficient convergence.", "configspace": "", "generation": 95, "fitness": 0.2465304242147248, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6169142084784529, 0.6168450140205659, 0.6130031930396171, 0.5841570634510453, 0.5805356375886463, 0.5792932239152877, 0.5911734973963207, 0.5735600954219624, 0.5944518855781362, 0.36579721855021996, 0.3487119158529195, 0.3547898465982724, 0.32915605089805433, 0.32249818664788865, 0.3733031904879882, 0.3433719929356476, 0.34043014832863305, 0.34164579806780726, 0.09155181838596183, 0.08100034642966547, 0.08139133731510706, 0.08411736039443307, 0.0761596736154877, 0.07764712146392305, 0.09155771059423845, 0.08357894327862303, 0.09068173555037884, 0.08908977459162815, 0.07161059336924513, 0.06978108713576603, 0.08859174389381075, 0.06580063782052004, 0.07364847059152657, 0.08712984561843151, 0.07437147328787252, 0.07978104777159023, 0.709681334390317, 0.7169680178625055, 0.7165950900485036, 0.6163975945247138, 0.6773008988056897, 0.7062344201105439, 0.6827456553173836, 0.7099817893764591, 0.7165270040188114, 0.2998582027353679, 0.26297165600727446, 0.25429870589090164, 0.28585415761353083, 0.27749346611631553, 0.26650788642501644, 0.2823523562137452, 0.2752032248071291, 0.2666413008080548, 0.4984161905092471, 0.48219817427004874, 0.43016225403649144, 0.5158481152091636, 0.4933769768828876, 0.4658640417325902, 0.42586611662173324, 0.4963468092191089, 0.485148385007125, 0.18335008687306986, 0.15578717373766726, 0.18479958004825825, 0.1682622641953272, 0.1636900129623775, 0.19318187149552446, 0.1975406097867275, 0.1712195924941312, 0.1904440274715976, 0.2017349056381239, 0.17411014741290165, 0.1891608504819483, 0.1738005297420797, 0.2417002067537033, 0.17452322457926983, 0.23420628080905503, 0.17104566081175765, 0.1747739788931405, 0.0876686885867417, 0.09749637404332767, 0.0804251247069937, 0.09372296345660902, 0.09838934509300545, 0.0886892355593889, 0.11260368307286595, 0.10932942215426178, 0.09630206896701077, 0.22520617770963947, 0.22764943870071264, 0.2620105048523893, 0.21275022650937614, 0.22978949760459422, 0.24910556105552284, 0.252968089221173, 0.24227637645282307, 0.2583966101439138, 0.04260849033704783, 0.031264241815521565, 0.018288795406570024, 0.03829289132982616, 0.05157388416344344, 0.031958514348599976, 0.05100585953366443, 0.043370733997549205, 0.011476785153256008, 0.11962236878324461, 0.11552497904282555, 0.13156136783306105, 0.1320718265403359, 0.12571725639308862, 0.14487025028565403, 0.12025534081674816, 0.13439854632823622, 0.12461283062928485, 0.45852316436612983, 0.4611086381820464, 0.4801751737734523, 0.45262556420456135, 0.4215694390700868, 0.4266418151863963, 0.4796795671443217, 0.46062142671642936, 0.4828888472525963, 0.06678042824815233, 0.06854715659345456, 0.08361532220742629, 0.07067006626916772, 0.06680090104706382, 0.09794663940165227, 0.06741214010003982, 0.06676287547541582, 0.06983932159638695, 0.15891809895842268, 0.1930652835375174, 0.1770113588938046, 0.17177941841959543, 0.13335459865868593, 0.21751342641409654, 0.1739558540314602, 0.1430183328948269, 0.14593258420936783, 0.22124600848100962, 0.23811209932190158, 0.2315496811524319, 0.255230711306196, 0.24101228008990927, 0.24891341151161017, 0.25544488971724266, 0.28305320222355035, 0.24561305447663506, 0.16529436118086416, 0.17553456934832157, 0.1760921575838723, 0.17223285336273897, 0.16065318451381405, 0.1782475282122319, 0.20339621852065393, 0.21147524163047238, 0.17488748668661536, 0.17092110187565013, 0.1559373870316051, 0.1590372568917996, 0.18678309849502417, 0.1755525675553017, 0.18103455630857657, 0.18995240622474374, 0.16240326189850984, 0.1693586572863336, 0.1688331741369279, 0.17986833156687787, 0.17359943587783577, 0.17767808687589115, 0.1672028876394237, 0.1887684522226869, 0.17314697690977643, 0.1734726957025554, 0.16816629157786778, 0.47503430767056387, 0.276134545281554, 0.4432734104671654, 0.5212292375798078, 0.19332412194748538, 0.45632184582101887, 0.420993149458878, 0.24669808663208248, 0.4845262246075379, 0.510347017821366, 0.457184244809999, 0.18054681300485076, 0.287559723247677, 0.2581981151923305, 0.4591737462516917, 0.4444433866975688, 0.36978170500188745, 0.4678856945695171, 0.19384620005692543, 0.19549246291235978, 0.18589473930602707, 0.17692952458915823, 0.18269041426717192, 0.18590185735318743, 0.19314443571131656, 0.19721997990108364, 0.19416030046639954, 0.06705360617820111, 0.06307849596163728, 0.06471288927513086, 0.06886502062940458, 0.06433265927718912, 0.05032810902924034, 0.06165772565760019, 0.05657451862761487, 0.05901623912661125]}, "mutation_prompt": null}
{"id": "731cbca0-f45c-4ed3-85f5-b31efc92e632", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "8002e6bb-dca7-4281-944a-9411cfea8bb2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedDynamicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.25  # Switch to Differential Evolution after 25% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with localized neighborhood search\n                for i in range(self.population_size):\n                    neighbor_radius = 0.1 * np.random.rand(self.dim)\n                    candidate = population[i] + np.random.normal(0, neighbor_radius, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive population scaling\n                scale_factor = 0.6 + 0.2 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedDynamicOptimizer", "description": "A hybrid optimization approach enhancing convergence by integrating a dynamic neighborhood search and adaptive population scaling within Differential Evolution.", "configspace": "", "generation": 97, "fitness": 0.271776836846825, "feedback": "The algorithm EnhancedDynamicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.19.", "error": "", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.6222275626129662, 0.6037361602260484, 0.6134156266178357, 0.6171320263551658, 0.6136938507646108, 0.6176563586373456, 0.592968807443703, 0.6154559329946043, 0.6031664847238287, 0.47684670925272055, 0.4673397014615366, 0.4836887063996027, 0.45203039489693375, 0.4639722165775062, 0.44884013819482804, 0.4559432666840849, 0.46103070426484916, 0.4898256454529937, 0.08233215752977574, 0.10320868033115438, 0.08615664843258197, 0.0878663044420126, 0.07616882768660904, 0.07997936038818099, 0.07575990237992669, 0.08876646742274263, 0.08810584371280639, 0.08426847646551738, 0.08298469648086337, 0.06725128455958529, 0.09024812321356401, 0.08660694103098432, 0.08424094388069536, 0.06577722945673592, 0.08062964536724282, 0.08210535929441498, 0.7405456926786597, 0.8204595968079929, 0.7288426803992731, 0.7296454639589387, 0.7451233741933598, 0.7343917358694024, 0.7287874382574515, 0.7437677293531588, 0.7193056076725679, 0.32312748097994237, 0.30277485903069434, 0.3215687575068711, 0.32280289115743, 0.2936645144385992, 0.38505796809268256, 0.31654715519077603, 0.34965417336250315, 0.3342478270839143, 0.4959634901449189, 0.5398200635623567, 0.4615068838883959, 0.5474912093593823, 0.540267095269982, 0.5613362287240798, 0.48065876924743434, 0.5098632267201973, 0.5505655233113442, 0.20546029997948634, 0.18738578701155206, 0.2668316653449321, 0.2700036152500753, 0.21797428890750126, 0.21773925900681157, 0.21286755443984207, 0.2307688776597011, 0.26467884344551285, 0.20164251683039724, 0.12640655762061093, 0.12552294701466127, 0.1791668346447579, 0.17564925668877063, 0.26422937894581955, 0.18249036189480095, 0.22109596317171576, 0.18625649260633004, 0.15191649868501333, 0.15500565913845443, 0.1439121690335372, 0.17208488205604977, 0.14326105949525736, 0.12394756343885471, 0.15181163321291768, 0.1320264304586748, 0.16565596758695922, 0.29670700291011554, 0.28524143588819717, 0.2828570733286647, 0.31523193057334975, 0.26860697317783666, 0.27157563570637977, 0.40077213974839376, 0.3218590665077914, 0.2893570726611622, 0.04487353818831796, 0.05763639402118115, 0.06700319120407272, 0.08281818702311283, 0.06995221931139495, 0.0609588595705971, 0.08159233709347502, 0.08636518161683782, 0.07994086288121327, 0.15988751686341696, 0.17014488255537652, 0.17255223670507625, 0.17702857016496631, 0.15844939072559083, 0.20405711520994751, 0.17520230509584778, 0.1787008227725443, 0.1771374535951118, 0.49635036316291614, 0.5147899737079257, 0.5239563485141577, 0.47321032788240147, 0.4680670817476731, 0.46722692447691383, 0.5054049573356258, 0.477517892351052, 0.5060331360679923, 0.08240087125087825, 0.07098236532888391, 0.06850467841326935, 0.06861219949410102, 0.06340481783031648, 0.08636927208561707, 0.06235698835281778, 0.07955098479160061, 0.0837383730621174, 0.1393342551373098, 0.1593674083105754, 0.14179650527578358, 0.21439151128155198, 0.17700003676409337, 0.14862864291208677, 0.2139854604136171, 0.1300456509661524, 0.1358934659861678, 0.27799916641078726, 0.27912928673286497, 0.28351076084040217, 0.2650549427986031, 0.24970687345127407, 0.27023573869778716, 0.32422924848063783, 0.30023520277950055, 0.3079007482065689, 0.2145563857902385, 0.16560054472827124, 0.206380809594487, 0.20073894432970207, 0.19211037119671937, 0.21386328646873798, 0.22828622759916006, 0.2134803653295696, 0.21007961872993097, 0.17755678065535518, 0.1569552086270467, 0.18063591343425867, 0.18171427670612206, 0.17070168049539902, 0.17403008772958506, 0.17072628418987879, 0.1569758569255082, 0.1727763064155341, 0.16455434338377783, 0.15508196374474714, 0.15326320230246293, 0.1612129098882269, 0.15256102269575345, 0.16145953704941018, 0.19318532146186795, 0.1400288704918694, 0.18837889136291774, 0.5369449264827348, 0.6120354799070993, 0.5099031624226611, 0.6016629552249401, 0.3784345694816924, 0.43247251935767994, 0.16028272545269395, 0.49575816461510014, 0.5967052608513788, 0.6071064919615341, 0.18677878468716302, 0.1751543932917532, 0.4142376621826559, 0.16946092323120154, 0.23364830328283415, 0.43470401905043077, 0.16520378470854136, 0.1776551367981447, 0.17607657649528285, 0.18304555325607685, 0.20571530248532421, 0.21744352656990107, 0.17654489572830045, 0.19578560011824298, 0.19681491155174657, 0.18960359285726425, 0.19793236260528868, 0.059385823620245914, 0.059991354282245446, 0.07290176705535556, 0.06959757694774193, 0.06333227346884995, 0.06343467168135286, 0.06904521254844387, 0.05816706347041112, 0.05549557798548499]}, "mutation_prompt": null}
{"id": "a7df1637-f75a-4a7d-86eb-ee1d08d5c6cf", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
{"id": "3fe17e92-9387-48a9-86a2-2fd15c43dd4b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(30, budget // 10)\n        self.strategy_switch = 0.2  # Switch to Differential Evolution after 20% of budget\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            if evals < self.strategy_switch * self.budget:\n                # Random Search with Nelder-Mead and elitism\n                for i in range(self.population_size):\n                    candidate = population[i] + np.random.normal(0, 0.2, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < best_fitness:\n                            best_fitness = candidate_fitness\n                            best_solution = candidate.copy()\n                    if evals >= self.budget:\n                        break\n                if evals + self.dim + 1 <= self.budget:\n                    result = minimize(func, best_solution, method='Nelder-Mead', options={'maxfev': self.dim + 1})\n                    evals += result.nfev\n                    if result.fun < best_fitness:\n                        best_fitness = result.fun\n                        best_solution = result.x\n            else:\n                # Differential Evolution with adaptive mutation\n                scale_factor = 0.5 + 0.3 * np.random.rand()\n                for i in range(self.population_size):\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = a + scale_factor * (b - c)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n                    trial_fitness = func(trial)\n                    evals += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_fitness = trial_fitness\n                            best_solution = trial.copy()\n                    if evals >= self.budget:\n                        break\n\n        return best_solution", "name": "EnhancedHybridOptimizer", "description": "A hybrid optimization approach combining Random Search with Nelder-Mead, introducing adaptive mutation in Differential Evolution for better convergence.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "28550123-fcd5-4b69-90e7-1bb1b2c0ca07", "metadata": {"aucs": [0.7307423523916328, 0.6852083693154469, 0.7221055350147526, 0.7234776493344128, 0.693796479648024, 0.7068961486720222, 0.7071570354267604, 0.7110761782758472, 0.7035622606457246, 0.5654138843525691, 0.5512615147867503, 0.5634363802582555, 0.5552733232391585, 0.552911966374484, 0.5496952711996723, 0.5682616629474584, 0.5554560054211427, 0.571346492565197, 0.10119341126373982, 0.09199359554293274, 0.08502841758056134, 0.1013875692684576, 0.10645817339108765, 0.0880070801899252, 0.08767671996134507, 0.08241889443218331, 0.09389355423303536, 0.09002543184301193, 0.0985218561608483, 0.11131115435900008, 0.10188615318911598, 0.09626370777963023, 0.07407804413403951, 0.08925424346462918, 0.07902551642856193, 0.09653996544674315, 0.7601627857760023, 0.8196695465331416, 0.7746813255173169, 0.7674612321753846, 0.7515465912531305, 0.8057794659162012, 0.7643989689372592, 0.7758870411774418, 0.7918883112945463, 0.42243726725839426, 0.41810665434078187, 0.43629474304738225, 0.4463878800932711, 0.398309501169375, 0.46576633598488715, 0.42723870742543946, 0.4708657789946169, 0.4659645704301547, 0.7020585467312944, 0.6572667509610435, 0.6069102717384984, 0.674023214531092, 0.6277109765884319, 0.5970335302355991, 0.6624812278690504, 0.6442000313392694, 0.6401781268048576, 0.23544088133740637, 0.3467595961623481, 0.26823234456493994, 0.34189345427312934, 0.2699102745515405, 0.3631478138260965, 0.2693793205526731, 0.39683646184849075, 0.3599344109265682, 0.3599456549914688, 0.23943436419951714, 0.22203863938340063, 0.4007290563499012, 0.31718022545586333, 0.33832342203350096, 0.3823603457398739, 0.3037724779263995, 0.3184013916518227, 0.36761022260136944, 0.3862415446049985, 0.3571613915774553, 0.36181077559532826, 0.37391622317087003, 0.33391155571735975, 0.3616895338627858, 0.3895992234407788, 0.35041354633037447, 0.5231355166516856, 0.49114398004890825, 0.47469978578925576, 0.5123327682004568, 0.52508542167802, 0.5208361670088713, 0.5334938840569281, 0.570980314530797, 0.5115776319664467, 0.11846588988858908, 0.1146745613795831, 0.09458259371065048, 0.23648564967345187, 0.20574844403265313, 0.2509713741627677, 0.12260706730275384, 0.14426434137040456, 0.08900344538080385, 0.27639993217085335, 0.2822007617518615, 0.28466871173021935, 0.2865120122482323, 0.28184251600061416, 0.31680328704082517, 0.2848164310953879, 0.26936554116506173, 0.25700797686462595, 0.6245652101137095, 0.6420811711521148, 0.643000741388138, 0.629400678486395, 0.5833518229035948, 0.5976578636251512, 0.6618141002967655, 0.5886969479961353, 0.6389757899257512, 0.07642784937834513, 0.08741750651061808, 0.0710040936805042, 0.08885970459871728, 0.07819846404118658, 0.0942004960727918, 0.08544003179229454, 0.08074423426145239, 0.10530936494811216, 0.16883974408399993, 0.1910920958254957, 0.17200417831692905, 0.19193515750521228, 0.18732934685409464, 0.17557699417157435, 0.19176748970099067, 0.14637803104829417, 0.15517439141331402, 0.3420570935463786, 0.35728180476040783, 0.3332366809537223, 0.33746684678340666, 0.31146956718698027, 0.3214632618628751, 0.3633116856701434, 0.40820088865965576, 0.34810380474403835, 0.2447081345796539, 0.2582070875647303, 0.27193129335790633, 0.2636078110131478, 0.2782201614492874, 0.24198640949347128, 0.2746360100029168, 0.3234964084127331, 0.2677458965459102, 0.19146028956662453, 0.17229379340665796, 0.20108041587470393, 0.1908729836118519, 0.17034055005412974, 0.1734260141964723, 0.18159514520997466, 0.1808239025068311, 0.19068922425870594, 0.20114680029505072, 0.40388412208516655, 0.18127363324890278, 0.4377736835224023, 0.1855654786858616, 0.26416212763502744, 0.19710221430819064, 0.29547136549245734, 0.19545867784098936, 0.62621472301732, 0.6801653863422414, 0.6689342091432651, 0.6694217487569363, 0.19922948498099335, 0.6075379394834338, 0.17745433389622445, 0.6364420546245676, 0.4808161262467544, 0.7005477112007384, 0.6221782158945869, 0.6068439142934181, 0.642278211985043, 0.1595960886114377, 0.19434760074003843, 0.6208300142437444, 0.6382645292167519, 0.6865533460291879, 0.1941003642728174, 0.18128142921772905, 0.19269032450080426, 0.186438480636824, 0.17319119319084475, 0.18228655910728764, 0.1954977245736803, 0.18364061796634545, 0.1791927152537237, 0.06810092020203462, 0.06555629644935868, 0.06675713131747996, 0.07405066239746227, 0.08697725951638458, 0.06493651455671356, 0.07362553716165932, 0.07469202869329472, 0.06574747948223025]}, "mutation_prompt": null}
