{"id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 0, "fitness": 0.23902346376588893, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "734f428a-9c8e-435b-b1b9-00a525bd460e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n\n        # Adaptive inertia weight\n        progress = self.evaluations / self.budget\n        self.inertia_weight = 0.9 - (0.5 * progress)\n\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n            # Adaptive DE mutation factor\n            self.f = 0.4 + 0.3 * progress\n\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by adaptive inertia and DE mutation scaling based on evaluation progress.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'progress' is not defined\").", "error": "NameError(\"name 'progress' is not defined\")", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {}, "mutation_prompt": null}
{"id": "e99482b2-47ec-43fb-9872-2965e8c05c3c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        self.inertia_weight *= 0.99  # Added adaptive inertia weight decay\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A refined HybridPSO_DE algorithm with adaptive inertia weight for enhanced exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.23569306434267304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.62477214594475, 0.6188015362221368, 0.608719954945681, 0.6547050527493758, 0.6364292597536519, 0.6422619665076451, 0.6542713332908525, 0.6340276759279377, 0.5809129479814295, 0.3061692491401934, 0.30037473175753826, 0.3088203914371396, 0.32810862963557086, 0.3337600661917727, 0.0362633758888955, 0.0362186643893645, 0.28172968442704904, 0.2669576458354388, 0.13242481045287313, 0.1326107556748104, 0.12375599515551894, 0.13424809777273017, 0.12036754219457835, 0.10780796322421682, 0.10064650966002697, 0.1390045209871198, 0.12946092258854447, 0.09719879918049268, 0.10922524159990754, 0.09743799118431018, 0.11436728029791388, 0.09553207688907805, 0.0968598630623223, 0.09853708947307527, 0.09619910779384244, 0.10708111063976389, 0.9830921521377634, 0.9769090147442534, 0.9771283867584529, 0.9683921170809892, 0.9686460773654966, 0.9743410040840276, 0.9825439383996223, 0.9756568910050764, 0.976480525449321, 0.4043427611788728, 0.41561751691162596, 0.05737951348792558, 0.37650221617146806, 0.14108043927329617, 0.3600894700426266, 0.08096331051777084, 0.08803581465201638, 0.08331600905552006, 0.5828258394578145, 0.2139243884319676, 0.1683086779235411, 0.19934333476706134, 0.3416463280067379, 0.18818393461539895, 0.5036473301344001, 0.12422322458289359, 0.553787248532431, 0.15006535921256214, 0.15792660875381848, 0.16342117011235147, 0.09341680072112302, 0.10725782685642882, 0.10784558189173876, 0.16026262017016468, 0.1527956256984513, 0.16000358370366352, 0.15576432038806198, 0.15626034066310235, 0.15855257060478656, 0.12886455874982183, 0.10823546162463915, 0.15138443582395744, 0.1788622365712923, 0.0895164047323237, 0.17836516685646142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026796427854294036, 9.999999999998899e-05, 0.04957788131320884, 0.06313337111802919, 0.031053543804431705, 0.08872570083838205, 0.07895784721635013, 9.999999999998899e-05, 0.030910047366451754, 0.06147443897004068, 0.08328572195738249, 0.08078815045234311, 0.01852138211381449, 9.999999999998899e-05, 0.0785727509655384, 0.05070200758132537, 0.04681753293476654, 0.0478523242339961, 0.1977642260582344, 0.11294262691560286, 0.06356969651232613, 0.1619265271688748, 9.999999999998899e-05, 0.0392422330416593, 0.09116972537336665, 0.034051205630356574, 0.004709918524726131, 0.04710787254328663, 0.1482481061651919, 0.0661056721833354, 0.44079246587553633, 0.44549060427051823, 0.4349409208077816, 0.44115040768251734, 0.4368177859740717, 0.20550687574944004, 0.4629769441627245, 0.4348787464386872, 0.4529858575682748, 0.07244412804578915, 0.08853510094952222, 0.10602912376072304, 0.11804084918041302, 0.11214545374706664, 0.11359337260422653, 0.10754587523199899, 0.10145862284583274, 0.12546031503437693, 0.23724453982832394, 0.1713162816571837, 0.16845990426420687, 0.21921379030620258, 0.35777084449778185, 0.1646870057599764, 0.1817236953360366, 0.20965656603822858, 0.24311453159486407, 0.33839592830934995, 0.358890139298048, 0.2831550605538068, 0.2052349478522788, 0.18894093078158092, 0.3344525823353328, 0.36680240124149843, 0.35510521152293184, 0.3653918338244533, 0.23904990617326127, 0.16398705911660272, 0.24096041082635344, 0.18264917504706335, 0.29374324422541953, 0.19418716012366888, 0.2919464642799031, 0.2273146757319543, 0.23331510474943085, 0.24188059695859976, 0.2109169087953594, 0.1856307093706404, 0.19519432219539434, 0.20838184746635102, 0.18563722863004373, 0.19883629263984715, 0.195538070231293, 0.22916066853769645, 0.2854607962938569, 0.19703277999593738, 0.21553439715534306, 0.18914153164479408, 0.18411011786897113, 0.36913472438612693, 0.2059594093128283, 0.2038457391788212, 0.2265929605512026, 0.16131195040275326, 0.16625737285857378, 0.15237342347051852, 0.7207171999097723, 0.19401468145399048, 0.19135412350021275, 0.13846309348733976, 0.16363859026681182, 0.19947642447395209, 0.6313666184334108, 0.20501404630553888, 0.47481393200986965, 0.43230021182329026, 0.5312147369422957, 0.1659155884980068, 0.19040803823667807, 0.20247263583508113, 0.20698818842255873, 0.2030754180049008, 0.19579730833650733, 0.184829502032562, 0.18293018842778697, 0.17659454882946735, 0.1887189527378177, 0.1954095467017234, 0.17857339742516654, 0.195612380289517, 0.07671338846491249, 0.08297733355279002, 0.07955294706271487, 0.07125431441651908, 0.07636456240355005, 0.0823130522689095, 0.09138992794005607, 0.08405769534472807, 0.07365956443075661]}, "mutation_prompt": null}
{"id": "b970a00b-e30a-4d8c-8b0f-c9ddfe529e0b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "8d198f43-b5a6-4e18-9a1a-ecfb00fdeff1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "fa5aed14-2894-4138-a36d-e48a49b70713", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "d1cd2303-b923-496b-b65b-f5f16b9148b1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.8  # Changed from 0.5 to 0.8\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploration-exploitation by adapting inertia weight and employing a more aggressive DE mutation strategy.", "configspace": "", "generation": 6, "fitness": 0.16025460989716353, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.28411092822785455, 0.2990486206970959, 0.28393899354294694, 0.3676402933952557, 0.31650696586422933, 0.3107932994046524, 0.3201105199779666, 0.3158418485170249, 0.33533439058114667, 9.999999999998899e-05, 0.01087606544311126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028338747548305454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0712499672082153, 0.07577935894554322, 0.06534719636076314, 0.07098914575782544, 0.06835330452436905, 0.08051339506245836, 0.07522806296908313, 0.06684866339249207, 0.08294679220623435, 0.054406874577720865, 0.053439143119748955, 0.06919514684430195, 0.07349874029067083, 0.07389334969127614, 0.0681881641284865, 0.06348364646081628, 0.09905120963652791, 0.059156354716202064, 0.9830920549165649, 0.9770463886709845, 0.9771436214958489, 0.9769965635505269, 0.9686790616998823, 0.9688532941882023, 0.9825092683173117, 0.9762500107140096, 0.973956031034553, 0.1576920525604495, 0.1424077233476233, 0.13487834624060324, 0.1341977821662167, 0.14022152421390344, 0.16113485016571416, 0.10943653551233512, 0.08706514506951024, 0.11981183803686324, 0.20015797224825904, 0.1595853525594122, 0.21733672022605832, 0.18750804004093635, 0.18423869296674733, 0.17705251613952966, 0.14883846579504356, 0.22713566401478724, 0.16112099806591473, 0.09662184631104864, 0.024686695373343892, 0.07021577378322308, 0.06456436337641447, 0.10238939523920776, 0.04322978596748128, 0.09314362224076411, 0.07268745488566708, 0.13846968562677064, 0.09675020611382534, 0.031209670695650282, 0.0762799208963777, 0.09020778227241211, 0.05653362193906064, 0.07447025107078609, 0.11635307751558444, 0.011455856081935223, 0.05547665274042979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014922349159058879, 0.02272550917688787, 0.07420309641876865, 0.02739660499606411, 0.007312653058584195, 0.031907098178224236, 0.0176607479749209, 0.0373894425092105, 0.013432870760565874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036432221381691665, 0.015785842234226743, 0.04186975795661163, 0.053548131731474546, 0.061204126946327264, 0.058661604774536524, 0.0375738963805301, 0.03569495136646039, 0.04787348367508626, 0.27035572933955243, 0.3061589563598808, 0.30363449965238776, 0.28205369544276204, 0.2955987990271376, 0.20401468974994996, 0.2706895955181775, 0.27527679079834666, 0.3146100410169197, 0.06407129942688716, 0.05080955743725446, 0.0727112379557906, 0.07885395908614279, 0.07186073593648834, 0.0716868593388823, 0.06655196803250107, 0.059002206838799975, 0.07818558806143572, 0.15413982790809277, 0.14925296160635804, 0.19030491086872336, 0.17078067971184085, 0.15229115505363877, 0.13413493909488639, 0.14391202293611238, 0.1506482321871352, 0.13958991525402398, 0.20479446192109485, 0.1951625369918335, 0.22307710792674018, 0.20748271650886474, 0.21563962462746844, 0.2150093768601049, 0.2216161218336382, 0.22476395557351736, 0.20932198385573475, 0.17561289531360058, 0.13976567656165428, 0.16946925167737759, 0.1222808604966723, 0.1564043870619285, 0.13712679131057937, 0.17421601895475702, 0.17231636756576807, 0.17240119966295642, 0.2379568450537909, 0.16673829885045, 0.1764075174492853, 0.18930534573822866, 0.17678755139351543, 0.1699764284671773, 0.1665590350622046, 0.18252945943727394, 0.18096416120876624, 0.16746069408899078, 0.1719580841045799, 0.16832807793527904, 0.17950722317798196, 0.17441615605076244, 0.16434316421302664, 0.16054011999917717, 0.16602285217686052, 0.16698438408651273, 0.35353022854684646, 0.1643790415291564, 0.15209155934544016, 0.3371864062293142, 0.19283724684441805, 0.1762661265729486, 0.15741897046700903, 0.16840757746358448, 0.18104375365016923, 0.21562095809385395, 0.19073789488008908, 0.2755704167025387, 0.1742762224966149, 0.20710145830050075, 0.11029504225616749, 0.19429588852157353, 0.19641783508065414, 0.1506559683309786, 0.1828594071975923, 0.1886190685708916, 0.18139765633793048, 0.18956945987649665, 0.17753704479119192, 0.19311150646598652, 0.199386579205853, 0.18979926368297173, 0.18402563780771297, 0.06028060845714078, 0.07128491662204872, 0.09156143081821233, 0.05950792239577418, 0.06373468169017016, 0.06985700244469895, 0.06145988136749181, 0.059305408011233185, 0.06334719882794593]}, "mutation_prompt": null}
{"id": "0afbffb6-2632-4e2f-8834-0c8ed96fdf49", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight_max = 0.9  # Updated for dynamic control\n        self.inertia_weight_min = 0.4  # Updated for dynamic control\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        # Dynamic inertia weight based on evaluations\n        inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (self.evaluations / self.budget)\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance the exploitation capability by dynamically adjusting the inertia weight in the PSO component.", "configspace": "", "generation": 7, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "6590c41f-1291-4c38-9c7d-3ff94730df47", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "3719728b-d828-4349-9d23-746920126045", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "ce14ecfa-0469-42fb-9fd4-de303ca0c355", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Initialize with a higher inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.inertia_weight = 0.9 - (0.5 * (self.evaluations / self.budget))  # Adaptive inertia weight\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight in PSO to enhance exploration and exploitation balance over iterations.", "configspace": "", "generation": 10, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "6e1fd140-641e-43fa-91d0-fbedeaf1f81f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        progress = self.evaluations / self.budget  # Change 1\n        self.inertia_weight = 0.9 - 0.4 * progress  # Change 2\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance the balance between exploration and exploitation by adjusting the inertia weight dynamically based on evaluation progress.", "configspace": "", "generation": 11, "fitness": 0.2074225297040595, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.4993229808883224, 0.46855704024201417, 0.48707754991548524, 0.5309468995185873, 0.5239107748015892, 0.5253921053906339, 0.5222714449386507, 0.47847554512431556, 0.3840852503268296, 0.1526235209756025, 0.12234220548646169, 0.09696077793118896, 0.14426824955063078, 0.15561920779990435, 0.12073345252494927, 9.999999999998899e-05, 0.03247287195698756, 0.025820632847020852, 0.09156302835871188, 0.11173000775362052, 0.12287830038997694, 0.11888088366753258, 0.11986648543873091, 0.108385752623255, 0.12116326532920962, 0.11821002745101528, 0.09708341823014421, 0.07906471733876574, 0.0828020058920319, 0.08779732372816562, 0.09261563719028054, 0.09994982674388742, 0.07164040110006031, 0.09655660591161397, 0.1400549335738993, 0.09635912957254389, 0.9830922049369839, 0.9769086069214031, 0.9771306797683567, 0.9683952958338765, 0.9686679606849622, 0.9743449387429463, 0.9825443318490981, 0.9756575356414081, 0.9764822069864371, 0.32213075387600876, 0.2818763440739155, 0.057033683982503525, 0.22573329504061945, 0.1367437450385769, 0.2502370692304632, 0.08072591115754857, 0.2043836304106914, 0.08328920274843055, 0.42561184323574275, 0.39106224714254656, 0.16811330483369724, 0.1910940054015473, 0.397391570682885, 0.18318044399769984, 0.3466116320247573, 0.3344259715736875, 0.3832274464574795, 0.13202063589930402, 0.10248943657493614, 0.14131777144310165, 0.09352669765467925, 0.1064120491100623, 0.1298626853001218, 0.12778980116788685, 0.13737655396735482, 0.13202532724258254, 0.15196166664936916, 0.1291184684085016, 0.12510055710254475, 0.11629823010833495, 0.10026645968000225, 0.1027607736149424, 0.12631208819783135, 0.10480893230088628, 0.15586546308815397, 0.00785828060270799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05022330440277323, 0.03212558958560041, 0.03478253508303952, 0.039734413025644066, 0.009626907061169865, 0.09969458733080028, 0.056798752391822194, 9.999999999998899e-05, 0.01040959163014521, 0.03428490379435356, 0.06500075813434036, 0.04885459919209445, 9.999999999998899e-05, 9.999999999998899e-05, 0.07546853036279699, 0.029911452301755515, 0.03453392890111118, 0.028309389589753153, 0.09177476082152114, 0.03332822796357582, 0.054591220798682505, 0.11510569305145091, 9.999999999998899e-05, 0.04593452554175148, 0.07878609033660955, 0.13699064235490221, 0.004668865606540784, 0.11190657162047024, 0.10019345706121963, 0.06275544543289269, 0.39915743062159137, 0.40695058024218167, 0.38361494998857204, 0.3971690667835823, 0.3996517253885067, 0.3567746348005115, 0.3855025573261809, 0.3814005670143311, 0.408254633062191, 0.068358196159513, 0.11392958978125112, 0.11795284631530101, 0.0948862310209988, 0.0856949807098305, 0.10692218966488376, 0.10841431455202677, 0.09029515550184808, 0.09921635068880497, 0.22449026060820132, 0.17420467930951777, 0.22260356265440728, 0.33151488304647236, 0.15903819843846045, 0.21082972285318058, 0.16298201154657344, 0.20094306908993853, 0.19326430053913513, 0.2946561460051751, 0.26770995683878174, 0.29184689630426874, 0.27182869379876395, 0.19035405751151768, 0.281257904617507, 0.2976760902458484, 0.2804601320714609, 0.28770577340813686, 0.21000765035456903, 0.15179490927473616, 0.2168677549335566, 0.14480998998461259, 0.232397946886443, 0.18102871401914855, 0.22055235236417225, 0.20419884812716893, 0.21576136490154063, 0.2062266304111512, 0.1858818807658411, 0.17245582294120054, 0.17908205634853624, 0.18232129470377778, 0.19581395575720872, 0.1965771418512915, 0.20096532566409697, 0.18137893176914, 0.19907661806489652, 0.19287836188980867, 0.18886093390585945, 0.2547672595562368, 0.19578909463621919, 0.1831024351185757, 0.20933760176998661, 0.20193814699590962, 0.17680456947395284, 0.16134996731886864, 0.166314977348354, 0.15276745496765487, 0.6250492616776882, 0.19337136197375082, 0.18827390567252, 0.1379188499929962, 0.16398222505925064, 0.20017125999111662, 0.33901393588057893, 0.1979898219539088, 0.4583883324765602, 0.3525047022590324, 0.21756230045895764, 0.1648320106088519, 0.18908329578526184, 0.20122067207626215, 0.2015345559128474, 0.1791858380707383, 0.18121094507730273, 0.20668287543424202, 0.17413076910414071, 0.17637531820644958, 0.17942159316940487, 0.18084378790010014, 0.17815165950866108, 0.18954004721576556, 0.07269388708042512, 0.08434026899092406, 0.08462346611750104, 0.07317456538938805, 0.07366094082735986, 0.07871065235690533, 0.09715118371592157, 0.0894481958963681, 0.08085685534468634]}, "mutation_prompt": null}
{"id": "ab0ab5b4-babf-47a0-bdc5-0ffd84a5c138", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "9a7779b5-ff4a-4cce-b0fe-0decaa3dd46a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Change 1: Modified initial inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        self.inertia_weight *= 0.99  # Change 2: Apply decay to inertia weight\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Improved inertia weight decay strategy variant for better balance between exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.23569306434267304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.62477214594475, 0.6188015362221368, 0.608719954945681, 0.6547050527493758, 0.6364292597536519, 0.6422619665076451, 0.6542713332908525, 0.6340276759279377, 0.5809129479814295, 0.3061692491401934, 0.30037473175753826, 0.3088203914371396, 0.32810862963557086, 0.3337600661917727, 0.0362633758888955, 0.0362186643893645, 0.28172968442704904, 0.2669576458354388, 0.13242481045287313, 0.1326107556748104, 0.12375599515551894, 0.13424809777273017, 0.12036754219457835, 0.10780796322421682, 0.10064650966002697, 0.1390045209871198, 0.12946092258854447, 0.09719879918049268, 0.10922524159990754, 0.09743799118431018, 0.11436728029791388, 0.09553207688907805, 0.0968598630623223, 0.09853708947307527, 0.09619910779384244, 0.10708111063976389, 0.9830921521377634, 0.9769090147442534, 0.9771283867584529, 0.9683921170809892, 0.9686460773654966, 0.9743410040840276, 0.9825439383996223, 0.9756568910050764, 0.976480525449321, 0.4043427611788728, 0.41561751691162596, 0.05737951348792558, 0.37650221617146806, 0.14108043927329617, 0.3600894700426266, 0.08096331051777084, 0.08803581465201638, 0.08331600905552006, 0.5828258394578145, 0.2139243884319676, 0.1683086779235411, 0.19934333476706134, 0.3416463280067379, 0.18818393461539895, 0.5036473301344001, 0.12422322458289359, 0.553787248532431, 0.15006535921256214, 0.15792660875381848, 0.16342117011235147, 0.09341680072112302, 0.10725782685642882, 0.10784558189173876, 0.16026262017016468, 0.1527956256984513, 0.16000358370366352, 0.15576432038806198, 0.15626034066310235, 0.15855257060478656, 0.12886455874982183, 0.10823546162463915, 0.15138443582395744, 0.1788622365712923, 0.0895164047323237, 0.17836516685646142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026796427854294036, 9.999999999998899e-05, 0.04957788131320884, 0.06313337111802919, 0.031053543804431705, 0.08872570083838205, 0.07895784721635013, 9.999999999998899e-05, 0.030910047366451754, 0.06147443897004068, 0.08328572195738249, 0.08078815045234311, 0.01852138211381449, 9.999999999998899e-05, 0.0785727509655384, 0.05070200758132537, 0.04681753293476654, 0.0478523242339961, 0.1977642260582344, 0.11294262691560286, 0.06356969651232613, 0.1619265271688748, 9.999999999998899e-05, 0.0392422330416593, 0.09116972537336665, 0.034051205630356574, 0.004709918524726131, 0.04710787254328663, 0.1482481061651919, 0.0661056721833354, 0.44079246587553633, 0.44549060427051823, 0.4349409208077816, 0.44115040768251734, 0.4368177859740717, 0.20550687574944004, 0.4629769441627245, 0.4348787464386872, 0.4529858575682748, 0.07244412804578915, 0.08853510094952222, 0.10602912376072304, 0.11804084918041302, 0.11214545374706664, 0.11359337260422653, 0.10754587523199899, 0.10145862284583274, 0.12546031503437693, 0.23724453982832394, 0.1713162816571837, 0.16845990426420687, 0.21921379030620258, 0.35777084449778185, 0.1646870057599764, 0.1817236953360366, 0.20965656603822858, 0.24311453159486407, 0.33839592830934995, 0.358890139298048, 0.2831550605538068, 0.2052349478522788, 0.18894093078158092, 0.3344525823353328, 0.36680240124149843, 0.35510521152293184, 0.3653918338244533, 0.23904990617326127, 0.16398705911660272, 0.24096041082635344, 0.18264917504706335, 0.29374324422541953, 0.19418716012366888, 0.2919464642799031, 0.2273146757319543, 0.23331510474943085, 0.24188059695859976, 0.2109169087953594, 0.1856307093706404, 0.19519432219539434, 0.20838184746635102, 0.18563722863004373, 0.19883629263984715, 0.195538070231293, 0.22916066853769645, 0.2854607962938569, 0.19703277999593738, 0.21553439715534306, 0.18914153164479408, 0.18411011786897113, 0.36913472438612693, 0.2059594093128283, 0.2038457391788212, 0.2265929605512026, 0.16131195040275326, 0.16625737285857378, 0.15237342347051852, 0.7207171999097723, 0.19401468145399048, 0.19135412350021275, 0.13846309348733976, 0.16363859026681182, 0.19947642447395209, 0.6313666184334108, 0.20501404630553888, 0.47481393200986965, 0.43230021182329026, 0.5312147369422957, 0.1659155884980068, 0.19040803823667807, 0.20247263583508113, 0.20698818842255873, 0.2030754180049008, 0.19579730833650733, 0.184829502032562, 0.18293018842778697, 0.17659454882946735, 0.1887189527378177, 0.1954095467017234, 0.17857339742516654, 0.195612380289517, 0.07671338846491249, 0.08297733355279002, 0.07955294706271487, 0.07125431441651908, 0.07636456240355005, 0.0823130522689095, 0.09138992794005607, 0.08405769534472807, 0.07365956443075661]}, "mutation_prompt": null}
{"id": "6c813a13-9d62-4c75-a516-b105c4608ad5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "fd8e1eaa-5017-488c-827c-7269655bf87c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "e739aa15-90e7-4210-9a74-a32d1eff1239", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "8481393e-48cf-46d5-a170-9af5fd86cd2a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        inertia_weight = 0.9 - (0.9 - 0.4) * (self.evaluations / self.budget)  # Dynamic inertia weight\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce dynamic adjustment of inertia weight to improve convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "bb555810-366a-4847-afee-e053dc6b5cfc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Adjusted inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        eval_ratio = self.evaluations / self.budget\n        self.inertia_weight = 0.9 - eval_ratio * 0.5  # Dynamic inertia weight\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            self.f = 0.5 + 0.4 * eval_ratio  # Dynamic mutation factor\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhanced inertia weight adjustment and mutation factor adaptation based on evaluation ratio for improved balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'eval_ratio' is not defined\").", "error": "NameError(\"name 'eval_ratio' is not defined\")", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {}, "mutation_prompt": null}
{"id": "d88ebb4e-3a9f-43ed-a4f6-619b5ef2156e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "de1def10-7ca9-40e4-9bee-ff0de604a274", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "94202dc9-eb84-4959-94b3-665cec2db1ea", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.inertia_weight = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adjusted line\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            self.f = 0.5 + 0.3 * (1 - self.evaluations / self.budget)  # Adjusted line\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Improve exploitation by dynamically updating the inertia weight and differential evolution parameters.  ", "configspace": "", "generation": 21, "fitness": 0.22032681731351922, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.5645002442278921, 0.5296774325206821, 0.5374230598361245, 0.6168832945763207, 0.598660726255031, 0.58440758387975, 0.566417921973916, 0.5670971031822358, 0.5676506683220318, 0.19334678792156756, 0.2060790121753714, 0.03016157771327288, 0.0257164743506042, 0.2302019082330128, 0.03941342056685426, 0.20845195201425293, 0.21147138756261552, 0.16437159988329708, 0.11921131405945085, 0.10820180851085626, 0.1173475535236399, 0.09815511222746631, 0.1385583879465485, 0.10965998189373893, 0.16912546163057107, 0.11082368270200782, 0.11319510024780521, 0.08751547606465426, 0.10601862038832355, 0.11941419388103858, 0.09183833867498548, 0.10201826906949263, 0.09244176734574772, 0.1101261340622468, 0.09776363567999069, 0.08916420946788384, 0.9830918214098452, 0.977047813131085, 0.9771364801850019, 0.9769938614637783, 0.96863754588626, 0.9684122845903586, 0.982507893468876, 0.9762497503152125, 0.9739416532407584, 0.31247679766143954, 0.2945039371605491, 0.2620993440790591, 0.24114886792999823, 0.1393580208954367, 0.24897026585286108, 0.08199798019397608, 0.08734370052228291, 0.31562094424298626, 0.20279908391327206, 0.1653845021103405, 0.3965208945011567, 0.19488444686242334, 0.18723743633071754, 0.18699443751291378, 0.4376012900107642, 0.37706900585359326, 0.4768796362447848, 0.14271024525543585, 0.08283369866286872, 0.1337815729100057, 0.08718252839710328, 0.1594543736509917, 0.08378595343776318, 0.15246367906036995, 0.13407932423783298, 0.14098379221836022, 0.1449351268421527, 0.0935715854461856, 0.16956800166014474, 0.12009127363742955, 0.13702970974308193, 0.10565309461790329, 0.1559815557095089, 0.09353129745433197, 0.20516499602070282, 9.999999999998899e-05, 0.019163139830904896, 9.999999999998899e-05, 0.002598880405753734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01401518963973758, 9.999999999998899e-05, 0.06882254162154311, 0.04254357313091606, 0.09044142382675169, 0.12051044292707247, 0.0007741856851721796, 0.009572912651100385, 0.04812485447129544, 0.05136571235464471, 0.03409476494898023, 0.13668340914383204, 9.999999999998899e-05, 0.023598519074236934, 0.06214639458852311, 0.04032734010470029, 0.038964490519604045, 0.044384016951522054, 0.03516049419991829, 0.04740646956087802, 0.06717036794100728, 0.031650209283007436, 0.11611727812279238, 0.022388992600751223, 0.08360079335568826, 0.1318655965175669, 0.06981818019846364, 9.999999999998899e-05, 0.0649532794141906, 0.41440447636431244, 0.42299037963055675, 0.4278476136217284, 0.43102661730090375, 0.4519096603161299, 0.20569255526564734, 0.4356474266248028, 0.4005820776283948, 0.46528028758456896, 0.0725693787375642, 0.11298817405581707, 0.10966528229310823, 0.09906796891905634, 0.1012247781238087, 0.08928109999822131, 0.09604761272938844, 0.08193740429436314, 0.1051201654301478, 0.16466915369901303, 0.1997572989390516, 0.1693888401564434, 0.22822722809828533, 0.2093040914137987, 0.1694555337366812, 0.14291905261253157, 0.18195673633549825, 0.14492491398638063, 0.27090462585840414, 0.29767891469618757, 0.22854368545149895, 0.2556225766899053, 0.30077020074000216, 0.20619101815513308, 0.3294903264478155, 0.30655196637824667, 0.3476565755297859, 0.2505206981503465, 0.23901575247808338, 0.1944062388923572, 0.14431183025044825, 0.16772117167880873, 0.21205945541074667, 0.2214942632375344, 0.24255800905251967, 0.215799915351509, 0.19064476718306167, 0.18222356798862005, 0.24396537157284304, 0.19138743861407836, 0.19714236173388444, 0.20095580702617377, 0.20972575143815686, 0.1971862981177953, 0.20799084455388328, 0.2653328859265687, 0.18097933114704468, 0.1886051181858569, 0.18715236078690545, 0.1926734796169658, 0.29636681230805517, 0.18562362389264941, 0.19691683440821384, 0.18927956658875733, 0.7113392761738682, 0.16729764837083827, 0.15223941172305022, 0.6734475160730935, 0.1941113110899365, 0.16808344823553945, 0.13878949710529032, 0.17298216636170638, 0.20094839447623758, 0.38298298033417155, 0.20346994603885982, 0.48245915791801897, 0.19401622821929843, 0.3551980276682849, 0.14352747634670382, 0.18955744387998907, 0.19989554063983184, 0.40701746833873176, 0.21005419216241006, 0.1915507738197293, 0.19440287909038523, 0.19406807890755307, 0.20896268134863372, 0.1822695313646273, 0.18436898075196229, 0.19483669129555414, 0.1958659505158964, 0.0739586640178419, 0.08340831942732052, 0.08781386286529491, 0.09114519076535343, 0.08512252054201186, 0.0849681576628949, 0.08664281424228704, 0.08110196011168302, 0.0760669382264677]}, "mutation_prompt": null}
{"id": "9c040a5d-8cc7-42c0-8c2a-3df2ce6f1244", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "f7d7977a-910c-4999-a121-ab3c8fd2d44d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Adjusted line\n        self.inertia_weight_min = 0.4  # New line\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        # Inertia weight adaptation\n        self.inertia_weight = max(self.inertia_weight_min, self.inertia_weight * 0.99)  # New line\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A refined hybrid PSO-DE algorithm that includes inertia weight adaptation for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.23555561020133411, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.62477214594475, 0.6188015362221368, 0.608719954945681, 0.6547050527493758, 0.6364292597536519, 0.6422619665076451, 0.6542713332908525, 0.6340276759279377, 0.5809129479814295, 0.3071348648604124, 0.2994295562445022, 0.30786685769151056, 0.328297348339174, 0.33384593908114435, 0.03626337589369688, 0.036218664389398914, 0.27687087065052707, 0.2659297857011118, 0.13242428578684484, 0.13261124042759098, 0.12375611449868318, 0.134248099007358, 0.12036754174924114, 0.10780785905336121, 0.10064650932706831, 0.13900452078522263, 0.12944427229985755, 0.0971987995344682, 0.10922514738284239, 0.09743801379454142, 0.11436728029698917, 0.0955320769188942, 0.09685986303027805, 0.09853708947478934, 0.09619885426747699, 0.10708181894789193, 0.9830921521377634, 0.9769090147442534, 0.9771283867584529, 0.9683921170809892, 0.9686460773654966, 0.9743410040840276, 0.9825439383996223, 0.9756568910050764, 0.976480525449321, 0.40112695575669743, 0.41127566749020694, 0.05737951345259429, 0.37357729700748743, 0.14108035845540867, 0.3578215121174687, 0.0809633103393631, 0.0880358149996211, 0.08331600264989569, 0.5828258394578145, 0.2139243884319676, 0.1683086779235411, 0.19934333476706134, 0.3416463280067379, 0.18818393461539895, 0.5036473301344001, 0.12422322458289359, 0.553787248532431, 0.15061251314095248, 0.15824945194812012, 0.163484340810365, 0.09341680072112302, 0.10725487090038244, 0.10783788741960176, 0.16078820673334793, 0.15251821550596, 0.16051441846453396, 0.15581258204599202, 0.15635882739145068, 0.1593495556879736, 0.1286252879615578, 0.10820834493570053, 0.15202859893488208, 0.17863622314388472, 0.08950488020511527, 0.17920363808938933, 0.000133733962495719, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026743363527348407, 9.999999999998899e-05, 0.049655355793229106, 0.06257880942206195, 0.031199391190475434, 0.08797089694561178, 0.07775063894705037, 9.999999999998899e-05, 0.031010248662248108, 0.061241849267297366, 0.08320594060467645, 0.07963339116340973, 0.018521382082663296, 9.999999999998899e-05, 0.07857189797136432, 0.050702007566628904, 0.04681753294314872, 0.047852324243134015, 0.1977641076030392, 0.11294190988162134, 0.0635704076619309, 0.16192546536436836, 9.999999999998899e-05, 0.03924195999906788, 0.09116974268015199, 0.034051207954884366, 0.004709916882808307, 0.04710785697578901, 0.14824676903929734, 0.0661056756801659, 0.43973956445243734, 0.445121344291175, 0.43590152945702354, 0.442161465831751, 0.4371720454694049, 0.20550687574944004, 0.46339500081578844, 0.4355568249455166, 0.4540095320372258, 0.0724441237840121, 0.08853510059804992, 0.10602872479914371, 0.11804082505140445, 0.11214545284657929, 0.11359371120829365, 0.1075458740937304, 0.1014586315694096, 0.12546031560972093, 0.23723617575820866, 0.17131548697567756, 0.1684598781978318, 0.2192510023056662, 0.3577215906749114, 0.16450371335484215, 0.18172369533603172, 0.2095959596549105, 0.2431096192400144, 0.3381816889561394, 0.36047260453354946, 0.2831621199994554, 0.20521085377073023, 0.1889470691887043, 0.3330948571095209, 0.3675326149952467, 0.3523154880892121, 0.3695196553208846, 0.23901197389723472, 0.16396487358588896, 0.24088558593667453, 0.18264475999704555, 0.29192660824964145, 0.1942435178073234, 0.2916436559634743, 0.22723721603606584, 0.2333010506757257, 0.24188268895145737, 0.21100086357862136, 0.18637014940429675, 0.19438191587097475, 0.20837478963204348, 0.1830744998634869, 0.20001869610334344, 0.195538113328391, 0.22916097397905555, 0.28581797234936535, 0.1970327987469105, 0.21553440116612532, 0.18914153164459913, 0.18411011785957443, 0.36740412725687854, 0.2059593898836709, 0.20384573917859594, 0.22659296054678568, 0.16131195040275326, 0.16625737285857378, 0.15237342347051852, 0.7207171999097723, 0.19401468145393053, 0.19135412350021652, 0.13846309348734254, 0.16363859111527546, 0.19947642447389202, 0.6313670072765132, 0.20501404630557707, 0.47112212070208614, 0.4305188455053919, 0.531210873804698, 0.1659155884979968, 0.19040803823667807, 0.20247263583508113, 0.20698818842255873, 0.2030754682721838, 0.19579311134358846, 0.18482866022429412, 0.1829175528380883, 0.17659304151753719, 0.18921355246536942, 0.19544656259047466, 0.17830399276250186, 0.1956123804724561, 0.07659266086879235, 0.08310590080476177, 0.07703754998562107, 0.07055646914929026, 0.07588852698233417, 0.08218720078985975, 0.09139834774644828, 0.08406083925227448, 0.07260999603790752]}, "mutation_prompt": null}
{"id": "e423efd8-cf71-47ee-af55-519bc5d1b1be", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "94d48545-fff9-4d2f-9468-038d05390f4c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        # Adaptive inertia weight\n        self.inertia_weight = 0.9 - (0.5 * (self.evaluations / self.budget))\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight based on evaluations to enhance convergence by smoothly transitioning from exploration to exploitation.", "configspace": "", "generation": 25, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "5b4c8055-54aa-4cb9-8a92-757f79a743fe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        # Add adaptive inertia weight\n        self.inertia_weight = 0.4 + (0.9 - 0.4) * (1 - self.evaluations / self.budget)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.2226682300950016, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.5598789441124297, 0.5406476698117949, 0.5159140902743313, 0.5601346103378007, 0.6086460083731382, 0.5559452567308962, 0.5744780244322885, 0.5472120391015785, 0.5648254038833753, 0.192312096128609, 0.023523500598093383, 0.024705512433237486, 0.17442363943850392, 0.2546323855670528, 0.2118239905782755, 0.07997395585395628, 0.03558681783307949, 0.17222446656018242, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.33722827665287536, 0.30536589033387784, 0.05756147486155527, 0.14357203715096334, 0.14676492610629388, 0.29712567173708204, 0.08059200968295632, 0.2381717460435393, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598871622, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975586848, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232936, 0.06557664903192495, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882744003, 0.0818755820002427, 0.011743510108358168, 9.999999999998899e-05, 0.11385362337402405, 0.05308202050422661, 0.03864920867554755, 0.042242455403313395, 0.043396774814115635, 0.03345444851389767, 0.038021377837877623, 0.14563828201854068, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.16027548634515554, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.41374207231064897, 0.43779189039937894, 0.4164526066773523, 0.39386574225639837, 0.4167485389208889, 0.44424582423489667, 0.42717512314628847, 0.44030134534797094, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880752, 0.22016246831304742, 0.2148714938429993, 0.20553890693250787, 0.1504918924339107, 0.23229022053337112, 0.27108112350165414, 0.17468114214914132, 0.21122409056899583, 0.31769593876224256, 0.30952162534465144, 0.30832879617874065, 0.3072846393513632, 0.2839638988963361, 0.2824979203028971, 0.3189158125515762, 0.32285988246626685, 0.333325605244139, 0.24524543400255838, 0.2033469439524268, 0.1918748198067628, 0.20915769620671654, 0.2394655390408692, 0.228073034300051, 0.23941799959579846, 0.22086147332438755, 0.23646405295051354, 0.20307379851171214, 0.1860985835715676, 0.19614627307933852, 0.19016702087822346, 0.21203506702373442, 0.17950408829096887, 0.19696338532046442, 0.19950595467970023, 0.21378804265450213, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.30920906580082697, 0.3192014153537316, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416991357, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999537, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113267, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705493176, 0.1786434054697693, 0.20110268539511167, 0.18100582436716117, 0.1882260047730976, 0.19367999264768665, 0.17600769325619037, 0.18819152859158939, 0.18075741069790097, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400919945, 0.07488147591361627]}, "mutation_prompt": null}
{"id": "e57a290c-38f7-47c3-9ad0-233bd47a6b61", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        self.cognitive_coeff = 1.5 + 0.5 * (self.evaluations / self.budget)  # Adjust cognitive coefficient\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhanced exploration by varying PSO coefficients adaptively based on iteration count.", "configspace": "", "generation": 27, "fitness": 0.22938471247956832, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.616786573369863, 0.5908177769147436, 0.6026562499735968, 0.5923785563530832, 0.5906965767399579, 0.6305667977745528, 0.6102909990930033, 0.594813542936472, 0.5450137290010381, 0.03164344057837809, 0.05935263409410396, 0.23861587191496836, 0.21884402696439598, 0.22844600348556543, 0.09784092617704587, 0.2047136516385154, 0.20476771468904809, 0.23495263065722216, 0.1121278780829078, 0.13579574185085963, 0.09460862404337145, 0.17431838200220395, 0.10642748293248683, 0.0847178395207604, 0.12721377189531557, 0.11555257148907927, 0.10316378217037947, 0.09857962645618623, 0.13986663411622813, 0.1454252227098607, 0.09301758751517741, 0.1145149826910461, 0.1351156799733848, 0.12555112712585592, 0.10459399879794873, 0.13031564450243205, 0.9775506931456137, 0.9762878555641374, 0.9759583889316217, 0.9683279945357552, 0.9681908190084599, 0.9762394802845327, 0.9824761664960557, 0.9676933511808923, 0.9722725266064038, 0.3253860705451048, 0.3260493018378462, 0.28787815291251284, 0.31737924591124933, 0.23751249541948616, 0.32245814519121674, 0.08178089947248568, 0.08778859615123913, 0.12257365771974837, 0.18937673861128002, 0.16998357787714558, 0.16692141090387613, 0.19255680992185065, 0.2520841416353746, 0.19919237697030334, 0.2093782810944509, 0.2658253327645881, 0.41330763362895684, 0.09746257931573454, 0.16062288123859048, 0.17694257505289968, 0.09768577011755242, 0.11606203660827918, 0.147330911753623, 0.14985926213317557, 0.18467136673783102, 0.1508101751699401, 0.15579988195625005, 0.205034758436634, 0.1618928006174456, 0.12489661383181516, 0.1710012394867403, 0.26649385936987, 0.12057455114810123, 0.17005514387535037, 0.2696433949731578, 9.999999999998899e-05, 9.999999999998899e-05, 0.029132591400295116, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018975628563530078, 0.017679909653754433, 0.05820424853319495, 0.06427959438823361, 0.06204340970354183, 0.10756037251035688, 0.007723946762502765, 0.024667298436308327, 0.07503402765068534, 0.1021274963721035, 0.08837540783524878, 0.03621001099904808, 0.03196475087625095, 0.037416885311661985, 0.07113570558279303, 0.043016219322448146, 0.04589313537884321, 0.05800626827411559, 0.08019623790457264, 0.07958063582578456, 0.1375340172716687, 0.13279568086445814, 0.03924401062169913, 0.1153470345883888, 0.09788832995373375, 0.0917386922418697, 0.0735957529295771, 0.12340118361573682, 0.07683333028400308, 0.4522744363583311, 0.44149057399679004, 0.4419808218789971, 0.438695215822822, 0.45791427075728597, 0.2062980453428339, 0.4986126054123937, 0.44169123427216483, 0.43700194876472986, 0.0952902575043636, 0.10426736195452324, 0.09119926055502414, 0.10549274882805604, 0.08764700800334935, 0.09444461489196343, 0.10845024295910766, 0.09992096654299898, 0.09353093129315637, 0.22477835902426768, 0.22418334849020172, 0.1760347133894975, 0.26440576036764574, 0.2559953597736345, 0.20494460755953392, 0.18465417688671637, 0.25487787327521005, 0.19582605490868288, 0.3312635820628468, 0.34313727644477776, 0.2767118754783179, 0.1874533355730753, 0.30709725845604197, 0.3227014073748361, 0.3257917737943611, 0.34133247956768353, 0.3304554797343733, 0.17732364254858823, 0.2222227597617199, 0.2067974485351297, 0.1411317886061888, 0.2378484669350469, 0.24410047591599482, 0.23849119247257267, 0.2889235611991626, 0.2535801639519063, 0.2153987367254846, 0.1966406139902961, 0.19208353019068558, 0.22935466988837416, 0.21048115411674784, 0.1822154444144658, 0.21550914236696395, 0.20200550541172446, 0.21031539511932873, 0.2144162749457068, 0.19306784935282095, 0.21407416346921748, 0.24244798215017027, 0.22088550471302448, 0.20915666670036348, 0.20780650933233957, 0.21498378088415881, 0.23378490463219792, 0.25838351159212225, 0.16623628630720322, 0.1528557415704327, 0.771344254638855, 0.19754238002593305, 0.15934006948189017, 0.1412781452282903, 0.1609272333670091, 0.2079652075234356, 0.5139803199853133, 0.20801787510656466, 0.23756685265397792, 0.20337943197520225, 0.3409577161517484, 0.19663779348134658, 0.37734824271640843, 0.20105968530665574, 0.45698351642229385, 0.18567282764706183, 0.19465544510389476, 0.18234938525844246, 0.17747789646365186, 0.1953516968991419, 0.1927792444862071, 0.17259984612154655, 0.1943432134424632, 0.18288267227554422, 0.09438652369338929, 0.08056771599086388, 0.08137042947771, 0.08444382128830297, 0.07682577046795047, 0.07711040065450547, 0.0879277092927867, 0.0875712788184857, 0.07958518471369969]}, "mutation_prompt": null}
{"id": "4060d8b4-5077-4bde-ad7c-be5cc1025616", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "ed16839f-c3fd-4e2c-9b77-0beb1c5d8ca1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "1e805f45-29ba-41eb-9456-838187d0d8d9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight_initial = 0.9  # Changed\n        self.inertia_weight_final = 0.4  # Changed\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        inertia_weight = self.inertia_weight_initial - ((self.inertia_weight_initial - self.inertia_weight_final) * (self.evaluations / self.budget))  # Changed\n        self.velocity = inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia weight to improve convergence by dynamically adjusting balance between exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "8be5703d-2260-4e21-b357-dcafce5913ad", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "57ac1f1f-25f0-437d-9ccd-80e15e716baf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "536c103c-53bb-4860-be1b-924996771aec", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "07669c88-8488-4166-ab92-f86c1e75f247", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "412755c6-76ce-429e-a65d-738ae4568b48", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Improved the exploration capability of the algorithm by dynamically adjusting the inertia weight.", "configspace": "", "generation": 35, "fitness": 0.15978959798722273, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.2682097939201433, 0.28119411813794937, 0.3091944492596357, 0.32261999780398043, 0.31670458782773336, 0.32179266478573587, 0.28855399486854905, 0.3063452357045813, 0.17710594013248315, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008377482251055168, 9.999999999998899e-05, 0.005000537030314223, 9.999999999998899e-05, 9.999999999998899e-05, 0.06072379208771905, 0.07602476229879762, 0.08094744055790182, 0.06725046187646821, 0.058465363803621995, 0.09016646995943889, 0.08362434843257238, 0.07770058796238899, 0.08900103833595419, 0.052976612221557806, 0.046536833892426466, 0.052652281230168074, 0.06807340886686142, 0.05833004327189084, 0.0748619239937105, 0.06413898804625473, 0.06390493255822238, 0.08374228554890073, 0.9830923956716299, 0.9769108322510098, 0.9771358138849318, 0.968400639815473, 0.9687038307369006, 0.9743516095083271, 0.9825464902754486, 0.9756484676863939, 0.976484974814861, 0.16990106753618928, 0.1572887090660452, 0.05733004202385528, 0.1463200981344227, 0.13509992268054993, 0.16934386267522117, 0.08043985037673484, 0.08799602943950358, 0.08280133410657231, 0.21528346184717984, 0.20021363025638084, 0.16305863255878994, 0.18852564903883162, 0.1834934845065187, 0.1810869292558176, 0.1940552990548391, 0.1750549578010141, 0.16583149036854028, 0.02845299047652694, 0.05058411357378356, 0.008408570903677859, 0.0621789452947229, 0.04634830448690119, 0.05700834701078494, 0.09086952527550218, 0.11388782248069729, 0.09887023894619629, 0.0817804894626939, 0.09324204971377059, 0.07683884665797092, 0.09776734833016232, 0.062480373554491764, 0.09860216355256102, 0.07583108676283157, 0.06623248215200095, 0.08696532924646294, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050185112301688095, 0.03582742316943566, 0.07786375260746903, 0.03034844553661531, 9.999999999998899e-05, 0.012853340058087137, 0.034376121038306895, 0.03514328207467754, 0.02489657514231458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028924144558919895, 0.02430282755164992, 0.028674288781661894, 0.028852436620379507, 0.019195273521102507, 0.0002362426095600112, 0.04183267116024014, 0.03294367522848263, 0.018103643148000392, 0.2971722876076024, 0.2705498255085438, 0.2922337204091725, 0.3098442345528055, 0.2843586818409807, 0.20404363034665207, 0.2908029589289187, 0.2669230563255526, 0.3066068797483301, 0.059241221234432095, 0.06280122560974122, 0.0785189493642583, 0.07357465296345234, 0.07572952873612593, 0.10618588072393687, 0.06775661808889943, 0.07608203689375936, 0.07016268684848348, 0.19046768689609284, 0.1924186860328384, 0.1769530710141758, 0.20522193071547012, 0.12438666303620793, 0.1486396695299571, 0.20882579054108574, 0.13098163632939375, 0.16135193946813764, 0.22235206624148762, 0.22510531499903952, 0.19269588965699158, 0.21357757424835488, 0.18954249788422095, 0.1958727689814619, 0.258850047184528, 0.216723839623441, 0.25220923913122506, 0.17414437352423906, 0.12416234766706624, 0.14367450199209908, 0.12575851166691987, 0.15063900491607551, 0.1312238465765453, 0.1810921327053887, 0.17312098616744276, 0.16019633691814128, 0.2379568450537909, 0.23435418149841725, 0.182231860271719, 0.19894703822019288, 0.1602959128898621, 0.19339889730850368, 0.16259503537926323, 0.18714085577468154, 0.18347745950887506, 0.17431116907487265, 0.1719580841045799, 0.16877652503353124, 0.16254506102456967, 0.16571557140253212, 0.17458703412896415, 0.16455792299351868, 0.15726012264710953, 0.17232561290854342, 0.16114746096582255, 0.1670105432872684, 0.15164511230460298, 0.29353595876122085, 0.19071527388512088, 0.1891332639345107, 0.13577809395324236, 0.16364642812327346, 0.19181055328136876, 0.24890979810428127, 0.20027599066221824, 0.26741163571751514, 0.3038879946091534, 0.21989493433353358, 0.19747042914494828, 0.1937680178168446, 0.2010024673553863, 0.20280667185755918, 0.17237704634796502, 0.1908084525379934, 0.20116370779041703, 0.19388303509355687, 0.1803547599917652, 0.18293644866470382, 0.18792235415168435, 0.18792594050132838, 0.18859883695463542, 0.05942632906641432, 0.07390728348903264, 0.06077765432784821, 0.06730164926123394, 0.07544442170091081, 0.06676914695698033, 0.06814595424288239, 0.07311419990669676, 0.08204526654960553]}, "mutation_prompt": null}
{"id": "ae789053-5784-436e-a841-c181728d123f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "1f899550-b949-491b-9116-2e3c9dda1ba2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "51d7d794-316d-4ea3-a1ce-48eabdb82e27", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.inertia_weight = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adaptive inertia weight\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Improved balance in exploration and exploitation by introducing adaptive inertia weight linearly decreasing over iterations.", "configspace": "", "generation": 38, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "fea47c01-9e6a-43b6-b653-fcebdacaedb6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "2e865a9a-4e24-443f-ade0-d8475a8a4c01", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "13e1b220-9110-4b95-9727-841922083f35", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "3ee3e2e0-ed56-4d97-8a4d-55f58324bd8a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "965ac7a2-b0f9-4db7-afeb-84f473468253", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "9bdb3d2d-3275-45a3-b352-7c4daf5fd864", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "4de8732d-c0f7-43ea-ac7c-6a7d7aa520ad", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        # Dynamic adjustment based on evaluations\n        self.inertia_weight = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance balance between exploration and exploitation by adjusting velocity update parameters dynamically based on evaluation count.", "configspace": "", "generation": 45, "fitness": 0.20742252970405864, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.4993229808883778, 0.4685570402421019, 0.48707754991547525, 0.5309468995184288, 0.523910774801613, 0.5253921053906466, 0.5222714449385876, 0.4784755451245666, 0.384085250326367, 0.1526235209756749, 0.1223422054864921, 0.09696077793018665, 0.14426824955052675, 0.15561920779986504, 0.12073345252505241, 9.999999999998899e-05, 0.03247287195698756, 0.025820632847020852, 0.09156302835871188, 0.11173000775362052, 0.12287830038997694, 0.11888088366753258, 0.11986648543873091, 0.108385752623255, 0.12116326532917321, 0.11821002745101528, 0.09708341823014421, 0.07906471733876574, 0.0828020058920319, 0.08779732372816562, 0.09261563719028054, 0.09994982674388742, 0.07164040110006031, 0.09655660591161397, 0.14005493357392584, 0.09635912957254389, 0.9830922049369839, 0.9769086069214031, 0.9771306797683567, 0.9683952958338765, 0.9686679606849622, 0.9743449387429463, 0.9825443318490981, 0.9756575356414081, 0.9764822069864371, 0.32213075387599577, 0.28187634407392037, 0.057033683982503525, 0.22573329504061646, 0.1367437450385769, 0.250237069230545, 0.08072591115754857, 0.2043836304106914, 0.08328920274843055, 0.42561184323574275, 0.39106224714254656, 0.16811330483369724, 0.1910940054015473, 0.397391570682885, 0.18318044399769984, 0.3466116320247573, 0.3344259715736875, 0.3832274464574795, 0.13202063589930402, 0.10248943657493359, 0.14131777144310165, 0.09352669765467925, 0.1064120491100623, 0.1298626853001218, 0.12778980116788685, 0.13737655396735082, 0.13202532724258254, 0.15196166664936916, 0.1291184684085016, 0.12510055710254475, 0.11629823010833495, 0.10026645968000225, 0.1027607736149424, 0.12631208819783135, 0.10480893230088628, 0.15586546308815397, 0.00785828060270799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05022330440277323, 0.03212558958560041, 0.03478253508303952, 0.039734413025644066, 0.009626907061169865, 0.09969458733080028, 0.056798752391822194, 9.999999999998899e-05, 0.01040959163014521, 0.03428490379435356, 0.06500075813434036, 0.04885459919209445, 9.999999999998899e-05, 9.999999999998899e-05, 0.07546853036283341, 0.029911452301755515, 0.03453392890111118, 0.028309389589753153, 0.09177476082153424, 0.03332822796357582, 0.054591220798682505, 0.1151056930514891, 9.999999999998899e-05, 0.04593452554175148, 0.07878609033660955, 0.13699064235490221, 0.004668865606540784, 0.11190657162047024, 0.1001934570612022, 0.06275544543289269, 0.39915743062169007, 0.40695058024215724, 0.38361494998857204, 0.39716906678359143, 0.39965172538851335, 0.35677463480057914, 0.3855025573261681, 0.3814005670143311, 0.408254633062191, 0.068358196159513, 0.11392958978125112, 0.11795284631530101, 0.0948862310209988, 0.0856949807098305, 0.10692218966488376, 0.10841431455202677, 0.09029515550184808, 0.09921635068880497, 0.22449026060819866, 0.17420467930951777, 0.2226035626544437, 0.33151488304644317, 0.15903819843855638, 0.21082972285315693, 0.16298201154662129, 0.2009430690898507, 0.19326430053915555, 0.294656146005183, 0.2677099568388368, 0.2918468963042866, 0.2718286937988015, 0.19035405751151768, 0.2812579046175441, 0.29767609024586494, 0.280460132071467, 0.28770577340813686, 0.21000765035463798, 0.1517949092747627, 0.2168677549336573, 0.14480998998461259, 0.2323979468865357, 0.18102871401914855, 0.22055235236417037, 0.20419884812712785, 0.21576136490161013, 0.2062266304111512, 0.18588188076593826, 0.17245582294118122, 0.1790820563485438, 0.18232129470385128, 0.19581395575729998, 0.1965771418512915, 0.20096532566409697, 0.18137893176914, 0.19907661806489652, 0.19287836188980867, 0.18886093390585945, 0.25476725955624535, 0.19578909463621919, 0.1831024351185757, 0.20933760176998661, 0.20193814699590962, 0.17680456947395284, 0.16134996731886864, 0.166314977348354, 0.15276745496765487, 0.6250492616776882, 0.19337136197375082, 0.18827390567252, 0.1379188499929962, 0.16398222505925064, 0.20017125999111662, 0.33901393588057893, 0.1979898219539088, 0.4583883324765624, 0.3525047022590324, 0.21756230045895764, 0.1648320106088519, 0.18908329578526184, 0.20122067207626215, 0.2015345559128474, 0.17918583807080413, 0.18121094507730273, 0.20668287543422403, 0.17413076910402492, 0.17637531820644958, 0.17942159316940487, 0.18084378790010014, 0.17815165950866108, 0.18954004721576556, 0.07269388708042512, 0.08434026899092406, 0.08462346611750104, 0.07317456538938805, 0.07366094082735986, 0.07871065235690533, 0.09715118371592157, 0.0894481958963681, 0.08085685534468634]}, "mutation_prompt": null}
{"id": "c4166212-e06d-4182-b7e1-32d487796fb9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "9b3d1347-78c3-4396-917c-109bbf38a4c7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Line changed: Start with a higher inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        self.inertia_weight *= 0.99  # Line changed: Adaptive inertia weight reduction\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A refined HybridPSO_DE with adaptive inertia weight for enhanced dynamic balance between exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.23569306434267304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.62477214594475, 0.6188015362221368, 0.608719954945681, 0.6547050527493758, 0.6364292597536519, 0.6422619665076451, 0.6542713332908525, 0.6340276759279377, 0.5809129479814295, 0.3061692491401934, 0.30037473175753826, 0.3088203914371396, 0.32810862963557086, 0.3337600661917727, 0.0362633758888955, 0.0362186643893645, 0.28172968442704904, 0.2669576458354388, 0.13242481045287313, 0.1326107556748104, 0.12375599515551894, 0.13424809777273017, 0.12036754219457835, 0.10780796322421682, 0.10064650966002697, 0.1390045209871198, 0.12946092258854447, 0.09719879918049268, 0.10922524159990754, 0.09743799118431018, 0.11436728029791388, 0.09553207688907805, 0.0968598630623223, 0.09853708947307527, 0.09619910779384244, 0.10708111063976389, 0.9830921521377634, 0.9769090147442534, 0.9771283867584529, 0.9683921170809892, 0.9686460773654966, 0.9743410040840276, 0.9825439383996223, 0.9756568910050764, 0.976480525449321, 0.4043427611788728, 0.41561751691162596, 0.05737951348792558, 0.37650221617146806, 0.14108043927329617, 0.3600894700426266, 0.08096331051777084, 0.08803581465201638, 0.08331600905552006, 0.5828258394578145, 0.2139243884319676, 0.1683086779235411, 0.19934333476706134, 0.3416463280067379, 0.18818393461539895, 0.5036473301344001, 0.12422322458289359, 0.553787248532431, 0.15006535921256214, 0.15792660875381848, 0.16342117011235147, 0.09341680072112302, 0.10725782685642882, 0.10784558189173876, 0.16026262017016468, 0.1527956256984513, 0.16000358370366352, 0.15576432038806198, 0.15626034066310235, 0.15855257060478656, 0.12886455874982183, 0.10823546162463915, 0.15138443582395744, 0.1788622365712923, 0.0895164047323237, 0.17836516685646142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026796427854294036, 9.999999999998899e-05, 0.04957788131320884, 0.06313337111802919, 0.031053543804431705, 0.08872570083838205, 0.07895784721635013, 9.999999999998899e-05, 0.030910047366451754, 0.06147443897004068, 0.08328572195738249, 0.08078815045234311, 0.01852138211381449, 9.999999999998899e-05, 0.0785727509655384, 0.05070200758132537, 0.04681753293476654, 0.0478523242339961, 0.1977642260582344, 0.11294262691560286, 0.06356969651232613, 0.1619265271688748, 9.999999999998899e-05, 0.0392422330416593, 0.09116972537336665, 0.034051205630356574, 0.004709918524726131, 0.04710787254328663, 0.1482481061651919, 0.0661056721833354, 0.44079246587553633, 0.44549060427051823, 0.4349409208077816, 0.44115040768251734, 0.4368177859740717, 0.20550687574944004, 0.4629769441627245, 0.4348787464386872, 0.4529858575682748, 0.07244412804578915, 0.08853510094952222, 0.10602912376072304, 0.11804084918041302, 0.11214545374706664, 0.11359337260422653, 0.10754587523199899, 0.10145862284583274, 0.12546031503437693, 0.23724453982832394, 0.1713162816571837, 0.16845990426420687, 0.21921379030620258, 0.35777084449778185, 0.1646870057599764, 0.1817236953360366, 0.20965656603822858, 0.24311453159486407, 0.33839592830934995, 0.358890139298048, 0.2831550605538068, 0.2052349478522788, 0.18894093078158092, 0.3344525823353328, 0.36680240124149843, 0.35510521152293184, 0.3653918338244533, 0.23904990617326127, 0.16398705911660272, 0.24096041082635344, 0.18264917504706335, 0.29374324422541953, 0.19418716012366888, 0.2919464642799031, 0.2273146757319543, 0.23331510474943085, 0.24188059695859976, 0.2109169087953594, 0.1856307093706404, 0.19519432219539434, 0.20838184746635102, 0.18563722863004373, 0.19883629263984715, 0.195538070231293, 0.22916066853769645, 0.2854607962938569, 0.19703277999593738, 0.21553439715534306, 0.18914153164479408, 0.18411011786897113, 0.36913472438612693, 0.2059594093128283, 0.2038457391788212, 0.2265929605512026, 0.16131195040275326, 0.16625737285857378, 0.15237342347051852, 0.7207171999097723, 0.19401468145399048, 0.19135412350021275, 0.13846309348733976, 0.16363859026681182, 0.19947642447395209, 0.6313666184334108, 0.20501404630553888, 0.47481393200986965, 0.43230021182329026, 0.5312147369422957, 0.1659155884980068, 0.19040803823667807, 0.20247263583508113, 0.20698818842255873, 0.2030754180049008, 0.19579730833650733, 0.184829502032562, 0.18293018842778697, 0.17659454882946735, 0.1887189527378177, 0.1954095467017234, 0.17857339742516654, 0.195612380289517, 0.07671338846491249, 0.08297733355279002, 0.07955294706271487, 0.07125431441651908, 0.07636456240355005, 0.0823130522689095, 0.09138992794005607, 0.08405769534472807, 0.07365956443075661]}, "mutation_prompt": null}
{"id": "e5bc14fd-cd75-4422-a169-40e3982409fe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "cf4148e6-ce16-49c5-846a-fd74cbf12890", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "2b2b8330-cadd-443b-8fd7-f932f24dce2d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        # Adjust inertia weight based on progress\n        self.inertia_weight = 0.9 - 0.5 * (self.evaluations / self.budget)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhanced exploration and exploitation by adjusting PSO parameters based on iteration progress.", "configspace": "", "generation": 50, "fitness": 0.22266823009496808, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.559878944112535, 0.5406476698117495, 0.5159140902742483, 0.5601346103377689, 0.6086460083732187, 0.5559452567307299, 0.57447802443225, 0.5472120391017603, 0.5648254038833308, 0.19231209613015265, 0.023523500598103597, 0.024705512433237486, 0.1744236394387293, 0.25463238556698176, 0.21182399057444523, 0.07997395585395028, 0.03558681783307949, 0.17222446655968104, 0.10804036308732035, 0.10176466952960872, 0.11081978477111554, 0.11243797697705171, 0.11282649251915933, 0.1292808597528663, 0.12470102542312433, 0.11390924050645534, 0.1151252378711708, 0.09410944306080948, 0.08195270421662337, 0.08221824035359315, 0.09893588290283806, 0.09134756517844889, 0.11164010003330427, 0.11057475769069769, 0.10907020006373636, 0.10237080920850605, 0.983092157324547, 0.9769080557863709, 0.977129406071578, 0.9683939683050548, 0.968659461184064, 0.9743433163346564, 0.9825438018991888, 0.9756571435442366, 0.9764815175480358, 0.3372282766529061, 0.30536589033389716, 0.05756147486155527, 0.14357203715096334, 0.14676492610629377, 0.2971256717371056, 0.08059200968295632, 0.23817174604343305, 0.08335395209671881, 0.5003147711407674, 0.20708446345225862, 0.16654502533110083, 0.1951716875404309, 0.5596473440256156, 0.18348299681949543, 0.2146527235231187, 0.3944555358459988, 0.20768518832983862, 0.1802969560394183, 0.16803018598869768, 0.11720104886197824, 0.09399372232029835, 0.14950317483427733, 0.15696941420198984, 0.09971338374045957, 0.14615912201560455, 0.13552991975589668, 0.15097510107981904, 0.13956178128867391, 0.13909564251437, 0.13929105738100223, 0.1232603624820624, 0.09842515615119207, 0.11285623913147369, 0.06260204310055106, 0.1891781792799132, 0.02525963586625002, 9.999999999998899e-05, 0.016010632021594362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013225820420017631, 0.028520710382398118, 0.04384218473031465, 0.09352102029943521, 0.09264828642232026, 0.06557664903189908, 0.08832134952479631, 0.003568891687583675, 0.048040317182567516, 0.06079869382055125, 0.04277907882739307, 0.0818755820002427, 0.011743510108367938, 9.999999999998899e-05, 0.11385362337402316, 0.05308202050425348, 0.03864920867554755, 0.04224245540331484, 0.0433967748141344, 0.033454448513925095, 0.038021377837877623, 0.14563828201854123, 9.999999999998899e-05, 0.03474243582753278, 0.08572950013353053, 0.08932359600357598, 0.03847393062542015, 0.1602754863451542, 0.12529772022485886, 0.0634153462925624, 0.40913625884164107, 0.4137420723105695, 0.4377918903993667, 0.41645260667740835, 0.3938657422563592, 0.4167485389194443, 0.44424582423491643, 0.42717512314639317, 0.4403013453479744, 0.10187949245890071, 0.08713815483526777, 0.12535958046716755, 0.11295106546075095, 0.0876322827942404, 0.11215099063766343, 0.12786771442475964, 0.10195082992572502, 0.10345569303495938, 0.24744373721880297, 0.2201624683130725, 0.21487149384302306, 0.20553890693249044, 0.15049189243383643, 0.23229022053341264, 0.27108112350153835, 0.17468114214922337, 0.21122409056900238, 0.3176959387622309, 0.30952162534462924, 0.30832879617876674, 0.3072846393512916, 0.2839638988962997, 0.282497920302886, 0.3189158125514364, 0.32285988246624864, 0.3333256052438086, 0.24524543400247334, 0.20334694395244268, 0.19187481980679533, 0.209157696206691, 0.2394655390410424, 0.22807303429993986, 0.239417999595938, 0.22086147332438755, 0.23646405295054318, 0.20307379851171237, 0.18609858357152131, 0.19614627307933974, 0.1901670208783589, 0.21203506702373442, 0.17950408829093556, 0.19696338532051938, 0.19950595467916155, 0.21378804265447504, 0.2098688694208729, 0.18573776376839202, 0.21257104542924932, 0.3092090658003813, 0.31920141535311986, 0.18934752103473573, 0.1837062860201346, 0.2023275920949542, 0.3159588416980682, 0.1612605445777815, 0.16595592063622266, 0.15224416029484233, 0.6594607937743985, 0.19360374656786772, 0.5715666689999235, 0.16115219692913774, 0.16375716407494567, 0.204320022406695, 0.46176375525046287, 0.205188265185829, 0.3634803536113177, 0.43625090589140814, 0.3143734940693341, 0.1651524238252161, 0.10399641409330074, 0.20311006736266712, 0.19515087537654308, 0.18579011705506765, 0.1786434054697693, 0.20110268539511478, 0.18100582436716117, 0.18822600477316287, 0.1936799926476841, 0.17600769325598709, 0.18819152859158972, 0.18075741069777418, 0.08303977030347909, 0.07217478953426304, 0.08176109443110668, 0.07113798007226557, 0.0800404339930858, 0.08362570651026979, 0.08683414903688769, 0.08193848400928072, 0.07488147591359806]}, "mutation_prompt": null}
{"id": "f2307475-a5de-413a-bbff-50f07f38469b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "40bd1529-9871-4b54-8c39-1adfe4b85cf8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that dynamically balances exploration and exploitation based on population diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6480796418638615, 0.6093509020967548, 0.6423868127709347, 0.6734754262357715, 0.6539872818131396, 0.650538022280549, 0.6191309392648732, 0.613878368303304, 0.6087072829653644, 0.24257018325348123, 0.21597760155004175, 0.24045212914541148, 0.2640400387391333, 0.24570829751437473, 0.16499381838229965, 0.23117686956026096, 0.24861146608579132, 0.2157022910746833, 0.15584380209510196, 0.16015989394412156, 0.07273751252928162, 0.12600532046488044, 0.12295211287172492, 0.11618393651735115, 0.13160001924767184, 0.15682969420615134, 0.12083058891798448, 0.12164981878105463, 0.11389844163976903, 0.13408283231873197, 0.10182579389660384, 0.11375853639147904, 0.10141312768922439, 0.12219794466184908, 0.08930296270068372, 0.09467680895401442, 0.9775506775122011, 0.9762884770949211, 0.9758959563146574, 0.9683244838867021, 0.9681900564365965, 0.9762385869884032, 0.9824762988296557, 0.9676894673800617, 0.9722776461439206, 0.3545976798114133, 0.3296233364212562, 0.31811449447660556, 0.3279473372312798, 0.14559453756607177, 0.3349829157520283, 0.08175747678677725, 0.0878507356338516, 0.12339323687520332, 0.2204391575061091, 0.21626492274448184, 0.21359577682883024, 0.19226906291480228, 0.19775228364503106, 0.20224565210746503, 0.3178504158587513, 0.3559087334048324, 0.46189320716924887, 0.08448418252921908, 0.15912378615184075, 0.15587188561795684, 0.09941561797882881, 0.1527455205695082, 0.14789530613634871, 0.1579674277918801, 0.16923462742093676, 0.15553167065792894, 0.17349324771126917, 0.1690788704027616, 0.17587208147845945, 0.14749705316403283, 0.15983661447836262, 0.3240919647785686, 0.16259193821389495, 0.17543805416857883, 0.18113638981072222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017612007998480617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005988066694395111, 0.05507648569740209, 0.047867838374081706, 0.06324026511070335, 0.08828220517122953, 0.0037526723967905573, 0.034831840922216584, 0.03771854067002589, 0.05978635363169593, 0.07739731917023596, 0.025361271825018794, 0.04142274299437376, 0.029846872316491302, 0.11285920882450595, 0.036187812161338706, 0.05094426793602069, 0.0660888295261608, 0.0765097842896163, 0.09423230146334938, 0.11165479919488064, 0.03417534783760856, 0.03899323814616473, 0.1614249922850418, 0.08111040775204437, 0.04798659996915289, 0.07260775555893395, 0.1252307263401885, 0.07226369134357791, 0.43711564107151124, 0.4616140975508999, 0.4636717834388827, 0.46192741669849113, 0.47497335115447015, 0.20623691528263555, 0.48327117322589985, 0.4477873872736413, 0.461500137548131, 0.1360812102900676, 0.09564277582164793, 0.09130974159355065, 0.1291498739785205, 0.10747690081770156, 0.12434878181848108, 0.1078704287885337, 0.12365597430682085, 0.10533386974599068, 0.19028580137507733, 0.23153230528891644, 0.1944677048518617, 0.28000295952185816, 0.26398319716938023, 0.2577701365420635, 0.18879628882402322, 0.2252972190446232, 0.19783660527596714, 0.3083168272696094, 0.30162214406721377, 0.3391644090180618, 0.2025125867271419, 0.31717254449397825, 0.25054025438287086, 0.3498360225345263, 0.3543007058747035, 0.33157761422066945, 0.20618919129508118, 0.2082112555664265, 0.252385868162159, 0.17314758212717385, 0.20825914025743864, 0.21738637728852495, 0.26235137477811776, 0.2627284548245493, 0.23711888082088772, 0.210989556944155, 0.20065731708702528, 0.19389464398091127, 0.23848752232935255, 0.21713295455071357, 0.2075551676785422, 0.2431721038603275, 0.23221505061972614, 0.20839894118654323, 0.18364639208347044, 0.30506065205653754, 0.2145423189935488, 0.20753489898366306, 0.21428174079569817, 0.21582800376314892, 0.222935679552971, 0.2052195542089318, 0.1941983312314618, 0.7559695548988563, 0.16484510143288844, 0.15285753861003337, 0.73955956232518, 0.19772344536053055, 0.16440690986710382, 0.1413014077455942, 0.15984521856044198, 0.20659997843746092, 0.5480686206363535, 0.20807714985606274, 0.3159936100675108, 0.2051928571742807, 0.38158461545824673, 0.19630281972069608, 0.40781074699739994, 0.1990941245468315, 0.5203030498200815, 0.17993216839169124, 0.17904848138964935, 0.19510210478458734, 0.19889348521677275, 0.18802968275527887, 0.1808210032377997, 0.18626581826286226, 0.1783751987203961, 0.17407443137394008, 0.08117345768634554, 0.09612971518203539, 0.07290472750806543, 0.08148956828259757, 0.08460952642920205, 0.0734357619021252, 0.08389529495502446, 0.07468910699530373, 0.0929609682155711]}, "mutation_prompt": null}
{"id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce dynamic parameter adaptation for the DE mutation factor and crossover rate to enhance convergence speed and solution precision.", "configspace": "", "generation": 53, "fitness": 0.24410961043633145, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "ea6974e3-00e9-45e7-9ed9-ab2abb819fd2", "metadata": {"aucs": [0.6502747064208669, 0.5937767296917291, 0.6312134241174933, 0.63652458494246, 0.5778199904085557, 0.6622810441605901, 0.6164083512433034, 0.6451808527141981, 0.5940007693590131, 0.17710934802450828, 0.21079010490361183, 0.21819666175304497, 0.23434173078957743, 0.18885851123423303, 9.999999999998899e-05, 0.27713068780167693, 0.20804399084489744, 0.22170102786202073, 0.14526383297653123, 0.11126983065897389, 0.10298495209812064, 0.11371614372110195, 0.12111298290521444, 0.06833774727767727, 0.1277261399352836, 0.11232842871806936, 0.17003208773905532, 0.10887057204857375, 0.12225732245382626, 0.11803961808051588, 0.11820966023562107, 0.11270270383801728, 0.12851659391420522, 0.1435538272269612, 0.10337227248253111, 0.11326588802489046, 0.9775506775122011, 0.976263609683216, 0.9758779533945103, 0.9683164739977224, 0.968182647504696, 0.9762386622087493, 0.9824762988296557, 0.9676870286635975, 0.9723125831166942, 0.40102483255999855, 0.3531261052465955, 0.3313496015954228, 0.4077762262446445, 0.14795001826953835, 0.37726527772802754, 0.08192768984324461, 0.3156620035926323, 0.34650375197659466, 0.17070152865864963, 0.5738235208580602, 0.16907196347615683, 0.2648105226391706, 0.1873505570654912, 0.19289213390384607, 0.22800722458277933, 0.20279623425701443, 0.6403478231755534, 0.09098229332484242, 0.1693226762221628, 0.18160282419965224, 0.1047515133037552, 0.15997492324729723, 0.12060113516104443, 0.14677492034212025, 0.15692509366612484, 0.16385689941320214, 0.19673168440719524, 0.2460122825736204, 0.18334184812887755, 0.1402768559556793, 0.13047524825828527, 0.16515761957498598, 0.15792645071907208, 0.18904162003211544, 0.1778256728194676, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305326264205069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03613375630039806, 0.0071493850886629184, 0.04772910906682615, 0.038870390883741446, 0.07345423364956061, 0.05669865865478818, 0.013650943564554097, 0.02141993817177823, 0.07740751267390045, 0.07865673247677096, 0.03731434595992178, 0.029763290584301272, 0.03996023844814245, 0.03351926805938621, 0.08634390629045952, 0.04434929647908015, 0.040310239583900564, 0.06267214176751645, 0.08267799300169276, 0.0897584352348525, 0.17316369723598912, 0.08654620492094967, 0.056138535252946875, 0.18097796451648196, 0.11113430040048256, 0.0679809169270702, 0.12611302425285065, 0.09613678782985713, 0.0714508304976822, 0.4332541975279014, 0.4644497429503506, 0.46092134308155097, 0.4643409733786388, 0.4776439456886864, 0.2068551249629511, 0.47009915687763904, 0.43832772710561585, 0.477214690623626, 0.07728441068627712, 0.06969917501705947, 0.06489273933287698, 0.1377519504431275, 0.11548239154144779, 0.12265126946477134, 0.09981120353915574, 0.12349739650589941, 0.09706876260678887, 0.32817573927912413, 0.30110580246605856, 0.33486647374821754, 0.28480388136291523, 0.24980390612029324, 0.29923784507296947, 0.3856535926125634, 0.17684492975363042, 0.20046405273490975, 0.28277885112552126, 0.33123298649486366, 0.293240792951882, 0.21291526852696985, 0.30878868345270616, 0.30733379590482524, 0.34026865991784194, 0.3643670503790909, 0.322515450534391, 0.26417813491308106, 0.234857017267026, 0.2387614641697161, 0.16970683449815083, 0.23391870950409832, 0.2592122321837067, 0.20005708843094172, 0.23257847913532936, 0.23801569099119302, 0.19318077595724048, 0.16083498198634438, 0.20608415085562337, 0.20413468165788629, 0.24756648565724826, 0.19663662147471428, 0.21513159508768975, 0.20016212039557102, 0.21123480802735817, 0.2006755520011677, 0.18953357049701025, 0.22444604292533454, 0.29930137615775865, 0.19984024397970612, 0.21086916334929162, 0.2152005211817839, 0.20803369763377755, 0.22616580193141866, 0.7502874764555849, 0.14036219891569868, 0.1528178557824098, 0.7201016161518212, 0.198530852915066, 0.18340024646058695, 0.14139559524891976, 0.1596198586680584, 0.20323123047539826, 0.5454013317788309, 0.2096296400536063, 0.17132946525458703, 0.4186419343343084, 0.39178507793009076, 0.15090819857656446, 0.47282306111513084, 0.10496036739444514, 0.5428714973451108, 0.19711687573172465, 0.16824991463501682, 0.20077889817140426, 0.22952984662591802, 0.19847094681497313, 0.21345997511314063, 0.18286174028661473, 0.17694689699371613, 0.1799968868842874, 0.08635767187530852, 0.08842272867743317, 0.08267659973134556, 0.08571156643347766, 0.0827351008856072, 0.08156382809211593, 0.08839086084184478, 0.08231517436632407, 0.08270805865030506]}, "mutation_prompt": null}
{"id": "00c1e09b-6a0a-48b3-bd7f-03ff854d687f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.5 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploitation capabilities by adjusting inertia weight dynamically based on evaluations.", "configspace": "", "generation": 54, "fitness": 0.2227550080565262, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "metadata": {"aucs": [0.5598107812515463, 0.5310916140023316, 0.5420628465356968, 0.5927509268873361, 0.5462136758493079, 0.5664839577306809, 0.5813318044911517, 0.5299612191774655, 0.5433740897980168, 0.09588387696285283, 0.20472751342167628, 0.17859452794478026, 0.12121154307090654, 0.22039461056785536, 0.20752052279476707, 0.0003399564612013295, 0.011107077795201814, 0.024922609153031905, 0.13573491280730954, 0.10319558713845023, 0.0991471041266988, 0.11838535503677516, 0.10903766688383199, 0.10913975204600668, 0.09273171725278384, 0.10728626128407881, 0.11639362369373707, 0.13479186908879925, 0.09442842063484802, 0.11206140010344756, 0.10425775368613943, 0.09285542228504728, 0.10518222607250105, 0.10540447465370217, 0.11674368891997633, 0.09047848938982028, 0.983092157324547, 0.9768746823590386, 0.9771295524550931, 0.968393263909078, 0.9686579327011058, 0.9743432804708272, 0.9825438018991888, 0.9756473664518986, 0.9764815175480358, 0.3241367346652908, 0.3225003522784423, 0.058033260858925906, 0.14192333364496368, 0.1396468273590179, 0.37512071893205334, 0.0809801606531324, 0.2844565876447368, 0.08238063312711985, 0.4770664024043868, 0.16958083750754216, 0.16922423429803146, 0.1898704458800745, 0.6247898751129093, 0.18582504306784298, 0.434125689766809, 0.48575290763932166, 0.5258759653878271, 0.13081445735434316, 0.14036843994936987, 0.06731467245404732, 0.08890198424803619, 0.11225007738614312, 0.13530351465701174, 0.13837055295262557, 0.14705060978577533, 0.1441444857633587, 0.1497524568135088, 0.13770612971111984, 0.17799615470596308, 0.1583380385086941, 0.1501561515335441, 0.17334637972399836, 0.18258252926841712, 0.027087671779105427, 0.17551842384668692, 9.999999999998899e-05, 9.999999999998899e-05, 0.07554504472591705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02275006290557302, 9.999999999998899e-05, 0.0445379151385874, 0.06497834180763129, 0.020424463136853088, 0.07323258467015148, 0.09156807212907425, 9.999999999998899e-05, 0.03334592396855007, 0.033085230644340324, 0.02596340615223347, 0.008176412870176897, 0.01476631915022586, 9.999999999998899e-05, 0.053304022324991984, 0.07311060219354093, 0.034749025372861064, 0.039946855333628406, 0.05105268854482581, 0.04513036836522877, 0.0314406842517021, 0.15273224984692335, 0.03275819927788126, 0.08516464609301333, 0.11050075877595245, 0.028984110222501802, 0.004852873537435465, 0.04133736125694121, 0.06866464479731371, 0.06385446899356972, 0.41771997823655527, 0.4243128481917422, 0.42069329052731164, 0.4265599187811536, 0.4314714998939848, 0.20484876269149743, 0.4142998668912402, 0.41393992268382485, 0.42128799249975046, 0.05448163685087781, 0.10735851014825626, 0.13046473921675683, 0.10131034286416685, 0.09527215052679416, 0.08661874601794295, 0.0872120260731688, 0.09146784755703496, 0.09965573710673947, 0.232873138058723, 0.17246656292404883, 0.16357343863140827, 0.2547961465033687, 0.2522279771683854, 0.23435584585398372, 0.27036710927872776, 0.15270595087919114, 0.2654166708753871, 0.3100405878700795, 0.2434298434204163, 0.30184210153299007, 0.31265536606524946, 0.3374670445241307, 0.31025472843588, 0.258605900335392, 0.32712492339880916, 0.3303713270044506, 0.21439549421156612, 0.17437014660119765, 0.17825048633309837, 0.18756109818429834, 0.23216042332186104, 0.1889197863396075, 0.1441540589787117, 0.2271955039947141, 0.2669864467351274, 0.1969550879770411, 0.19120150835377714, 0.2009131623483118, 0.20189854951026986, 0.20570752212112597, 0.2063417297463529, 0.18968035633074798, 0.22526987330927828, 0.2055734213941085, 0.18606537313228233, 0.18894422164641822, 0.20171914630116117, 0.18770575816886026, 0.19973328914642596, 0.20866376891565064, 0.3338489337443984, 0.28173786779774335, 0.19500215188158976, 0.16143561650807536, 0.16622184018677377, 0.1522242869387057, 0.6497358697986387, 0.1944587936746328, 0.1649175125300788, 0.13887625456521435, 0.16114508054379584, 0.20017579704187982, 0.4561718234030492, 0.20651496164610406, 0.5515233537902202, 0.4131061442826023, 0.36680019354095017, 0.3773671537179314, 0.4050328331163131, 0.20391244107375006, 0.1948127504525774, 0.18088433443594354, 0.1880801636179834, 0.19581342100554955, 0.18579771888497187, 0.1816167435612619, 0.1855736789625314, 0.19187764221769954, 0.2058738687510846, 0.18684830276030007, 0.07816726220125347, 0.085664197446785, 0.08463753502239069, 0.08521526582292516, 0.08172937077459042, 0.07776461828955794, 0.09228679236598347, 0.08286331026526272, 0.07619664969077078]}, "mutation_prompt": null}
{"id": "17be680e-a203-467c-aeb5-b7f36908afa3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce dynamic parameter adaptation for the DE mutation factor and crossover rate to enhance convergence speed and solution precision.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "metadata": {"aucs": [0.6502747064208669, 0.5937767296917291, 0.6312134241174933, 0.63652458494246, 0.5778199904085557, 0.6622810441605901, 0.6164083512433034, 0.6451808527141981, 0.5940007693590131, 0.17710934802450828, 0.21079010490361183, 0.21819666175304497, 0.23434173078957743, 0.18885851123423303, 9.999999999998899e-05, 0.27713068780167693, 0.20804399084489744, 0.22170102786202073, 0.14526383297653123, 0.11126983065897389, 0.10298495209812064, 0.11371614372110195, 0.12111298290521444, 0.06833774727767727, 0.1277261399352836, 0.11232842871806936, 0.17003208773905532, 0.10887057204857375, 0.12225732245382626, 0.11803961808051588, 0.11820966023562107, 0.11270270383801728, 0.12851659391420522, 0.1435538272269612, 0.10337227248253111, 0.11326588802489046, 0.9775506775122011, 0.976263609683216, 0.9758779533945103, 0.9683164739977224, 0.968182647504696, 0.9762386622087493, 0.9824762988296557, 0.9676870286635975, 0.9723125831166942, 0.40102483255999855, 0.3531261052465955, 0.3313496015954228, 0.4077762262446445, 0.14795001826953835, 0.37726527772802754, 0.08192768984324461, 0.3156620035926323, 0.34650375197659466, 0.17070152865864963, 0.5738235208580602, 0.16907196347615683, 0.2648105226391706, 0.1873505570654912, 0.19289213390384607, 0.22800722458277933, 0.20279623425701443, 0.6403478231755534, 0.09098229332484242, 0.1693226762221628, 0.18160282419965224, 0.1047515133037552, 0.15997492324729723, 0.12060113516104443, 0.14677492034212025, 0.15692509366612484, 0.16385689941320214, 0.19673168440719524, 0.2460122825736204, 0.18334184812887755, 0.1402768559556793, 0.13047524825828527, 0.16515761957498598, 0.15792645071907208, 0.18904162003211544, 0.1778256728194676, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305326264205069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03613375630039806, 0.0071493850886629184, 0.04772910906682615, 0.038870390883741446, 0.07345423364956061, 0.05669865865478818, 0.013650943564554097, 0.02141993817177823, 0.07740751267390045, 0.07865673247677096, 0.03731434595992178, 0.029763290584301272, 0.03996023844814245, 0.03351926805938621, 0.08634390629045952, 0.04434929647908015, 0.040310239583900564, 0.06267214176751645, 0.08267799300169276, 0.0897584352348525, 0.17316369723598912, 0.08654620492094967, 0.056138535252946875, 0.18097796451648196, 0.11113430040048256, 0.0679809169270702, 0.12611302425285065, 0.09613678782985713, 0.0714508304976822, 0.4332541975279014, 0.4644497429503506, 0.46092134308155097, 0.4643409733786388, 0.4776439456886864, 0.2068551249629511, 0.47009915687763904, 0.43832772710561585, 0.477214690623626, 0.07728441068627712, 0.06969917501705947, 0.06489273933287698, 0.1377519504431275, 0.11548239154144779, 0.12265126946477134, 0.09981120353915574, 0.12349739650589941, 0.09706876260678887, 0.32817573927912413, 0.30110580246605856, 0.33486647374821754, 0.28480388136291523, 0.24980390612029324, 0.29923784507296947, 0.3856535926125634, 0.17684492975363042, 0.20046405273490975, 0.28277885112552126, 0.33123298649486366, 0.293240792951882, 0.21291526852696985, 0.30878868345270616, 0.30733379590482524, 0.34026865991784194, 0.3643670503790909, 0.322515450534391, 0.26417813491308106, 0.234857017267026, 0.2387614641697161, 0.16970683449815083, 0.23391870950409832, 0.2592122321837067, 0.20005708843094172, 0.23257847913532936, 0.23801569099119302, 0.19318077595724048, 0.16083498198634438, 0.20608415085562337, 0.20413468165788629, 0.24756648565724826, 0.19663662147471428, 0.21513159508768975, 0.20016212039557102, 0.21123480802735817, 0.2006755520011677, 0.18953357049701025, 0.22444604292533454, 0.29930137615775865, 0.19984024397970612, 0.21086916334929162, 0.2152005211817839, 0.20803369763377755, 0.22616580193141866, 0.7502874764555849, 0.14036219891569868, 0.1528178557824098, 0.7201016161518212, 0.198530852915066, 0.18340024646058695, 0.14139559524891976, 0.1596198586680584, 0.20323123047539826, 0.5454013317788309, 0.2096296400536063, 0.17132946525458703, 0.4186419343343084, 0.39178507793009076, 0.15090819857656446, 0.47282306111513084, 0.10496036739444514, 0.5428714973451108, 0.19711687573172465, 0.16824991463501682, 0.20077889817140426, 0.22952984662591802, 0.19847094681497313, 0.21345997511314063, 0.18286174028661473, 0.17694689699371613, 0.1799968868842874, 0.08635767187530852, 0.08842272867743317, 0.08267659973134556, 0.08571156643347766, 0.0827351008856072, 0.08156382809211593, 0.08839086084184478, 0.08231517436632407, 0.08270805865030506]}, "mutation_prompt": null}
{"id": "4e641971-15a3-4f04-9782-9487c9f2ef30", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce dynamic parameter adaptation for the DE mutation factor and crossover rate to enhance convergence speed and solution precision.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "metadata": {"aucs": [0.6502747064208669, 0.5937767296917291, 0.6312134241174933, 0.63652458494246, 0.5778199904085557, 0.6622810441605901, 0.6164083512433034, 0.6451808527141981, 0.5940007693590131, 0.17710934802450828, 0.21079010490361183, 0.21819666175304497, 0.23434173078957743, 0.18885851123423303, 9.999999999998899e-05, 0.27713068780167693, 0.20804399084489744, 0.22170102786202073, 0.14526383297653123, 0.11126983065897389, 0.10298495209812064, 0.11371614372110195, 0.12111298290521444, 0.06833774727767727, 0.1277261399352836, 0.11232842871806936, 0.17003208773905532, 0.10887057204857375, 0.12225732245382626, 0.11803961808051588, 0.11820966023562107, 0.11270270383801728, 0.12851659391420522, 0.1435538272269612, 0.10337227248253111, 0.11326588802489046, 0.9775506775122011, 0.976263609683216, 0.9758779533945103, 0.9683164739977224, 0.968182647504696, 0.9762386622087493, 0.9824762988296557, 0.9676870286635975, 0.9723125831166942, 0.40102483255999855, 0.3531261052465955, 0.3313496015954228, 0.4077762262446445, 0.14795001826953835, 0.37726527772802754, 0.08192768984324461, 0.3156620035926323, 0.34650375197659466, 0.17070152865864963, 0.5738235208580602, 0.16907196347615683, 0.2648105226391706, 0.1873505570654912, 0.19289213390384607, 0.22800722458277933, 0.20279623425701443, 0.6403478231755534, 0.09098229332484242, 0.1693226762221628, 0.18160282419965224, 0.1047515133037552, 0.15997492324729723, 0.12060113516104443, 0.14677492034212025, 0.15692509366612484, 0.16385689941320214, 0.19673168440719524, 0.2460122825736204, 0.18334184812887755, 0.1402768559556793, 0.13047524825828527, 0.16515761957498598, 0.15792645071907208, 0.18904162003211544, 0.1778256728194676, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305326264205069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03613375630039806, 0.0071493850886629184, 0.04772910906682615, 0.038870390883741446, 0.07345423364956061, 0.05669865865478818, 0.013650943564554097, 0.02141993817177823, 0.07740751267390045, 0.07865673247677096, 0.03731434595992178, 0.029763290584301272, 0.03996023844814245, 0.03351926805938621, 0.08634390629045952, 0.04434929647908015, 0.040310239583900564, 0.06267214176751645, 0.08267799300169276, 0.0897584352348525, 0.17316369723598912, 0.08654620492094967, 0.056138535252946875, 0.18097796451648196, 0.11113430040048256, 0.0679809169270702, 0.12611302425285065, 0.09613678782985713, 0.0714508304976822, 0.4332541975279014, 0.4644497429503506, 0.46092134308155097, 0.4643409733786388, 0.4776439456886864, 0.2068551249629511, 0.47009915687763904, 0.43832772710561585, 0.477214690623626, 0.07728441068627712, 0.06969917501705947, 0.06489273933287698, 0.1377519504431275, 0.11548239154144779, 0.12265126946477134, 0.09981120353915574, 0.12349739650589941, 0.09706876260678887, 0.32817573927912413, 0.30110580246605856, 0.33486647374821754, 0.28480388136291523, 0.24980390612029324, 0.29923784507296947, 0.3856535926125634, 0.17684492975363042, 0.20046405273490975, 0.28277885112552126, 0.33123298649486366, 0.293240792951882, 0.21291526852696985, 0.30878868345270616, 0.30733379590482524, 0.34026865991784194, 0.3643670503790909, 0.322515450534391, 0.26417813491308106, 0.234857017267026, 0.2387614641697161, 0.16970683449815083, 0.23391870950409832, 0.2592122321837067, 0.20005708843094172, 0.23257847913532936, 0.23801569099119302, 0.19318077595724048, 0.16083498198634438, 0.20608415085562337, 0.20413468165788629, 0.24756648565724826, 0.19663662147471428, 0.21513159508768975, 0.20016212039557102, 0.21123480802735817, 0.2006755520011677, 0.18953357049701025, 0.22444604292533454, 0.29930137615775865, 0.19984024397970612, 0.21086916334929162, 0.2152005211817839, 0.20803369763377755, 0.22616580193141866, 0.7502874764555849, 0.14036219891569868, 0.1528178557824098, 0.7201016161518212, 0.198530852915066, 0.18340024646058695, 0.14139559524891976, 0.1596198586680584, 0.20323123047539826, 0.5454013317788309, 0.2096296400536063, 0.17132946525458703, 0.4186419343343084, 0.39178507793009076, 0.15090819857656446, 0.47282306111513084, 0.10496036739444514, 0.5428714973451108, 0.19711687573172465, 0.16824991463501682, 0.20077889817140426, 0.22952984662591802, 0.19847094681497313, 0.21345997511314063, 0.18286174028661473, 0.17694689699371613, 0.1799968868842874, 0.08635767187530852, 0.08842272867743317, 0.08267659973134556, 0.08571156643347766, 0.0827351008856072, 0.08156382809211593, 0.08839086084184478, 0.08231517436632407, 0.08270805865030506]}, "mutation_prompt": null}
{"id": "d9a883d7-fd14-4c25-b1f9-52d3c9b501bf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Start with a higher inertia weight\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        # Adaptive inertia weight\n        self.inertia_weight = max(0.4, self.inertia_weight - 0.001 * (self.inertia_weight - 0.4))\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight for the PSO component to enhance exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.16597253056127617, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "metadata": {"aucs": [0.2907383106803141, 0.28199176805162474, 0.28919602508041087, 0.3307766155508749, 0.3451815178531077, 0.3641934822596774, 0.37090436917783554, 0.3159578086810939, 0.3281983313094504, 0.021902877209052707, 0.002644386476256977, 0.0017732969283827948, 9.999999999998899e-05, 0.004676359966610311, 0.004474923510765061, 0.0011742491949428002, 0.014345611134448544, 0.014611554554633588, 0.0818779437050734, 0.07704333196094448, 0.08039558069377639, 0.07319042103535234, 0.07102767443943936, 0.06984875326757078, 0.07578203283457352, 0.08464163249586798, 0.07607983208403679, 0.08092066706684764, 0.06293641878510114, 0.06166376762873149, 0.06756025678819899, 0.06322262491714792, 0.07084460557040129, 0.06781936390251608, 0.06404716528763854, 0.06523002001708678, 0.9830923820985071, 0.9768767526737852, 0.9771355486925836, 0.9683994654059115, 0.9686988560062832, 0.974350960486193, 0.9825463452701815, 0.975649053913978, 0.9764847263744982, 0.19095121886192334, 0.20047413014636406, 0.05702012510689747, 0.15811563690847397, 0.13497183423998937, 0.16335898094530343, 0.07893790831311742, 0.11669671048158403, 0.08217680081997225, 0.1703714968530159, 0.16929437885677967, 0.16878198408470813, 0.19952135049374053, 0.18510027363994896, 0.18727870906249455, 0.20625780310297848, 0.18969060866220766, 0.2047011925555392, 0.07127057630338618, 0.0856556740349752, 0.07488565544123305, 0.0747268315896008, 0.05816819690606667, 0.09974265718196462, 0.0780957793776772, 0.10659614862603906, 0.12124480859994868, 0.07266488708649399, 0.10194984702086918, 0.07989695638665018, 0.09104264768117665, 0.08282194893105355, 0.06854781737126636, 0.11300390661832227, 0.06729826905165281, 0.08974917514331171, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04011584395451295, 0.057315459387122236, 0.05246183213019717, 0.057400298244627446, 9.999999999998899e-05, 0.0019450645679018885, 0.05921995493363719, 0.02370796749119386, 0.0019100461647669764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00155522918270945, 9.999999999998899e-05, 9.999999999998899e-05, 0.04369132512536722, 0.019495326677701263, 0.02597644187716308, 0.056252917302723526, 0.06057779551085041, 0.0010969067321726644, 0.05241038409289234, 0.040839297196848756, 0.04233007836909586, 0.3193177528139065, 0.2969771750807967, 0.3109371048877043, 0.31338853426047186, 0.31448598757636514, 0.20439309327749666, 0.3124550349539007, 0.27582742028728224, 0.29743868529294415, 0.058182865240136716, 0.07660111140393433, 0.09344202026362236, 0.08595486607308211, 0.07949785106619711, 0.08425680882404141, 0.07321767370092325, 0.08821584389439052, 0.0843603561548707, 0.19371219656510974, 0.21169049502129045, 0.17794784520111484, 0.1357197339983106, 0.17438115559758793, 0.17366940878325077, 0.16900021217247252, 0.1366804489945176, 0.1796813799603466, 0.22576404300195507, 0.23401145652803512, 0.2073928337412505, 0.21782332307183683, 0.1798830598029827, 0.21797975771355516, 0.2278648862802527, 0.23112851631435838, 0.2274152460743506, 0.17289965619892012, 0.1440225396238326, 0.1642253371941126, 0.12159602660350532, 0.18150174776325, 0.18641526854093027, 0.17463257056284076, 0.18127238874237783, 0.18372332547059922, 0.2379568450537909, 0.1926935743643603, 0.19393342692187365, 0.1749558598556814, 0.18457494053786017, 0.17095604431053124, 0.19121696464951243, 0.1709529492559857, 0.18336355808032756, 0.16830233954251905, 0.17260631400658422, 0.18236203284265595, 0.20542747776753434, 0.17452490967205025, 0.16892953777626263, 0.1787354274891737, 0.1824261653098601, 0.18672303627210984, 0.1605569869586676, 0.16157640773441506, 0.15200407176404862, 0.3887938327310776, 0.19313230831470563, 0.1659118808337504, 0.13597329723349816, 0.18425222396916785, 0.19862058398281213, 0.2768056636153171, 0.1949697677100255, 0.2921575889216791, 0.22069473086148417, 0.21828244009581443, 0.20891327739906307, 0.23442335127251102, 0.20023179310694905, 0.18274075586477323, 0.1800717894094801, 0.18828201893819174, 0.18385297324077754, 0.18737051939064653, 0.1883004239421764, 0.17554329417337744, 0.18947072635891837, 0.17808773139751843, 0.1784758366044229, 0.058898834151492, 0.06348626891624387, 0.07337971335764681, 0.0697053659539757, 0.0632211533232725, 0.0679542176292316, 0.07567731063504501, 0.06937876383847574, 0.06586948287139205]}, "mutation_prompt": null}
{"id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance diversity with adaptive inertia weight and population seeding near the best solution.", "configspace": "", "generation": 58, "fitness": 0.27332048723896585, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "94adc843-66de-4de0-ac75-c13f52cb89e8", "metadata": {"aucs": [0.759884430892632, 0.7659215137669244, 0.7614769299599582, 0.7421374888399332, 0.7194210739442966, 0.7430249826105422, 0.7190402131522491, 0.7397863140713441, 0.7310960820230058, 0.2907084279993015, 0.18592625889585024, 0.34544915066106674, 0.3964549816929289, 0.3130806037872039, 0.3564623968931522, 0.36695140444037255, 0.23147368503083354, 0.3544168459639885, 0.1374456328546998, 0.12612354541852933, 0.12268717451692301, 0.14910034246568304, 0.15178841706099722, 0.14618136573486573, 0.16171001097136117, 0.15269156603436096, 0.140893180959492, 0.10758633115345306, 0.1278850238586572, 0.13748163494558518, 0.11159125325636454, 0.14575502135481855, 0.1397755763469526, 0.10174444604145028, 0.13031182010860265, 0.15520547742791335, 0.9756412623419741, 0.969227495768886, 0.9750121475123386, 0.9684157150234013, 0.9665609881494607, 0.9748780211013952, 0.9808899304866093, 0.9676027975299064, 0.9738612210351456, 0.45876926668245055, 0.5012776767887505, 0.1619911618138945, 0.4633689563084451, 0.3587880637516251, 0.45833489938057015, 0.2654659461482797, 0.31945434372064374, 0.43326902166280135, 0.22515855650673877, 0.16952078894353817, 0.1704728099561138, 0.19396675772089422, 0.27327954504368424, 0.1929236443474468, 0.3589076661875059, 0.7989172347738658, 0.7730953437132916, 0.12673438245530066, 0.12243815017063842, 0.19331446169762234, 0.09741593102128976, 0.18472864959579038, 0.1625530637129523, 0.121306353560107, 0.18203404511090215, 0.19748741462494668, 0.1970874710969095, 0.18692986548101187, 0.21963822980885384, 0.19780649119245497, 0.19671611310415715, 0.16035699868804254, 0.21579956051628268, 0.2255775652987989, 0.15010411241566657, 0.002403121526577512, 9.999999999998899e-05, 9.999999999998899e-05, 0.028141468261595914, 0.008329943284181018, 9.999999999998899e-05, 9.999999999998899e-05, 0.06477904859275463, 0.06840960706882926, 0.037201786210876886, 0.05432593365227911, 0.049203626920490406, 0.061985690071682975, 0.030312225833161177, 0.014167091740927562, 0.059603834768622965, 0.0995442439696963, 0.04979059872386116, 0.041672331015219055, 9.999999999998899e-05, 0.0934704382334286, 0.07124738534750685, 0.16020187335408065, 0.18040694669574098, 0.09660579023138294, 0.12461470797424867, 0.062000319215137045, 0.09382568087612653, 0.11746719215556334, 0.21034521400921857, 0.06974146689725713, 0.06672151665547754, 0.09657047822068776, 0.07753862919123677, 0.1269787929604831, 0.07976733629170663, 0.5111611653216979, 0.487253311431334, 0.5135459612372895, 0.5370092907789913, 0.5198913434245678, 0.4918467290007439, 0.48172185410812085, 0.476560425488341, 0.5283674576833054, 0.12867122095424732, 0.08051075382442918, 0.1393709946134961, 0.1078345612553876, 0.14459817370818273, 0.10312102071108198, 0.135659053925833, 0.10708780299034149, 0.1698092066989102, 0.2376576629586168, 0.3717772377395656, 0.2038011644178196, 0.29503699805051453, 0.43879932816499034, 0.27855866287173525, 0.31714188041659486, 0.3208835384248432, 0.2518615996114112, 0.3161882754096147, 0.2957327128428292, 0.35533597796443095, 0.37872993878133776, 0.3656147928425014, 0.3968475916365404, 0.43831694717779557, 0.40204656450144616, 0.32301397049538305, 0.29087290967557355, 0.2307866512647455, 0.30754218500754704, 0.2905662479337453, 0.31549435023180405, 0.2468424753215438, 0.2823260527019892, 0.25859670245872546, 0.32203981391071224, 0.20744344489277278, 0.2079657759488509, 0.20298181164182538, 0.2134290682580242, 0.20624628688530844, 0.17782937530540965, 0.2600251027245194, 0.2015197461117626, 0.21780514650527272, 0.20568871913729492, 0.3548972516942521, 0.4486569105449496, 0.22341184433951822, 0.2097574660879824, 0.24026002589281836, 0.24500405011929538, 0.2127178067764789, 0.22103439968053817, 0.854083424566897, 0.15650892752656842, 0.15349938857129142, 0.8457617834610298, 0.19980944520664579, 0.16595330329814384, 0.1418353201933482, 0.1651838028843915, 0.18554737084235495, 0.7201624669897666, 0.2090722247556861, 0.07212118658034339, 0.20741394505050637, 0.16856768997867078, 0.15390338819356475, 0.10466873679620314, 0.10513345550947961, 0.6052342352601257, 0.18110044175532003, 0.19172133151550608, 0.19320089344837055, 0.19391097880941133, 0.1938968601223272, 0.18370883849627484, 0.1997860851814358, 0.1729701487932247, 0.21650603788483924, 0.10046302164992904, 0.09442288036748447, 0.08438054634812542, 0.09056696517480067, 0.09985391872047222, 0.08483853442293221, 0.08579978647183473, 0.08238280118125463, 0.08652323805280826]}, "mutation_prompt": null}
{"id": "b190c8aa-5c24-4f46-b3fe-4f98a89f3a1c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance diversity with adaptive inertia weight and population seeding near the best solution.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.759884430892632, 0.7659215137669244, 0.7614769299599582, 0.7421374888399332, 0.7194210739442966, 0.7430249826105422, 0.7190402131522491, 0.7397863140713441, 0.7310960820230058, 0.2907084279993015, 0.18592625889585024, 0.34544915066106674, 0.3964549816929289, 0.3130806037872039, 0.3564623968931522, 0.36695140444037255, 0.23147368503083354, 0.3544168459639885, 0.1374456328546998, 0.12612354541852933, 0.12268717451692301, 0.14910034246568304, 0.15178841706099722, 0.14618136573486573, 0.16171001097136117, 0.15269156603436096, 0.140893180959492, 0.10758633115345306, 0.1278850238586572, 0.13748163494558518, 0.11159125325636454, 0.14575502135481855, 0.1397755763469526, 0.10174444604145028, 0.13031182010860265, 0.15520547742791335, 0.9756412623419741, 0.969227495768886, 0.9750121475123386, 0.9684157150234013, 0.9665609881494607, 0.9748780211013952, 0.9808899304866093, 0.9676027975299064, 0.9738612210351456, 0.45876926668245055, 0.5012776767887505, 0.1619911618138945, 0.4633689563084451, 0.3587880637516251, 0.45833489938057015, 0.2654659461482797, 0.31945434372064374, 0.43326902166280135, 0.22515855650673877, 0.16952078894353817, 0.1704728099561138, 0.19396675772089422, 0.27327954504368424, 0.1929236443474468, 0.3589076661875059, 0.7989172347738658, 0.7730953437132916, 0.12673438245530066, 0.12243815017063842, 0.19331446169762234, 0.09741593102128976, 0.18472864959579038, 0.1625530637129523, 0.121306353560107, 0.18203404511090215, 0.19748741462494668, 0.1970874710969095, 0.18692986548101187, 0.21963822980885384, 0.19780649119245497, 0.19671611310415715, 0.16035699868804254, 0.21579956051628268, 0.2255775652987989, 0.15010411241566657, 0.002403121526577512, 9.999999999998899e-05, 9.999999999998899e-05, 0.028141468261595914, 0.008329943284181018, 9.999999999998899e-05, 9.999999999998899e-05, 0.06477904859275463, 0.06840960706882926, 0.037201786210876886, 0.05432593365227911, 0.049203626920490406, 0.061985690071682975, 0.030312225833161177, 0.014167091740927562, 0.059603834768622965, 0.0995442439696963, 0.04979059872386116, 0.041672331015219055, 9.999999999998899e-05, 0.0934704382334286, 0.07124738534750685, 0.16020187335408065, 0.18040694669574098, 0.09660579023138294, 0.12461470797424867, 0.062000319215137045, 0.09382568087612653, 0.11746719215556334, 0.21034521400921857, 0.06974146689725713, 0.06672151665547754, 0.09657047822068776, 0.07753862919123677, 0.1269787929604831, 0.07976733629170663, 0.5111611653216979, 0.487253311431334, 0.5135459612372895, 0.5370092907789913, 0.5198913434245678, 0.4918467290007439, 0.48172185410812085, 0.476560425488341, 0.5283674576833054, 0.12867122095424732, 0.08051075382442918, 0.1393709946134961, 0.1078345612553876, 0.14459817370818273, 0.10312102071108198, 0.135659053925833, 0.10708780299034149, 0.1698092066989102, 0.2376576629586168, 0.3717772377395656, 0.2038011644178196, 0.29503699805051453, 0.43879932816499034, 0.27855866287173525, 0.31714188041659486, 0.3208835384248432, 0.2518615996114112, 0.3161882754096147, 0.2957327128428292, 0.35533597796443095, 0.37872993878133776, 0.3656147928425014, 0.3968475916365404, 0.43831694717779557, 0.40204656450144616, 0.32301397049538305, 0.29087290967557355, 0.2307866512647455, 0.30754218500754704, 0.2905662479337453, 0.31549435023180405, 0.2468424753215438, 0.2823260527019892, 0.25859670245872546, 0.32203981391071224, 0.20744344489277278, 0.2079657759488509, 0.20298181164182538, 0.2134290682580242, 0.20624628688530844, 0.17782937530540965, 0.2600251027245194, 0.2015197461117626, 0.21780514650527272, 0.20568871913729492, 0.3548972516942521, 0.4486569105449496, 0.22341184433951822, 0.2097574660879824, 0.24026002589281836, 0.24500405011929538, 0.2127178067764789, 0.22103439968053817, 0.854083424566897, 0.15650892752656842, 0.15349938857129142, 0.8457617834610298, 0.19980944520664579, 0.16595330329814384, 0.1418353201933482, 0.1651838028843915, 0.18554737084235495, 0.7201624669897666, 0.2090722247556861, 0.07212118658034339, 0.20741394505050637, 0.16856768997867078, 0.15390338819356475, 0.10466873679620314, 0.10513345550947961, 0.6052342352601257, 0.18110044175532003, 0.19172133151550608, 0.19320089344837055, 0.19391097880941133, 0.1938968601223272, 0.18370883849627484, 0.1997860851814358, 0.1729701487932247, 0.21650603788483924, 0.10046302164992904, 0.09442288036748447, 0.08438054634812542, 0.09056696517480067, 0.09985391872047222, 0.08483853442293221, 0.08579978647183473, 0.08238280118125463, 0.08652323805280826]}, "mutation_prompt": null}
{"id": "2fae0db7-3ac8-46cd-bc95-a358ea483c73", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance diversity with adaptive inertia weight and population seeding near the best solution.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.759884430892632, 0.7659215137669244, 0.7614769299599582, 0.7421374888399332, 0.7194210739442966, 0.7430249826105422, 0.7190402131522491, 0.7397863140713441, 0.7310960820230058, 0.2907084279993015, 0.18592625889585024, 0.34544915066106674, 0.3964549816929289, 0.3130806037872039, 0.3564623968931522, 0.36695140444037255, 0.23147368503083354, 0.3544168459639885, 0.1374456328546998, 0.12612354541852933, 0.12268717451692301, 0.14910034246568304, 0.15178841706099722, 0.14618136573486573, 0.16171001097136117, 0.15269156603436096, 0.140893180959492, 0.10758633115345306, 0.1278850238586572, 0.13748163494558518, 0.11159125325636454, 0.14575502135481855, 0.1397755763469526, 0.10174444604145028, 0.13031182010860265, 0.15520547742791335, 0.9756412623419741, 0.969227495768886, 0.9750121475123386, 0.9684157150234013, 0.9665609881494607, 0.9748780211013952, 0.9808899304866093, 0.9676027975299064, 0.9738612210351456, 0.45876926668245055, 0.5012776767887505, 0.1619911618138945, 0.4633689563084451, 0.3587880637516251, 0.45833489938057015, 0.2654659461482797, 0.31945434372064374, 0.43326902166280135, 0.22515855650673877, 0.16952078894353817, 0.1704728099561138, 0.19396675772089422, 0.27327954504368424, 0.1929236443474468, 0.3589076661875059, 0.7989172347738658, 0.7730953437132916, 0.12673438245530066, 0.12243815017063842, 0.19331446169762234, 0.09741593102128976, 0.18472864959579038, 0.1625530637129523, 0.121306353560107, 0.18203404511090215, 0.19748741462494668, 0.1970874710969095, 0.18692986548101187, 0.21963822980885384, 0.19780649119245497, 0.19671611310415715, 0.16035699868804254, 0.21579956051628268, 0.2255775652987989, 0.15010411241566657, 0.002403121526577512, 9.999999999998899e-05, 9.999999999998899e-05, 0.028141468261595914, 0.008329943284181018, 9.999999999998899e-05, 9.999999999998899e-05, 0.06477904859275463, 0.06840960706882926, 0.037201786210876886, 0.05432593365227911, 0.049203626920490406, 0.061985690071682975, 0.030312225833161177, 0.014167091740927562, 0.059603834768622965, 0.0995442439696963, 0.04979059872386116, 0.041672331015219055, 9.999999999998899e-05, 0.0934704382334286, 0.07124738534750685, 0.16020187335408065, 0.18040694669574098, 0.09660579023138294, 0.12461470797424867, 0.062000319215137045, 0.09382568087612653, 0.11746719215556334, 0.21034521400921857, 0.06974146689725713, 0.06672151665547754, 0.09657047822068776, 0.07753862919123677, 0.1269787929604831, 0.07976733629170663, 0.5111611653216979, 0.487253311431334, 0.5135459612372895, 0.5370092907789913, 0.5198913434245678, 0.4918467290007439, 0.48172185410812085, 0.476560425488341, 0.5283674576833054, 0.12867122095424732, 0.08051075382442918, 0.1393709946134961, 0.1078345612553876, 0.14459817370818273, 0.10312102071108198, 0.135659053925833, 0.10708780299034149, 0.1698092066989102, 0.2376576629586168, 0.3717772377395656, 0.2038011644178196, 0.29503699805051453, 0.43879932816499034, 0.27855866287173525, 0.31714188041659486, 0.3208835384248432, 0.2518615996114112, 0.3161882754096147, 0.2957327128428292, 0.35533597796443095, 0.37872993878133776, 0.3656147928425014, 0.3968475916365404, 0.43831694717779557, 0.40204656450144616, 0.32301397049538305, 0.29087290967557355, 0.2307866512647455, 0.30754218500754704, 0.2905662479337453, 0.31549435023180405, 0.2468424753215438, 0.2823260527019892, 0.25859670245872546, 0.32203981391071224, 0.20744344489277278, 0.2079657759488509, 0.20298181164182538, 0.2134290682580242, 0.20624628688530844, 0.17782937530540965, 0.2600251027245194, 0.2015197461117626, 0.21780514650527272, 0.20568871913729492, 0.3548972516942521, 0.4486569105449496, 0.22341184433951822, 0.2097574660879824, 0.24026002589281836, 0.24500405011929538, 0.2127178067764789, 0.22103439968053817, 0.854083424566897, 0.15650892752656842, 0.15349938857129142, 0.8457617834610298, 0.19980944520664579, 0.16595330329814384, 0.1418353201933482, 0.1651838028843915, 0.18554737084235495, 0.7201624669897666, 0.2090722247556861, 0.07212118658034339, 0.20741394505050637, 0.16856768997867078, 0.15390338819356475, 0.10466873679620314, 0.10513345550947961, 0.6052342352601257, 0.18110044175532003, 0.19172133151550608, 0.19320089344837055, 0.19391097880941133, 0.1938968601223272, 0.18370883849627484, 0.1997860851814358, 0.1729701487932247, 0.21650603788483924, 0.10046302164992904, 0.09442288036748447, 0.08438054634812542, 0.09056696517480067, 0.09985391872047222, 0.08483853442293221, 0.08579978647183473, 0.08238280118125463, 0.08652323805280826]}, "mutation_prompt": null}
{"id": "b0f59f9b-255c-4aa6-8f13-5b3020ff11b4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            # Adaptive mutation factor based on distance from gbest\n            adaptive_f = self.f * (1 + np.linalg.norm(self.population[i] - self.gbest) / (self.upper_bound - self.lower_bound))\n            mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Integrate an adaptive mutation strategy into Differential Evolution to enhance exploration capabilities.", "configspace": "", "generation": 61, "fitness": 0.26095659998252735, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.7548051205844574, 0.7358972333969884, 0.7581923597917338, 0.7157130638181437, 0.7482230820872262, 0.7449473730177041, 0.7565685934494442, 0.7311359602974918, 0.7296745736637369, 0.32309860007743063, 0.32799170887860896, 0.28337095174433025, 0.36441383729258026, 0.37562175955631605, 0.2970452064872776, 0.3489924760061335, 0.35496911593281466, 0.24165502724151322, 0.16479346469367795, 0.1764927966406964, 0.13702077638716914, 0.13993962363886037, 0.14569359392250825, 0.06934817134826932, 0.11300511153931658, 0.13687066103229495, 0.1375329439626788, 0.12529917547185454, 0.10411610294990514, 0.1550498479360244, 0.1102632533977923, 0.153219520798351, 0.09645673008286959, 0.09489166992824483, 0.14512671496230634, 0.13061331591128078, 0.9771888666914419, 0.9766610010693096, 0.9683104401465563, 0.976526973874456, 0.9679659147161326, 0.9746280248559436, 0.9781540466437328, 0.9698836979802787, 0.976501292478279, 0.4715472272572576, 0.426849397177686, 0.05832964655493256, 0.41736867417944057, 0.45500580508145905, 0.4161347265772225, 0.1256086021717311, 0.4195681172112897, 0.3390086011211253, 0.811992475042128, 0.2197670917813055, 0.22549537625915006, 0.20790674635036188, 0.21241877926908614, 0.2033631351870827, 0.22486487950583744, 0.22760811344025167, 0.22802500337981746, 0.19245538678293173, 0.13632640578097033, 0.1620187041286978, 0.09915904648923446, 0.19711058927071612, 0.1794460504849098, 0.16885955172500056, 0.22721399786660434, 0.19136943789206418, 0.12847781589860607, 0.19754357505165565, 0.20155492027622823, 0.2267661688136593, 0.16813817500937744, 0.21568093187821602, 0.21917662831456253, 0.17165761992440332, 0.1766743393615483, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00036748027673583206, 0.019114384180596078, 9.999999999998899e-05, 0.012736251023172551, 9.999999999998899e-05, 0.10952988788534257, 0.12364118626570764, 0.04722756915199211, 0.0915387490317553, 0.04136719295954483, 0.016794318863655677, 0.017659985612297868, 0.06946637445508697, 0.06913193701339226, 0.04819682137913517, 0.13520723983805805, 0.029573039519606548, 0.04176205452695991, 0.06498492871387884, 0.05945965191078617, 0.10600680737039381, 0.10281895477480374, 0.09727179430666022, 0.08037393283732341, 0.21834633208976273, 0.1684000023866674, 0.11263035536259236, 0.06145749073191842, 0.0368433619779549, 0.15009527841808445, 0.07776958416941981, 0.0780782735542156, 0.0785620452914767, 0.4744329561764621, 0.531844756726635, 0.47619926255543754, 0.5665854916722061, 0.5157423757810622, 0.20695363527272415, 0.5048824088722377, 0.5122961931581062, 0.5450786064111173, 0.16982058632105146, 0.12652998455083542, 0.07996303813412264, 0.1081108572277506, 0.11847127971752647, 0.10119929956961782, 0.10544106402234488, 0.14476062887619934, 0.12113880274854816, 0.19113088541611722, 0.3229204439489176, 0.16965612278784026, 0.31877123121021944, 0.21105821493392052, 0.3019158119334251, 0.2535804156921243, 0.1940635819544292, 0.2018748393876062, 0.3538291859544125, 0.3278240356803176, 0.32168761695638937, 0.354884072705303, 0.2890819427394875, 0.31727194713018103, 0.3683310788363173, 0.3935559375461203, 0.37509100602590595, 0.25073848679532706, 0.2802655152494965, 0.26065672370765847, 0.20351532670363937, 0.169405547363498, 0.21936782362727758, 0.2721851407493283, 0.3586641234952572, 0.26510068202821446, 0.27046433771621503, 0.1898594504469654, 0.2016771730368725, 0.21154216253285074, 0.20518904828347095, 0.19527561393115267, 0.19631324481793155, 0.20564427367261717, 0.2042126992272989, 0.19892439230734893, 0.2184641118995434, 0.19962868358616148, 0.23355170332790476, 0.19840205308621695, 0.21643673157302412, 0.47914881972182544, 0.18641836279047497, 0.19936137630575612, 0.807291968661211, 0.15616457967711617, 0.1534578533472577, 0.8786208615274846, 0.19930978394092913, 0.1661352131368714, 0.14154566253524314, 0.16286447780134328, 0.21044944862633486, 0.8376743791637034, 0.21024866677708287, 0.07210218516267541, 0.20559076292499634, 0.16816705934418374, 0.15236169997214888, 0.10431563399842358, 0.10518065952437516, 0.15426666145310297, 0.22166135302745937, 0.17786329454180683, 0.1991632448815256, 0.1904242580351181, 0.18412544938891584, 0.19270648302051463, 0.1891496643279863, 0.17153230090651195, 0.2056707127472438, 0.085887370156559, 0.08255927009288355, 0.08352676508633705, 0.09727353545837336, 0.08515793677421535, 0.07770419327323674, 0.08291571606576476, 0.08306716805371184, 0.0928213314372206]}, "mutation_prompt": null}
{"id": "4d2b2d6d-faa7-452f-9688-01357b59b78f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance diversity with adaptive inertia weight and population seeding near the best solution.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.759884430892632, 0.7659215137669244, 0.7614769299599582, 0.7421374888399332, 0.7194210739442966, 0.7430249826105422, 0.7190402131522491, 0.7397863140713441, 0.7310960820230058, 0.2907084279993015, 0.18592625889585024, 0.34544915066106674, 0.3964549816929289, 0.3130806037872039, 0.3564623968931522, 0.36695140444037255, 0.23147368503083354, 0.3544168459639885, 0.1374456328546998, 0.12612354541852933, 0.12268717451692301, 0.14910034246568304, 0.15178841706099722, 0.14618136573486573, 0.16171001097136117, 0.15269156603436096, 0.140893180959492, 0.10758633115345306, 0.1278850238586572, 0.13748163494558518, 0.11159125325636454, 0.14575502135481855, 0.1397755763469526, 0.10174444604145028, 0.13031182010860265, 0.15520547742791335, 0.9756412623419741, 0.969227495768886, 0.9750121475123386, 0.9684157150234013, 0.9665609881494607, 0.9748780211013952, 0.9808899304866093, 0.9676027975299064, 0.9738612210351456, 0.45876926668245055, 0.5012776767887505, 0.1619911618138945, 0.4633689563084451, 0.3587880637516251, 0.45833489938057015, 0.2654659461482797, 0.31945434372064374, 0.43326902166280135, 0.22515855650673877, 0.16952078894353817, 0.1704728099561138, 0.19396675772089422, 0.27327954504368424, 0.1929236443474468, 0.3589076661875059, 0.7989172347738658, 0.7730953437132916, 0.12673438245530066, 0.12243815017063842, 0.19331446169762234, 0.09741593102128976, 0.18472864959579038, 0.1625530637129523, 0.121306353560107, 0.18203404511090215, 0.19748741462494668, 0.1970874710969095, 0.18692986548101187, 0.21963822980885384, 0.19780649119245497, 0.19671611310415715, 0.16035699868804254, 0.21579956051628268, 0.2255775652987989, 0.15010411241566657, 0.002403121526577512, 9.999999999998899e-05, 9.999999999998899e-05, 0.028141468261595914, 0.008329943284181018, 9.999999999998899e-05, 9.999999999998899e-05, 0.06477904859275463, 0.06840960706882926, 0.037201786210876886, 0.05432593365227911, 0.049203626920490406, 0.061985690071682975, 0.030312225833161177, 0.014167091740927562, 0.059603834768622965, 0.0995442439696963, 0.04979059872386116, 0.041672331015219055, 9.999999999998899e-05, 0.0934704382334286, 0.07124738534750685, 0.16020187335408065, 0.18040694669574098, 0.09660579023138294, 0.12461470797424867, 0.062000319215137045, 0.09382568087612653, 0.11746719215556334, 0.21034521400921857, 0.06974146689725713, 0.06672151665547754, 0.09657047822068776, 0.07753862919123677, 0.1269787929604831, 0.07976733629170663, 0.5111611653216979, 0.487253311431334, 0.5135459612372895, 0.5370092907789913, 0.5198913434245678, 0.4918467290007439, 0.48172185410812085, 0.476560425488341, 0.5283674576833054, 0.12867122095424732, 0.08051075382442918, 0.1393709946134961, 0.1078345612553876, 0.14459817370818273, 0.10312102071108198, 0.135659053925833, 0.10708780299034149, 0.1698092066989102, 0.2376576629586168, 0.3717772377395656, 0.2038011644178196, 0.29503699805051453, 0.43879932816499034, 0.27855866287173525, 0.31714188041659486, 0.3208835384248432, 0.2518615996114112, 0.3161882754096147, 0.2957327128428292, 0.35533597796443095, 0.37872993878133776, 0.3656147928425014, 0.3968475916365404, 0.43831694717779557, 0.40204656450144616, 0.32301397049538305, 0.29087290967557355, 0.2307866512647455, 0.30754218500754704, 0.2905662479337453, 0.31549435023180405, 0.2468424753215438, 0.2823260527019892, 0.25859670245872546, 0.32203981391071224, 0.20744344489277278, 0.2079657759488509, 0.20298181164182538, 0.2134290682580242, 0.20624628688530844, 0.17782937530540965, 0.2600251027245194, 0.2015197461117626, 0.21780514650527272, 0.20568871913729492, 0.3548972516942521, 0.4486569105449496, 0.22341184433951822, 0.2097574660879824, 0.24026002589281836, 0.24500405011929538, 0.2127178067764789, 0.22103439968053817, 0.854083424566897, 0.15650892752656842, 0.15349938857129142, 0.8457617834610298, 0.19980944520664579, 0.16595330329814384, 0.1418353201933482, 0.1651838028843915, 0.18554737084235495, 0.7201624669897666, 0.2090722247556861, 0.07212118658034339, 0.20741394505050637, 0.16856768997867078, 0.15390338819356475, 0.10466873679620314, 0.10513345550947961, 0.6052342352601257, 0.18110044175532003, 0.19172133151550608, 0.19320089344837055, 0.19391097880941133, 0.1938968601223272, 0.18370883849627484, 0.1997860851814358, 0.1729701487932247, 0.21650603788483924, 0.10046302164992904, 0.09442288036748447, 0.08438054634812542, 0.09056696517480067, 0.09985391872047222, 0.08483853442293221, 0.08579978647183473, 0.08238280118125463, 0.08652323805280826]}, "mutation_prompt": null}
{"id": "ee033a6b-6f2d-4fae-a83f-1d5ce04388e4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.cognitive_coeff = 1.0 + 1.0 * (self.evaluations / self.budget)  # Adjust cognitive coefficient\n            self.social_coeff = 2.0 - 1.0 * (self.evaluations / self.budget)  # Adjust social coefficient\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Improve convergence by dynamically adjusting cognitive and social coefficients based on evaluations.", "configspace": "", "generation": 63, "fitness": 0.25740899440689724, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.7573960867012662, 0.7449755446696164, 0.7335841881992616, 0.7383237716998152, 0.7584314257473482, 0.732086657462342, 0.7557897951226922, 0.7632168900467635, 0.7196076791186936, 0.3052870598538465, 0.07127448715363649, 9.999999999998899e-05, 0.2640030581206807, 0.04166998034706104, 0.41881150876410744, 0.3291636819374695, 0.35472068564995574, 0.2866112966240214, 0.11198252245139262, 0.11306144735893153, 0.1250420299202265, 0.1111514590408309, 0.07565492662305229, 0.07475520939368197, 0.1375319024869266, 0.1429456795059174, 0.05773022034306219, 0.09772531894499148, 0.0963435032526877, 0.1007440655721612, 0.10902489823450356, 0.1461529872286379, 0.1349224493144764, 0.1448360956449426, 0.11970156254307784, 0.11179078385091867, 0.9807313603668872, 0.9767618042453454, 0.9770710429180374, 0.9679903453244085, 0.9748791480235489, 0.9769085652330161, 0.9825330909083816, 0.98455570009509, 0.9769897463271703, 0.4202737330986063, 0.4525486575965164, 0.41396821066762457, 0.355027366261357, 0.4091460346208049, 0.4023577470453108, 0.12480852543903498, 0.45284190097863497, 0.12641191175756428, 0.22416199492779643, 0.13619369480439547, 0.13618410260863234, 0.19305363668571895, 0.20425602135387888, 0.18963745793932896, 0.17368575557560728, 0.13825915462762517, 0.14943753730067488, 0.19838007180084194, 0.09777007081486322, 0.18143648520646194, 0.21393807733255443, 0.17881038964580254, 0.13387454701253643, 0.17727633867468862, 0.2006114305862876, 0.17434795881687537, 0.1956297789063064, 0.2150202061436105, 0.11821785287438469, 0.20928308528030115, 0.2095633248502774, 0.17615863783227292, 0.19673310590298698, 0.033302293015892825, 0.23626600866064318, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029808735202798586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02794629901540535, 9.999999999998899e-05, 0.06621885807057315, 0.04295796966077092, 0.06810832019217272, 0.05424598254913271, 0.00010507799690240294, 0.03139939386394941, 0.06626972038308265, 0.05871831951823603, 0.031480830912794966, 0.02993090247889396, 9.999999999998899e-05, 0.09880438680279635, 0.06487706475653177, 0.07418646125813644, 0.08694429007722915, 0.0808855924846763, 0.05799796986411365, 0.058409491690901816, 0.1094252650912656, 0.03884653467111965, 0.1962144564306213, 0.006120933907134529, 0.17036648181837477, 0.2359017325300129, 0.09396989180491222, 0.05460812280969041, 0.07625981288599182, 0.49185788108867357, 0.46793802184250255, 0.47477806499189046, 0.20873413413656494, 0.4728952324340878, 0.4785336079737783, 0.5041884910193669, 0.49794323019638875, 0.5037811816032766, 0.09158475677595435, 0.07082987414964426, 0.08424836655321766, 0.11571505417984518, 0.1199290954911072, 0.1070377193497567, 0.08568431647008856, 0.10703102876605686, 0.11822707997744042, 0.2596001429140675, 0.1944915524532983, 0.2631114242403575, 0.24517195989612595, 0.39028808958539907, 0.21316029241886691, 0.3900448041912813, 0.19820574118968137, 0.34820120592752235, 0.22884482197732836, 0.39410209867795587, 0.3938953616224474, 0.21813766377469446, 0.39394146570884025, 0.3713111677433708, 0.42134581462748166, 0.28113625997995817, 0.36578543303350985, 0.17675214194113253, 0.31251954172015284, 0.25580604561184406, 0.1856839672325704, 0.19265265604870352, 0.2568947340379405, 0.3316543533893509, 0.24384167086118202, 0.1706063835238648, 0.24623547781564425, 0.17941015656200687, 0.20788872215703247, 0.19556163160230156, 0.21022454359179032, 0.19881218468622597, 0.23212555455319028, 0.2212294463546327, 0.21455563790905607, 0.446888161694152, 0.22712368078209688, 0.4249297797806457, 0.18925891732736133, 0.2176164824791178, 0.20547363053437684, 0.20466526308654198, 0.23216324483745476, 0.20172711633962848, 0.8242656300614176, 0.12602031428143023, 0.15419033847504182, 0.8589725991199816, 0.8413260367389177, 0.19893565550339332, 0.14141442597287512, 0.17574460739998776, 0.20708780051005626, 0.5527676976733695, 0.2139455034258838, 0.20392941535232956, 0.47370844638442344, 0.6479499724018247, 0.16439113007490525, 0.10465508638386123, 0.10343339672071994, 0.7221270305935055, 0.18854937511164338, 0.17864962304007637, 0.18093802825091843, 0.20663369650680752, 0.17489127152658113, 0.18616014192555908, 0.18704328816851146, 0.1889200484674165, 0.18176138101434292, 0.08732900423441659, 0.09214820395846168, 0.09152254397030268, 0.08001279848142917, 0.08280358910226493, 0.08668580351090827, 0.12289588327671186, 0.08276140237802265, 0.08650439072387783]}, "mutation_prompt": null}
{"id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Refine velocity update with chaotic maps to enhance exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.3053081963427821, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "6995dabc-1275-4ce6-a313-928c05c3a60e", "metadata": {"aucs": [0.8833461270453159, 0.8605116928416663, 0.8607763186179695, 0.8790958684498615, 0.8546217000312526, 0.87496052348352, 0.8787887722007455, 0.8719576466281435, 0.8601471627563925, 0.6271970482566727, 0.6853346378067195, 0.674488245982527, 0.706503698191322, 0.6932616266483197, 0.7184295427963948, 0.5447142327840235, 0.6975824350760675, 0.6047688342363222, 0.1305645831078105, 0.14075430301268788, 0.15825528806486566, 0.1308031703338043, 0.15632102658274072, 0.1575943562695149, 0.12774875250239215, 0.13174578687658123, 0.12230338622557557, 0.0833974653015288, 0.15814069763379135, 0.07741369253610975, 0.11132923153017182, 0.11263508225969421, 0.15101523319822585, 0.1133778959295012, 0.08691847793198726, 0.1093761859806871, 0.9330742544301136, 0.9480265180933458, 0.9522802367375449, 0.948892634805296, 0.952980656201768, 0.9343987839800086, 0.9488974521635144, 0.9329895155435524, 0.9593104890763796, 0.709297622413673, 0.7011727470310529, 0.4346440783433291, 0.6686496050395654, 0.6993923919380537, 0.7087363485510451, 0.6733510580802986, 0.7171086353863235, 0.729438460655959, 0.1904152870663669, 0.3467618851808909, 0.37401037800351, 0.21233517203347674, 0.20707610033875468, 0.2751434433053478, 0.17611071036993886, 0.23654425456563133, 0.24267943952889004, 0.3455812690933452, 0.23817600850730647, 0.18132511465171464, 0.1287750853328412, 0.16848735951569926, 0.11685412467348377, 0.16659117559375713, 0.3648695567704603, 0.24226360794221813, 0.26751791875313946, 0.1916111647632811, 0.20919697694962813, 0.21902409693304292, 0.2803168604265105, 0.16307581074063127, 0.2112166651514923, 0.09802236387765584, 0.12541173015395057, 9.999999999998899e-05, 9.999999999998899e-05, 0.0881013137123462, 0.07541769214385463, 9.999999999998899e-05, 0.010534855665249587, 9.999999999998899e-05, 0.0072759397862468544, 0.10812541670749831, 0.13363970385837542, 0.04591105079819391, 0.05399829537764378, 0.05892249920148984, 0.056386068726811955, 0.03444472484526773, 0.07774032879267834, 0.056363371974692766, 0.09470764273992627, 0.0722008163197223, 0.03314423725685578, 0.12762790537312318, 0.12309875641158197, 0.08929494810218053, 0.0800067370858697, 0.24051136030101217, 0.16085753157574112, 0.19103317770021866, 0.0668361608584519, 0.2964425824867777, 0.11894058724818002, 0.08555086641187826, 0.12327992289151257, 0.06008681915953984, 0.08272499664922983, 0.29121406661821647, 0.08212771897835569, 0.5288682102716282, 0.5456748856912023, 0.5326227189004549, 0.5310258553214935, 0.5763233080979697, 0.630566854498426, 0.5637003304195408, 0.5407581289217002, 0.5775669078069918, 0.1511424306208048, 0.07500536307243333, 0.08171218921555612, 0.10158324152819243, 0.08058054274664994, 0.10052341573154522, 0.11634395074334025, 0.1388645750338201, 0.10453407309108731, 0.39520967391668327, 0.36112135564365744, 0.1961239570266835, 0.3306191680565912, 0.17831573585786753, 0.2582505788398186, 0.26597850189521943, 0.21045161898416853, 0.2376524662727063, 0.27819878104259943, 0.27845546723753867, 0.40475996616907783, 0.43848595416594194, 0.35360139145858394, 0.25544398344270725, 0.5833854492602932, 0.3862459898093985, 0.476385161970165, 0.31875871418281476, 0.23571737366905376, 0.24214711376387055, 0.3014711827659906, 0.18619719319177042, 0.21743434462819056, 0.2413919232284506, 0.2908524573109521, 0.2868885314225884, 0.2378481642582636, 0.1863060319785843, 0.22252350629594586, 0.22041169363599922, 0.21793987667590597, 0.2240881260115941, 0.25467157724630174, 0.2120279900926676, 0.20372953837306618, 0.17982057368015159, 0.24916173856804547, 0.1893006572806003, 0.19980596183698351, 0.19016079328759183, 0.19791454682459597, 0.19929938065111497, 0.19906122208582078, 0.1844314175190116, 0.918965397588139, 0.1875605405884988, 0.15357460414405288, 0.17259116706986966, 0.20014505390968595, 0.1991703598409481, 0.14229066011457492, 0.160832193703074, 0.9012850998714862, 0.46164888203866095, 0.21319937815419276, 0.07346951416228853, 0.43283390865684546, 0.3427276899606585, 0.15450047859163774, 0.10477467566197096, 0.10473830076047108, 0.7166066678822782, 0.17971882463925481, 0.18536196627626966, 0.19229237554684053, 0.176949834191662, 0.21081931353770478, 0.19312348495506548, 0.1750288574596598, 0.19287229457823163, 0.1824822745274156, 0.09634992336101045, 0.0853106530445461, 0.0808825315918088, 0.07277505557013486, 0.093993301305065, 0.0922781506237107, 0.14299501999565922, 0.0969549824639151, 0.10485930688176359]}, "mutation_prompt": null}
{"id": "6660c087-9cd4-436f-8d2d-6336c05d1861", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        levy_flights = np.random.normal(loc=0, scale=0.3, size=(self.pop_size, self.dim))  # Levy flight exploration\n        self.velocity = self.velocity * np.sin(r2 * np.pi) + levy_flights\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            self.f = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploration with Levy flights and adaptive mutation factor.", "configspace": "", "generation": 65, "fitness": 0.19929087056153325, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.3458503901798624, 0.37710996421225584, 0.37084145803558133, 0.33941817806304286, 0.3438449995771845, 0.3410295787726696, 0.347821751910822, 0.3549258544197462, 0.35657756263537876, 0.022993860740091132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01650931975209513, 9.999999999998899e-05, 0.0978517806630298, 0.10058550490564144, 0.09934783965389737, 0.11224690289017092, 0.091184773694718, 0.11605726303947161, 0.10558050166432309, 0.12359617525816269, 0.10626741219207192, 0.09248146021610393, 0.09056842473564575, 0.08443260732560598, 0.090760595078905, 0.0932021159816453, 0.08317085034892258, 0.06831682672446204, 0.09707843346337086, 0.10054573462933336, 0.9513198356098169, 0.9336917251272263, 0.953787610135441, 0.9519847187441213, 0.9560223656275277, 0.9608560951304838, 0.9670886263587612, 0.9419120502939425, 0.9516022252859614, 0.23064903930834246, 0.23061580077669241, 0.20256844616968128, 0.24198310379743082, 0.21993169744060026, 0.22479764340363695, 0.21989323459394527, 0.22649729083533077, 0.23580649269810017, 0.27280628969604814, 0.2563335763199982, 0.295058413083949, 0.2514681736477137, 0.2928114945701088, 0.26931880334089464, 0.22899769457210928, 0.7345936340395924, 0.25853440734485056, 0.12312855947513779, 0.082705446811, 0.13421625063868192, 0.147025395838574, 0.17561722109434774, 0.09371613174387572, 0.15002738652901149, 0.1292048362682272, 0.11927651068119993, 0.11818770112401011, 0.12864636275563623, 0.13064038615173867, 0.13050216131145242, 0.11847935553993427, 0.14403064988198389, 0.12470653178104552, 0.05131437189116772, 0.14400833840555405, 9.999999999998899e-05, 0.00025611380024292973, 0.009501464575037089, 0.020221705833227355, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015788660364494, 0.11371257479020658, 0.03634069854651212, 0.1093763019119004, 0.10127777644894576, 0.04457279258035107, 0.01169692414958956, 0.13203328325932873, 0.11572866376215296, 0.08431555871972163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06575343331205696, 0.07238737408645424, 0.06617569488974273, 0.0514304350045679, 0.05636566673465804, 0.05948833645360807, 0.06170839272735762, 0.057025991165017165, 0.06433310660274205, 0.34029228296812797, 0.3456210116757328, 0.33543065396803085, 0.37162279143793375, 0.34341244936869963, 0.3395515302834661, 0.3453176983962438, 0.32981172281379545, 0.34682848878637673, 0.10348769541727709, 0.10346130146676291, 0.11772086650342883, 0.09098840155018573, 0.0919793416686262, 0.13712159905738186, 0.1064956965546966, 0.11218538287489721, 0.09775450180444456, 0.1478393383569091, 0.1559083730332168, 0.1816690485153768, 0.22773060004986923, 0.19529496708191574, 0.18365922125493528, 0.17273055678220428, 0.16202906086310465, 0.16709678510001558, 0.24942218714395092, 0.2513885780948152, 0.2656528886362707, 0.23973344916771577, 0.25934942111134773, 0.2511283016103286, 0.26510015930080466, 0.255209982720775, 0.25668964843316644, 0.192866310649363, 0.18245571090758972, 0.19519067619788877, 0.1826675529592533, 0.17677359255519254, 0.18692731989970046, 0.19983153243731344, 0.19772169732052103, 0.18208882831344786, 0.23978701391390544, 0.21354670304895285, 0.26113807335117967, 0.21772400145143056, 0.23350560620669414, 0.21992031558419534, 0.24340206415331134, 0.22198956099722378, 0.2558266337647519, 0.1929063446861119, 0.18431822933923037, 0.1798936656670188, 0.19627127817659074, 0.18255649092158266, 0.17575839887643196, 0.18480950116487815, 0.18254935983561782, 0.19209213006705683, 0.47373774241786404, 0.18489904402434088, 0.15251044426876015, 0.5055548505548906, 0.1960894598380547, 0.1973933923116694, 0.4886259115964081, 0.1755649397737341, 0.5124329543432803, 0.39290641176205277, 0.2089253146789949, 0.07316181455625759, 0.42018129191728937, 0.33118361938897, 0.15005690088376544, 0.10385989460865308, 0.20909696301368885, 0.34847880875256876, 0.1832147021330296, 0.18300508210486943, 0.18587307792044605, 0.1816935011197418, 0.18916162076696053, 0.1888181404161311, 0.17915932642838783, 0.2019729998351507, 0.17617329751761168, 0.09075294507551301, 0.08509574820131982, 0.08354037317904017, 0.08183298948616924, 0.08592923251308804, 0.0916947064951058, 0.09617013945879882, 0.08969206826050069, 0.09900059903179625]}, "mutation_prompt": null}
{"id": "6fcc251d-dc43-4c8b-b0a3-5bc58d9add6f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Refine velocity update with chaotic maps to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.8833461270453159, 0.8605116928416663, 0.8607763186179695, 0.8790958684498615, 0.8546217000312526, 0.87496052348352, 0.8787887722007455, 0.8719576466281435, 0.8601471627563925, 0.6271970482566727, 0.6853346378067195, 0.674488245982527, 0.706503698191322, 0.6932616266483197, 0.7184295427963948, 0.5447142327840235, 0.6975824350760675, 0.6047688342363222, 0.1305645831078105, 0.14075430301268788, 0.15825528806486566, 0.1308031703338043, 0.15632102658274072, 0.1575943562695149, 0.12774875250239215, 0.13174578687658123, 0.12230338622557557, 0.0833974653015288, 0.15814069763379135, 0.07741369253610975, 0.11132923153017182, 0.11263508225969421, 0.15101523319822585, 0.1133778959295012, 0.08691847793198726, 0.1093761859806871, 0.9330742544301136, 0.9480265180933458, 0.9522802367375449, 0.948892634805296, 0.952980656201768, 0.9343987839800086, 0.9488974521635144, 0.9329895155435524, 0.9593104890763796, 0.709297622413673, 0.7011727470310529, 0.4346440783433291, 0.6686496050395654, 0.6993923919380537, 0.7087363485510451, 0.6733510580802986, 0.7171086353863235, 0.729438460655959, 0.1904152870663669, 0.3467618851808909, 0.37401037800351, 0.21233517203347674, 0.20707610033875468, 0.2751434433053478, 0.17611071036993886, 0.23654425456563133, 0.24267943952889004, 0.3455812690933452, 0.23817600850730647, 0.18132511465171464, 0.1287750853328412, 0.16848735951569926, 0.11685412467348377, 0.16659117559375713, 0.3648695567704603, 0.24226360794221813, 0.26751791875313946, 0.1916111647632811, 0.20919697694962813, 0.21902409693304292, 0.2803168604265105, 0.16307581074063127, 0.2112166651514923, 0.09802236387765584, 0.12541173015395057, 9.999999999998899e-05, 9.999999999998899e-05, 0.0881013137123462, 0.07541769214385463, 9.999999999998899e-05, 0.010534855665249587, 9.999999999998899e-05, 0.0072759397862468544, 0.10812541670749831, 0.13363970385837542, 0.04591105079819391, 0.05399829537764378, 0.05892249920148984, 0.056386068726811955, 0.03444472484526773, 0.07774032879267834, 0.056363371974692766, 0.09470764273992627, 0.0722008163197223, 0.03314423725685578, 0.12762790537312318, 0.12309875641158197, 0.08929494810218053, 0.0800067370858697, 0.24051136030101217, 0.16085753157574112, 0.19103317770021866, 0.0668361608584519, 0.2964425824867777, 0.11894058724818002, 0.08555086641187826, 0.12327992289151257, 0.06008681915953984, 0.08272499664922983, 0.29121406661821647, 0.08212771897835569, 0.5288682102716282, 0.5456748856912023, 0.5326227189004549, 0.5310258553214935, 0.5763233080979697, 0.630566854498426, 0.5637003304195408, 0.5407581289217002, 0.5775669078069918, 0.1511424306208048, 0.07500536307243333, 0.08171218921555612, 0.10158324152819243, 0.08058054274664994, 0.10052341573154522, 0.11634395074334025, 0.1388645750338201, 0.10453407309108731, 0.39520967391668327, 0.36112135564365744, 0.1961239570266835, 0.3306191680565912, 0.17831573585786753, 0.2582505788398186, 0.26597850189521943, 0.21045161898416853, 0.2376524662727063, 0.27819878104259943, 0.27845546723753867, 0.40475996616907783, 0.43848595416594194, 0.35360139145858394, 0.25544398344270725, 0.5833854492602932, 0.3862459898093985, 0.476385161970165, 0.31875871418281476, 0.23571737366905376, 0.24214711376387055, 0.3014711827659906, 0.18619719319177042, 0.21743434462819056, 0.2413919232284506, 0.2908524573109521, 0.2868885314225884, 0.2378481642582636, 0.1863060319785843, 0.22252350629594586, 0.22041169363599922, 0.21793987667590597, 0.2240881260115941, 0.25467157724630174, 0.2120279900926676, 0.20372953837306618, 0.17982057368015159, 0.24916173856804547, 0.1893006572806003, 0.19980596183698351, 0.19016079328759183, 0.19791454682459597, 0.19929938065111497, 0.19906122208582078, 0.1844314175190116, 0.918965397588139, 0.1875605405884988, 0.15357460414405288, 0.17259116706986966, 0.20014505390968595, 0.1991703598409481, 0.14229066011457492, 0.160832193703074, 0.9012850998714862, 0.46164888203866095, 0.21319937815419276, 0.07346951416228853, 0.43283390865684546, 0.3427276899606585, 0.15450047859163774, 0.10477467566197096, 0.10473830076047108, 0.7166066678822782, 0.17971882463925481, 0.18536196627626966, 0.19229237554684053, 0.176949834191662, 0.21081931353770478, 0.19312348495506548, 0.1750288574596598, 0.19287229457823163, 0.1824822745274156, 0.09634992336101045, 0.0853106530445461, 0.0808825315918088, 0.07277505557013486, 0.093993301305065, 0.0922781506237107, 0.14299501999565922, 0.0969549824639151, 0.10485930688176359]}, "mutation_prompt": null}
{"id": "0f52dc15-52fe-4af2-a553-6f501a0b0ab8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Refine velocity update with chaotic maps to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.8833461270453159, 0.8605116928416663, 0.8607763186179695, 0.8790958684498615, 0.8546217000312526, 0.87496052348352, 0.8787887722007455, 0.8719576466281435, 0.8601471627563925, 0.6271970482566727, 0.6853346378067195, 0.674488245982527, 0.706503698191322, 0.6932616266483197, 0.7184295427963948, 0.5447142327840235, 0.6975824350760675, 0.6047688342363222, 0.1305645831078105, 0.14075430301268788, 0.15825528806486566, 0.1308031703338043, 0.15632102658274072, 0.1575943562695149, 0.12774875250239215, 0.13174578687658123, 0.12230338622557557, 0.0833974653015288, 0.15814069763379135, 0.07741369253610975, 0.11132923153017182, 0.11263508225969421, 0.15101523319822585, 0.1133778959295012, 0.08691847793198726, 0.1093761859806871, 0.9330742544301136, 0.9480265180933458, 0.9522802367375449, 0.948892634805296, 0.952980656201768, 0.9343987839800086, 0.9488974521635144, 0.9329895155435524, 0.9593104890763796, 0.709297622413673, 0.7011727470310529, 0.4346440783433291, 0.6686496050395654, 0.6993923919380537, 0.7087363485510451, 0.6733510580802986, 0.7171086353863235, 0.729438460655959, 0.1904152870663669, 0.3467618851808909, 0.37401037800351, 0.21233517203347674, 0.20707610033875468, 0.2751434433053478, 0.17611071036993886, 0.23654425456563133, 0.24267943952889004, 0.3455812690933452, 0.23817600850730647, 0.18132511465171464, 0.1287750853328412, 0.16848735951569926, 0.11685412467348377, 0.16659117559375713, 0.3648695567704603, 0.24226360794221813, 0.26751791875313946, 0.1916111647632811, 0.20919697694962813, 0.21902409693304292, 0.2803168604265105, 0.16307581074063127, 0.2112166651514923, 0.09802236387765584, 0.12541173015395057, 9.999999999998899e-05, 9.999999999998899e-05, 0.0881013137123462, 0.07541769214385463, 9.999999999998899e-05, 0.010534855665249587, 9.999999999998899e-05, 0.0072759397862468544, 0.10812541670749831, 0.13363970385837542, 0.04591105079819391, 0.05399829537764378, 0.05892249920148984, 0.056386068726811955, 0.03444472484526773, 0.07774032879267834, 0.056363371974692766, 0.09470764273992627, 0.0722008163197223, 0.03314423725685578, 0.12762790537312318, 0.12309875641158197, 0.08929494810218053, 0.0800067370858697, 0.24051136030101217, 0.16085753157574112, 0.19103317770021866, 0.0668361608584519, 0.2964425824867777, 0.11894058724818002, 0.08555086641187826, 0.12327992289151257, 0.06008681915953984, 0.08272499664922983, 0.29121406661821647, 0.08212771897835569, 0.5288682102716282, 0.5456748856912023, 0.5326227189004549, 0.5310258553214935, 0.5763233080979697, 0.630566854498426, 0.5637003304195408, 0.5407581289217002, 0.5775669078069918, 0.1511424306208048, 0.07500536307243333, 0.08171218921555612, 0.10158324152819243, 0.08058054274664994, 0.10052341573154522, 0.11634395074334025, 0.1388645750338201, 0.10453407309108731, 0.39520967391668327, 0.36112135564365744, 0.1961239570266835, 0.3306191680565912, 0.17831573585786753, 0.2582505788398186, 0.26597850189521943, 0.21045161898416853, 0.2376524662727063, 0.27819878104259943, 0.27845546723753867, 0.40475996616907783, 0.43848595416594194, 0.35360139145858394, 0.25544398344270725, 0.5833854492602932, 0.3862459898093985, 0.476385161970165, 0.31875871418281476, 0.23571737366905376, 0.24214711376387055, 0.3014711827659906, 0.18619719319177042, 0.21743434462819056, 0.2413919232284506, 0.2908524573109521, 0.2868885314225884, 0.2378481642582636, 0.1863060319785843, 0.22252350629594586, 0.22041169363599922, 0.21793987667590597, 0.2240881260115941, 0.25467157724630174, 0.2120279900926676, 0.20372953837306618, 0.17982057368015159, 0.24916173856804547, 0.1893006572806003, 0.19980596183698351, 0.19016079328759183, 0.19791454682459597, 0.19929938065111497, 0.19906122208582078, 0.1844314175190116, 0.918965397588139, 0.1875605405884988, 0.15357460414405288, 0.17259116706986966, 0.20014505390968595, 0.1991703598409481, 0.14229066011457492, 0.160832193703074, 0.9012850998714862, 0.46164888203866095, 0.21319937815419276, 0.07346951416228853, 0.43283390865684546, 0.3427276899606585, 0.15450047859163774, 0.10477467566197096, 0.10473830076047108, 0.7166066678822782, 0.17971882463925481, 0.18536196627626966, 0.19229237554684053, 0.176949834191662, 0.21081931353770478, 0.19312348495506548, 0.1750288574596598, 0.19287229457823163, 0.1824822745274156, 0.09634992336101045, 0.0853106530445461, 0.0808825315918088, 0.07277505557013486, 0.093993301305065, 0.0922781506237107, 0.14299501999565922, 0.0969549824639151, 0.10485930688176359]}, "mutation_prompt": null}
{"id": "a831c752-798b-4ddc-8d26-ce9c0c9c10d0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        levy_step = np.random.normal(0, 1, (self.pop_size, self.dim)) * (self.velocity ** 2)\n        self.population += self.velocity + levy_step\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Integrate Levy flight with PSO for enhanced local exploitation and diverse global exploration.", "configspace": "", "generation": 68, "fitness": 0.24407612479605253, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.7684669702424777, 0.7636895329024209, 0.7225603670007625, 0.7894549887755018, 0.7500261657034462, 0.7726711066270415, 0.8089856328718158, 0.7963542408328368, 0.7512104089157109, 0.6337317964015945, 0.5866038402571326, 0.47892865549181374, 0.2915618199906217, 0.5326404632925583, 0.45014382004637077, 0.5436182764639523, 0.6073516781746677, 0.541321453138236, 0.10497389936399482, 0.09530803943433075, 0.17984954175575696, 0.09855771085659015, 0.10837278293095154, 0.14172536219315846, 0.112833570110485, 0.08498481263673763, 0.153099717736496, 0.11637728685503057, 0.09366646319091487, 0.10604691258320798, 0.10417972253140739, 0.12426296364496137, 0.10693277749490404, 0.1044891592920496, 0.12466244414405736, 0.0970256955253408, 0.9835983205662056, 0.9619420115185209, 0.9731617159720557, 0.9767481726503049, 0.9767739198880185, 0.9587126429122845, 0.9694872135022676, 0.9835855992759437, 0.9650488956543241, 0.28701020928399135, 0.29597522179352875, 0.24816103590079308, 0.14100289078180506, 0.13840264418378778, 0.2675274193482621, 0.28414066149870665, 0.2739296235307396, 0.24351515070605811, 0.21312613123743218, 0.16411668481948505, 0.2230941659740444, 0.2195074265507584, 0.2091391785428176, 0.1864601822129982, 0.28503844818887114, 0.29697509141246103, 0.16919192150195705, 0.13972616992286313, 0.12847750293579407, 0.11918002202584088, 0.08344741084578089, 0.11625070005688953, 0.17910579923505177, 0.20907128915870543, 0.29378157125215243, 0.13708696009196397, 0.11825976368440949, 0.10467923214533004, 0.11491637126101684, 0.12953119800873847, 0.12340433958332508, 0.19467840956992122, 0.1298242087473298, 0.1287766830743825, 0.14012420574596451, 9.999999999998899e-05, 9.999999999998899e-05, 0.029836459972256812, 0.00032129139636616344, 9.999999999998899e-05, 9.999999999998899e-05, 0.007841362446115108, 9.999999999998899e-05, 9.999999999998899e-05, 0.04903774139136763, 0.049010037981421006, 0.03189847505182475, 0.06004867539860692, 0.008099031342947871, 0.03773156858377347, 0.0799642579393598, 0.05518246549187733, 0.04890461722594175, 0.19789951823875584, 0.03186232522863086, 0.04551169062738536, 0.08334291135383975, 0.19288196876165709, 0.0764107014783364, 0.10348497240484789, 0.12045663355837699, 0.21033090506934393, 0.3042037801442191, 0.03981880344583444, 0.038358914167741065, 0.08638651274215625, 0.006214231189935915, 0.024455357402833222, 0.04820991257056395, 0.07344922787758801, 0.08094065582249155, 0.39681384904840156, 0.47679468533380287, 0.4384483799758381, 0.495452470150049, 0.5002215163384895, 0.4348325223520859, 0.4657456557615527, 0.4361052404334602, 0.4550862969439531, 0.10078128756212612, 0.07984481322788883, 0.08820011753231027, 0.09032293117230583, 0.09408719150963718, 0.1065724669239817, 0.0628298761884456, 0.10821170286958826, 0.1016181846574351, 0.1441614699050613, 0.18872715708262477, 0.3624075207128329, 0.19401359785401695, 0.29890861333393326, 0.2248442098030078, 0.29712064620358036, 0.1735017084152165, 0.20769587644535137, 0.18253736548965105, 0.2273672169981783, 0.27889483526617365, 0.19066107921255293, 0.2562781134778832, 0.29659920268007145, 0.4678058984259482, 0.301753403679369, 0.2584448846093538, 0.1926497471015538, 0.23628752653692908, 0.1791515040511631, 0.15797527801970157, 0.1918622984501306, 0.1855716425464603, 0.2302982711832401, 0.3596209589388215, 0.13259469290044323, 0.16625147818115493, 0.16419573436498303, 0.1978068801988112, 0.17664221430434157, 0.18915948862694998, 0.20925119728270714, 0.26586261497096797, 0.1757194198909494, 0.17838791536277965, 0.1949083714267914, 0.19839711230498658, 0.19020570409273063, 0.18545136157692932, 0.21233781584016886, 0.2217037330291991, 0.18866052422551616, 0.34402404475586923, 0.1652529077306375, 0.7594665889518298, 0.15642838199610265, 0.15180661672001028, 0.19155966011230985, 0.19160563438459255, 0.1684063520364274, 0.1418393699968592, 0.18664485663827068, 0.1638305815734451, 0.26138020750710456, 0.16693077903352005, 0.3097134730178436, 0.3075995167158151, 0.16518182875609855, 0.13805981023132063, 0.20085293775418833, 0.11168466574305436, 0.2105122805769123, 0.19373867241313059, 0.1839789784624567, 0.20376035158085437, 0.18481375349893148, 0.18106379127029604, 0.19367003174812214, 0.21884937511761704, 0.1918433085068968, 0.2025701595426178, 0.0700850203604606, 0.05483178685017376, 0.07365483461401967, 0.07941884944921951, 0.08065816939703896, 0.0814915912307923, 0.06694466492962625, 0.06589028623040816, 0.08069386105829313]}, "mutation_prompt": null}
{"id": "6038cf6a-5d1f-4d83-8f59-747d6b54207f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Refine velocity update with chaotic maps to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.8833461270453159, 0.8605116928416663, 0.8607763186179695, 0.8790958684498615, 0.8546217000312526, 0.87496052348352, 0.8787887722007455, 0.8719576466281435, 0.8601471627563925, 0.6271970482566727, 0.6853346378067195, 0.674488245982527, 0.706503698191322, 0.6932616266483197, 0.7184295427963948, 0.5447142327840235, 0.6975824350760675, 0.6047688342363222, 0.1305645831078105, 0.14075430301268788, 0.15825528806486566, 0.1308031703338043, 0.15632102658274072, 0.1575943562695149, 0.12774875250239215, 0.13174578687658123, 0.12230338622557557, 0.0833974653015288, 0.15814069763379135, 0.07741369253610975, 0.11132923153017182, 0.11263508225969421, 0.15101523319822585, 0.1133778959295012, 0.08691847793198726, 0.1093761859806871, 0.9330742544301136, 0.9480265180933458, 0.9522802367375449, 0.948892634805296, 0.952980656201768, 0.9343987839800086, 0.9488974521635144, 0.9329895155435524, 0.9593104890763796, 0.709297622413673, 0.7011727470310529, 0.4346440783433291, 0.6686496050395654, 0.6993923919380537, 0.7087363485510451, 0.6733510580802986, 0.7171086353863235, 0.729438460655959, 0.1904152870663669, 0.3467618851808909, 0.37401037800351, 0.21233517203347674, 0.20707610033875468, 0.2751434433053478, 0.17611071036993886, 0.23654425456563133, 0.24267943952889004, 0.3455812690933452, 0.23817600850730647, 0.18132511465171464, 0.1287750853328412, 0.16848735951569926, 0.11685412467348377, 0.16659117559375713, 0.3648695567704603, 0.24226360794221813, 0.26751791875313946, 0.1916111647632811, 0.20919697694962813, 0.21902409693304292, 0.2803168604265105, 0.16307581074063127, 0.2112166651514923, 0.09802236387765584, 0.12541173015395057, 9.999999999998899e-05, 9.999999999998899e-05, 0.0881013137123462, 0.07541769214385463, 9.999999999998899e-05, 0.010534855665249587, 9.999999999998899e-05, 0.0072759397862468544, 0.10812541670749831, 0.13363970385837542, 0.04591105079819391, 0.05399829537764378, 0.05892249920148984, 0.056386068726811955, 0.03444472484526773, 0.07774032879267834, 0.056363371974692766, 0.09470764273992627, 0.0722008163197223, 0.03314423725685578, 0.12762790537312318, 0.12309875641158197, 0.08929494810218053, 0.0800067370858697, 0.24051136030101217, 0.16085753157574112, 0.19103317770021866, 0.0668361608584519, 0.2964425824867777, 0.11894058724818002, 0.08555086641187826, 0.12327992289151257, 0.06008681915953984, 0.08272499664922983, 0.29121406661821647, 0.08212771897835569, 0.5288682102716282, 0.5456748856912023, 0.5326227189004549, 0.5310258553214935, 0.5763233080979697, 0.630566854498426, 0.5637003304195408, 0.5407581289217002, 0.5775669078069918, 0.1511424306208048, 0.07500536307243333, 0.08171218921555612, 0.10158324152819243, 0.08058054274664994, 0.10052341573154522, 0.11634395074334025, 0.1388645750338201, 0.10453407309108731, 0.39520967391668327, 0.36112135564365744, 0.1961239570266835, 0.3306191680565912, 0.17831573585786753, 0.2582505788398186, 0.26597850189521943, 0.21045161898416853, 0.2376524662727063, 0.27819878104259943, 0.27845546723753867, 0.40475996616907783, 0.43848595416594194, 0.35360139145858394, 0.25544398344270725, 0.5833854492602932, 0.3862459898093985, 0.476385161970165, 0.31875871418281476, 0.23571737366905376, 0.24214711376387055, 0.3014711827659906, 0.18619719319177042, 0.21743434462819056, 0.2413919232284506, 0.2908524573109521, 0.2868885314225884, 0.2378481642582636, 0.1863060319785843, 0.22252350629594586, 0.22041169363599922, 0.21793987667590597, 0.2240881260115941, 0.25467157724630174, 0.2120279900926676, 0.20372953837306618, 0.17982057368015159, 0.24916173856804547, 0.1893006572806003, 0.19980596183698351, 0.19016079328759183, 0.19791454682459597, 0.19929938065111497, 0.19906122208582078, 0.1844314175190116, 0.918965397588139, 0.1875605405884988, 0.15357460414405288, 0.17259116706986966, 0.20014505390968595, 0.1991703598409481, 0.14229066011457492, 0.160832193703074, 0.9012850998714862, 0.46164888203866095, 0.21319937815419276, 0.07346951416228853, 0.43283390865684546, 0.3427276899606585, 0.15450047859163774, 0.10477467566197096, 0.10473830076047108, 0.7166066678822782, 0.17971882463925481, 0.18536196627626966, 0.19229237554684053, 0.176949834191662, 0.21081931353770478, 0.19312348495506548, 0.1750288574596598, 0.19287229457823163, 0.1824822745274156, 0.09634992336101045, 0.0853106530445461, 0.0808825315918088, 0.07277505557013486, 0.093993301305065, 0.0922781506237107, 0.14299501999565922, 0.0969549824639151, 0.10485930688176359]}, "mutation_prompt": null}
{"id": "8689a54a-183d-4af8-bf73-47ea5cd39c33", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Refine velocity update with chaotic maps to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.8833461270453159, 0.8605116928416663, 0.8607763186179695, 0.8790958684498615, 0.8546217000312526, 0.87496052348352, 0.8787887722007455, 0.8719576466281435, 0.8601471627563925, 0.6271970482566727, 0.6853346378067195, 0.674488245982527, 0.706503698191322, 0.6932616266483197, 0.7184295427963948, 0.5447142327840235, 0.6975824350760675, 0.6047688342363222, 0.1305645831078105, 0.14075430301268788, 0.15825528806486566, 0.1308031703338043, 0.15632102658274072, 0.1575943562695149, 0.12774875250239215, 0.13174578687658123, 0.12230338622557557, 0.0833974653015288, 0.15814069763379135, 0.07741369253610975, 0.11132923153017182, 0.11263508225969421, 0.15101523319822585, 0.1133778959295012, 0.08691847793198726, 0.1093761859806871, 0.9330742544301136, 0.9480265180933458, 0.9522802367375449, 0.948892634805296, 0.952980656201768, 0.9343987839800086, 0.9488974521635144, 0.9329895155435524, 0.9593104890763796, 0.709297622413673, 0.7011727470310529, 0.4346440783433291, 0.6686496050395654, 0.6993923919380537, 0.7087363485510451, 0.6733510580802986, 0.7171086353863235, 0.729438460655959, 0.1904152870663669, 0.3467618851808909, 0.37401037800351, 0.21233517203347674, 0.20707610033875468, 0.2751434433053478, 0.17611071036993886, 0.23654425456563133, 0.24267943952889004, 0.3455812690933452, 0.23817600850730647, 0.18132511465171464, 0.1287750853328412, 0.16848735951569926, 0.11685412467348377, 0.16659117559375713, 0.3648695567704603, 0.24226360794221813, 0.26751791875313946, 0.1916111647632811, 0.20919697694962813, 0.21902409693304292, 0.2803168604265105, 0.16307581074063127, 0.2112166651514923, 0.09802236387765584, 0.12541173015395057, 9.999999999998899e-05, 9.999999999998899e-05, 0.0881013137123462, 0.07541769214385463, 9.999999999998899e-05, 0.010534855665249587, 9.999999999998899e-05, 0.0072759397862468544, 0.10812541670749831, 0.13363970385837542, 0.04591105079819391, 0.05399829537764378, 0.05892249920148984, 0.056386068726811955, 0.03444472484526773, 0.07774032879267834, 0.056363371974692766, 0.09470764273992627, 0.0722008163197223, 0.03314423725685578, 0.12762790537312318, 0.12309875641158197, 0.08929494810218053, 0.0800067370858697, 0.24051136030101217, 0.16085753157574112, 0.19103317770021866, 0.0668361608584519, 0.2964425824867777, 0.11894058724818002, 0.08555086641187826, 0.12327992289151257, 0.06008681915953984, 0.08272499664922983, 0.29121406661821647, 0.08212771897835569, 0.5288682102716282, 0.5456748856912023, 0.5326227189004549, 0.5310258553214935, 0.5763233080979697, 0.630566854498426, 0.5637003304195408, 0.5407581289217002, 0.5775669078069918, 0.1511424306208048, 0.07500536307243333, 0.08171218921555612, 0.10158324152819243, 0.08058054274664994, 0.10052341573154522, 0.11634395074334025, 0.1388645750338201, 0.10453407309108731, 0.39520967391668327, 0.36112135564365744, 0.1961239570266835, 0.3306191680565912, 0.17831573585786753, 0.2582505788398186, 0.26597850189521943, 0.21045161898416853, 0.2376524662727063, 0.27819878104259943, 0.27845546723753867, 0.40475996616907783, 0.43848595416594194, 0.35360139145858394, 0.25544398344270725, 0.5833854492602932, 0.3862459898093985, 0.476385161970165, 0.31875871418281476, 0.23571737366905376, 0.24214711376387055, 0.3014711827659906, 0.18619719319177042, 0.21743434462819056, 0.2413919232284506, 0.2908524573109521, 0.2868885314225884, 0.2378481642582636, 0.1863060319785843, 0.22252350629594586, 0.22041169363599922, 0.21793987667590597, 0.2240881260115941, 0.25467157724630174, 0.2120279900926676, 0.20372953837306618, 0.17982057368015159, 0.24916173856804547, 0.1893006572806003, 0.19980596183698351, 0.19016079328759183, 0.19791454682459597, 0.19929938065111497, 0.19906122208582078, 0.1844314175190116, 0.918965397588139, 0.1875605405884988, 0.15357460414405288, 0.17259116706986966, 0.20014505390968595, 0.1991703598409481, 0.14229066011457492, 0.160832193703074, 0.9012850998714862, 0.46164888203866095, 0.21319937815419276, 0.07346951416228853, 0.43283390865684546, 0.3427276899606585, 0.15450047859163774, 0.10477467566197096, 0.10473830076047108, 0.7166066678822782, 0.17971882463925481, 0.18536196627626966, 0.19229237554684053, 0.176949834191662, 0.21081931353770478, 0.19312348495506548, 0.1750288574596598, 0.19287229457823163, 0.1824822745274156, 0.09634992336101045, 0.0853106530445461, 0.0808825315918088, 0.07277505557013486, 0.093993301305065, 0.0922781506237107, 0.14299501999565922, 0.0969549824639151, 0.10485930688176359]}, "mutation_prompt": null}
{"id": "620f3852-b2cb-4418-985f-7c708b78c387", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive chaotic mutation in DE to dynamically balance exploration and exploitation.", "configspace": "", "generation": 71, "fitness": 0.3134506766689559, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "0eae57b9-1ca4-47b8-82ed-fd668eeb304b", "metadata": {"aucs": [0.8771955180425387, 0.8598621577532959, 0.8671956961663929, 0.8673271045496741, 0.8724711999682947, 0.8697714072552367, 0.8700710997118117, 0.8739015098311813, 0.8660511117838812, 0.6390218894556824, 0.7022966250216927, 0.6431697951488102, 0.6461864528548422, 0.6572434976127404, 0.6952074210214814, 0.5435722784097125, 0.6574046990192084, 0.6370258688065696, 0.14338405469463777, 0.14239016281647765, 0.14397117206647236, 0.11522066523679841, 0.08136990893516194, 0.12285105262709217, 0.11054995587265404, 0.14294596181603703, 0.15309982050310578, 0.09991394864669478, 0.07988954678676696, 0.08527238268501991, 0.11100267302100852, 0.10774980248035226, 0.10819769125092571, 0.1402671768335516, 0.10706139894284916, 0.1095067372661701, 0.933589951649658, 0.948043529369547, 0.95987630067038, 0.9493597690089085, 0.9531078420923699, 0.9341624650839186, 0.9508844211931609, 0.9340675427333366, 0.959701023970182, 0.6476176360332704, 0.7218064644921519, 0.680877265603924, 0.7530079103369889, 0.7451973049791578, 0.6983480880919775, 0.6998915017391973, 0.6303795053452176, 0.7285405170018199, 0.8476307916522129, 0.32071642201651895, 0.16934058100791594, 0.21926546876819963, 0.2206734908563709, 0.37120021151754445, 0.16144161384153288, 0.2335051415065439, 0.38237669713719735, 0.3470965623092661, 0.23289305810658922, 0.15338206077391714, 0.13102599835912077, 0.15165831724698653, 0.11834107607153621, 0.18495412263783217, 0.17452004451079595, 0.24279272021945475, 0.26604678097323287, 0.16719121327478625, 0.1975756838058068, 0.18645045016958361, 0.2280771837264851, 0.18924847644502063, 0.20776523801028346, 0.13167451764365756, 0.12475494062645798, 9.999999999998899e-05, 9.999999999998899e-05, 0.11447736327304647, 0.04485078775124307, 9.999999999998899e-05, 0.00015647137061425287, 0.015170016087017957, 9.999999999998899e-05, 0.1468985475909398, 0.12309744772369813, 0.052243621224075665, 0.11131201174430994, 0.07254213123234388, 0.04335296427326196, 0.02417920867679968, 0.07621452071708668, 0.08067450796311004, 0.05709594791113837, 0.09670366803332564, 0.034702171333950926, 0.15027990797705315, 0.16422612649311108, 0.07897352072514119, 0.08290887932088642, 0.21972535015447137, 0.16488977135847127, 0.1542657494345172, 0.07000677701838942, 0.19912504021684996, 0.13218712782564834, 0.07155083158862874, 0.10019998522100482, 0.06567006286835309, 0.0819695183567748, 0.16951263263662641, 0.08246486192778701, 0.5191699099212002, 0.5096099383804112, 0.5550043456284419, 0.5670765013063024, 0.6514088608837126, 0.5268999644629064, 0.5701744156361688, 0.5894627186761361, 0.5792089006295249, 0.11189525004000989, 0.10766987767109149, 0.09556101253353921, 0.15754896275717567, 0.09094418225834289, 0.1532569505774789, 0.15798237950139027, 0.10688907632848077, 0.10186417295809902, 0.16298730555959373, 0.39804716601633494, 0.2248289824587223, 0.26810894779161654, 0.19773321118514564, 0.3466349439903206, 0.22224414567293238, 0.2163474166330447, 0.20319308771409172, 0.35247075587507737, 0.2883185204808054, 0.38917412635046866, 0.40600127771674255, 0.4444463322294818, 0.2392204992926521, 0.35135752541096743, 0.5285418941818764, 0.545769322740339, 0.29536037534824133, 0.21392289481739135, 0.21274121576812766, 0.2807839748913936, 0.28553392869696237, 0.2691653164224095, 0.2185874548284753, 0.3472197276092023, 0.26452567261681514, 0.2790395498906183, 0.20302167826743633, 0.21366365036123292, 0.24042068708131004, 0.22674639477007963, 0.2329667594975947, 0.2078020895932431, 0.20942917836095098, 0.19687475441567748, 0.22753917345934593, 0.19833223472098815, 0.2225726264065575, 0.22428750253746588, 0.24770755463520167, 0.21111505279679144, 0.19806801674306695, 0.18556246306579682, 0.18179248114993174, 0.8935581687799908, 0.1876249402741047, 0.15358567701838877, 0.17259858967078212, 0.20004508617238304, 0.19908826956517256, 0.14231469110333128, 0.8898175794480578, 0.9164785343587694, 0.6908864741568164, 0.2130134576315842, 0.07347212513037504, 0.5135276647182967, 0.6644557360343832, 0.15404250823349352, 0.10480947845454613, 0.10476494688988347, 0.5341065086659211, 0.19181176319968662, 0.18280770096213483, 0.21987661997462116, 0.1912125975148864, 0.19199237165484995, 0.2162304914567822, 0.19237781270971321, 0.1952393396097638, 0.17769445862368194, 0.08509924276645742, 0.09353572510317931, 0.08236145423535512, 0.09217079154275976, 0.09750561092682675, 0.10106150898965882, 0.13441175821206286, 0.09927797616671175, 0.09894833280161142]}, "mutation_prompt": null}
{"id": "c7b58e1f-8925-4640-990e-f30266c501d0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.initial_pop_size = 50  # Initial population size (new)\n        self.final_pop_size = 30  # Final population size (new)\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Dynamic population size adjustment (new)\n            self.pop_size = int(self.initial_pop_size - (self.evaluations / self.budget) * (self.initial_pop_size - self.final_pop_size))\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a dynamic population size adjustment strategy to balance diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (49,5) (50,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (49,5) (50,5) ')", "parent_id": "620f3852-b2cb-4418-985f-7c708b78c387", "metadata": {}, "mutation_prompt": null}
{"id": "6f4c05b4-84ef-4bd3-9ae5-2cbb5c17ce5e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive chaotic mutation in DE to dynamically balance exploration and exploitation.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "620f3852-b2cb-4418-985f-7c708b78c387", "metadata": {"aucs": [0.8771955180425387, 0.8598621577532959, 0.8671956961663929, 0.8673271045496741, 0.8724711999682947, 0.8697714072552367, 0.8700710997118117, 0.8739015098311813, 0.8660511117838812, 0.6390218894556824, 0.7022966250216927, 0.6431697951488102, 0.6461864528548422, 0.6572434976127404, 0.6952074210214814, 0.5435722784097125, 0.6574046990192084, 0.6370258688065696, 0.14338405469463777, 0.14239016281647765, 0.14397117206647236, 0.11522066523679841, 0.08136990893516194, 0.12285105262709217, 0.11054995587265404, 0.14294596181603703, 0.15309982050310578, 0.09991394864669478, 0.07988954678676696, 0.08527238268501991, 0.11100267302100852, 0.10774980248035226, 0.10819769125092571, 0.1402671768335516, 0.10706139894284916, 0.1095067372661701, 0.933589951649658, 0.948043529369547, 0.95987630067038, 0.9493597690089085, 0.9531078420923699, 0.9341624650839186, 0.9508844211931609, 0.9340675427333366, 0.959701023970182, 0.6476176360332704, 0.7218064644921519, 0.680877265603924, 0.7530079103369889, 0.7451973049791578, 0.6983480880919775, 0.6998915017391973, 0.6303795053452176, 0.7285405170018199, 0.8476307916522129, 0.32071642201651895, 0.16934058100791594, 0.21926546876819963, 0.2206734908563709, 0.37120021151754445, 0.16144161384153288, 0.2335051415065439, 0.38237669713719735, 0.3470965623092661, 0.23289305810658922, 0.15338206077391714, 0.13102599835912077, 0.15165831724698653, 0.11834107607153621, 0.18495412263783217, 0.17452004451079595, 0.24279272021945475, 0.26604678097323287, 0.16719121327478625, 0.1975756838058068, 0.18645045016958361, 0.2280771837264851, 0.18924847644502063, 0.20776523801028346, 0.13167451764365756, 0.12475494062645798, 9.999999999998899e-05, 9.999999999998899e-05, 0.11447736327304647, 0.04485078775124307, 9.999999999998899e-05, 0.00015647137061425287, 0.015170016087017957, 9.999999999998899e-05, 0.1468985475909398, 0.12309744772369813, 0.052243621224075665, 0.11131201174430994, 0.07254213123234388, 0.04335296427326196, 0.02417920867679968, 0.07621452071708668, 0.08067450796311004, 0.05709594791113837, 0.09670366803332564, 0.034702171333950926, 0.15027990797705315, 0.16422612649311108, 0.07897352072514119, 0.08290887932088642, 0.21972535015447137, 0.16488977135847127, 0.1542657494345172, 0.07000677701838942, 0.19912504021684996, 0.13218712782564834, 0.07155083158862874, 0.10019998522100482, 0.06567006286835309, 0.0819695183567748, 0.16951263263662641, 0.08246486192778701, 0.5191699099212002, 0.5096099383804112, 0.5550043456284419, 0.5670765013063024, 0.6514088608837126, 0.5268999644629064, 0.5701744156361688, 0.5894627186761361, 0.5792089006295249, 0.11189525004000989, 0.10766987767109149, 0.09556101253353921, 0.15754896275717567, 0.09094418225834289, 0.1532569505774789, 0.15798237950139027, 0.10688907632848077, 0.10186417295809902, 0.16298730555959373, 0.39804716601633494, 0.2248289824587223, 0.26810894779161654, 0.19773321118514564, 0.3466349439903206, 0.22224414567293238, 0.2163474166330447, 0.20319308771409172, 0.35247075587507737, 0.2883185204808054, 0.38917412635046866, 0.40600127771674255, 0.4444463322294818, 0.2392204992926521, 0.35135752541096743, 0.5285418941818764, 0.545769322740339, 0.29536037534824133, 0.21392289481739135, 0.21274121576812766, 0.2807839748913936, 0.28553392869696237, 0.2691653164224095, 0.2185874548284753, 0.3472197276092023, 0.26452567261681514, 0.2790395498906183, 0.20302167826743633, 0.21366365036123292, 0.24042068708131004, 0.22674639477007963, 0.2329667594975947, 0.2078020895932431, 0.20942917836095098, 0.19687475441567748, 0.22753917345934593, 0.19833223472098815, 0.2225726264065575, 0.22428750253746588, 0.24770755463520167, 0.21111505279679144, 0.19806801674306695, 0.18556246306579682, 0.18179248114993174, 0.8935581687799908, 0.1876249402741047, 0.15358567701838877, 0.17259858967078212, 0.20004508617238304, 0.19908826956517256, 0.14231469110333128, 0.8898175794480578, 0.9164785343587694, 0.6908864741568164, 0.2130134576315842, 0.07347212513037504, 0.5135276647182967, 0.6644557360343832, 0.15404250823349352, 0.10480947845454613, 0.10476494688988347, 0.5341065086659211, 0.19181176319968662, 0.18280770096213483, 0.21987661997462116, 0.1912125975148864, 0.19199237165484995, 0.2162304914567822, 0.19237781270971321, 0.1952393396097638, 0.17769445862368194, 0.08509924276645742, 0.09353572510317931, 0.08236145423535512, 0.09217079154275976, 0.09750561092682675, 0.10106150898965882, 0.13441175821206286, 0.09927797616671175, 0.09894833280161142]}, "mutation_prompt": null}
{"id": "22fc2b19-ff7c-4b5c-9669-025105d62d0b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=L)\n        v = np.random.normal(0, 1, size=L)\n        return u / np.abs(v) ** (1 / beta)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            levy_step = self.levy_flight(self.dim)\n            self.population = np.clip(self.population + levy_step, self.lower_bound, self.upper_bound)  # Line changed\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Integrate a Lvy flight strategy to enhance exploration capabilities, especially during early iterations.", "configspace": "", "generation": 74, "fitness": 0.17272247037525387, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "620f3852-b2cb-4418-985f-7c708b78c387", "metadata": {"aucs": [0.2953032324070809, 0.2871012197857091, 0.28919428012437565, 0.2970273770813605, 0.3062560917780537, 0.31753219876669514, 0.2955996206941399, 0.28602329484574507, 0.2794647361978332, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013619368477757465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07938004943116916, 0.07926127295039564, 0.08968841819686424, 0.0817987859764473, 0.08722251983844731, 0.09387971717522636, 0.08207812132544845, 0.08970233409991091, 0.08453003203952814, 0.055355623792422204, 0.08708526559632424, 0.06166366818397695, 0.0683925469973301, 0.07145532060599258, 0.07154206311532618, 0.06983205185671937, 0.07690539088144432, 0.08529981266670039, 0.9587875001312873, 0.9661904556760001, 0.9600849132499548, 0.9497029248832959, 0.9337542879009227, 0.9417331312775968, 0.9517678503097221, 0.9585428192360894, 0.9628186548333132, 0.20671553771735618, 0.1645387663647998, 0.12477140299708012, 0.17157396611072506, 0.1619101693713184, 0.19240222858570388, 0.16846957320949618, 0.15968595330602964, 0.18496638449841463, 0.1964904375399371, 0.2491896478521879, 0.20327836967032142, 0.21080626138446035, 0.27118588204969196, 0.24644258086465154, 0.2087572042817999, 0.21461893965421042, 0.21590361461212648, 0.09070293927177575, 0.0919782494237521, 0.07928590822434467, 0.08554499873023191, 0.07958801257826742, 0.10646235047667874, 0.08313559012323135, 0.10094686832116573, 0.08060382500843932, 0.1281533866697222, 0.08476810545147051, 0.08536729001939569, 0.09724106928440068, 0.08965944880608134, 0.10241913571120187, 0.08312206817918799, 0.044628088974173585, 0.09234753045699895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034775943594435033, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11325347933015328, 0.08097763818404824, 0.09493230088583515, 0.044184097045609105, 0.10837922732831429, 0.014363649837995207, 0.04671624376656058, 0.0775581366129271, 0.08761461941738069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02443857903805713, 0.04400342675602986, 0.04098370169505183, 0.015570736673797159, 0.027703007987012418, 0.033565760093489216, 0.03761228368106184, 0.03895499583265005, 0.03201760191052294, 0.2710279520040434, 0.3038794230678512, 0.28406298884757775, 0.28474198657676375, 0.30409019104429236, 0.28506662186493026, 0.2944759147211643, 0.28378124613635836, 0.31314416162334635, 0.08860497059242012, 0.09817193763522625, 0.08036801849535258, 0.08359614892456413, 0.10017173200114315, 0.083833627768234, 0.07175839559488595, 0.09771910267376283, 0.08689820594828657, 0.17077940257320334, 0.18895595674569865, 0.1414095445027329, 0.14484506800149155, 0.16726831689847077, 0.13457736602652726, 0.13867713455674002, 0.14768101153256208, 0.1687068379702179, 0.21882670258771875, 0.22215397654605162, 0.21204249697856636, 0.21560707404934443, 0.2223019972487087, 0.21144830869901698, 0.23668265792664, 0.224913072646167, 0.23296978763325793, 0.14144249703896183, 0.15353839945891246, 0.16622876661604824, 0.15007068703191873, 0.14090767976589813, 0.14171350153934836, 0.1569788047448033, 0.1672070629415977, 0.1890938367561028, 0.18169130190748362, 0.16890422200856048, 0.1882614188008187, 0.19604659045177864, 0.19785676197692026, 0.183011638831437, 0.19505861971833038, 0.20943691689662702, 0.21367341400699302, 0.17884028825733456, 0.1822004695898659, 0.17935451310071893, 0.17139285001788795, 0.18037613252034568, 0.17116112666771133, 0.16910351045341665, 0.16920948863953422, 0.17480118332043804, 0.39826432294229763, 0.1826788970681852, 0.1498134514884789, 0.3234564033309184, 0.17862163126584907, 0.18382543539629181, 0.34422579134643927, 0.3483918887626527, 0.40202821401049604, 0.286179089151566, 0.19781935147786067, 0.18336091198175863, 0.3381852579669081, 0.3017295457034843, 0.13469747388427933, 0.10327973039948535, 0.17537904799353132, 0.35353492107645945, 0.17596704698382382, 0.1873658668826541, 0.19095536336228003, 0.19133428379874262, 0.17883926887116863, 0.18827170951044558, 0.197526246460343, 0.21166298070320233, 0.2007488635907405, 0.07439972779129, 0.06814783263162338, 0.07892623573830482, 0.07591525822319312, 0.07889742347455231, 0.08089929376038851, 0.07312530827423902, 0.0793913977587617, 0.07761871931563746]}, "mutation_prompt": null}
{"id": "7da47a67-82c1-4fed-a129-d4f03a47b186", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation\n        self.f = max(0.1, self.f - adaptation_rate * (self.f - 0.1))\n        self.cr = min(0.9, self.cr + adaptation_rate * (0.9 - self.cr))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive chaotic mutation in DE to dynamically balance exploration and exploitation.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "620f3852-b2cb-4418-985f-7c708b78c387", "metadata": {"aucs": [0.8771955180425387, 0.8598621577532959, 0.8671956961663929, 0.8673271045496741, 0.8724711999682947, 0.8697714072552367, 0.8700710997118117, 0.8739015098311813, 0.8660511117838812, 0.6390218894556824, 0.7022966250216927, 0.6431697951488102, 0.6461864528548422, 0.6572434976127404, 0.6952074210214814, 0.5435722784097125, 0.6574046990192084, 0.6370258688065696, 0.14338405469463777, 0.14239016281647765, 0.14397117206647236, 0.11522066523679841, 0.08136990893516194, 0.12285105262709217, 0.11054995587265404, 0.14294596181603703, 0.15309982050310578, 0.09991394864669478, 0.07988954678676696, 0.08527238268501991, 0.11100267302100852, 0.10774980248035226, 0.10819769125092571, 0.1402671768335516, 0.10706139894284916, 0.1095067372661701, 0.933589951649658, 0.948043529369547, 0.95987630067038, 0.9493597690089085, 0.9531078420923699, 0.9341624650839186, 0.9508844211931609, 0.9340675427333366, 0.959701023970182, 0.6476176360332704, 0.7218064644921519, 0.680877265603924, 0.7530079103369889, 0.7451973049791578, 0.6983480880919775, 0.6998915017391973, 0.6303795053452176, 0.7285405170018199, 0.8476307916522129, 0.32071642201651895, 0.16934058100791594, 0.21926546876819963, 0.2206734908563709, 0.37120021151754445, 0.16144161384153288, 0.2335051415065439, 0.38237669713719735, 0.3470965623092661, 0.23289305810658922, 0.15338206077391714, 0.13102599835912077, 0.15165831724698653, 0.11834107607153621, 0.18495412263783217, 0.17452004451079595, 0.24279272021945475, 0.26604678097323287, 0.16719121327478625, 0.1975756838058068, 0.18645045016958361, 0.2280771837264851, 0.18924847644502063, 0.20776523801028346, 0.13167451764365756, 0.12475494062645798, 9.999999999998899e-05, 9.999999999998899e-05, 0.11447736327304647, 0.04485078775124307, 9.999999999998899e-05, 0.00015647137061425287, 0.015170016087017957, 9.999999999998899e-05, 0.1468985475909398, 0.12309744772369813, 0.052243621224075665, 0.11131201174430994, 0.07254213123234388, 0.04335296427326196, 0.02417920867679968, 0.07621452071708668, 0.08067450796311004, 0.05709594791113837, 0.09670366803332564, 0.034702171333950926, 0.15027990797705315, 0.16422612649311108, 0.07897352072514119, 0.08290887932088642, 0.21972535015447137, 0.16488977135847127, 0.1542657494345172, 0.07000677701838942, 0.19912504021684996, 0.13218712782564834, 0.07155083158862874, 0.10019998522100482, 0.06567006286835309, 0.0819695183567748, 0.16951263263662641, 0.08246486192778701, 0.5191699099212002, 0.5096099383804112, 0.5550043456284419, 0.5670765013063024, 0.6514088608837126, 0.5268999644629064, 0.5701744156361688, 0.5894627186761361, 0.5792089006295249, 0.11189525004000989, 0.10766987767109149, 0.09556101253353921, 0.15754896275717567, 0.09094418225834289, 0.1532569505774789, 0.15798237950139027, 0.10688907632848077, 0.10186417295809902, 0.16298730555959373, 0.39804716601633494, 0.2248289824587223, 0.26810894779161654, 0.19773321118514564, 0.3466349439903206, 0.22224414567293238, 0.2163474166330447, 0.20319308771409172, 0.35247075587507737, 0.2883185204808054, 0.38917412635046866, 0.40600127771674255, 0.4444463322294818, 0.2392204992926521, 0.35135752541096743, 0.5285418941818764, 0.545769322740339, 0.29536037534824133, 0.21392289481739135, 0.21274121576812766, 0.2807839748913936, 0.28553392869696237, 0.2691653164224095, 0.2185874548284753, 0.3472197276092023, 0.26452567261681514, 0.2790395498906183, 0.20302167826743633, 0.21366365036123292, 0.24042068708131004, 0.22674639477007963, 0.2329667594975947, 0.2078020895932431, 0.20942917836095098, 0.19687475441567748, 0.22753917345934593, 0.19833223472098815, 0.2225726264065575, 0.22428750253746588, 0.24770755463520167, 0.21111505279679144, 0.19806801674306695, 0.18556246306579682, 0.18179248114993174, 0.8935581687799908, 0.1876249402741047, 0.15358567701838877, 0.17259858967078212, 0.20004508617238304, 0.19908826956517256, 0.14231469110333128, 0.8898175794480578, 0.9164785343587694, 0.6908864741568164, 0.2130134576315842, 0.07347212513037504, 0.5135276647182967, 0.6644557360343832, 0.15404250823349352, 0.10480947845454613, 0.10476494688988347, 0.5341065086659211, 0.19181176319968662, 0.18280770096213483, 0.21987661997462116, 0.1912125975148864, 0.19199237165484995, 0.2162304914567822, 0.19237781270971321, 0.1952393396097638, 0.17769445862368194, 0.08509924276645742, 0.09353572510317931, 0.08236145423535512, 0.09217079154275976, 0.09750561092682675, 0.10106150898965882, 0.13441175821206286, 0.09927797616671175, 0.09894833280161142]}, "mutation_prompt": null}
{"id": "58467fb8-bbcd-4060-aed0-0c2b7d6a9c46", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.sin(np.pi * self.evaluations / self.budget)  # Dynamic cognitive coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance the synergy of PSO and DE by integrating exponential decay for DE parameters and a dynamic cognitive coefficient for improved exploration.", "configspace": "", "generation": 76, "fitness": 0.3224601790842103, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "620f3852-b2cb-4418-985f-7c708b78c387", "metadata": {"aucs": [0.875344131956702, 0.858430977920578, 0.867422660373419, 0.8682767325176401, 0.8678121879421823, 0.8725183190410191, 0.8737430982685519, 0.8587650884421933, 0.8633089642087434, 0.6987134502204374, 0.6919323676915601, 0.676371711887223, 0.652414193982179, 0.7040288350729137, 0.6803163104216704, 0.6917025653125395, 0.6983449380252724, 0.636394162761239, 0.11138524147222251, 0.17148990881648607, 0.1435170696993393, 0.16612718212577693, 0.0953210500738827, 0.1415390591109592, 0.14074535010052913, 0.1754145306539474, 0.1763225679385383, 0.09643688818323626, 0.09224202700520034, 0.13495758945660496, 0.14175955795146533, 0.11406115394373462, 0.11946502436438877, 0.11030986043293955, 0.09815211541093771, 0.12967110481006405, 0.9493592901845537, 0.9446000099847668, 0.9569273128939685, 0.9252013156727901, 0.9506687370216496, 0.9337713715511876, 0.9320866577468884, 0.9512895327876775, 0.9591983617717272, 0.7187145676887843, 0.7267638901797763, 0.6123754976982614, 0.7435931800577695, 0.6528408177235561, 0.6713795966448586, 0.6817026985144865, 0.6361040885684535, 0.6812492785156428, 0.22395122719641702, 0.9034545710613605, 0.37446798477178245, 0.21428368862068414, 0.19317955370011075, 0.27817406599634964, 0.6361449700104622, 0.2353587575185081, 0.38677393410967253, 0.26434093496586397, 0.13569404421687037, 0.18136199548496745, 0.19814252439183688, 0.18637992614834142, 0.12307755068629189, 0.18798766073930306, 0.19610063024947333, 0.21843900315887377, 0.2515884477426983, 0.18142632227099498, 0.1848006916488112, 0.18080862588746782, 0.24761383681471083, 0.2148596438755368, 0.23028013806361192, 9.999999999998899e-05, 0.15339843342338533, 9.999999999998899e-05, 9.999999999998899e-05, 0.008401312453445664, 0.04569059503594908, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001508808916148574, 0.0011929529397899374, 0.06290026821514838, 0.15476764297185963, 0.05276008836909207, 0.10529105439411102, 0.08467678968677739, 0.06452933395379457, 0.03768581331485987, 0.06666056832459322, 0.1376101578794009, 0.0715425652706061, 0.13513045831008452, 0.038107851458896946, 0.11839306740470512, 0.15306264525470814, 0.12089971829650836, 0.09295255789574952, 0.14322561641907539, 0.19393679746281722, 0.24751243921339705, 0.07533989265345475, 0.2186950813368984, 0.11274097777595327, 0.11649240473451095, 0.1757973733022662, 0.0505758304478886, 0.09161907922528423, 0.3944145949769584, 0.083504511336149, 0.5331918954590575, 0.56869075399405, 0.5324208547645813, 0.5276936258959672, 0.5720936468692359, 0.5225408779369844, 0.5531219439916537, 0.5565773827626495, 0.5764344013838043, 0.10331745551809057, 0.10644719563026006, 0.11432581731909774, 0.10163016520879009, 0.07112262218083032, 0.10747903287735716, 0.10512486285249345, 0.11595243745050521, 0.1336078969472777, 0.16042606332101017, 0.4491849951245742, 0.2029784718025608, 0.261131157040855, 0.21325544791862905, 0.21980094614167955, 0.2722276777809851, 0.28076652027814575, 0.25469551631161025, 0.2652437808222674, 0.2676946794141636, 0.3512257364535899, 0.2775054116988216, 0.4658366691131388, 0.25941796900005587, 0.4607009756745277, 0.4409329799563969, 0.5417876506851457, 0.3461876844512066, 0.23606977475613244, 0.3332956995645646, 0.35265698787681754, 0.30942475980794315, 0.24501385142923737, 0.277886657416926, 0.28852272057274764, 0.2650732791148034, 0.22732805584954274, 0.1945900786143897, 0.23148393573359816, 0.24218659978286494, 0.21060425319888, 0.18930786874409533, 0.19137057526000234, 0.21101050435254043, 0.24387467739490798, 0.1862728382291492, 0.2220786108748627, 0.22269970407631046, 0.19244652578175592, 0.21873110253877026, 0.19728309567057378, 0.18871950287325723, 0.19787041227892532, 0.17466622823493982, 0.8837780667120241, 0.17655264789761915, 0.15351745834377417, 0.811686778783444, 0.20003564745545888, 0.19974259418221285, 0.14218235046832428, 0.9030730281441552, 0.9327407017347492, 0.5215102147196475, 0.21302611610754107, 0.4161087963909018, 0.616496055066241, 0.6032986296235994, 0.15239254738243146, 0.10485222561675422, 0.10480739907613534, 0.6997942037705864, 0.18659804504706134, 0.1892053400931245, 0.1876034766111968, 0.19793966052651224, 0.18580136959749682, 0.19604667720609836, 0.19557310417017826, 0.24419035949811685, 0.19355271049783418, 0.09316054993440503, 0.08765091136431602, 0.1597320835780982, 0.0856700154014205, 0.09560634079568864, 0.09133687134408808, 0.12022939579129033, 0.10736379735327284, 0.09386674307918985]}, "mutation_prompt": null}
{"id": "512c0e7a-c24d-475c-92c6-3f98aa98c389", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.sin(np.pi * self.evaluations / self.budget)  # Dynamic cognitive coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        levy_flight = np.random.standard_cauchy((self.pop_size, self.dim))  # Lvy flight step added\n        self.velocity = (self.inertia_weight * self.velocity + cognitive + social + levy_flight)\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight with sinusoidal adjustment\n            self.inertia_weight = 0.5 + 0.4 * np.sin(self.evaluations * np.pi / (2 * self.budget))\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a Lvy flight mechanism in velocity update for enhanced exploration and a sinusoidal adjustment in the inertia weight for dynamic balancing.", "configspace": "", "generation": 77, "fitness": 0.12578967954217715, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "58467fb8-bbcd-4060-aed0-0c2b7d6a9c46", "metadata": {"aucs": [0.18439327834924646, 0.20507113279936606, 0.15877771320452483, 0.20755473609960073, 0.17753557828096567, 0.18158337543628955, 0.1754707338271797, 0.17353273113401824, 0.20371065880661765, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03857364061437929, 0.039634918353187665, 0.038580501182230775, 0.04333465392386693, 0.03704719330093775, 0.04139869948827912, 0.044871266590278736, 0.0351829124829115, 0.06856211382333655, 0.047645536225595975, 0.02836306556884083, 0.0242262619866096, 0.03247951691623552, 0.030684005493390343, 0.04137051993423324, 0.02498823244261239, 0.020819792949265725, 0.030717866084857604, 0.9841891228347841, 0.9769234540229348, 0.9849996665455377, 0.976736095869398, 0.9848057624338766, 0.981289306963073, 0.9856241734385747, 0.985917530999962, 0.97679222550757, 0.07159126712612052, 0.0691695634733771, 0.07522528521972038, 0.10995763028963379, 0.1046314081212778, 0.0974939277336927, 0.08181308379657637, 0.07683657559357526, 0.073680308625101, 0.11652082132212183, 0.15319587470102725, 0.1275872901606162, 0.16026760893986214, 0.12380023135905371, 0.11654961327226698, 0.12181258720546162, 0.1066267603925316, 0.11336748467552038, 9.999999999998899e-05, 0.00031155240416169683, 0.003689878905270616, 0.019585094270966108, 0.0027961617065181965, 9.999999999998899e-05, 0.012964017587138166, 0.004446292112598171, 9.999999999998899e-05, 0.003905236045498861, 0.009756331930108497, 0.012905004485493143, 0.01382070286667969, 0.0013053866835691652, 9.999999999998899e-05, 9.999999999998899e-05, 0.005538752588934437, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032748063286552664, 0.019683291935258973, 0.04788084947180016, 0.04046074628342322, 0.004003984659502358, 0.0015225174991224666, 0.06411701849394125, 0.018689641396599455, 0.043456874869221784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0073029037504492855, 0.19344919038393305, 0.19368392668856982, 0.18969155724579445, 0.25063039018686595, 0.21246683278170708, 0.2834648022389462, 0.1758391834704709, 0.16184424834822853, 0.23023404212174814, 0.06145829475944664, 0.06482795150068321, 0.045542692114174166, 0.055203116106679606, 0.052459118550754136, 0.054425805258894955, 0.045633816157044205, 0.03262431601309612, 0.03597448717030893, 0.13402229440756253, 0.12483031973490832, 0.12881426889516512, 0.1270644735062899, 0.1429081725414968, 0.1426956889505705, 0.12937424969713907, 0.13519015184883132, 0.14597324256930844, 0.16761532765930665, 0.16274129943679294, 0.19381442491671375, 0.1742508497071643, 0.1556834835753531, 0.15314887155610646, 0.1690071203730309, 0.17377774300845283, 0.15653772685844525, 0.09834148857304004, 0.10141356682815972, 0.11289156860682248, 0.11712272328915219, 0.1124630714652669, 0.09903241395096707, 0.13381042525164066, 0.11899930599559017, 0.1451180622048761, 0.13563160769462013, 0.13480063532270292, 0.1675834896267665, 0.14886144538638146, 0.13965103980729998, 0.15696947035156683, 0.15658372155641698, 0.17878769633867797, 0.16697548981473087, 0.14018153459400529, 0.11159873589876168, 0.14328041841394712, 0.14343217423071242, 0.14132158280257356, 0.1507192781096368, 0.1262773492858703, 0.13920310268703961, 0.14213988105174435, 0.22101866438828022, 0.13390828289018264, 0.15822018427349105, 0.12082118736737468, 0.14732625418611278, 0.12281175832089408, 0.16093917634065635, 0.14746484036952245, 0.2003413549514148, 0.18800736727170209, 0.15242809129156576, 0.13673011466579155, 0.16029222998692438, 0.15315342891786166, 0.1261299160458299, 0.17366919211015042, 0.19300862170557653, 0.182124121573639, 0.19211509659525983, 0.18531831400832766, 0.18425916902883122, 0.17940656385855813, 0.18044929424321232, 0.17664284239565842, 0.20945133375422953, 0.1756365002714998, 0.19707680435010022, 0.0525276336866749, 0.04682875478737336, 0.05118188409573887, 0.05386588577476725, 0.050460314230571957, 0.05121407417074819, 0.04798590372040745, 0.03803354422653826, 0.05112172262092973]}, "mutation_prompt": null}
{"id": "fb924ad0-e7c0-494e-8322-2d1c8be85607", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.sin(np.pi * self.evaluations / self.budget)  # Dynamic cognitive coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Periodic reset every 20% of the budget\n            if self.evaluations % (self.budget // 5) == 0:\n                self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n                self.evaluate(func)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a periodic reset of velocity and population to avoid local optima and enhance exploration.", "configspace": "", "generation": 78, "fitness": 0.3224601790842103, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "58467fb8-bbcd-4060-aed0-0c2b7d6a9c46", "metadata": {"aucs": [0.875344131956702, 0.858430977920578, 0.867422660373419, 0.8682767325176401, 0.8678121879421823, 0.8725183190410191, 0.8737430982685519, 0.8587650884421933, 0.8633089642087434, 0.6987134502204374, 0.6919323676915601, 0.676371711887223, 0.652414193982179, 0.7040288350729137, 0.6803163104216704, 0.6917025653125395, 0.6983449380252724, 0.636394162761239, 0.11138524147222251, 0.17148990881648607, 0.1435170696993393, 0.16612718212577693, 0.0953210500738827, 0.1415390591109592, 0.14074535010052913, 0.1754145306539474, 0.1763225679385383, 0.09643688818323626, 0.09224202700520034, 0.13495758945660496, 0.14175955795146533, 0.11406115394373462, 0.11946502436438877, 0.11030986043293955, 0.09815211541093771, 0.12967110481006405, 0.9493592901845537, 0.9446000099847668, 0.9569273128939685, 0.9252013156727901, 0.9506687370216496, 0.9337713715511876, 0.9320866577468884, 0.9512895327876775, 0.9591983617717272, 0.7187145676887843, 0.7267638901797763, 0.6123754976982614, 0.7435931800577695, 0.6528408177235561, 0.6713795966448586, 0.6817026985144865, 0.6361040885684535, 0.6812492785156428, 0.22395122719641702, 0.9034545710613605, 0.37446798477178245, 0.21428368862068414, 0.19317955370011075, 0.27817406599634964, 0.6361449700104622, 0.2353587575185081, 0.38677393410967253, 0.26434093496586397, 0.13569404421687037, 0.18136199548496745, 0.19814252439183688, 0.18637992614834142, 0.12307755068629189, 0.18798766073930306, 0.19610063024947333, 0.21843900315887377, 0.2515884477426983, 0.18142632227099498, 0.1848006916488112, 0.18080862588746782, 0.24761383681471083, 0.2148596438755368, 0.23028013806361192, 9.999999999998899e-05, 0.15339843342338533, 9.999999999998899e-05, 9.999999999998899e-05, 0.008401312453445664, 0.04569059503594908, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001508808916148574, 0.0011929529397899374, 0.06290026821514838, 0.15476764297185963, 0.05276008836909207, 0.10529105439411102, 0.08467678968677739, 0.06452933395379457, 0.03768581331485987, 0.06666056832459322, 0.1376101578794009, 0.0715425652706061, 0.13513045831008452, 0.038107851458896946, 0.11839306740470512, 0.15306264525470814, 0.12089971829650836, 0.09295255789574952, 0.14322561641907539, 0.19393679746281722, 0.24751243921339705, 0.07533989265345475, 0.2186950813368984, 0.11274097777595327, 0.11649240473451095, 0.1757973733022662, 0.0505758304478886, 0.09161907922528423, 0.3944145949769584, 0.083504511336149, 0.5331918954590575, 0.56869075399405, 0.5324208547645813, 0.5276936258959672, 0.5720936468692359, 0.5225408779369844, 0.5531219439916537, 0.5565773827626495, 0.5764344013838043, 0.10331745551809057, 0.10644719563026006, 0.11432581731909774, 0.10163016520879009, 0.07112262218083032, 0.10747903287735716, 0.10512486285249345, 0.11595243745050521, 0.1336078969472777, 0.16042606332101017, 0.4491849951245742, 0.2029784718025608, 0.261131157040855, 0.21325544791862905, 0.21980094614167955, 0.2722276777809851, 0.28076652027814575, 0.25469551631161025, 0.2652437808222674, 0.2676946794141636, 0.3512257364535899, 0.2775054116988216, 0.4658366691131388, 0.25941796900005587, 0.4607009756745277, 0.4409329799563969, 0.5417876506851457, 0.3461876844512066, 0.23606977475613244, 0.3332956995645646, 0.35265698787681754, 0.30942475980794315, 0.24501385142923737, 0.277886657416926, 0.28852272057274764, 0.2650732791148034, 0.22732805584954274, 0.1945900786143897, 0.23148393573359816, 0.24218659978286494, 0.21060425319888, 0.18930786874409533, 0.19137057526000234, 0.21101050435254043, 0.24387467739490798, 0.1862728382291492, 0.2220786108748627, 0.22269970407631046, 0.19244652578175592, 0.21873110253877026, 0.19728309567057378, 0.18871950287325723, 0.19787041227892532, 0.17466622823493982, 0.8837780667120241, 0.17655264789761915, 0.15351745834377417, 0.811686778783444, 0.20003564745545888, 0.19974259418221285, 0.14218235046832428, 0.9030730281441552, 0.9327407017347492, 0.5215102147196475, 0.21302611610754107, 0.4161087963909018, 0.616496055066241, 0.6032986296235994, 0.15239254738243146, 0.10485222561675422, 0.10480739907613534, 0.6997942037705864, 0.18659804504706134, 0.1892053400931245, 0.1876034766111968, 0.19793966052651224, 0.18580136959749682, 0.19604667720609836, 0.19557310417017826, 0.24419035949811685, 0.19355271049783418, 0.09316054993440503, 0.08765091136431602, 0.1597320835780982, 0.0856700154014205, 0.09560634079568864, 0.09133687134408808, 0.12022939579129033, 0.10736379735327284, 0.09386674307918985]}, "mutation_prompt": null}
{"id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.3262870196602949, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "58467fb8-bbcd-4060-aed0-0c2b7d6a9c46", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "c33b1a67-aef8-455a-920b-017e29121337", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * (1 + 0.1 * np.sin(np.pi * self.evaluations / self.budget))  # More dynamic update\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing a chaotic mutation factor and adjusting the velocity update with a dynamic sinusoidal component.", "configspace": "", "generation": 80, "fitness": 0.2110468859412904, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.5462201399769382, 0.5314911314139701, 0.5173562764479974, 0.5305408606100019, 0.4893589191207728, 0.5659362537328643, 0.48756094201838385, 0.5228300459993689, 0.4847511744867353, 0.1400772379922146, 0.0613020816694001, 0.05530979547094217, 0.10140313692715519, 0.1561865971255293, 0.15728849783310417, 0.1301721086050508, 0.1421066782542164, 0.15341288032881417, 0.10817938252796844, 0.11463138272491558, 0.11366132879562918, 0.10253233853847232, 0.12181955035818359, 0.13685734241294267, 0.09649655082225017, 0.10359067666519517, 0.09233483876559134, 0.10988773423663656, 0.09270398794182988, 0.08329104135089127, 0.08149396536629461, 0.10432406067082634, 0.11668257031782236, 0.10335507321191895, 0.12684246328046045, 0.09281060597897028, 0.9829595741045045, 0.9778793064393113, 0.9773402309948018, 0.9730809950176765, 0.9764061547585373, 0.9852198760271466, 0.9837869030666554, 0.9845708564239164, 0.9772296552924451, 0.2315667912006164, 0.19483353514941026, 0.18814580501448774, 0.14430745725605443, 0.1429938088999606, 0.22111950892341659, 0.2054617683320844, 0.2249587362226907, 0.24024015945732757, 0.17060745006611777, 0.2217036194624894, 0.16891738464133177, 0.2110388328781595, 0.20318139729423434, 0.19090332697587287, 0.2238106625500459, 0.23416057691120917, 0.2856861700105625, 0.18136116790356804, 0.09327626601809802, 0.14857032279421167, 0.1409141470890125, 0.1218484059340812, 0.12168512851702928, 0.1487982937408393, 0.14068423860254442, 0.14880578973421454, 0.11670003860350553, 0.13686737708328656, 0.16579559080541928, 0.12084180094971486, 0.1433591380031023, 0.14955282154894867, 0.11866406109552752, 0.11037238100753588, 0.15521413981695065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019544766504995592, 9.999999999998899e-05, 9.999999999998899e-05, 0.026396197419545908, 0.02214180754165629, 0.11572480813309194, 0.06092671566128993, 0.00692040604201849, 0.035287821584949364, 0.045089006620100736, 0.06142930087257936, 0.0367566588899263, 0.005110032048028512, 0.015835661395347422, 0.021580911387464763, 0.040804643416552655, 0.07362334435462048, 0.03568901299466687, 0.01293011075604622, 0.030822664819519563, 0.036596220517248534, 0.09863670092920873, 0.03960696506874484, 0.08644361311066973, 0.10171705875741777, 0.051346054640219685, 0.08673701195862304, 0.06422627919942481, 0.1350105024497238, 0.07229211000374347, 0.4187659038174544, 0.3922766770965984, 0.41004418861338154, 0.4031157531701074, 0.4215461772174881, 0.4130480531279026, 0.4132069758624638, 0.3613387166155061, 0.39982786936519343, 0.06430333105617103, 0.08608101580213812, 0.09513831718612598, 0.08686865298176183, 0.08703158047736093, 0.12106197518524564, 0.06150572487970163, 0.09888801346002707, 0.10284050709577763, 0.3104138723842711, 0.18286573460843925, 0.1715979200330816, 0.20168194471613166, 0.17910954907679022, 0.20909446792970798, 0.28074219760332786, 0.1736579074054576, 0.15700631224040262, 0.2702485995316548, 0.26038544295652544, 0.2591621381503455, 0.267035325753224, 0.25606346645839817, 0.2629778927319776, 0.30370143756182566, 0.2918526367118093, 0.2894167207170446, 0.17329606950473175, 0.15577901638658864, 0.21837653618135755, 0.13921145629595122, 0.17538990906458907, 0.2374513756073957, 0.22184503928691457, 0.2780224854953569, 0.22688076637381283, 0.21160644749304391, 0.17443236000994933, 0.18676077329160168, 0.18961935492355564, 0.1879577949550465, 0.2003332303872234, 0.1887376450553372, 0.1877357551455947, 0.23342069531508003, 0.1752856829935594, 0.20048733984082423, 0.20955589495222315, 0.2027879616556839, 0.2319331625552229, 0.20169445704620326, 0.20495169876800334, 0.2398528757666062, 0.18205817759128584, 0.6730594967070289, 0.16238329259507078, 0.15406196078920453, 0.6224585922234214, 0.6216790981911882, 0.19721462387945254, 0.1808775009640563, 0.15910647601860817, 0.20565292047018624, 0.3291530814478346, 0.2095255756250891, 0.20353061832265407, 0.33864250982712285, 0.3538433118792721, 0.12378961330201621, 0.10338090302208269, 0.10437729638783844, 0.2001126148797906, 0.18521371421713317, 0.19608621519633684, 0.1802540671905366, 0.18070427728040428, 0.183987343394448, 0.18444231304192338, 0.17516498981890838, 0.1824177352586588, 0.19219673956640115, 0.07805041860247841, 0.0787226011229728, 0.07543117412016731, 0.07750371399550515, 0.07418545953478173, 0.07595680788814918, 0.08276649380876555, 0.07461087173682668, 0.06596828781251518]}, "mutation_prompt": null}
{"id": "41ef5bb8-3404-4fe7-9602-5404e2d9990a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(self.evaluations * r1 * np.pi)  # Updated chaotic influence\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            factor_scale = (1.5 - self.evaluations / self.budget)  # New mutation strategy\n            mutation_factor = self.f * factor_scale * (1 + np.sin(self.evaluations * np.pi / self.budget))\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploration by adjusting the chaotic map's influence on velocity and diversifying DE mutation strategy based on evaluation count.", "configspace": "", "generation": 81, "fitness": 0.16565432828797866, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.33343551674214644, 0.25446269239346786, 0.29439400984540887, 0.3582092520721427, 0.33956344981726383, 0.32941467890311804, 0.31881323479429136, 0.31344019130002176, 0.3198923930871429, 0.03032438863756126, 0.019797270477570628, 0.04780463790599532, 0.0561693642178025, 0.019720093943898953, 0.027974946241929532, 0.030710189270900412, 0.01373929340414104, 0.06638961914367081, 0.08734004277435137, 0.08653212067374538, 0.07924844346312732, 0.10894982905487871, 0.08135478637735594, 0.09148945656180785, 0.08254899007665395, 0.09021350122995742, 0.10838776580060216, 0.06685244806405133, 0.04743960374111211, 0.07117062420254483, 0.0717466018331292, 0.06675066003379293, 0.06314002817251108, 0.06503632599307496, 0.05945910891951367, 0.07130976614346796, 0.9152018241011499, 0.8922386306614731, 0.9462118943181034, 0.9173855809810358, 0.9441756589334896, 0.9165050012648757, 0.9608935871600375, 0.965540186318453, 0.8915651716654653, 0.14214665696911, 0.13715362198735404, 0.14462517174474288, 0.12969528639834316, 0.13760040669700357, 0.1503578063591514, 0.15015202731735244, 0.13964951122872094, 0.1400556989014351, 0.23672424095842348, 0.1883682999716796, 0.16938995646918809, 0.27929471606900513, 0.17563760189841382, 0.2606709802754502, 0.15657900308334305, 0.1769887086822035, 0.21503377429622095, 0.07630571141098841, 0.08110466865631227, 0.06177093735054673, 0.08312442241799067, 0.10388721638123077, 0.07217762716293197, 0.09080686893915169, 0.04708340455667914, 0.06987637324595286, 0.06996033833156312, 0.1080190323299619, 0.0862505542626284, 0.09346033614929927, 0.05412625306598895, 0.06784664783685079, 0.10161321245438681, 0.045119899990725965, 0.05693180708049328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07624293272857463, 0.03187412446068827, 0.08190150407658658, 0.04431939902406756, 0.07235221385906387, 0.04137968440939199, 0.042915266485232695, 0.017069295501863757, 0.05301775248102891, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031294287328510695, 0.022707218961228515, 0.04575376833643441, 0.04559275130003371, 0.048910055026619714, 0.013007938725866697, 0.04811736527587995, 0.03696704296226472, 0.045836506869618265, 0.3061903568456237, 0.3257634620331371, 0.28358743381824336, 0.30145696187086446, 0.29685952358008594, 0.2961929529540517, 0.2967208611416994, 0.27668972120637103, 0.34466658264810723, 0.07475593464097785, 0.08328450341654448, 0.08715217728267122, 0.07222300457337583, 0.06997368658532488, 0.07870372412270066, 0.07825041066559757, 0.0727616136695658, 0.06087051140379407, 0.18383500870476444, 0.16080972138364036, 0.19005142264093833, 0.1607349094835394, 0.155628120888736, 0.1641775735623301, 0.14495502514980452, 0.13023806273729355, 0.13606392093538544, 0.22135115197038058, 0.20816997392862513, 0.21744578435645867, 0.1739375876838647, 0.18639232584457688, 0.19178144293998844, 0.23877746803787536, 0.22632068731181643, 0.2533705213433822, 0.130309106138644, 0.16372570431672628, 0.14848970493289648, 0.13328288053618342, 0.13981519750362548, 0.13881083916245573, 0.16882313570806418, 0.15422213786217542, 0.1699648748581769, 0.18850078110505764, 0.177250500004278, 0.17521135324486292, 0.18757381006689156, 0.16947744906171336, 0.179150266579721, 0.18449081462619488, 0.17394374022858705, 0.16720177914556422, 0.178762112356338, 0.18302068019195683, 0.1665372132639037, 0.17519727152229259, 0.1548415074097178, 0.15659135967780313, 0.16776258277298928, 0.1573920328376356, 0.16356277379302608, 0.43761970087459345, 0.24781110099846893, 0.2602160405142093, 0.2463326325590658, 0.15758146208177892, 0.16782310222893937, 0.17379181111818542, 0.16923453016679268, 0.1613350812166482, 0.24787156400169386, 0.16406964022675352, 0.227662207330654, 0.283314074598255, 0.20603770827151613, 0.22120059218539911, 0.19850897884341134, 0.24538441176468273, 0.27185205271507173, 0.1849920516287593, 0.18180766055807895, 0.1739583011848228, 0.1715728832550536, 0.1874022307508434, 0.18387012254997048, 0.18187874734747933, 0.18618702264328213, 0.2072798132786816, 0.07918633579360446, 0.05507101176175855, 0.06677084649499065, 0.07116207723192225, 0.06917098477226391, 0.07656813820492425, 0.06458554506125691, 0.06265263866440451, 0.061925317593540474]}, "mutation_prompt": null}
{"id": "b4f1b553-9d29-40ca-adb3-513226dc2fb8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.tanh(r2 * np.pi)  # Updated line using chaotic tanh map for velocity\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.tanh(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation factor\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing chaotic sequences in velocity update and adaptive DE mutation factor.", "configspace": "", "generation": 82, "fitness": 0.2753502407302683, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.7780301767943913, 0.7393137632305319, 0.7698688626646121, 0.7632942877863622, 0.7376344618790527, 0.7543204855593312, 0.7575780496679924, 0.7414963780297656, 0.7335938572455323, 0.45921204701324514, 0.4746780302628423, 0.47699720877082363, 0.4797791502077141, 0.502772619875715, 0.48038085863494684, 0.04780473395767315, 0.42775399414803805, 0.49992337621497185, 0.13499842402877016, 0.10510668749462404, 0.14145371758130987, 0.13475445572909117, 0.13550364249310187, 0.07174352757880009, 0.14071893442117267, 0.16062532299893773, 0.13831982173747925, 0.10677138133346253, 0.10158316098026243, 0.15196248438810833, 0.12712061637395478, 0.12626774776551797, 0.15973278467440544, 0.11603953857449234, 0.10095102519232846, 0.09982459201308813, 0.9808161580863659, 0.9835119889568112, 0.9771186295187518, 0.9684565637273261, 0.9766139240469331, 0.9784162291151642, 0.9826603688522243, 0.9844458067904877, 0.977368615531312, 0.4731726871476557, 0.44586399946443644, 0.05732544649218674, 0.4065814628015466, 0.4075614361159088, 0.436116797848347, 0.43608858463994227, 0.44679853666145386, 0.45895734955879797, 0.2245652995341787, 0.22494277181341082, 0.17071220276304233, 0.2084374688959607, 0.32507061912670865, 0.8062938155329542, 0.5963921333649644, 0.20925699288778699, 0.7039235772723029, 0.11901675565113434, 0.1294936701394177, 0.177370326536472, 0.17184096302142204, 0.17710891476260404, 0.1105714896490465, 0.17340547303341824, 0.17820167128405884, 0.17857937352748943, 0.12499776897633963, 0.20250021623120473, 0.18501309475442218, 0.18154188924152315, 0.17850240241163207, 0.20238132871350867, 0.12709108429382798, 0.11442481233652269, 0.4033104956022684, 9.999999999998899e-05, 0.017005798593797916, 9.999999999998899e-05, 0.01242883397671557, 9.999999999998899e-05, 9.999999999998899e-05, 0.00023062977969490195, 0.015044379967846133, 0.14165601596362143, 0.050991561030416466, 0.051332421232918035, 0.08499851931300362, 0.0438891401053314, 0.01585742116784583, 0.003609600253648537, 0.0989014669244831, 0.09591778453316058, 0.12180667247432553, 0.027737293253834783, 0.028486665437350345, 0.06470303206664307, 0.09425719167267288, 0.07595975566485758, 0.06122459585517537, 0.08465699369550062, 0.06913210926230318, 0.07923940458110623, 0.18025565096578977, 0.0387103210683033, 0.03495542851961053, 0.07651732066504735, 0.12317636966806333, 0.2349147392798524, 0.0745250391893002, 0.05463401562050019, 0.08052707628093836, 0.5264328602535928, 0.5279363048439181, 0.5040451580050278, 0.5050988284555284, 0.5139042000425411, 0.5094500050170434, 0.5374878722092693, 0.5438456239459251, 0.5030598500428403, 0.14523293020617967, 0.08590520081346154, 0.08204311584919, 0.1048250679450663, 0.10252377087737152, 0.1386934701301641, 0.09404954077836847, 0.1525259663459856, 0.12864722063032008, 0.193946535390495, 0.26176047104994016, 0.18012959052441224, 0.1902464584508713, 0.15424090339740637, 0.23086758331422375, 0.39172520715078163, 0.195218895248236, 0.1992918615470719, 0.24753673859829584, 0.46083410443508765, 0.25044807561888005, 0.20163933846647975, 0.32312729068140367, 0.38150099440946206, 0.4245502363475657, 0.36569202256158573, 0.4073975943810968, 0.18793980046746062, 0.2487912331792751, 0.2227820613657331, 0.15534235992752687, 0.22533096474565106, 0.21544489541267142, 0.26962164727057014, 0.23600451459619787, 0.2559936433323964, 0.2373616499775545, 0.18053030438683382, 0.18851951680818646, 0.21859520763014784, 0.23022371877440173, 0.25655118539073873, 0.18683574523287172, 0.18866469818537523, 0.20316474999989953, 0.36057462306540433, 0.18971191473952753, 0.20417835908330662, 0.2170719655730834, 0.34411368860902014, 0.20936740647411134, 0.2824923430682158, 0.20777776883980115, 0.20697783488833899, 0.8299658708267418, 0.16399267098099057, 0.15343576084823163, 0.5696903318590185, 0.19879297634324322, 0.197943675164731, 0.14137775749027348, 0.16320439637643902, 0.7838603454773858, 0.5367970948262951, 0.2107765162382822, 0.7382502352803397, 0.5795535433716665, 0.16770278133254723, 0.15321152470199273, 0.10458008183913481, 0.10427944656669863, 0.15474545515335902, 0.214910470279708, 0.19998546980162868, 0.17788551367545702, 0.18036011393214235, 0.194422355629418, 0.18096871468112208, 0.19438527927833016, 0.18968288032794123, 0.1969828075916754, 0.07945460854163466, 0.08897818599887053, 0.08469563200765351, 0.08629727021669986, 0.0845747997453653, 0.08439147961411908, 0.1102937359545092, 0.09409023625031909, 0.08689263846521367]}, "mutation_prompt": null}
{"id": "12f830e3-ec13-48e8-b3dc-67e0e99d64e1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "e07c4f8c-8732-43ac-9998-b35e58c5719f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * np.sin(np.pi * self.evaluations / self.budget)  # Changed to sine function\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce an adaptive inertia weight based on the sine function to improve exploration and exploitation dynamically.", "configspace": "", "generation": 84, "fitness": 0.3087050545013029, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8422675104491261, 0.8241488672126365, 0.8333551151419958, 0.8555522080128881, 0.8692271026962286, 0.8423923297790186, 0.8434920418678138, 0.820629113184967, 0.8354112496654003, 0.6132509435539992, 0.07390019250381208, 0.49521472581924164, 0.6467309567182207, 0.6338656950475225, 0.6136241323416483, 0.6602233747072142, 0.36856048928326557, 0.6052987609119362, 0.18178979719414978, 0.12029469706004148, 0.15542465279394768, 0.1507626449358329, 0.15097199087879576, 0.1180165134700204, 0.1640022979122674, 0.17989653362134939, 0.14773157149079874, 0.09608016557039223, 0.1106911811298984, 0.10985996432785194, 0.11379423202395433, 0.11031339363661352, 0.11101214495032075, 0.17803981034682714, 0.11303400429513799, 0.1972378951599436, 0.9690962491102134, 0.9581563285364026, 0.9679668693585277, 0.9508752654632803, 0.9759367204422462, 0.9498702125460406, 0.9692421166575828, 0.9661631613165962, 0.9680036502807442, 0.6181205356610433, 0.5960127058043327, 0.6266356652771712, 0.6186205291326536, 0.541685134006026, 0.6125540182605755, 0.5827590642344305, 0.5815844727060802, 0.5956552434016738, 0.3780331582485732, 0.8425223147189613, 0.8880258616768739, 0.2751599731022455, 0.1939699612104263, 0.19366367018684705, 0.21187265185819348, 0.2287723499986397, 0.2313610904806611, 0.2412075414042153, 0.1622392412187581, 0.18796917639555366, 0.10265218903303797, 0.20841743776959532, 0.12297532174007031, 0.1975304536937491, 0.21014569546199413, 0.19165195001931667, 0.21507065739326436, 0.12561832924265015, 0.12859265960664157, 0.22593803501467447, 0.25164612646466833, 0.13163808592850568, 0.22551898939352966, 0.13950189519983613, 0.1294424820429263, 9.999999999998899e-05, 0.006335219133881909, 9.999999999998899e-05, 0.015832429831147188, 9.999999999998899e-05, 9.999999999998899e-05, 0.005265793624675608, 9.999999999998899e-05, 0.05375973417218394, 0.10310432554903981, 0.07174006395196153, 0.06713448349560835, 0.08607043707822393, 0.03324767322602751, 0.029344155894600266, 0.05848839985935561, 0.07319521076107072, 0.06755633972954167, 0.07853227406828378, 0.03462527075459365, 0.1185706447060858, 0.13663017895247032, 0.13483896166974596, 0.1315711383355439, 0.14746311472628038, 0.14031316290211704, 0.08968257362599996, 0.08091847528920648, 0.23286397177291118, 0.14858276313134533, 0.04696228209719722, 0.05721335914562109, 0.1433968948417942, 0.09990531986532947, 0.08831574690057864, 0.08073374466486472, 0.533661067054596, 0.5084454551056361, 0.5240140749393782, 0.5625082324698596, 0.5346691852151795, 0.5708524564555415, 0.5960676455700114, 0.5297868030492827, 0.5436182035949653, 0.06908196049923299, 0.06598020206108013, 0.11516556858027582, 0.10996051799973816, 0.13300949550973873, 0.09837401518380307, 0.12905657903069223, 0.07955890267177479, 0.07563273314813723, 0.4623278848181288, 0.3594936272748095, 0.20867273903651096, 0.33469275414018784, 0.19789846012503798, 0.40323870704627984, 0.2828229822543673, 0.3390364871478282, 0.2797530587149004, 0.27933558753907695, 0.3960728593763593, 0.4207461152464229, 0.4646248037229017, 0.5185993915175294, 0.3786712367085031, 0.4223995896413344, 0.4180016461852689, 0.48386950974236176, 0.3327562977713484, 0.22439689367451487, 0.3068608201619958, 0.3053001293106675, 0.2349289354549463, 0.16228749119730856, 0.2190782734993797, 0.25595876613887636, 0.2055891223344537, 0.216599438118651, 0.18053280186832377, 0.2041390581690291, 0.22296448345086117, 0.200980477471995, 0.23735823674778533, 0.21679551130370023, 0.19020504189826015, 0.22134694380587927, 0.2216142323081295, 0.19638525690745057, 0.20202965399353312, 0.25209043359020666, 0.18982708552363203, 0.20546046726328027, 0.2266908630468525, 0.18589121380968965, 0.18600953617922322, 0.8663929508418179, 0.18618204264119242, 0.1476122018044732, 0.8872557676213343, 0.20012176035642637, 0.169653107900412, 0.14276121615711723, 0.17803840369180435, 0.8974223619236281, 0.7247083340481134, 0.5001502352367568, 0.6774870395464518, 0.6068155691009305, 0.16669987144308962, 0.15385652607758438, 0.10467459493692644, 0.10493554286304041, 0.7201091573664602, 0.19397458230297637, 0.2014979534600717, 0.19923422235526955, 0.2206484293986447, 0.19289114820458753, 0.2107817527040451, 0.1983312500581078, 0.1895947148834244, 0.20393807020457955, 0.09251491430410319, 0.09456354813685142, 0.11364004537072292, 0.09834145292529772, 0.0745781319213511, 0.09785478073114229, 0.10279445034551626, 0.0870220946413609, 0.10056785924671408]}, "mutation_prompt": null}
{"id": "03f6359c-f126-44f4-ad8b-8b06b77d4482", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r1 * np.pi / 2)  # Enhanced chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.cos(self.evaluations * np.pi / self.budget / 2))  # Enhanced chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Enhance the chaotic maps used in the velocity update and mutation factor to improve convergence speed and solution accuracy.", "configspace": "", "generation": 85, "fitness": 0.2968278004436621, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8206223220785831, 0.8271104025745023, 0.813125799284809, 0.8204672339931706, 0.8037422551283455, 0.834442548809322, 0.824851506321139, 0.816897722913334, 0.8222786454863499, 0.5843759316333001, 0.6304813604585808, 0.5973176385825341, 0.6162335094512185, 0.6463735124999921, 0.6137998317903133, 0.6302664297902882, 0.6242595321009949, 0.6414053363688703, 0.1500937715388576, 0.1821174379145838, 0.1344716198237924, 0.16716788925066994, 0.15961066166353033, 0.14209690644752648, 0.1465696958570275, 0.14246714943775718, 0.15584932594963352, 0.11819103574636114, 0.15213722812593278, 0.13183841083450154, 0.10857748106701381, 0.16069560234974756, 0.12787953552506082, 0.10456170635832696, 0.13431304463936033, 0.11403210154244303, 0.9824347993789155, 0.968360777628949, 0.9704376766135696, 0.9678288963334737, 0.9688317517127515, 0.9760814284162319, 0.9751593195358765, 0.9684880810816843, 0.9762030715356169, 0.5268851577537611, 0.5541115353904269, 0.5470756892464742, 0.40842112388622265, 0.573374617033108, 0.5365032317974764, 0.5623147298462459, 0.5226533604158685, 0.4977766251833978, 0.22289084777474077, 0.22125942546007604, 0.22243256091474706, 0.21754712260840636, 0.1925252633108655, 0.20381822186595377, 0.2313515200003171, 0.7203768293527566, 0.6369943759039802, 0.2333971164702564, 0.1895999016649773, 0.1744299914762003, 0.1779159159198438, 0.13121509731282655, 0.13434454068657853, 0.1706441776260006, 0.1804986468125791, 0.1777516395210239, 0.1821311994267114, 0.186482207216499, 0.1239681451158795, 0.1713570416790937, 0.42532325351286526, 0.18556066886166478, 0.1280107883004381, 0.16346513042155653, 0.2150869996772381, 0.005580491551564926, 0.0604782626000433, 0.10135939514873682, 0.0058591551349030935, 0.012029372486414114, 9.999999999998899e-05, 0.06387933713431881, 9.999999999998899e-05, 0.06144352893420546, 0.059053658745861326, 0.08727502446689162, 0.09707411579797498, 0.06631680125138295, 0.05969654973822325, 0.10407033109555619, 0.047826879053041726, 0.09392037241918483, 0.1736757871947473, 0.10420845703672543, 0.05329178769372778, 0.10915291638533997, 0.11286509071852746, 0.12027517481469208, 0.10415726380020329, 0.09111555806989313, 0.08947007980516153, 0.1232037907233684, 0.16930124757587417, 0.054041941946081584, 0.08592926647087129, 0.03671194177605053, 0.11721936504798014, 0.029204664791016133, 0.054860130639523996, 0.055752565086854, 0.0843399668639313, 0.49543281233405834, 0.502286915128715, 0.5016893828317565, 0.5740996227779115, 0.4927554401251686, 0.5487687089854822, 0.5271280762248834, 0.5080994003308248, 0.5308621665988764, 0.1104212970861469, 0.10091386923401346, 0.12910646860866148, 0.14681686332675659, 0.12839913643153544, 0.12368167386187923, 0.07886832227302898, 0.12566148291771917, 0.1369954029476116, 0.18447857737174878, 0.41210305603127884, 0.1675714532290149, 0.2772562239865196, 0.33357607217620555, 0.3648755875019254, 0.34901792747852356, 0.1996370588110511, 0.23283180667220416, 0.32355276431482105, 0.3984163928468075, 0.33779707005814075, 0.30902612574570054, 0.3534698430995499, 0.3037151079641637, 0.4840368989034476, 0.2865964871034321, 0.4007577671618785, 0.2722026911698805, 0.25343391061810694, 0.25812924816991134, 0.2554683290469818, 0.24344181509739737, 0.2852475409079871, 0.31041469277731193, 0.29521845266591773, 0.39991823000453, 0.2441644400474965, 0.19568288251838428, 0.26433973234645225, 0.19626413914647511, 0.2025816526491767, 0.242320236370686, 0.28261285633350475, 0.19664938952897715, 0.19015280289828684, 0.2317452344162978, 0.19927096153631418, 0.19239210489272585, 0.22424500870935082, 0.23751106553536583, 0.183192074990429, 0.19531383535535174, 0.21270436506241397, 0.19403561000271452, 0.8342755641477694, 0.17447343718537378, 0.15318111141420632, 0.8465562146660186, 0.199424039640961, 0.19747641426514306, 0.14192313939332102, 0.15987573880716432, 0.782471685859031, 0.5294771604243863, 0.21154158406120627, 0.16555052051170238, 0.20793999655841244, 0.1636230740445619, 0.15286184213424692, 0.1045936967283535, 0.10489820450605325, 0.5344446644591376, 0.21868496949844474, 0.18996263787063683, 0.19777113873999352, 0.18685609341587484, 0.20023088729992056, 0.17975465080166309, 0.2058971294266767, 0.21287996531629194, 0.18771307945251403, 0.09443295674736618, 0.08344423452465433, 0.08769839145396452, 0.08013911500042359, 0.09120182678025324, 0.08012506428791255, 0.11095892704879229, 0.09881212353974334, 0.10541415351819428]}, "mutation_prompt": null}
{"id": "0be1a36e-a559-4096-8b5f-bb313adcf650", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "9f18eecc-cc90-4562-ba87-be42636d19c6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "b0bb942d-50ed-448b-b50c-918587639b33", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight using chaotic map\n            self.inertia_weight = 0.5 + 0.4 * np.sin(np.pi * self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding with fitness-based turbulence\n            if self.evaluations % (self.pop_size * 10) == 0:\n                turbulence = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n                self.population = np.clip(self.population + turbulence * (self.gbest_value / np.mean(self.pbest_value)), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce chaotic map for adaptive inertia weights and incorporate fitness-based turbulence to enhance diversity and escape local optima.", "configspace": "", "generation": 88, "fitness": 0.3087050545013029, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8422675104491261, 0.8241488672126365, 0.8333551151419958, 0.8555522080128881, 0.8692271026962286, 0.8423923297790186, 0.8434920418678138, 0.820629113184967, 0.8354112496654003, 0.6132509435539992, 0.07390019250381208, 0.49521472581924164, 0.6467309567182207, 0.6338656950475225, 0.6136241323416483, 0.6602233747072142, 0.36856048928326557, 0.6052987609119362, 0.18178979719414978, 0.12029469706004148, 0.15542465279394768, 0.1507626449358329, 0.15097199087879576, 0.1180165134700204, 0.1640022979122674, 0.17989653362134939, 0.14773157149079874, 0.09608016557039223, 0.1106911811298984, 0.10985996432785194, 0.11379423202395433, 0.11031339363661352, 0.11101214495032075, 0.17803981034682714, 0.11303400429513799, 0.1972378951599436, 0.9690962491102134, 0.9581563285364026, 0.9679668693585277, 0.9508752654632803, 0.9759367204422462, 0.9498702125460406, 0.9692421166575828, 0.9661631613165962, 0.9680036502807442, 0.6181205356610433, 0.5960127058043327, 0.6266356652771712, 0.6186205291326536, 0.541685134006026, 0.6125540182605755, 0.5827590642344305, 0.5815844727060802, 0.5956552434016738, 0.3780331582485732, 0.8425223147189613, 0.8880258616768739, 0.2751599731022455, 0.1939699612104263, 0.19366367018684705, 0.21187265185819348, 0.2287723499986397, 0.2313610904806611, 0.2412075414042153, 0.1622392412187581, 0.18796917639555366, 0.10265218903303797, 0.20841743776959532, 0.12297532174007031, 0.1975304536937491, 0.21014569546199413, 0.19165195001931667, 0.21507065739326436, 0.12561832924265015, 0.12859265960664157, 0.22593803501467447, 0.25164612646466833, 0.13163808592850568, 0.22551898939352966, 0.13950189519983613, 0.1294424820429263, 9.999999999998899e-05, 0.006335219133881909, 9.999999999998899e-05, 0.015832429831147188, 9.999999999998899e-05, 9.999999999998899e-05, 0.005265793624675608, 9.999999999998899e-05, 0.05375973417218394, 0.10310432554903981, 0.07174006395196153, 0.06713448349560835, 0.08607043707822393, 0.03324767322602751, 0.029344155894600266, 0.05848839985935561, 0.07319521076107072, 0.06755633972954167, 0.07853227406828378, 0.03462527075459365, 0.1185706447060858, 0.13663017895247032, 0.13483896166974596, 0.1315711383355439, 0.14746311472628038, 0.14031316290211704, 0.08968257362599996, 0.08091847528920648, 0.23286397177291118, 0.14858276313134533, 0.04696228209719722, 0.05721335914562109, 0.1433968948417942, 0.09990531986532947, 0.08831574690057864, 0.08073374466486472, 0.533661067054596, 0.5084454551056361, 0.5240140749393782, 0.5625082324698596, 0.5346691852151795, 0.5708524564555415, 0.5960676455700114, 0.5297868030492827, 0.5436182035949653, 0.06908196049923299, 0.06598020206108013, 0.11516556858027582, 0.10996051799973816, 0.13300949550973873, 0.09837401518380307, 0.12905657903069223, 0.07955890267177479, 0.07563273314813723, 0.4623278848181288, 0.3594936272748095, 0.20867273903651096, 0.33469275414018784, 0.19789846012503798, 0.40323870704627984, 0.2828229822543673, 0.3390364871478282, 0.2797530587149004, 0.27933558753907695, 0.3960728593763593, 0.4207461152464229, 0.4646248037229017, 0.5185993915175294, 0.3786712367085031, 0.4223995896413344, 0.4180016461852689, 0.48386950974236176, 0.3327562977713484, 0.22439689367451487, 0.3068608201619958, 0.3053001293106675, 0.2349289354549463, 0.16228749119730856, 0.2190782734993797, 0.25595876613887636, 0.2055891223344537, 0.216599438118651, 0.18053280186832377, 0.2041390581690291, 0.22296448345086117, 0.200980477471995, 0.23735823674778533, 0.21679551130370023, 0.19020504189826015, 0.22134694380587927, 0.2216142323081295, 0.19638525690745057, 0.20202965399353312, 0.25209043359020666, 0.18982708552363203, 0.20546046726328027, 0.2266908630468525, 0.18589121380968965, 0.18600953617922322, 0.8663929508418179, 0.18618204264119242, 0.1476122018044732, 0.8872557676213343, 0.20012176035642637, 0.169653107900412, 0.14276121615711723, 0.17803840369180435, 0.8974223619236281, 0.7247083340481134, 0.5001502352367568, 0.6774870395464518, 0.6068155691009305, 0.16669987144308962, 0.15385652607758438, 0.10467459493692644, 0.10493554286304041, 0.7201091573664602, 0.19397458230297637, 0.2014979534600717, 0.19923422235526955, 0.2206484293986447, 0.19289114820458753, 0.2107817527040451, 0.1983312500581078, 0.1895947148834244, 0.20393807020457955, 0.09251491430410319, 0.09456354813685142, 0.11364004537072292, 0.09834145292529772, 0.0745781319213511, 0.09785478073114229, 0.10279445034551626, 0.0870220946413609, 0.10056785924671408]}, "mutation_prompt": null}
{"id": "cc50869f-5495-48f3-9c58-49c56458ea13", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "50083a41-df2a-4cd4-be37-65c0405d8b11", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "a352468b-0f32-4226-b147-6ad6ee006e9c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        self.f = 0.6 * np.sin(np.pi * self.evaluations / (2 * self.budget)) + 0.4  # Sinusoidal adjustment\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a sinusoidal adjustment to the DE mutation factor for a more diverse exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.31744042739335476, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8607336624486396, 0.8566154471633655, 0.8633313515710008, 0.8632896732049341, 0.8617798490349916, 0.8534084636741412, 0.8659002865078886, 0.8589848995541783, 0.8417222214779306, 0.6451136946406537, 0.7084390788109194, 0.6062818799123315, 0.6513834169855134, 0.7179629833027567, 0.6761575419446892, 0.6839652649129326, 0.6946777422517516, 0.7082928098170802, 0.15499137703877364, 0.15441207157331915, 0.15127921070153771, 0.5688341437792734, 0.1558974171722166, 0.1776415944275035, 0.17733353467853974, 0.17497834760045183, 0.1621428215344376, 0.11677046904638388, 0.11054579697480915, 0.12852979651073715, 0.1154547240103646, 0.1069251520054606, 0.10000990887368844, 0.14431818084054326, 0.1366757157912496, 0.17423454614408673, 0.9690453176264217, 0.9581143309084618, 0.9655804808122249, 0.9504040097024424, 0.9705751543691792, 0.9499212113719886, 0.9687373211413272, 0.9669334643029727, 0.9679780188493085, 0.6384385029748476, 0.6232344501697288, 0.6680074325029375, 0.6811069265939691, 0.6260927300242844, 0.6329849820269171, 0.6325542300753485, 0.6280223488189247, 0.6566728795283352, 0.2434578068846608, 0.3902262382375218, 0.3805722095073102, 0.3747745535517546, 0.21310611185369432, 0.27715832306989996, 0.1157957368562289, 0.1643343965264168, 0.22216476259128093, 0.1834581458242166, 0.17699144568191205, 0.18332245126036617, 0.1012173599264472, 0.18833251370915183, 0.18682207172458876, 0.22386449957604593, 0.20380481449506715, 0.20045186807683124, 0.20231313009133356, 0.2072920872097278, 0.21402188132181132, 0.21975140632955947, 0.15321148721859568, 0.16774082428377657, 0.13341228330828436, 0.14082508292216567, 0.12784731066839072, 9.999999999998899e-05, 0.04135292782201172, 0.03661900881103897, 0.07009865688845818, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011041037405288279, 0.05295582854633796, 0.1063065357659716, 0.06031477136631769, 0.060340603155119465, 0.09481643637591719, 0.05580424146216556, 0.05303178141977971, 0.05012457150525462, 0.10537401737870111, 0.056719055970315124, 0.0943101386932984, 0.03453925577533867, 0.13215234876589088, 0.13028847609019956, 0.15167274075021941, 0.12866999342271468, 0.14322537797496426, 0.19165861547655894, 0.09806826391456325, 0.05814980575942719, 0.1622974876239941, 0.18967665474795636, 0.07694996245771468, 0.0981509749498084, 0.11494706906297647, 0.09326783647645276, 0.08617810544400129, 0.0823065993901968, 0.5226802059746596, 0.5239404138058767, 0.5157237768714553, 0.5288597637356718, 0.538707567031288, 0.5362255809196388, 0.5470439979937332, 0.5694436265258747, 0.5499544419712286, 0.08169385474516544, 0.08428500907848935, 0.11468266929881155, 0.11703553657506904, 0.11347296340226021, 0.13589945031819373, 0.11391155848689194, 0.08975573509654955, 0.07572181545122747, 0.32961946444475176, 0.38983349109767973, 0.33322215194532057, 0.42270282159036543, 0.20569411051090103, 0.34791299143100407, 0.3796082454100985, 0.18192463431955208, 0.38450097934930305, 0.49946911784396586, 0.3478572124753153, 0.2358572565698116, 0.27520608011092906, 0.3687199960146079, 0.2407427190055087, 0.3164342404320869, 0.3947306399302427, 0.3014688682593384, 0.3107056679887743, 0.37741084009703796, 0.26232713908814853, 0.2873945675432509, 0.21273581421718235, 0.2058377434449309, 0.21941120522464808, 0.2947717935735096, 0.1899928579983181, 0.28217571162122557, 0.15687811444080457, 0.20561567318753404, 0.21713177818336926, 0.2171260899738212, 0.24902035529085964, 0.22832096811171054, 0.2054307411654126, 0.29805458734392054, 0.6469853675401455, 0.18297078796793165, 0.20647178609399353, 0.7704826762838476, 0.20628946266628434, 0.2050972803892973, 0.20990127762462796, 0.20790622332208153, 0.18353998149622575, 0.884766371026434, 0.18656337735144002, 0.15364907194381738, 0.17224675909166287, 0.2000824906055172, 0.1695868664858402, 0.14274313488172352, 0.17805016706854437, 0.8969817921426022, 0.8014104919947167, 0.5263250748994504, 0.8167973230168528, 0.513540163301008, 0.4837438396511634, 0.15379751711166423, 0.10470939818255742, 0.10493903689756112, 0.6792557009066504, 0.19029638002729354, 0.172963943445119, 0.19704205186401358, 0.21217226963254343, 0.20144717668529766, 0.20049250788436535, 0.1778275959140465, 0.20880167837978703, 0.20626567112038052, 0.09014497290569523, 0.0808063978329896, 0.11363884839248273, 0.08789922949687479, 0.10801780286111784, 0.08387535278754588, 0.11588527082830347, 0.09303006580203688, 0.10130819356908727]}, "mutation_prompt": null}
{"id": "efea8317-645d-47e9-b1a4-3043a30e5a24", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Self-adaptive chaotic mappings for f and cr\n        self.f = 0.5 * (1 + np.sin(2 * np.pi * self.evaluations / self.budget))\n        self.cr = 0.9 * (1 + np.sin(3 * np.pi * self.evaluations / self.budget))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Integrate self-adaptive chaotic mappings to dynamically adjust DE's crossover rate and mutation factor, enhancing convergence efficiency.", "configspace": "", "generation": 92, "fitness": 0.3124400695421593, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8727426683654592, 0.8556661761613449, 0.8498310226211823, 0.8521684827767095, 0.8530842028631016, 0.8586060824875204, 0.8529644632523246, 0.8407404810498076, 0.8523757378823683, 0.6255350806262134, 0.6939334076102783, 0.611311437507148, 0.618527769346387, 0.6865135295769644, 0.6802322389093528, 0.6074880819879893, 0.5682274041680729, 0.7014930387773568, 0.22138736374741153, 0.1565132858575191, 0.15649154746327187, 0.1742975851295454, 0.18101511336186227, 0.14835109390713896, 0.1648120030848118, 0.1767156487089545, 0.13331058324947376, 0.09631139031859404, 0.10169505641323395, 0.11510513036510472, 0.11324870621546201, 0.1456527389332628, 0.10041615701908957, 0.12924353804926736, 0.11222005271473112, 0.17738138549835025, 0.9704857187651024, 0.9682755051931089, 0.9724650312884013, 0.9596519297558197, 0.9798183145404433, 0.9582504245929475, 0.9741646171547087, 0.9679130961355449, 0.9680944604979529, 0.6334170774523784, 0.6217183880776513, 0.684874156105442, 0.6213740183208046, 0.6567951170420705, 0.6557900111704067, 0.6335467429488733, 0.605104923964998, 0.6387391230450281, 0.37105991499394375, 0.3788874269062452, 0.22672479448053473, 0.21569016333257574, 0.2744994853350149, 0.2113656740795865, 0.14681771840097013, 0.32219246060261153, 0.2278109802378775, 0.1762286121179455, 0.1871916775898682, 0.17970572767400572, 0.1010703762541374, 0.18057608162885352, 0.12511214334912568, 0.19845318907209863, 0.31299324514070137, 0.22224888252403063, 0.21540027028006448, 0.2674360870384874, 0.1977507380681056, 0.12594799881682772, 0.12820246505019495, 0.1817941004949395, 0.23025694091811233, 0.10903751502068115, 0.20425766906445397, 0.031151392268045086, 0.00018285844724064138, 9.999999999998899e-05, 0.01773328573884081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04172245745777414, 0.11294294607634459, 0.04491021543576734, 0.09140173003808416, 0.07853690853307749, 0.02301691682726137, 0.025379461489749566, 0.04684671703964738, 0.08259411992773258, 0.07369878888333792, 0.23220449513907415, 0.03827063552901022, 0.16562752574551576, 0.12951230562181903, 0.13435340444044375, 0.11250968934409988, 0.15524094373001573, 0.11064505338110231, 0.09588709496843117, 0.06351191125376321, 0.08660817465958992, 0.18106130343510618, 0.05498450891159079, 0.08077666367358782, 0.09105253130370361, 0.0761720764835041, 0.061206340408088145, 0.08207578589110054, 0.5947875342940935, 0.5010839086176193, 0.5418868296129867, 0.5161160010137493, 0.5275126081470822, 0.5664265558487844, 0.5363605250982513, 0.5053180744305046, 0.5435900881402724, 0.07911907830239728, 0.13920959447950498, 0.1263989539870356, 0.10783124742608508, 0.11189258918439804, 0.140761306902065, 0.14728820746965465, 0.16459727332725138, 0.07574817060458938, 0.4044949903113655, 0.40928213613076037, 0.1927492535107047, 0.3615394606851906, 0.21134958658722758, 0.26615823380161696, 0.3135004552519557, 0.33120102807046736, 0.3184326025013946, 0.36066534825206786, 0.29256889182639245, 0.4383941352342132, 0.4723175002733574, 0.3550423195663517, 0.33182865245095705, 0.3704424510581499, 0.4914706860194413, 0.6082182386440366, 0.3157314200740028, 0.22362010137938282, 0.31971274924254567, 0.34847704526660206, 0.2313062280208773, 0.2098570998463024, 0.2342379018533064, 0.2476499756392876, 0.20748519739394156, 0.23164849103540053, 0.1699333669558427, 0.2012341345880061, 0.2007269027033609, 0.21021304970892474, 0.17441840947511444, 0.2197381473576232, 0.21752981314588216, 0.2360477928611091, 0.19158626474690077, 0.20790833649795248, 0.19710592920189163, 0.2265433500274695, 0.21689890993212613, 0.19254263423416607, 0.2091045127631369, 0.1850721547752996, 0.17978108376004898, 0.8529858819717809, 0.18638925091515401, 0.14780601347782707, 0.8869541284421867, 0.19954029211380087, 0.1695829958564884, 0.14267974351934698, 0.17812338097894231, 0.8803640886220875, 0.6667848192377274, 0.5145872077837585, 0.6658283602783184, 0.7244205708440633, 0.16781722200250282, 0.16622047663895412, 0.10463733527102081, 0.10495138540747373, 0.6783881325135418, 0.18255764623943582, 0.18062028976703381, 0.20039288642038744, 0.24241878754126756, 0.17569681401762105, 0.20489626624356205, 0.18160350486259613, 0.1839724684538483, 0.22465191005624363, 0.09118821285035306, 0.09167611868775971, 0.13010260287034414, 0.09579102365860415, 0.08937485214642438, 0.08246200322215258, 0.14453286132643461, 0.10783361930606428, 0.08040742540003598]}, "mutation_prompt": null}
{"id": "966f1cff-be25-4452-bc89-33cee286ed12", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "faac6c4e-9ba8-4ab7-a308-83264954b891", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with hybrid chaotic map\n        self.f = 0.5 * np.abs(np.sin(self.evaluations * np.pi / self.budget))\n        self.cr = 0.9 * np.abs(np.sin(self.evaluations * np.pi / self.budget))\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a hybrid chaotic map strategy for adaptive parameters in PSO and DE to enhance exploration and convergence speed.", "configspace": "", "generation": 94, "fitness": 0.3093405394607036, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8686683826754918, 0.8610505829669155, 0.8571792237783419, 0.8588069810753107, 0.8665161543658209, 0.8638026890158912, 0.8677524166527665, 0.856329827084236, 0.8598719282908149, 0.573621866142029, 0.6585779018207064, 0.6461229835038429, 0.664995174112643, 0.7107736703213825, 0.6841829487348091, 0.6384104058450072, 0.6109830327079717, 0.7032547149947747, 0.17469659791326597, 0.15073015876465468, 0.12980038600844868, 0.12774050559235206, 0.12773054113879256, 0.13162091218756267, 0.1730824168093863, 0.12133643034006458, 0.1551827139331301, 0.06892444326880254, 0.11167150269202197, 0.10711336205287858, 0.09988229881782229, 0.09236249698511678, 0.12089294013391283, 0.10740387170844001, 0.10081603801997863, 0.11313104678509667, 0.968664683098577, 0.9578063887436477, 0.9613540755804192, 0.9400326528940195, 0.9692318833097944, 0.9325174504745356, 0.9687373211413272, 0.9497933763415427, 0.9589832165246658, 0.6889538573773563, 0.7112921325948474, 0.6488904410974683, 0.6438079752121969, 0.6425866112202085, 0.6614328131048866, 0.6543020908405033, 0.6313410307016085, 0.6350861782115699, 0.22684993944316967, 0.21563927481174416, 0.20879392695814547, 0.20849450301186911, 0.21418747213965017, 0.2775586406538526, 0.12700022079227624, 0.13253653792663678, 0.33185981156459965, 0.24032921940778096, 0.16234976546881386, 0.20505921295326157, 0.10267370889091032, 0.1891957580996062, 0.13929529007888908, 0.22274316974323116, 0.18625131839012465, 0.2072837102105357, 0.18180589352747378, 0.2089439173617308, 0.19715552425813165, 0.153823770012667, 0.19077297026839135, 0.18823836959203377, 0.24340567388316015, 0.13659245605102788, 0.13009092319905735, 0.0030369659815043804, 0.04246561891205969, 0.05078666073263172, 0.014488074928481032, 9.999999999998899e-05, 9.999999999998899e-05, 0.008842256684259309, 0.007942406752729059, 0.00235807228099838, 0.12058189216426685, 0.03970704974603745, 0.10445797827198822, 0.1040006467286767, 0.0477119545090372, 0.029768379836174974, 0.060371356929514564, 0.08575990818174217, 0.08341944714108596, 0.06177246015523907, 0.034952667342078136, 0.14886110459506763, 0.11674437625674605, 0.10590187942365625, 0.09742782306532971, 0.14681876095006796, 0.18035882835909545, 0.09633042766123912, 0.05791880163882346, 0.20223283749637844, 0.1771327831714038, 0.03473732027462351, 0.29057711845615264, 0.07696936478130878, 0.05744386836911486, 0.055433422887645634, 0.11334019329373146, 0.5269568222684038, 0.592249794815111, 0.5143006915106796, 0.5842586080400874, 0.5751948753807417, 0.5407850539624633, 0.5717865582890903, 0.5545639689769697, 0.5658393710491963, 0.11603349071103808, 0.06946459622369583, 0.0879129619839556, 0.12270243306422546, 0.09008086062880227, 0.09828412453438196, 0.1565251381300452, 0.10098307795703254, 0.07584394960946483, 0.3567192547324872, 0.26047997959995195, 0.15894172974877108, 0.3902291318703802, 0.20070502124297585, 0.23732882846430936, 0.2497443127698733, 0.23548034509915716, 0.16951775020708537, 0.529027264189263, 0.38502667275931646, 0.2750095085969815, 0.22825484692125697, 0.5710840865309085, 0.5632515866298413, 0.28251027202521206, 0.5720849307670626, 0.31108332631606694, 0.3222019127752146, 0.21596629084066532, 0.24114815728296413, 0.3159252120292193, 0.2263077598461567, 0.20798397255828893, 0.23953103992349445, 0.30698978230560947, 0.2319818776153323, 0.24253305420815574, 0.17380563857115594, 0.1925454560220241, 0.19672224801924731, 0.22125365654132056, 0.19806752381502535, 0.21061415117628357, 0.22553684122968876, 0.22358820803372015, 0.2017597313197671, 0.19914840685618607, 0.17367062797942823, 0.21593274050223743, 0.24586493660601183, 0.19308822927687497, 0.19082882648386335, 0.19090785415903655, 0.19101647211778905, 0.8760785497811914, 0.18624639280012711, 0.17520724622719863, 0.8992627428710345, 0.19951525071920384, 0.16965216657773363, 0.1426368358064275, 0.1780409971108431, 0.901366889656546, 0.6969934881643485, 0.5949160744585598, 0.6191793147599549, 0.42684944514335144, 0.5405850540958438, 0.1517961715635342, 0.10476741553133184, 0.10495760529092935, 0.7149286916345277, 0.18996200013299325, 0.19562157221678478, 0.21007575703958914, 0.20976339375502806, 0.19384012808189677, 0.20049250788436535, 0.20313461276229305, 0.21364152414317872, 0.21200539766647974, 0.08657562370332439, 0.09590692373357246, 0.13779875981874468, 0.09105031617366188, 0.10691663254839479, 0.0801533418676672, 0.1397292076570733, 0.09330098909017037, 0.0798242569757116]}, "mutation_prompt": null}
{"id": "40f62690-c6e8-4551-a9a5-2fe914ae56ce", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "1ffb2036-eceb-423c-b449-d78ccb06b9b0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "cd4e339f-511e-42f1-ac95-12e7dbfb21dc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "5ed3f5fa-c426-407e-b25f-28b4f7e3e777", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates for PSO's cognitive and social components to dynamically adjust exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.8462363096802082, 0.8417563269915889, 0.8655989168763722, 0.8592492964871344, 0.8707344379200893, 0.8532996437897863, 0.8683401301898, 0.8523687102549926, 0.8570160861058287, 0.6013693156086739, 0.5495032838405389, 0.6893862421969312, 0.646743860782823, 0.702380578844948, 0.6874236639220865, 0.6975900424786257, 0.6566115746725008, 0.7184255283647686, 0.13381270756737318, 0.15016025363936336, 0.13748722681060677, 0.15372268659302823, 0.17737000577967355, 0.17662926081480523, 0.5409593399657084, 0.15446663708537833, 0.15698679724134457, 0.08830178832858071, 0.10739430976469011, 0.10855910287529225, 0.1291933206185567, 0.1288083972209355, 0.11853020570676598, 0.11298516612279585, 0.11517469687181292, 0.13269941416572206, 0.9690452436511521, 0.9581306828903228, 0.9679232745412976, 0.9506582702880905, 0.9706208577973476, 0.9499388646935264, 0.9687373211413272, 0.9670041634333808, 0.9679520631083873, 0.7135253392250116, 0.6724378552246854, 0.6522226142817485, 0.6638471907912031, 0.6444540227717108, 0.7040306834522871, 0.6320226794727656, 0.655739178076633, 0.6425779013807498, 0.8304388709533719, 0.8818600927404486, 0.8824722095798093, 0.21218130889645703, 0.2753476491269683, 0.2184692177868287, 0.22814029969233196, 0.21728961252883805, 0.3858736313551694, 0.22239450154172424, 0.16101931010125425, 0.17073563234653233, 0.10040902261777207, 0.12965199142864237, 0.17462516507160986, 0.18126827766721776, 0.17821879727635004, 0.1292325341253856, 0.19832359859630433, 0.12734600809500984, 0.20581975159139143, 0.19216396793800616, 0.1768648648927008, 0.32569103759159956, 0.2295154641310302, 0.142229575400326, 0.13053182472710545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052853023708173574, 9.999999999998899e-05, 9.999999999998899e-05, 0.00304093909649672, 9.999999999998899e-05, 0.04894672751737472, 0.1109411740476558, 0.05595004138766324, 0.06316987833019883, 0.05835311310311686, 0.04667658978547207, 0.02305602776381588, 0.06601208922059454, 0.10012748919071579, 0.07547993919728102, 0.10099644540219155, 0.03396117756488415, 0.11038701447191435, 0.1370789050361545, 0.13164278286514275, 0.12947650858322446, 0.13450586070006232, 0.16520777746389848, 0.09378836533170365, 0.05350038595879503, 0.1029167393270276, 0.318540551956512, 0.03602707130822602, 0.07065593333129294, 0.30360093758917506, 0.14958483771548614, 0.09794921113826971, 0.08125693886126406, 0.550539711488572, 0.5227606631778163, 0.5447705255673418, 0.5761691122322928, 0.5323885027249169, 0.5797966560392773, 0.5610829691908358, 0.5318562079425679, 0.579763843361615, 0.10737138426696036, 0.07761915773420602, 0.1386707751344336, 0.12143983175945783, 0.10845911438872846, 0.07723802190660367, 0.5353196074657302, 0.10815484058890656, 0.0836511192314201, 0.4436015227334804, 0.4516142187393535, 0.15642576548508824, 0.2742033238748627, 0.21332376642869544, 0.1775586946121741, 0.6719072395735612, 0.3522658214726335, 0.32367553616234623, 0.3582839618875048, 0.41274947901060377, 0.5890653440671685, 0.25807319857663624, 0.3155943032571611, 0.2641389043741461, 0.49157169175980364, 0.3249524946384108, 0.31634376591583013, 0.30240791958423363, 0.3460781298155273, 0.2775643002248167, 0.24371878946460102, 0.21503348419398027, 0.15644703191858111, 0.32057275422509324, 0.2794605361931569, 0.22702392021231976, 0.20118134090117634, 0.1596927689000497, 0.22407527641496305, 0.21517771422163257, 0.19306592510604825, 0.22326195775117563, 0.23370148568540094, 0.18813112488003614, 0.243863248360769, 0.21046385088421815, 0.24526592485584842, 0.20166948322544853, 0.2274777786215214, 0.2217364903056367, 0.22137518564756276, 0.19990938659441004, 0.19677293659809814, 0.19039499597277998, 0.8729882056997285, 0.18662552886490325, 0.14773976922063625, 0.9035816651395008, 0.20017915157904342, 0.169594544305397, 0.1427367229578942, 0.17804948906045615, 0.8872669099958234, 0.7847417485367294, 0.45726595117031676, 0.40589724353147216, 0.4963616649481116, 0.5310557654005659, 0.1536602641263909, 0.10470687854501959, 0.1049264197686105, 0.7687400456973209, 0.18400740862172438, 0.21118815106623212, 0.2140739105863192, 0.1993957409143563, 0.19170818144154123, 0.20049250788436535, 0.18415337848353552, 0.18269443922231943, 0.2148799452701985, 0.12242635421479331, 0.09830584311724144, 0.10166772054643303, 0.0878494567210848, 0.09460904501713285, 0.07639351670615524, 0.1383422097075614, 0.07978343303653779, 0.09944005083227947]}, "mutation_prompt": null}
{"id": "15347fa5-76ff-416b-8780-1ff079c6130f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover rate\n        self.population = None\n        self.velocity = None\n        self.pbest = None\n        self.gbest = None\n        self.gbest_value = np.inf\n        self.evaluations = 0\n\n    def initialize(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_value = np.full(self.pop_size, np.inf)\n\n    def evaluate(self, func):\n        values = np.apply_along_axis(func, 1, self.population)\n        self.evaluations += self.pop_size\n        for i in range(self.pop_size):\n            if values[i] < self.pbest_value[i]:\n                self.pbest_value[i] = values[i]\n                self.pbest[i] = self.population[i].copy()\n            if values[i] < self.gbest_value:\n                self.gbest_value = values[i]\n                self.gbest = self.population[i].copy()\n\n    def update_velocity_position(self):\n        r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n        self.cognitive_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive cognitive coeff\n        self.social_coeff = 1.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive social coeff\n        cognitive = self.cognitive_coeff * r1 * (self.pbest - self.population)\n        social = self.social_coeff * r2 * (self.gbest - self.population)\n        self.velocity = self.inertia_weight * self.velocity + cognitive + social\n        self.velocity = self.velocity * np.sin(r2 * np.pi)  # Updated line using chaotic map\n        self.population += self.velocity\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        # Turbulence mechanism\n        if self.evaluations % (self.pop_size * 5) == 0:\n            turbulence = np.random.normal(0, 0.1, (self.pop_size, self.dim))\n            self.population += turbulence\n\n    def differential_evolution(self, func):\n        adaptation_rate = 0.1  # Adaptation rate for f and cr\n        for i in range(self.pop_size):\n            indices = [index for index in range(self.pop_size) if index != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutation_factor = self.f * (1 + np.sin(self.evaluations * np.pi / self.budget))  # Adaptive chaotic mutation\n            mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            cross_points = np.random.rand(self.dim) < self.cr\n            trial = np.where(cross_points, mutant, self.population[i])\n            trial_value = func(trial)\n            self.evaluations += 1\n            if trial_value < self.pbest_value[i]:\n                self.pbest_value[i] = trial_value\n                self.pbest[i] = trial.copy()\n                if trial_value < self.gbest_value:\n                    self.gbest_value = trial_value\n                    self.gbest = trial.copy()\n            if self.evaluations >= self.budget:\n                break\n        # Dynamic adaptation with exponential decay\n        self.f = 0.5 * np.exp(-self.evaluations/self.budget)\n        self.cr = 0.9 - 0.4 * np.exp(-self.evaluations/self.budget)\n\n    def __call__(self, func):\n        self.initialize()\n        self.evaluate(func)\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.5 + 0.4 * (self.evaluations / self.budget)\n            self.update_velocity_position()\n            self.evaluate(func)\n            self.differential_evolution(func)\n            # Population seeding\n            if self.evaluations % (self.pop_size * 10) == 0:\n                self.population = np.clip(self.population + np.random.uniform(\n                    -0.5, 0.5, (self.pop_size, self.dim)) * (self.gbest - self.population), self.lower_bound, self.upper_bound)\n        return self.gbest", "name": "HybridPSO_DE", "description": "Introduce a turbulence mechanism in PSO for improved exploration and robustness.", "configspace": "", "generation": 99, "fitness": 0.2550364670984978, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "22df3703-5ebf-46d7-9f4f-65939ead457f", "metadata": {"aucs": [0.5604426227239854, 0.5443848877840658, 0.5634354222153553, 0.5625774598059137, 0.554963678848946, 0.5395014006072884, 0.5726701214174279, 0.5750874220961262, 0.529578479395171, 0.13858984616669, 0.11628146888813207, 0.11477020370517332, 0.16676320839049763, 0.1105620146220172, 0.12957285532122187, 0.06519592470699065, 0.19329237771058172, 0.12355083440497727, 0.11349947472022248, 0.14589730306252036, 0.14313153955248437, 0.14891636754172521, 0.15969191247022174, 0.1527493936305112, 0.1376528228356101, 0.10612235124985292, 0.17466446317282625, 0.08606180664874352, 0.117219329260568, 0.09603671062779673, 0.10889052687756284, 0.08474201612272014, 0.11323683797873785, 0.1481721034209189, 0.09694010594147562, 0.135763526169714, 0.9682145275028983, 0.9671702288596925, 0.967899854026166, 0.9590928912031184, 0.9700103846063479, 0.9507577666314417, 0.9687840413311912, 0.9585708783025471, 0.9679209042382404, 0.3585965507916179, 0.36793056797700463, 0.3639148393817757, 0.3607786464887395, 0.3789988228769484, 0.4091075448266447, 0.36043230393858416, 0.38576364350043546, 0.3783934177426801, 0.2281214215040851, 0.7273404740038676, 0.22528691952198276, 0.2197726479638792, 0.27807170779274126, 0.2786350991730374, 0.17475353960434092, 0.23321180605300718, 0.7540502602870355, 0.18144836766010008, 0.14681466500058105, 0.16125307862715232, 0.10442218557989547, 0.1755516228259979, 0.12405692380416, 0.1793862533452193, 0.18619954101793335, 0.18034651879694197, 0.17863450553093352, 0.17825244566291532, 0.17905855351704136, 0.12474782141177221, 0.3138913989938328, 0.2128783990364148, 0.20012646828782976, 0.1335354339260748, 0.1255074432341997, 9.999999999998899e-05, 0.041871091854879916, 9.999999999998899e-05, 0.08733996081660755, 9.999999999998899e-05, 0.017998003392382222, 0.04049847774600768, 9.999999999998899e-05, 0.00071029195048955, 0.08208701125125861, 0.03762338524302544, 0.0826979750327217, 0.06786429245307357, 0.01595123116692998, 0.02632119516480813, 0.05880978362052014, 0.08913612114610081, 0.05465628930757016, 0.03632812814200448, 0.007022029236765648, 0.050474794960388314, 0.04146875666887495, 0.026993389235636656, 0.020955604451826537, 0.07499218433389121, 0.11513526659517248, 0.055195657195152514, 0.1673322081004711, 0.15021176862241936, 0.13122266215537237, 0.06506201245101983, 0.08004210804854561, 0.11363985186691516, 0.058450455064984586, 0.08676847253965803, 0.08370175076343822, 0.4573752605405582, 0.45670241030977843, 0.49741071848126983, 0.47925262452897777, 0.5071490646708278, 0.47740305062619626, 0.495012697898236, 0.49872398955100194, 0.48251615103149936, 0.10154445022558956, 0.10447248297025091, 0.12877126077733647, 0.09224967358232139, 0.13254561171911794, 0.11846782856507576, 0.0998254942383463, 0.1335980083148195, 0.0894462466029734, 0.3786293132733375, 0.3139298716411072, 0.20281714114025096, 0.19878035751251666, 0.2850053501246965, 0.28781420981538264, 0.3059672342631007, 0.1637462139524125, 0.19685402557044185, 0.3099945104572952, 0.30551897149841933, 0.2770557419815338, 0.31753121085615166, 0.34949480793181353, 0.3084091752202226, 0.34668211679591776, 0.35173807691482484, 0.3364367259650808, 0.30041020259850826, 0.25145555426583166, 0.19781819451990923, 0.23781562144231316, 0.2077552109301103, 0.21474052839304092, 0.23906868918642665, 0.2775874607333483, 0.27162433712118916, 0.21187403164945784, 0.1615595873399136, 0.19628120830347662, 0.24645858077713734, 0.20623625350919572, 0.22332585984132913, 0.2183889603928757, 0.20144440957090415, 0.24537191348208576, 0.21024896261918835, 0.23643083146870048, 0.20639859899227997, 0.21378704710803842, 0.2203334755791857, 0.18891631839767298, 0.2104979371546799, 0.1930051755900668, 0.2170647436392149, 0.8416471411740007, 0.18573463481192143, 0.14777331348723033, 0.814124467763158, 0.19985954973353415, 0.16948336563767985, 0.14275297426032885, 0.17743164162358338, 0.8504743153524786, 0.5964581491006391, 0.46416933639934543, 0.5355923040350801, 0.5564102311649288, 0.5309767880841971, 0.15277838556581813, 0.10475929433048492, 0.10497662339856884, 0.5869044374588436, 0.19423450164896083, 0.17823154795979612, 0.183023214092781, 0.19155685060455452, 0.19159626341601732, 0.18518120599001076, 0.20771587446595863, 0.18099589243836134, 0.18643930624109528, 0.10453259589637787, 0.08028872027242229, 0.11057626803887544, 0.09525134267750468, 0.09959292719192747, 0.0955263026250539, 0.114109682987523, 0.09107503899143687, 0.09360628313754826]}, "mutation_prompt": null}
