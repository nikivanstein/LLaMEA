{"id": "722f3684-3680-46f5-886a-75aa2f1cec8a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.4\n        self.social_coefficient = 1.4\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Hybrid Particle Swarm and Differential Evolution that dynamically balances exploration and exploitation for efficient optimization.", "configspace": "", "generation": 0, "fitness": 0.11144597391468453, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.1258639212999082, 0.18972700686760657, 0.11746063419879282, 0.16164830310868217, 0.15952612656770593, 0.1521469765896445, 0.1811223059749908, 0.15324943748161335, 0.1942304801491238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036742227113882864, 0.028869187709263278, 0.03551296793221992, 0.02746125325634352, 0.04145838637825805, 0.03640806401644747, 0.03581780864472528, 0.028940034059873665, 0.02875876632444674, 0.021821308235351666, 0.016138446331724676, 0.009799627532170563, 0.021764963906781287, 0.02021412336009598, 0.017244246902001215, 0.008346576260623628, 0.01196128460245549, 0.004119665595049393, 0.9458259153464712, 0.9696103651551707, 0.9704218735051912, 0.9897428055281235, 0.990484237209869, 0.9782013474928573, 0.9902437705072864, 0.9891167470456868, 0.9796810451995658, 0.05350163769076932, 0.044591485778617934, 0.04282786194539734, 0.060343665507192834, 0.06083376835387988, 0.07028774473145238, 0.07531703003780965, 0.06423623577161486, 0.08259157750929225, 0.10027683525177622, 0.10556325360426744, 0.07182288626320665, 0.08759587630086496, 0.11117253979162689, 0.0879549344793562, 0.0880534513833201, 0.10585686387477067, 0.1193101445861453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008128602014520259, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00418559468430435, 0.0073951575360864386, 0.008981446742274635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0401125628910699, 0.03192548861931044, 0.034654881808235394, 0.01605838836968121, 0.029874525709716382, 0.05645802147534451, 0.0038428003919173115, 0.019017696811284956, 0.051041749734494934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16668756889446645, 0.16829430102226084, 0.17537025629020064, 0.16099996035117436, 0.17947499247371923, 0.1600042194387017, 0.16587495392831775, 0.1460564505205144, 0.14600902088540024, 0.06875038657754318, 0.03999275844902128, 0.03887789882989601, 0.05206652837562509, 0.03436289773563406, 0.027099733746372645, 0.033219414257675606, 0.03256619653002746, 0.029371499486606445, 0.15981063002561458, 0.12703375037327058, 0.13528078565848334, 0.1654472134239977, 0.13196892260949267, 0.12930234620777625, 0.1681670158443288, 0.13315258688774578, 0.1346264383333251, 0.1475781476620861, 0.1400930831788384, 0.1402906816502134, 0.141229267638184, 0.1409717908868624, 0.14446425967077936, 0.147088901739155, 0.1428389570130525, 0.15336255108852115, 0.09331574963213274, 0.1012949292748021, 0.08741008731577171, 0.09271317398090162, 0.09271273545542458, 0.08470564264119607, 0.08482987237128092, 0.08379250423071205, 0.10283586900258612, 0.12106476188534487, 0.14143224550131583, 0.13895968652682145, 0.13828694875617054, 0.12856155918876266, 0.15672575272911327, 0.14168112841588065, 0.13813843445126694, 0.13258727977023832, 0.026985466618129395, 0.10169402261403793, 0.08391004695613824, 0.12059766694943141, 0.11878794264935766, 0.06626698852699808, 0.11712246320160846, 0.07874722142951507, 0.11135715821778136, 0.11559412503733524, 0.12940721232179386, 0.140926315255806, 0.14398471291360115, 0.12341126678076764, 0.14293211696668207, 0.11552096736355455, 0.11826612878372089, 0.1515267782277251, 0.12180248782052372, 0.09739426818675312, 0.13117112472733095, 0.10113997000563923, 0.16999265918655582, 0.10457458293546829, 0.1324595385747489, 0.1594226765801472, 0.17570208483736383, 0.19604865086074574, 0.18089418326875817, 0.1869467916106542, 0.1978241282319091, 0.1762240486729375, 0.18395698160279295, 0.18336484038237966, 0.17422650581806287, 0.17715606275494378, 0.03431843566605164, 0.0373333078787782, 0.03739563112440669, 0.03590884032770014, 0.030690753737733445, 0.04258240922594869, 0.042469761811740336, 0.03191681306901084, 0.035042550004577455]}, "mutation_prompt": null}
{"id": "23c0e812-a6ef-42a2-8f13-4eeb20001e6f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.4\n        self.social_coefficient = 1.4\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Hybrid Particle Swarm and Differential Evolution that dynamically balances exploration and exploitation for efficient optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "722f3684-3680-46f5-886a-75aa2f1cec8a", "metadata": {"aucs": [0.1258639212999082, 0.18972700686760657, 0.11746063419879282, 0.16164830310868217, 0.15952612656770593, 0.1521469765896445, 0.1811223059749908, 0.15324943748161335, 0.1942304801491238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036742227113882864, 0.028869187709263278, 0.03551296793221992, 0.02746125325634352, 0.04145838637825805, 0.03640806401644747, 0.03581780864472528, 0.028940034059873665, 0.02875876632444674, 0.021821308235351666, 0.016138446331724676, 0.009799627532170563, 0.021764963906781287, 0.02021412336009598, 0.017244246902001215, 0.008346576260623628, 0.01196128460245549, 0.004119665595049393, 0.9458259153464712, 0.9696103651551707, 0.9704218735051912, 0.9897428055281235, 0.990484237209869, 0.9782013474928573, 0.9902437705072864, 0.9891167470456868, 0.9796810451995658, 0.05350163769076932, 0.044591485778617934, 0.04282786194539734, 0.060343665507192834, 0.06083376835387988, 0.07028774473145238, 0.07531703003780965, 0.06423623577161486, 0.08259157750929225, 0.10027683525177622, 0.10556325360426744, 0.07182288626320665, 0.08759587630086496, 0.11117253979162689, 0.0879549344793562, 0.0880534513833201, 0.10585686387477067, 0.1193101445861453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008128602014520259, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00418559468430435, 0.0073951575360864386, 0.008981446742274635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0401125628910699, 0.03192548861931044, 0.034654881808235394, 0.01605838836968121, 0.029874525709716382, 0.05645802147534451, 0.0038428003919173115, 0.019017696811284956, 0.051041749734494934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16668756889446645, 0.16829430102226084, 0.17537025629020064, 0.16099996035117436, 0.17947499247371923, 0.1600042194387017, 0.16587495392831775, 0.1460564505205144, 0.14600902088540024, 0.06875038657754318, 0.03999275844902128, 0.03887789882989601, 0.05206652837562509, 0.03436289773563406, 0.027099733746372645, 0.033219414257675606, 0.03256619653002746, 0.029371499486606445, 0.15981063002561458, 0.12703375037327058, 0.13528078565848334, 0.1654472134239977, 0.13196892260949267, 0.12930234620777625, 0.1681670158443288, 0.13315258688774578, 0.1346264383333251, 0.1475781476620861, 0.1400930831788384, 0.1402906816502134, 0.141229267638184, 0.1409717908868624, 0.14446425967077936, 0.147088901739155, 0.1428389570130525, 0.15336255108852115, 0.09331574963213274, 0.1012949292748021, 0.08741008731577171, 0.09271317398090162, 0.09271273545542458, 0.08470564264119607, 0.08482987237128092, 0.08379250423071205, 0.10283586900258612, 0.12106476188534487, 0.14143224550131583, 0.13895968652682145, 0.13828694875617054, 0.12856155918876266, 0.15672575272911327, 0.14168112841588065, 0.13813843445126694, 0.13258727977023832, 0.026985466618129395, 0.10169402261403793, 0.08391004695613824, 0.12059766694943141, 0.11878794264935766, 0.06626698852699808, 0.11712246320160846, 0.07874722142951507, 0.11135715821778136, 0.11559412503733524, 0.12940721232179386, 0.140926315255806, 0.14398471291360115, 0.12341126678076764, 0.14293211696668207, 0.11552096736355455, 0.11826612878372089, 0.1515267782277251, 0.12180248782052372, 0.09739426818675312, 0.13117112472733095, 0.10113997000563923, 0.16999265918655582, 0.10457458293546829, 0.1324595385747489, 0.1594226765801472, 0.17570208483736383, 0.19604865086074574, 0.18089418326875817, 0.1869467916106542, 0.1978241282319091, 0.1762240486729375, 0.18395698160279295, 0.18336484038237966, 0.17422650581806287, 0.17715606275494378, 0.03431843566605164, 0.0373333078787782, 0.03739563112440669, 0.03590884032770014, 0.030690753737733445, 0.04258240922594869, 0.042469761811740336, 0.03191681306901084, 0.035042550004577455]}, "mutation_prompt": null}
{"id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 2, "fitness": 0.13151265051465086, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "722f3684-3680-46f5-886a-75aa2f1cec8a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "774dd4a3-eb37-4d57-848f-d0ab7af0609a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "459ae87b-ee7b-46e0-804d-48907ca99249", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.local_search_intensity = 0.1  # New parameter for local search intensity\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (1.2 + 0.3 * np.sin(eval_count * np.pi / self.budget)) * r1 * (personal_best[i] - pop[i]) +  # adaptive cognitive\n                          (1.2 + 0.3 * np.cos(eval_count * np.pi / self.budget)) * r2 * (global_best - pop[i]))  # adaptive social\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                # Local search adjustment\n                if np.random.rand() < self.local_search_intensity:\n                    local_candidate = candidate + np.random.normal(0, 0.1, self.dim)\n                    local_candidate = np.clip(local_candidate, lower_bound, upper_bound)\n                    if func(local_candidate) < func(candidate):\n                        candidate = local_candidate\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Improved HybridPSODE with adaptive coefficients and local search boost for enhanced convergence performance.", "configspace": "", "generation": 4, "fitness": 0.12091042922567673, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.1593184723412987, 0.1678514756111117, 0.1845257332598017, 0.18456881748580334, 0.21108737457876392, 0.20369835844330897, 0.19646727522701757, 0.19678088823867557, 0.19255283111387045, 0.0005355908691025979, 0.0029219895366917603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001878343166133667, 9.999999999998899e-05, 0.0009152075777927315, 0.00037458064566786575, 0.03363878986559943, 0.03656716820323869, 0.03168694285454299, 0.04121721402175482, 0.042749271907659536, 0.04423188089355712, 0.04327425044836897, 0.04395749118256265, 0.039571841012283726, 0.02048398261669404, 0.029608689584064485, 0.025402452589537106, 0.029145588467896832, 0.029559072840758538, 0.03669879325178371, 0.034528596654263444, 0.02546569412361699, 0.03793065503778015, 0.9850653839580401, 0.9881209345246106, 0.9842543016255708, 0.9612819429535624, 0.9453203071832368, 0.9457950200642804, 0.9582484104290436, 0.9783945627866641, 0.9672979415280258, 0.08165383642771906, 0.09126637571614027, 0.08372792367735693, 0.06789740694229895, 0.07921998012935783, 0.08188524545407505, 0.09660130590125371, 0.11446473396328638, 0.07924750772633671, 0.11675841473320236, 0.08923804967663795, 0.11928561152349926, 0.11598484468196657, 0.10883858686272363, 0.13714455058090447, 0.1177339686532185, 0.11606734097598348, 0.12754845227996225, 0.005264042779293265, 0.011235131022147793, 0.025250849632929007, 0.014998251365493487, 0.014638251713419592, 0.007040312786200542, 0.019364729059146324, 0.007447025677545738, 0.011064322067911192, 0.03608182074781452, 0.03863051058580025, 0.04980055294118302, 0.0115917196652503, 0.006768532427432139, 0.011221700250240385, 0.003171457446022208, 0.006026537109165342, 0.005142160528438411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0416622259659678, 0.02843227704234108, 0.03269372860005859, 0.002917770805983988, 0.05394235707875272, 0.008014078107683287, 0.0393991175185352, 0.038436263751300936, 0.01417298175511772, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005062969016425112, 0.002919174311322603, 0.0032014995830055293, 0.005040577748853914, 0.006311443805971262, 0.008047428066384588, 0.012007155682803972, 0.01590403420221287, 0.010568651025843923, 0.20334826692331764, 0.18628464008321066, 0.19491564932392347, 0.18363340859215904, 0.20015126093735702, 0.19582679476495157, 0.17745791680989864, 0.17454307550920023, 0.1781595738967342, 0.04877068039831389, 0.05002375915584634, 0.05224315359006071, 0.04214393722429155, 0.04460400310417878, 0.04305448913393195, 0.03906859988533906, 0.03645933806875201, 0.034873049179272475, 0.15341060722680144, 0.1300139862824593, 0.1353911403111666, 0.13525509290927418, 0.16047550942735433, 0.14729726615801042, 0.14250713697103456, 0.14645256288002417, 0.14643374888132454, 0.1736703185040659, 0.16558322473451514, 0.15768382102644773, 0.15791264754529588, 0.14916026250672454, 0.15319663117426696, 0.1602006253460535, 0.17005542414703745, 0.17020931639614123, 0.1079583795621678, 0.09915504241904982, 0.10200275964001371, 0.10292457465762583, 0.10847081825326621, 0.09798432233441823, 0.10977429769861446, 0.10335942792735109, 0.11217041020102492, 0.14539198001341103, 0.12700274105455756, 0.1454706246894366, 0.15552048743427604, 0.14877666531174238, 0.1388635093575724, 0.13219493771670698, 0.13857295062509034, 0.14087682066529128, 0.10471033708857591, 0.120650897080395, 0.0682641968975215, 0.08322639202025384, 0.11348917056426999, 0.11043020012346083, 0.07685515714620228, 0.07531978398473949, 0.05257984770697999, 0.201034023582345, 0.15135695110016167, 0.15754811715607497, 0.14542952345064764, 0.1535991274633216, 0.1373693835605978, 0.1569973698050151, 0.1522828938756351, 0.13429019281897714, 0.13496016652382836, 0.13409009049042997, 0.14469346438768027, 0.12286481870761001, 0.1558974318756815, 0.13887657322986102, 0.1644379832436378, 0.17283018264966943, 0.17612460842570854, 0.17491932517402853, 0.18704285044898916, 0.1758983556822794, 0.17840638091841643, 0.17699882198218186, 0.20140093625802502, 0.19098318546353765, 0.1884835825853156, 0.1907323751870782, 0.039876983281884715, 0.03508411516726917, 0.05082620635710011, 0.03977760740227443, 0.03976963800713107, 0.04198536488617133, 0.039486696783639696, 0.040084990134593323, 0.04453484701266297]}, "mutation_prompt": null}
{"id": "f385e655-3b43-4ded-b9b0-4bff6cfddf0d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            diversity = np.std(pop, axis=0).mean()  # Calculate population diversity\n            self.social_coefficient = 1.0 + 1.0 / (1.0 + np.exp(-diversity))  # Adaptive social coefficient\n            \n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive social learning to improve convergence by dynamically adjusting social coefficients based on population diversity.", "configspace": "", "generation": 5, "fitness": 0.12755796895365126, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.20317305890290094, 0.19228912480895155, 0.18384972922774734, 0.2607718656921516, 0.24093131562888626, 0.24607718517230437, 0.23231865073357172, 0.21661425406373447, 0.21748226993241504, 0.01355914465949204, 0.015398401275498297, 0.006588686266038701, 0.0027595935902665625, 0.008344329919168891, 0.008214249423590836, 0.015260425952738244, 0.016774837811130427, 0.011728886554346118, 0.04320109107970782, 0.04371322769151098, 0.03403397409493103, 0.0451552577326485, 0.05202427748680416, 0.044178357433000914, 0.04818309844280266, 0.046805415024485764, 0.05862795145944888, 0.03735267292937916, 0.0268258111262758, 0.025623379048767103, 0.03723439090792524, 0.027610815533959054, 0.03137814936411487, 0.03341576963691073, 0.02768026115946487, 0.02566817931282117, 0.9680481141845876, 0.9766980521930594, 0.9633975180086004, 0.9897161747479672, 0.9902829177638457, 0.9611556875589267, 0.9707890496728571, 0.9894566258058646, 0.9789548869097591, 0.10726936574693369, 0.0927074313552595, 0.12187862998044152, 0.09736114980448529, 0.0978453526539057, 0.10383800944188193, 0.0769861963012709, 0.11458675166045829, 0.11180475734911599, 0.1277684358607537, 0.10336823098828496, 0.10614257981316311, 0.12701222793792255, 0.1459608216379622, 0.17219718506829018, 0.11596027302133716, 0.10812883427674491, 0.14709208229226844, 0.03107288774755601, 0.01997424124909486, 0.020857257360457737, 0.02338107415291546, 0.024316895241978775, 0.02574128984785662, 0.016490557970653352, 0.024093446142943842, 0.010721898952054443, 0.014697361666389575, 0.013967279725768833, 0.028899901769047, 0.021459813490132373, 0.0153514255471493, 0.018675949043373663, 0.02905601547647052, 0.012869593407603852, 0.022842381406223633, 9.999999999998899e-05, 9.999999999998899e-05, 0.00045042756998303624, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049015617116476506, 0.055131436459910255, 0.0203293673798276, 0.010830251931279622, 0.040332165284767685, 0.04313442911742327, 0.01633992928305028, 0.0312112863331373, 0.01764906512800013, 0.002945065629971544, 0.002699217987800484, 0.002464608716881256, 0.004718630239747612, 9.999999999998899e-05, 0.0013034786447330138, 0.006399315569842967, 0.002161849582579256, 0.0043073733551814986, 0.022551496109809666, 0.010648167866580849, 0.010088687381614725, 0.013731747884867973, 0.011291685672550789, 0.0023549303831083, 0.013650672315025592, 0.015763599264669415, 0.015314620158879522, 0.2047203581372683, 0.20134811383877338, 0.21822172482195246, 0.18644734074526226, 0.22128427760879255, 0.2179782127168871, 0.2154937279131106, 0.1947647621533426, 0.19812763844345305, 0.054150125716465713, 0.05468973005701705, 0.05665731750204961, 0.05462352561263739, 0.042215168280211546, 0.04172165814937545, 0.040289424505057125, 0.04050093845536229, 0.045503994867597264, 0.1523583391945209, 0.13629688108466598, 0.14009005724538437, 0.1473730132742448, 0.15208131845356998, 0.175364827808964, 0.1331433891888233, 0.13265465785765862, 0.1392177322630319, 0.15503909376870728, 0.16183362342596175, 0.16901290178414163, 0.18034793279133843, 0.15382421640404298, 0.1611091428733582, 0.15722335859183, 0.15157957889105822, 0.1696817598326248, 0.11526946375908298, 0.12181375474105338, 0.11367259857275969, 0.11416605203493513, 0.10425442802804918, 0.10935329806109217, 0.10784541974287587, 0.11032626093764353, 0.10279332029479538, 0.14250306335994067, 0.14746210847771468, 0.16736567421006043, 0.14827117007305424, 0.16609723871012316, 0.138171879432208, 0.16359637325785703, 0.14094259885239246, 0.14348886158438545, 0.10943208300674634, 0.11022693179565035, 0.10215413451873501, 0.1290097553287154, 0.0694327748350575, 0.10605933510195975, 0.0946851879096019, 0.14188063098590975, 0.09342222667541789, 0.14343235076512717, 0.1478290636009999, 0.14944570946360092, 0.1268694206300166, 0.14470346754530727, 0.13146762395120748, 0.15243757411250358, 0.1517491995368222, 0.14591034330946073, 0.14782629077693032, 0.14078005154853435, 0.13637268664461366, 0.16580475186946264, 0.10998170857264489, 0.11987287999182594, 0.1776657343012088, 0.1839561948636801, 0.18921398908242026, 0.17838230268196786, 0.18282574082180758, 0.18724022901778115, 0.18892371409258202, 0.18611349676340705, 0.1727000007338365, 0.18086035158631097, 0.17781665709055616, 0.18919899643999039, 0.04701498011561411, 0.03847373174632007, 0.06400141397118841, 0.051869410768948576, 0.04460944084474017, 0.04144472944605837, 0.04630315454993761, 0.0453128110154728, 0.04400077950821646]}, "mutation_prompt": null}
{"id": "281fe70a-d4e4-4038-8c6d-bf2de97e93fc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "4e28d822-7e8a-4949-b04f-ee0f70ad6d3f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "3b61f199-bbf8-497a-9fc1-951d6fb4bf51", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "44fb8efc-ca1f-4ac2-b46f-20a3284be42b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of inertia and crossover parameters for better convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.2188258323452501, 0.2337006169595216, 0.19037224310326284, 0.2584663562372541, 0.2528124193901603, 0.24523184553296673, 0.27201848334087086, 0.22479886545212513, 0.2276220574150628, 0.02841732595822888, 0.008539640057646292, 0.02678982453439749, 0.008914888820632072, 0.010168337660111826, 0.015168676531050918, 0.006841117287683662, 0.017931303772375062, 0.027688841937234754, 0.04783769248401348, 0.052202025738471436, 0.04722327731503739, 0.050006735573454586, 0.050291108512165006, 0.0481650575215985, 0.0450830172288017, 0.05548684050057162, 0.05677348631505341, 0.022743452681426635, 0.030103176965866063, 0.027368037127311062, 0.03563184549598408, 0.03837045428382557, 0.030639505358851626, 0.05066980544450339, 0.03788115905453593, 0.038302458659480565, 0.9587410447241207, 0.9743382897159266, 0.9808049923240101, 0.9897195796020563, 0.9897539690584161, 0.9600087348649081, 0.9910320458422359, 0.98051917913892, 0.9636949741553563, 0.1105750579158139, 0.10803662362061495, 0.11795014916397917, 0.08363530566152055, 0.08597369072529637, 0.1016294510067628, 0.13190576013819078, 0.1156266101775052, 0.10803603093795733, 0.13895240275784781, 0.1289516623964484, 0.1321306454108715, 0.13696512527689575, 0.1297715862454768, 0.13193450055942557, 0.13120070845895515, 0.1292044719026575, 0.15686442818198176, 0.02881839214187054, 0.03355599238547424, 0.027537136141958407, 0.02985616602286878, 0.03796702686249287, 0.018624362040417286, 0.03186947920798089, 0.020485591840698758, 0.03534379955357603, 0.009151996796264994, 0.017528669496970517, 0.01634680963269619, 0.02787584895749129, 0.03365284089597009, 0.02637172012526734, 0.025944932752329453, 0.02732595086396372, 0.02132962311131137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011098771939654917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033608499170267536, 0.03996494672493478, 0.047150474236040796, 0.04513838677140081, 0.061672836040993606, 0.0361626966819234, 0.03661153318951271, 0.02143622803376688, 0.03733619031601865, 0.0029751212348637646, 0.0030242651193744807, 0.0016798691443853375, 0.0048868597339051245, 0.0020926689082439998, 0.00236266335044677, 0.007432660789836176, 0.0027739411018257165, 0.0018766740400396609, 0.011075432476872038, 0.016907226851905377, 9.999999999998899e-05, 0.03280163896671473, 0.02806915859000947, 0.022395490151130293, 0.015241414790133634, 0.01695239993935016, 0.019207235040832327, 0.20523021110026962, 0.22153591456179045, 0.2206563776540278, 0.2262093426494438, 0.22530704960745007, 0.2228343590199977, 0.2042934079339851, 0.19281814969077982, 0.2070070922049092, 0.059323520307203004, 0.05890212248524407, 0.07872920721294818, 0.04915773384117672, 0.05583284655806364, 0.052040694608150084, 0.05162589972014864, 0.04549191756631621, 0.04897496350334807, 0.15133932719676668, 0.15789855009970066, 0.14764239726546546, 0.15449294468645025, 0.1402829191988536, 0.18817786221715083, 0.1568867477170761, 0.13658825228576954, 0.13706888684248408, 0.165670813605576, 0.17059798234847512, 0.1665377288801254, 0.1690895998720061, 0.15120945639959316, 0.17212937255242888, 0.18804690614934416, 0.17660659124258804, 0.1868041043917813, 0.12783685331352257, 0.1136539205083662, 0.11818030328279616, 0.1104836092967093, 0.11285835516102993, 0.10379653699610081, 0.13127600414497975, 0.11152396204646142, 0.12361024811530008, 0.14507850733144445, 0.15129035274791092, 0.16604814103485133, 0.1430008495243419, 0.15123677420334503, 0.14731189288509083, 0.1544801680655129, 0.1426444529282802, 0.14273097101159216, 0.10240453704371921, 0.09299178572155309, 0.09903986410237864, 0.08702007303466996, 0.12016327040197683, 0.12349555672096046, 0.08029338866141711, 0.07855470404495501, 0.0752864114266073, 0.15102058956113018, 0.13122904275244895, 0.15951660615879515, 0.15060059754959498, 0.1850647455602814, 0.1546744009012777, 0.14735692673683587, 0.155148327173392, 0.14262954447524212, 0.14191530131713304, 0.1548166736116504, 0.13076997423362446, 0.1168148926323127, 0.13798846683740862, 0.12881708229082012, 0.1869704184121911, 0.14366732457614595, 0.17026470836815055, 0.2028478914252092, 0.18075919567292908, 0.1736407473922814, 0.18548993298301664, 0.18140856809172035, 0.1854989278594832, 0.17430381652752713, 0.18576183949064173, 0.20592050922048977, 0.04678723134875695, 0.04755395952398189, 0.043529783858872406, 0.04617922202356184, 0.04862595727246388, 0.04253413263454875, 0.0496093715858007, 0.0447728447448793, 0.04443153892255958]}, "mutation_prompt": null}
{"id": "ddfee31a-8c3e-47b9-85e5-fdeef3e57665", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.5  # Slight increase for better personal exploration\n        self.social_coefficient = 1.5  # Slight increase for stronger pull to global best\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(pop[indices], 3, replace=False)\n                step_factor = 0.5 + 0.3 * (1 - eval_count/self.budget)  # Adaptive mutation strategy\n                mutant = np.clip(a + step_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))  # Dynamic crossover rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)  # Decreasing inertia over iterations\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive population size and mutation strategy for better convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {}, "mutation_prompt": null}
{"id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 11, "fitness": 0.1391337905272723, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "00bf13f9-042e-49f9-8eb0-bc5ceb36651a", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "64e263d5-5c14-41f6-9412-de632d68247f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "e91842bd-eb56-45c4-bfac-cbfdbb924261", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "34ff2190-6793-46ab-98e4-4dab0ab99715", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "0c96c647-37ac-46d2-b4e4-8bcab26daac1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "4758df94-ab77-44cb-9772-74dd978ba25c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "28a45ee7-91b1-4634-b21d-d72c9243e759", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "12881e93-ef33-4193-a1e0-3fe2c0b3e25b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "2c453165-5fe8-40a1-8eaf-0da2df0ac200", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "c3de3818-adb1-4b85-a3d6-0b6298464208", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                # Levy flight perturbation\n                if np.random.rand() < 0.1:\n                    levy_step = np.random.normal(size=self.dim) * np.power(np.random.rand(), -1/1.5)\n                    candidate += 0.01 * levy_step\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "A refined HybridPSODE incorporating adaptive velocity adjustment with Levy flight perturbations for enhanced exploration.", "configspace": "", "generation": 20, "fitness": 0.13740142278777887, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.20676982148751266, 0.2042080237089663, 0.22195185717736754, 0.25507632419325765, 0.27520639450189543, 0.2774919444638564, 0.2452503844024142, 0.24434205043382873, 0.254690406991524, 0.008304779419242347, 0.019856010734926932, 0.021944210686925314, 0.006116328403718785, 0.00880101535795963, 0.021764741599900272, 0.016531672068001324, 0.022669739152742063, 0.02639477400054946, 0.04541945134200376, 0.050329066728968086, 0.05084644647484471, 0.053765478038621084, 0.05654800364150614, 0.063870838750827, 0.049075723963948104, 0.050884873758864524, 0.05506919140198785, 0.03109799063393659, 0.0342735936141596, 0.03917696331797704, 0.04069237605009457, 0.0368674313205003, 0.031059119023293946, 0.04158808442790907, 0.036915449925377986, 0.04243226692958035, 0.976665789832733, 0.9919469761160872, 0.9596437837738987, 0.9808343104432197, 0.9763698713938661, 0.9590037213928293, 0.9884160295378531, 0.9641508421317381, 0.9685711532819261, 0.12851408211205217, 0.10057931419814503, 0.1120754627289352, 0.11224634820259272, 0.1096652517576393, 0.10426614188285144, 0.12540081486012566, 0.1204899158011753, 0.11398319057386086, 0.13021772249267904, 0.1887711818302158, 0.13010666863340226, 0.12956046111000064, 0.11644260010721152, 0.12739217108287426, 0.1240122406636448, 0.15069978929397598, 0.13731681487171898, 0.037548139274292014, 0.02825057202650716, 0.03002731391419733, 0.0366602844035997, 0.02849311948125466, 0.03212986991013944, 0.03189929149450377, 0.034157691907471976, 0.040222372577459864, 0.04812962197019155, 0.05686376810041116, 0.0549335036043016, 0.029635719054088128, 0.03659585393822906, 0.025892125394228582, 0.020134741123296718, 0.021581559473282885, 0.033525898218510486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003414182254104503, 0.00041798644030588417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04489735809384021, 0.04649404508125954, 0.044900735554672444, 0.04343247598786981, 0.03692277569301494, 0.0004685767319985157, 0.036624553276166094, 0.01147048544381668, 0.06306475724772587, 0.003161667052441919, 0.002078226222075652, 0.0017926625690907194, 0.0034330513999352164, 0.001870949942365585, 0.006017799347047381, 0.004142549678805563, 0.005922942378709162, 0.009195629058031174, 0.0077404929152120605, 0.011457791908608628, 0.0175085595529485, 0.02209116546777079, 0.025490111950235095, 0.02063005942034557, 0.020726202924412407, 0.023620416413803302, 0.017779363422034677, 0.22111918034984523, 0.22840081082147112, 0.22524408337718338, 0.2368169741932541, 0.22673968395812594, 0.2625961352750459, 0.21880699678495408, 0.20530250172687114, 0.23568633858729426, 0.06728687814682321, 0.06146456345760398, 0.060808302474341325, 0.052069381608283005, 0.052939146261117065, 0.05177601269845111, 0.04356598885093499, 0.037686558732078046, 0.04847602447592125, 0.16271128376340982, 0.17195395202791974, 0.13094920271574662, 0.16264893982651463, 0.15066960643926863, 0.16125129725328502, 0.13762049073482086, 0.17628435680199872, 0.13397677291123, 0.18462390783359206, 0.1681883645605542, 0.1875314686327516, 0.17812536098369525, 0.16335189617515167, 0.18485967543063575, 0.19254572455514185, 0.17813263011083158, 0.1905930421324631, 0.1146037277798474, 0.12651093935714997, 0.11005161008497011, 0.11633011211063027, 0.11432131405382606, 0.13206163188333775, 0.11276678177614541, 0.09834533416896396, 0.13635627620323398, 0.1506710029474616, 0.15030636624004234, 0.14991808147555608, 0.14349786290402133, 0.14198852973987452, 0.14725274621310547, 0.14524185710959647, 0.14256472753707838, 0.1599134749491664, 0.1271434044960017, 0.14838913718632085, 0.12041810306689349, 0.10338307901544774, 0.12133504527085603, 0.1547690814018794, 0.08962149583111645, 0.10107040197437434, 0.14265509875395233, 0.19007826047689524, 0.2053188044659976, 0.15791444763290297, 0.1578750209500045, 0.15686740175970193, 0.14253218725377337, 0.22755217836570774, 0.17956800658441496, 0.23638691969933823, 0.14725493742337348, 0.14566848690387046, 0.14786462435007686, 0.11142444687787811, 0.19477368823145913, 0.16360872434316265, 0.19383856225846707, 0.19229050766421796, 0.16904315094864542, 0.1762829925194903, 0.19016962392951842, 0.2178235077651257, 0.17804221487116245, 0.1860444821790218, 0.1887268291387466, 0.19804990857456695, 0.21294804325451633, 0.1898585726040708, 0.043942208460598486, 0.04499560350260512, 0.048681492421159045, 0.05397254090011594, 0.043957763161870944, 0.048893971767986266, 0.05470809898801676, 0.04379819489177572, 0.04488566130968141]}, "mutation_prompt": null}
{"id": "78f46ba2-bc43-42c6-a753-bae5bbc4e5e9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "bb3b481d-b6cd-4d5b-895d-3e604b6cbd37", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "36cef514-8d9b-489f-b25c-4425886da6b2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "fbfdf79c-4c51-4a62-a388-e50ce0f1789f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "ac465df2-fbf1-48bc-825c-eadf7356ccc3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 10 + 2 * int(np.sqrt(dim))\n        self.population_size = self.base_population_size\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n                # Adaptive population size\n                self.population_size = self.base_population_size + int(0.1 * self.base_population_size * np.sin(np.pi * eval_count / self.budget))\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n            \n            # Local restart to escape local optima\n            if eval_count % 100 == 0:\n                worst_indices = np.argsort(personal_best_values)[-3:]\n                for index in worst_indices:\n                    personal_best[index] = np.random.uniform(low=lower_bound, high=upper_bound, size=self.dim)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive population size, dynamic coefficients, and local restart strategy for improved convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 14').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 14')", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {}, "mutation_prompt": null}
{"id": "6ec67653-ceb3-4911-8608-db0552dec3d9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "ee485da1-877d-4380-9597-375b08a2d3ab", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8 + 0.2 * np.random.rand()  # Adaptive mutation factor\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.4 * (eval_count/self.budget)\n\n            # Strategic re-initialization to enhance diversity\n            if eval_count % 100 == 0:\n                new_pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE using adaptive mutation and inertia weights with strategic re-initialization for improved diversity and convergence.", "configspace": "", "generation": 27, "fitness": 0.12647399186151667, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.2101539376894569, 0.20238946103489475, 0.1735287369164984, 0.21725977901746096, 0.22505236900215664, 0.22406765865385758, 0.19966769634250203, 0.22387629196298198, 0.20790956274759897, 0.0019671570971265817, 0.0059502295596446375, 0.0011473298052192549, 0.0004769191983965415, 0.0063482434675479205, 9.999999999998899e-05, 0.0028008975713118556, 0.0042406367558822655, 0.002682863976753991, 0.04218955028037086, 0.048151445432722206, 0.0484195949434556, 0.03485900926122654, 0.051298980305842234, 0.03798559291075876, 0.04014763891584061, 0.05299914558667718, 0.04537037910400743, 0.019102387178661084, 0.027600482825470674, 0.03062783474479236, 0.032416367137887536, 0.03889238449829868, 0.029186343137286297, 0.021863392744726706, 0.03052920510918644, 0.02453590981075937, 0.993762200144786, 0.9834787521990361, 0.988971218290984, 0.9909391814087078, 0.9654896258491645, 0.9691029607343145, 0.9763712798342054, 0.992732663558095, 0.98539853815021, 0.08563454329036435, 0.09926015216533601, 0.08438403798924665, 0.07985002293059063, 0.09269289200694986, 0.09230822316125886, 0.09395395668618889, 0.08897003154946537, 0.07463478958107839, 0.10419944156358762, 0.1332226538316138, 0.10644099284708919, 0.11726922442175403, 0.10414597643243706, 0.13526937110905723, 0.09985606651779688, 0.11364805952168011, 0.13208928991785873, 0.013241720506615096, 0.029471282340107097, 0.01839059081639438, 0.019012836101822694, 0.04390695899413499, 0.025505094797242944, 0.023068736656452926, 0.02977194798594318, 0.026409132878662644, 0.00853595413582442, 0.0066607412798100896, 0.009648648551055738, 0.041249351390545974, 0.018901515613696795, 0.007403731002537106, 0.00645857576431208, 0.010206584817685327, 0.019743301480832254, 9.999999999998899e-05, 0.0004694376835102654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05173312158672738, 0.03997406237282486, 0.03415073890628484, 0.007046318640652527, 0.04077838507595921, 0.015324560653772634, 0.027999632918452644, 0.07388115659681194, 0.029227252355696343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020442412013943478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012000292715284688, 0.007859918664354315, 0.012106016829962263, 0.011268780153390057, 0.013553390055671688, 0.02334304497085593, 0.011463007746594811, 0.01362794184858318, 0.011894921264086977, 0.18433410052182475, 0.20333064622018726, 0.20085846264132767, 0.2090387701230736, 0.21394297432474974, 0.21156482350002492, 0.18913062630459143, 0.19796717668516772, 0.2061413987175975, 0.051433776698966316, 0.056086992919826884, 0.04940281286920778, 0.04912052281931356, 0.05001918309448827, 0.03957172460859726, 0.04605795393094614, 0.04575337312116878, 0.0363680944443886, 0.14543430282720637, 0.14448435885292854, 0.13427348390441407, 0.15316028569165463, 0.15486317799175886, 0.12845500618214867, 0.14022728624909164, 0.1352508584623483, 0.14774462086602558, 0.17051193293886102, 0.17223001634555624, 0.1634764100470658, 0.16957335399353668, 0.16728705760323936, 0.1500363297530679, 0.16737131107301517, 0.15791001849258324, 0.19631378076743244, 0.11423772692394396, 0.11647574041485498, 0.1044806135828118, 0.09404643876552854, 0.1325144977123608, 0.10287915016708826, 0.1076512604701485, 0.10380852499973203, 0.1217599800186574, 0.13061229042335964, 0.14430889132504976, 0.1392024169462387, 0.151585706441553, 0.15931133849595858, 0.1390928659680145, 0.1644525546203791, 0.1584597093584441, 0.13867906638587535, 0.1335888692053646, 0.1157123255199769, 0.12670178019257017, 0.0767721841643546, 0.09834043086540711, 0.12919988760977508, 0.08493319473321592, 0.10565435719307736, 0.14289025513950038, 0.16533854421959482, 0.14789727328445756, 0.19277778827653136, 0.14951883849031733, 0.1643075955340606, 0.16229661352260005, 0.1433556870372208, 0.15525531237297563, 0.1630235552627355, 0.171180814980469, 0.14461095625077103, 0.13945115468418812, 0.12544962183464647, 0.12705795495785133, 0.12204876802882614, 0.17008261463279883, 0.1817987933805757, 0.1803122578331362, 0.18460596778167027, 0.188734635317498, 0.18251360688650342, 0.18497586394554721, 0.18482013115118068, 0.1806814030602294, 0.17869458179122266, 0.19484159528126777, 0.19567619675551207, 0.03826061033093153, 0.04411185808540008, 0.03898894528084362, 0.04383476226253624, 0.06592233195704489, 0.04651526591015298, 0.04609801053040463, 0.05004726746277066, 0.04025132978909263]}, "mutation_prompt": null}
{"id": "d098406a-d47c-40a4-8ac0-93fafb050e91", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor changes\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.4 * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            if eval_count % 60 == 0:  # Changed reinitialization frequency\n                pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n                new_pop = pop  # Reinitialize population to avoid stagnation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhancing HybridPSODE with adaptive mutation factor and periodic reinitialization for improved exploration.", "configspace": "", "generation": 28, "fitness": 0.135653382299259, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.2077151081876416, 0.22125862110640448, 0.22617044841239498, 0.2642475826387116, 0.24730166877407322, 0.25612759095311965, 0.241693142721366, 0.23180223866065652, 0.26203673809269057, 0.008160139630827845, 0.01313102853319048, 0.011632643988694458, 0.00815900013886317, 0.0177326885674034, 0.005667794192034337, 0.00546039233581197, 0.010356531159671278, 0.005458482339672832, 0.047996874525756184, 0.060777551430524324, 0.05433339411888283, 0.05435146420094539, 0.043116323656473665, 0.04702719432369906, 0.046659675663891176, 0.05159885585403212, 0.05995866494859603, 0.041310987045029446, 0.03299052471170727, 0.038121094177965054, 0.0318739825821307, 0.03801017197582801, 0.039264980884392786, 0.03763637080372351, 0.0491419647570257, 0.03929045353883576, 0.99375689129503, 0.9833583589732544, 0.9703267508980444, 0.9909347827351067, 0.980171590109931, 0.969325314228297, 0.94547462712299, 0.9962578989481327, 0.9853405198373986, 0.1226832920559695, 0.10630891484024452, 0.116597650364055, 0.10631959469580765, 0.08529599312584779, 0.12599766900720333, 0.12421378247355241, 0.11504309377256339, 0.1103286540753059, 0.1261840659933816, 0.12109676431942207, 0.13223757322458773, 0.13725163551750608, 0.12868529816659646, 0.14234187736163184, 0.13021708133271936, 0.13468358733914465, 0.1456458859895169, 0.026536981103765123, 0.04271399696252387, 0.03993729443220495, 0.06306728157116015, 0.022958425814648797, 0.042885097648311055, 0.04566520336001034, 0.032682513901111765, 0.037602536149614396, 0.01380106578260587, 0.015511684744042076, 0.02236747253259619, 0.034359871455749036, 0.025604938676898725, 0.028749731985928895, 0.020108919471276798, 0.025155578563713754, 0.03207073905073399, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011656756671458712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03601130498011551, 0.05623459575336598, 0.03617247074193697, 0.07447829954962637, 0.016016345681796884, 0.008139285226597348, 0.08193650167867439, 0.05130461071591852, 0.028618513169805793, 0.002494851399273079, 0.0017525354474715593, 0.0013811434522705834, 0.003195669086239139, 0.0027123019870390896, 0.0006432489308563216, 0.0011361867416206373, 0.004052556515234063, 0.001085749181490847, 0.01784537720052337, 0.014352911397431112, 0.011043382503689858, 0.02251743394855299, 0.010979196616463738, 0.028815319972488207, 0.019139167117398714, 0.0134537620272136, 0.02269580367887014, 0.20884568237570222, 0.21248533413341797, 0.22891413978020814, 0.22308299108846985, 0.23803226380299936, 0.23718204095315454, 0.22346715996885191, 0.22374822925158955, 0.23351693081199565, 0.04583937002045191, 0.05561906879317735, 0.0676869881618748, 0.051853070643973265, 0.05794279398977997, 0.05139237552752329, 0.048080000538959444, 0.04908944179880059, 0.04124101330738272, 0.12350359310504633, 0.13361192469562777, 0.14401367349988636, 0.1456596252935376, 0.12996582684073632, 0.1567054823702816, 0.14484360650649486, 0.1413951024665554, 0.13620965128083407, 0.19861823187112748, 0.1791536011279291, 0.1814314222058815, 0.17718584606178922, 0.1896290853664948, 0.15720899150807033, 0.18039662426414393, 0.1905232520930047, 0.20214973121218405, 0.13233155086293025, 0.12573128072720952, 0.13174880024194702, 0.13308720035109178, 0.1139137406531956, 0.11424243990430916, 0.15660454534852575, 0.11486104882842085, 0.12266598566741937, 0.13288958617418034, 0.15715729860477334, 0.14301073347544135, 0.1448763289875078, 0.14143829181486778, 0.15122663647740264, 0.1392720690815611, 0.14666646156416085, 0.1411823433813093, 0.11244350370242195, 0.11636253465314916, 0.09376187936435454, 0.1314219445548339, 0.09552760491486245, 0.11853397351491934, 0.09718830871857231, 0.09538425892879698, 0.09723140294412191, 0.24768762655569598, 0.17732079885323404, 0.13707503992483672, 0.1508631273950114, 0.2501061559133858, 0.14537416930254765, 0.15115025856142816, 0.22516578350226968, 0.1352563399436565, 0.23709844169243188, 0.13509749122866488, 0.14228246019775037, 0.1773649237370617, 0.14110632493919895, 0.13741056137162522, 0.17923486613194528, 0.2080648949163808, 0.17429567698854975, 0.17688344338965212, 0.1865239824259033, 0.1884521754498374, 0.1847278046053108, 0.1888665845945765, 0.20159068143302816, 0.18487735796383908, 0.16996386482502834, 0.17432084480982046, 0.05016983556206578, 0.050063029095155254, 0.047453574536322596, 0.05767406813820508, 0.04722651289842816, 0.059123120149893627, 0.04721533718671178, 0.04947353972435087, 0.047978907523995806]}, "mutation_prompt": null}
{"id": "9bd9b7c8-b90a-4089-acf6-07047b82b60c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.5  # Slightly increased for more exploration\n        self.social_coefficient = 1.5  # Slightly increased for better convergence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.85  # Reduced to balance increased coefficients\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.standard_normal(size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adaptation of coefficients and increased diversity through chaotic sequences.", "configspace": "", "generation": 29, "fitness": 0.11414419939956923, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.12118260654330515, 0.15527567530689323, 0.13909686154531342, 0.18093858568770815, 0.18415249384580779, 0.1940894027002925, 0.1545729860523536, 0.1635406507546613, 0.17756586666865137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03394054378058786, 0.03507361547164767, 0.02552821663820437, 0.07702491998287697, 0.03315135389301782, 0.03072407902478569, 0.03502983882390531, 0.03730025398929704, 0.04339114492132867, 0.01910429962607718, 0.014793254773405762, 0.0209306762083028, 0.021636384477350057, 0.03020944671457204, 0.015196022274715282, 0.022717619410715262, 0.027312509157248144, 0.015153484874790402, 0.9840427481707801, 0.9878499124851973, 0.9846035856462846, 0.9913560305009181, 0.9930931288299045, 0.985494122309925, 0.971036917623609, 0.9931515893664548, 0.985655179567501, 0.06883309177834529, 0.05997366677562388, 0.06294205691260435, 0.06389285039533754, 0.06060641376112963, 0.07087599215585683, 0.0705600270320127, 0.07872940337870893, 0.0651500150494978, 0.11236183628174601, 0.055052106892546915, 0.09362298494817911, 0.1064705088280985, 0.10666509102532384, 0.10028040768390623, 0.12137172385794004, 0.09866085320659823, 0.10001685766175705, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026437816708406725, 0.0007940483678896548, 9.999999999998899e-05, 0.01352617973453396, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015242401353606105, 0.026558344783531362, 0.026872034692947078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03619295202538686, 0.04636526599731605, 0.026419963326457574, 0.045291069887598456, 0.015290559935765113, 0.03145070176627618, 0.014301296601757718, 0.027140018840648206, 0.0163727200516105, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003226157881973113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010560571284923714, 0.00499857794769154, 9.999999999998899e-05, 0.16653149066061124, 0.15926756757164018, 0.16207563754742427, 0.19480730280260372, 0.1762961043839899, 0.18437530785082368, 0.15619383344404436, 0.1601617834603305, 0.16095996097741494, 0.04907704552004866, 0.04808870337829119, 0.05040624684930639, 0.03423668375787914, 0.03692793943988015, 0.032668652268587395, 0.02915725599061081, 0.03368172924022461, 0.05240916016197805, 0.1434640797830622, 0.1369918395706321, 0.12941167370033269, 0.14124145562888957, 0.12929700563927982, 0.16464197075605902, 0.13532355096669235, 0.17844169954772893, 0.15754014073643463, 0.1493380690356495, 0.14439035019840574, 0.14749094702926746, 0.14117433291454295, 0.13957882970344693, 0.14092439603098794, 0.15423275999558028, 0.15640979867952354, 0.15738951897279274, 0.09013692458564015, 0.09959385755704642, 0.09770853725783657, 0.09172281293195761, 0.10410197695293277, 0.09838377838977685, 0.09369297319375569, 0.09759584043066494, 0.10430729315698661, 0.13130917208434678, 0.13794588756318138, 0.13908745977256565, 0.15267102548046718, 0.1471855645659369, 0.13098613902047906, 0.145313700470718, 0.16618044142094968, 0.127322585072718, 0.06824652438364243, 0.05843022035077283, 0.04602334970814681, 0.0751131351928851, 0.033832162160109314, 0.06769819792695508, 0.07618960193793378, 0.13914630389375504, 0.08099908414620927, 0.1510198777256626, 0.13727917595315653, 0.13344201280284929, 0.11168659975568085, 0.13907035205034513, 0.11542406212419387, 0.1195801480239117, 0.14210866217204932, 0.1447216563356153, 0.15958660407814185, 0.14525380497510199, 0.14368894964606893, 0.10267723190309475, 0.11650016198145152, 0.1520319948523574, 0.18440021590330846, 0.18164754872893984, 0.17193686543920594, 0.17438926294830548, 0.19987695553756069, 0.18370592446343192, 0.18611482853928374, 0.1773814043945111, 0.18705456895674655, 0.19031356712410907, 0.18212663515142857, 0.17464148135150048, 0.04594448090781422, 0.040036303688254504, 0.0511141262310586, 0.03929551944064702, 0.038674982686141446, 0.0385223254717354, 0.040465522106293283, 0.030612244046981374, 0.03856309758228782]}, "mutation_prompt": null}
{"id": "a7ad78da-77c2-4e1f-8254-766070f3bf86", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "9826cf71-5b23-447a-8dd1-c66352e1e2fd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.5 + 0.5 * np.random.rand()  # Adjusted to encourage exploration\n        self.social_coefficient = 1.5 + 0.5 * np.random.rand()     # Adjusted similarly\n        self.mutation_factor = 0.85  # Slightly increased for mutation diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for more robust exploration\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Modified chaotic perturbation for enhanced diversity\n            if eval_count % 30 == 0:  # More frequent perturbation\n                perturbation = 0.15 * np.tan(np.random.uniform(-np.pi/2, np.pi/2, size=(self.population_size, self.dim)))\n                new_pop += perturbation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive dynamic coefficients and chaotic perturbation to improve convergence and diversity.", "configspace": "", "generation": 31, "fitness": 0.12420144146832787, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.15934276004635317, 0.16366710508599935, 0.1809873602126162, 0.22399949843272826, 0.22881936219762844, 0.21724365763764975, 0.19156755619702148, 0.19426270099469967, 0.2307325375613769, 0.0021291671092038555, 0.00043716952875405557, 0.006336373734980971, 0.0006087103317288234, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007503871711367349, 0.0015759261183079243, 0.0012348042034769913, 0.038518608432654755, 0.036325090558962936, 0.04480443677574819, 0.0451633677060056, 0.04114099307306007, 0.046947107757437934, 0.05273658893445465, 0.039585114490107154, 0.04904789941170096, 0.03355862711408264, 0.030230920918959958, 0.02334237587375787, 0.02922480493966484, 0.023468962360991497, 0.030153245832032938, 0.02977159693979925, 0.022779140784507934, 0.027564451921164745, 0.9903390865517092, 0.9879008868721642, 0.978564711965977, 0.9892578126221013, 0.9705655382750374, 0.9712461849027693, 0.9853651477106379, 0.9687828393609471, 0.9931182959054909, 0.09252622990090809, 0.07867366148115229, 0.10367749958015815, 0.06331606983111338, 0.08155784472039795, 0.07473229103952106, 0.10226613222230296, 0.09722534660830007, 0.08135237159865627, 0.11888905678810335, 0.11081455393173223, 0.10754180316278383, 0.14098009247765364, 0.12638588562772857, 0.12198305774957519, 0.12584374651516084, 0.12903000494336847, 0.13101571405858725, 0.01748276616744282, 0.034004465571476294, 0.03658173356572203, 0.016937084310222228, 0.01081172324976798, 0.019478090459387976, 0.0162307915485026, 0.031831460576043136, 0.023988930739119674, 0.026451484103348966, 0.040534454121206376, 0.04348429031326173, 0.014334317418706832, 0.00843152826914606, 0.012332876098582135, 0.017665014222271402, 0.005378106234871338, 0.014576854004716533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02606264876613973, 0.03544131353070168, 0.03544612204880759, 0.05880256350382074, 0.01915287561990664, 0.05156599075091539, 0.03824904835330001, 0.013736650304641662, 0.012670230155594209, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036079369778366788, 0.014039152006427136, 0.00853210777628488, 0.0064272073432756205, 0.00334692618697352, 0.014478664924167939, 0.013979791602998892, 0.014443322040890938, 0.017018453577944626, 0.17501809553527548, 0.18881321915422378, 0.1852646488517672, 0.20806173754952528, 0.2092119959656833, 0.2098714895608531, 0.18352014272949269, 0.18592628743621098, 0.20500999387030705, 0.05486864847763939, 0.06296639664824122, 0.052249756693382055, 0.04182325537184661, 0.03988713492197127, 0.0486228449153443, 0.05022275427173861, 0.04297788763597987, 0.04148573779242326, 0.13657950529921947, 0.13196991382436607, 0.1390084546498419, 0.1574838752442922, 0.13942158953297434, 0.15906092149543005, 0.16550735598492705, 0.1306899706188357, 0.15153339983542424, 0.16667835042843016, 0.16320193453036014, 0.1640284014045441, 0.14940634429616584, 0.14726470480789322, 0.16015347090100718, 0.16836888567050012, 0.17100469216741299, 0.17376807232116775, 0.10900084503796592, 0.1054770381509561, 0.11476653562840688, 0.11154451505985163, 0.10119540569414098, 0.11474879984220221, 0.11352236578269836, 0.1070854246404982, 0.1276505086770856, 0.13926675871701788, 0.1620511619975763, 0.1485114363536224, 0.13286778630465435, 0.13331980702756374, 0.1565706893179729, 0.12871043775211077, 0.13884414086423713, 0.13559106537316945, 0.06473357879801, 0.1386550751740424, 0.0888125227921237, 0.09393480036171609, 0.07721323301809369, 0.12362196295150496, 0.0917975123652246, 0.09353839479828097, 0.12391368520804757, 0.1369818013167946, 0.14326572012236538, 0.165564894382919, 0.14405019583453482, 0.1503266047950612, 0.16020624634989178, 0.15782016734685944, 0.14557192173012934, 0.14492908502559754, 0.13479024910217308, 0.14455932415894435, 0.14500923615350492, 0.13871667684941535, 0.11571596090504643, 0.13385905964136602, 0.18326545959555218, 0.2329982260853556, 0.1700498875626858, 0.17584627275541587, 0.19847409473542288, 0.17150037961164966, 0.18102782855866517, 0.18365916169781726, 0.17628422771699026, 0.17776793074490704, 0.17579539653384257, 0.1835844498241107, 0.04617454193862536, 0.03700562666875595, 0.0446193246387373, 0.04200523760839425, 0.039849636371816266, 0.04101815134368314, 0.04111214620946213, 0.03651044944424631, 0.039171172477386995]}, "mutation_prompt": null}
{"id": "c2173585-0a1c-4ade-9974-fd05272ed342", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "24601a1f-b8a0-4205-ba52-35d35f89fbe2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An optimized HybridPSODE with adaptive coefficients and enhanced diversity through chaotic initialization and random perturbation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.23904065372107475, 0.24123458099499206, 0.23797608533847037, 0.25563645297394466, 0.2613634438465672, 0.28153368792676114, 0.23127558781110635, 0.2562581559429946, 0.28335860065162766, 0.004827182288469123, 0.004427134124188381, 0.01615092827364928, 0.019904367541537793, 0.027004264624169827, 0.033421875719470306, 0.024542116635458133, 0.028788362884506924, 0.035213591060910265, 0.05125951264830142, 0.04491177032634874, 0.05694986276512448, 0.044083347013808116, 0.05749484021028328, 0.05853198933597992, 0.06702332224702856, 0.05276608185152876, 0.056563892955624806, 0.03904049721975611, 0.03594857274417462, 0.03362270080509622, 0.04823012493344814, 0.049864120344890406, 0.042433452823666284, 0.036468758633216525, 0.03685410202579531, 0.047001496470988835, 0.9869907758951896, 0.9753241567782681, 0.9843184637967449, 0.9605268834633106, 0.9726472769585535, 0.9850784396945751, 0.9707143935823557, 0.9844382190544778, 0.9799602047316508, 0.12073111451748464, 0.11750413986079589, 0.12652527592365292, 0.12195928994808214, 0.1227006557079221, 0.12702904372873758, 0.1251287070654693, 0.10430773928519121, 0.1289592455102394, 0.13222193932932846, 0.12856274783755284, 0.21218629570605108, 0.12100587609515934, 0.13298481789452343, 0.15780993954331246, 0.14548745875581603, 0.1483926542846371, 0.15040017577839904, 0.03653800492174142, 0.037089591108457, 0.038901794377672716, 0.029494198379621084, 0.052188455549313395, 0.04489400735341553, 0.03654970231145327, 0.03216505797159608, 0.02565463772573917, 0.04128356384012799, 0.05532102814550799, 0.04895831924080507, 0.019075731943606677, 0.034053635085690814, 0.03358172628678713, 0.010455902616272716, 0.031468188189504476, 0.023891111633974838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005096697751288959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0411946377385517, 0.03655873423896194, 0.038878728691584596, 0.04282342966795438, 0.06012949875681628, 0.02209418507124461, 0.031062663605374685, 0.03893638308818392, 0.025832329898478168, 0.004377643457505687, 0.005576306702842482, 0.00459174420290287, 0.0019228635513248715, 0.007611640089312144, 0.008788451444235346, 0.008531106916853437, 0.0061907601279084234, 0.01778091435267093, 0.009111959193091934, 0.015271417192977088, 0.012360773706157291, 0.024473801655993888, 0.02528178163791217, 0.03035072152773788, 0.016059564704886675, 0.013995915473376641, 0.022868153244066547, 0.23104064646994815, 0.2337950321658222, 0.23437834525883583, 0.24045951630024542, 0.25052988773358853, 0.23252784186337216, 0.22622238093646596, 0.23624687362352348, 0.23998359098231892, 0.06378566792933749, 0.05221226966307935, 0.06280428615043587, 0.04813829457581742, 0.05411504324540495, 0.05701719867137822, 0.048145883846096305, 0.04906953844561324, 0.0508907154604763, 0.14496450406686323, 0.14197880590712886, 0.14441013433772953, 0.14349481946851772, 0.15457704813072126, 0.1556569313750078, 0.13490694264337144, 0.1382540740463577, 0.2127728153505487, 0.17945123871620294, 0.18812473462850698, 0.17292385752338546, 0.15252353169029287, 0.16354673918022067, 0.19303972448678008, 0.1892542650581337, 0.1922065553547163, 0.198930304983025, 0.12123065287589652, 0.11161947088368651, 0.12602484038906792, 0.12414337241541706, 0.13178355021758192, 0.1169177383562372, 0.13556408760316296, 0.11479571396297195, 0.13416247271629222, 0.1590562376491942, 0.15719137012337991, 0.1399868102046654, 0.1444830338271509, 0.1442682510375789, 0.14453137643801806, 0.15085852044351666, 0.15025186557470005, 0.13857515789386965, 0.10256298872162006, 0.14683629546620414, 0.1180262812620475, 0.10335208014038344, 0.11610472866475252, 0.14438877846657983, 0.12860546894882485, 0.14113123531747696, 0.14842653114516957, 0.1437154591511789, 0.2791654845674695, 0.13817012387805394, 0.15290668953696518, 0.15289210292039757, 0.13846458630003966, 0.15388270252058467, 0.24659101127007432, 0.15559328840157427, 0.18565424055029156, 0.14827767211333553, 0.13183903011271503, 0.16208483496254777, 0.15118048459017497, 0.12452306824880455, 0.1770018228659901, 0.18660108698159128, 0.18936487150551973, 0.17854765208675216, 0.17283053638717616, 0.17715379311131196, 0.19516459515478857, 0.18708390910030703, 0.1687571026064223, 0.1739272212193924, 0.18714081590472031, 0.18801622216820113, 0.04689404593425095, 0.04150496949145821, 0.05102752788784126, 0.049115433247654106, 0.04455659285432889, 0.04984928676002842, 0.05010788040299263, 0.04840986056167762, 0.0472119126817262]}, "mutation_prompt": null}
{"id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive mutation factor and non-linear decrement of inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.14253281203970772, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "661f0c8f-5610-483e-99e4-30c7cad358f5", "metadata": {"aucs": [0.27645983867888535, 0.2734052946573263, 0.2951968790424191, 0.3236876237910845, 0.3111327690999296, 0.3366631818665402, 0.3014517014992669, 0.30265602693045646, 0.3259611517056985, 0.06927515491900338, 0.0728202904602342, 0.09064341578465063, 0.018274557202308972, 0.0836055924845559, 0.08708427942004726, 0.08213467212645087, 0.015657530154919552, 0.09874359461109239, 0.05572992051379644, 0.04602828281078586, 0.04973505274164969, 0.05166184957930986, 0.06543081421334496, 0.06681316310913421, 0.0525751224694081, 0.03411661596921367, 0.058726274400968226, 0.04664186575381768, 0.03579160620486144, 0.04154388285785793, 0.03217977689063012, 0.04330045116124315, 0.04325593532391303, 0.04350622358603562, 0.03982134578240826, 0.0424007791897415, 0.9749515564330257, 0.9748700610041535, 0.979065583224945, 0.9726240411996282, 0.9721106004054992, 0.9894867093717948, 0.989966802301645, 0.9802323865683243, 0.9925534054267503, 0.14747262697223595, 0.13492479206779484, 0.16168910604918163, 0.13091039231222634, 0.13668014625792224, 0.13166283890868802, 0.14757052146798555, 0.12906877550228057, 0.1650829401664372, 0.14068495968182237, 0.10695497065278081, 0.11607641551266512, 0.12095967881714809, 0.11415006280337803, 0.12307819791525476, 0.2493521959675823, 0.16016357820046379, 0.11698968857210434, 0.04403809148504567, 0.038298534084797, 0.02283716185300777, 0.021973546909706654, 0.026994484334624258, 0.04953124848338064, 0.04518760816841183, 0.032924775794698546, 0.05064333296772405, 0.04746825814450972, 0.06478197432722954, 0.05404154227037705, 0.03956678499742994, 0.03929822669032168, 0.04375414726064575, 0.023791652972716126, 0.028469909310170127, 0.033954727311948596, 9.999999999998899e-05, 9.999999999998899e-05, 0.003604100774422525, 0.0005228264033827479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532104915019185, 0.0449542429962454, 0.027390876051247348, 0.026562637211086426, 0.03274111679823777, 0.018628164521597323, 0.017893670905259063, 0.019337188950557693, 0.019904794955726723, 0.005827063469677207, 0.006444838250501572, 0.007935474826890276, 0.009686676026362862, 0.015637457382735365, 0.019875135672004607, 0.01547343632243714, 0.017986992961139703, 0.021191952429984284, 0.011650753551044501, 0.017738494811366246, 0.04338701705535608, 0.04815592009027403, 0.020234989308852924, 0.05251048808348946, 0.02100390619282666, 0.018989148255075472, 0.023074151489173134, 0.22374997692629717, 0.23689390208037253, 0.2562470854119123, 0.2560250208645749, 0.24317046071082327, 0.2704115875701033, 0.22214308311030917, 0.24210924968096748, 0.23718097532977278, 0.05606435621165906, 0.06938040467293427, 0.05653524935761289, 0.055818490815769284, 0.0485428990871416, 0.06970394700061866, 0.047418030383963194, 0.041577064732171265, 0.05266429706062503, 0.1508203885163193, 0.17076022343376496, 0.1642236769532689, 0.1578003172816036, 0.1340384037753911, 0.14364576116799654, 0.14175901271265923, 0.11999294912791503, 0.15047669176347722, 0.19978329856147137, 0.19933273038564225, 0.17449169536395293, 0.16116274095526772, 0.1818992848230795, 0.1782594420603515, 0.2034964277670619, 0.20502683640786756, 0.23354560824672177, 0.11969197288380651, 0.11384498506838481, 0.1063596086139843, 0.11746607381637009, 0.11791758313476419, 0.11546861565577071, 0.13948814793797715, 0.13821104828188313, 0.1253553021553684, 0.15108382154305822, 0.15169564093901133, 0.14110504248413214, 0.1460772322631526, 0.14387538574564185, 0.14135270875533845, 0.15060347776651906, 0.1477266674529989, 0.14752564238279886, 0.0917983686406958, 0.14674382188580637, 0.07884834793729134, 0.08144790878786357, 0.10434150576030221, 0.07292694078366713, 0.09303208715859435, 0.12359828142802143, 0.09116492429759893, 0.15048935597581525, 0.16224470233911248, 0.13881561976323298, 0.14929630172552477, 0.1364999418320929, 0.27020363686798454, 0.13280323250909554, 0.1463246639091873, 0.16353273819295777, 0.11892047644342396, 0.14333609945265324, 0.13557359897505417, 0.14912922730993305, 0.1418093988724508, 0.09246485401646354, 0.18928050030406007, 0.18800706083036334, 0.18328068341281956, 0.17956920630007622, 0.19069066771864995, 0.1890132491208194, 0.17813051081262243, 0.18209319752037045, 0.18055901312382627, 0.17885310198967852, 0.1805472514817158, 0.1817027612309523, 0.04559022055495332, 0.046704168260388035, 0.04283516018658151, 0.04173925863017647, 0.04772424768794026, 0.0425105158630209, 0.04231056768790442, 0.03914441950709657, 0.04508895327503193]}, "mutation_prompt": null}
{"id": "0a06f619-375f-4aed-9d3a-5c3bf51f2a75", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation with enhanced dynamic factor\n                self.mutation_factor = 0.7 + 0.5 * (1 - eval_count/self.budget)  # Enhanced adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover with elite preservation\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.8 * (eval_count/self.budget)**2  # Slightly more aggressive decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.05 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))  # Reduced perturbation\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            best_idx = np.argmin(new_values)\n            if new_values[best_idx] < func(global_best):\n                global_best = new_pop[best_idx]  # Direct assignment for elite preservation\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "A refined HybridPSODE with improved convergence rate through enhanced mutation dynamics and elite preservation strategy.", "configspace": "", "generation": 35, "fitness": 0.12990626854443366, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.24890446896356466, 0.2520421711628469, 0.2607884105115269, 0.2624297396286943, 0.27718052567384954, 0.2896951122558511, 0.29426124469821047, 0.2451765065902266, 0.2806260052555518, 0.05355559527531839, 0.06059071697130802, 0.05740479052884695, 0.008837176735389196, 0.03114575124323893, 0.05936821870163911, 0.0057344359841999815, 0.049479906465561, 0.07350050237262207, 0.04760017481955947, 0.0283127655083818, 0.03750516322260389, 0.044095310240161556, 0.030248276714365252, 0.04674867310365627, 0.024018897635364245, 0.053290933650740446, 0.047426782418399815, 0.027496316805748156, 0.029266150806452784, 0.02961830763655071, 0.03170213946405742, 0.028638944509584485, 0.03923994556885957, 0.03812829423485187, 0.022314431036219884, 0.036324632601487106, 0.9752892265632858, 0.980855420572697, 0.9867954153506391, 0.9765263519055597, 0.9851537746513186, 0.9856839999978388, 0.9703410401217855, 0.983857957742062, 0.9928600752423035, 0.06522827348440352, 0.13085155345502975, 0.13500404638124763, 0.08863911630220978, 0.08131428198127888, 0.06902261487842443, 0.10708094567757376, 0.13141858701755627, 0.14522379212698056, 0.092362183239168, 0.09427349630075166, 0.11286086495963676, 0.11632485110240964, 0.09952170760075263, 0.11814725824977845, 0.10892212731861384, 0.14271739847284703, 0.10800330277572578, 0.03868760998827925, 0.04358715947573366, 0.042958864095085536, 0.04197047554892319, 0.030065255867111396, 0.014085471139262173, 0.021382543511553553, 0.02513011285437383, 0.02618646903505395, 0.04556879335741559, 0.04848382207608537, 0.05009023557094683, 0.025851705528410984, 0.028900200054843617, 9.999999999998899e-05, 0.02324804556160487, 0.025103669586335364, 0.025413626369292452, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027095893054093323, 0.025161095653901566, 0.02952181006592891, 0.004482159781286077, 0.016818071782204735, 0.014790025880531132, 0.006417348710924253, 0.017543126713815194, 0.02732140391182747, 0.004961575661514006, 0.004900017139364721, 0.005738650457767336, 0.03000735757627848, 0.027593275425223274, 0.015492720593355824, 0.012400727762910013, 0.013143469926685247, 0.013534081103306894, 0.015183031580088713, 0.009173939096993156, 0.009089827634613523, 0.02759554766796246, 0.02883209068839665, 0.001362864418345433, 0.015644258137946454, 0.00979688589362504, 0.015113604573541828, 0.19653283856797443, 0.18125364600576976, 0.21341228122347666, 0.21213769024862106, 0.2182520229493473, 0.2342885099513593, 0.20896816901979187, 0.19047609900926088, 0.2316615313799758, 0.05279484302308335, 0.05157507966720554, 0.043305681946125496, 0.045961123918407565, 0.045948749151201396, 0.054540606603703634, 0.03422599746717514, 0.039122102322531105, 0.06250474324371058, 0.1426168658635737, 0.1383559112546091, 0.1410800763247766, 0.17724944083868155, 0.18890161198910005, 0.17902304426952564, 0.16375269883204469, 0.1410339910861167, 0.12599273951238554, 0.17195383689735644, 0.14471970455079586, 0.16768512489266651, 0.14791331095055016, 0.1573897818300316, 0.172157176490902, 0.19159693893839735, 0.16165115304856048, 0.19453477328569002, 0.10568143105246819, 0.10409132588385706, 0.10989847546198417, 0.09839265780080153, 0.11551025905932188, 0.1172617643744186, 0.10771091084725448, 0.11789381501008933, 0.12761252465689155, 0.15165110466000897, 0.14317009790602697, 0.14505001416508134, 0.13286656388578832, 0.13676018862497585, 0.15312606037124277, 0.130138882998466, 0.14094355364307898, 0.14886555212696695, 0.06254489179444023, 0.14207695283091526, 0.0736983933634574, 0.07388451534664886, 0.07810299724301528, 0.09396586173655774, 0.08470435263014864, 0.0867490871840324, 0.07241850093648294, 0.12422607322567258, 0.12578374529330505, 0.13044978998223833, 0.12903108169741284, 0.13806790325321694, 0.14334372522536487, 0.13637240527679917, 0.132652609464612, 0.15100423943530272, 0.12452360344616631, 0.11185088143384114, 0.13334219413530302, 0.13304996639316646, 0.1857833750691532, 0.14959728529471472, 0.17173222552100464, 0.18111078591331642, 0.1720825489334502, 0.182722818850371, 0.17471425500891313, 0.18046146448096045, 0.17713669476384852, 0.175560627110661, 0.18202773918612236, 0.18030399300401245, 0.19064097030352956, 0.17373307459173515, 0.035613496366653674, 0.038118496693836046, 0.04016474348116661, 0.043525343960835516, 0.03726548012196795, 0.04806244351750977, 0.04471710010782193, 0.04052655068562494, 0.03770763923904219]}, "mutation_prompt": null}
{"id": "7db646ab-90aa-4bdc-b7d9-f1fdf5652cee", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2  # Adjusted for consistency\n        self.social_coefficient = 1.2  # Adjusted for consistency\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                self.cognitive_coefficient = 1.2 + 0.6 * (eval_count/self.budget)  # Adaptive cognitive coefficient\n                self.social_coefficient = 1.2 + 0.6 * (1 - eval_count/self.budget)  # Adaptive social coefficient\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.sin(np.linspace(0, np.pi, self.population_size * self.dim)).reshape(self.population_size, self.dim)\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE that includes adaptive learning rates for cognitive and social coefficients, and a chaotic map-based perturbation for improved diversity and convergence.", "configspace": "", "generation": 36, "fitness": 0.1348401101498814, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.26114437968194426, 0.23900369335334237, 0.23686170201843038, 0.2966248955264086, 0.28237044393107813, 0.3096502495334913, 0.27262238172056386, 0.2826950077950038, 0.26567092062443054, 0.05562873288554271, 0.03985603691216422, 0.06217415768005341, 0.06196499425305135, 0.0199670247883319, 0.062093457170944166, 0.07113171430544607, 0.05378501251766943, 0.033069391037662155, 0.049706819460301865, 0.04887552154545283, 0.048505596990895516, 0.04670616622778745, 0.057413075506584255, 0.05856901297400874, 0.0496338309362111, 0.05306374694727123, 0.05061663747149847, 0.04609763642865805, 0.03333568377811991, 0.030387308815883585, 0.04933758228489937, 0.03161134525749676, 0.03336740248094283, 0.03777531335401041, 0.03927062848041096, 0.03534891376285054, 0.9836344268088407, 0.9812148901840974, 0.9925036102879161, 0.9945288011195137, 0.9931146367576497, 0.9374739507306238, 0.9911393430281449, 0.9810726847284279, 0.9476344629233772, 0.13649443264186523, 0.12735479023589436, 0.13146814062551437, 0.08288343729510983, 0.10241214779628649, 0.12877915987325705, 0.12287278469555274, 0.1327552509603276, 0.1276456805272903, 0.14656589012565968, 0.06558929272391201, 0.17955219884252616, 0.11356090219161374, 0.118449682651802, 0.11863829118057634, 0.11063258578080681, 0.11622639332881901, 0.12651548505732735, 0.04133119151126596, 0.044178605380501, 0.04355039951738404, 0.04735238507889228, 0.030612570892939228, 0.029543324328338394, 0.037243923939733525, 0.0403594933078415, 0.037534953831736106, 0.03512884800215743, 0.045709503336342605, 0.05646460320701385, 0.031164725128577264, 0.02741523383426525, 0.049581365946306355, 0.017726865741652387, 0.018707935060469416, 0.02113754082210506, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014793486234643272, 0.0001505348534628359, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0341165969117867, 0.029714314327353386, 0.030693778070560618, 0.014967539635039606, 0.05755069309935168, 0.06873792225657704, 0.026730613368546208, 0.011092498459618017, 0.02357737063356813, 0.006874203269154888, 0.00590962037932552, 0.005211691091946857, 0.013122176060499258, 0.01286595599926621, 0.014663117364697942, 0.017756943185044505, 0.011435737410182223, 0.013268306906559113, 0.012185649420761502, 0.021492841107971228, 0.0028284669721028166, 0.016435877316613, 0.040128464314235335, 0.024057948415442842, 0.02016337546697977, 0.02255803174534121, 0.019636965000621953, 0.2279793389175636, 0.21400790539423276, 0.2398652582700096, 0.23437534907337498, 0.23577925338567707, 0.2520966183340101, 0.2208391748762829, 0.21575490406844555, 0.22580907170571474, 0.051051174717534065, 0.05431976826462381, 0.06099935964269332, 0.040686785466164443, 0.0341405031887303, 0.05095999989286393, 0.04777355680707984, 0.042171177629871326, 0.05123715829436626, 0.13848383532417297, 0.15511516340779274, 0.1690642302729577, 0.14389416554970047, 0.14028094465329688, 0.14086986216537423, 0.14821907624304131, 0.14993132748746207, 0.12922002255725218, 0.17322349919783842, 0.17005880037775278, 0.17027503560555757, 0.15664529006740757, 0.15202593690815902, 0.15550508289951537, 0.1686996597275091, 0.1972447400037265, 0.1887251898924126, 0.11941936367589101, 0.10816441091052531, 0.10602408219276716, 0.10468852185451705, 0.10251618980139776, 0.1219654539986923, 0.13360828369134925, 0.14087416287240906, 0.12236969950227683, 0.1549470768097002, 0.13934601946031944, 0.14811158661732093, 0.13958778117799886, 0.1341211157991412, 0.16241827556868282, 0.14807580316036506, 0.1468184052533026, 0.14480853733723975, 0.07708580390026032, 0.09066124924026064, 0.0850649835421331, 0.09186724606854113, 0.08765688815505146, 0.08141077538816022, 0.08697079236140304, 0.07149417767315158, 0.10464710975833369, 0.1533574551589758, 0.14009803788892672, 0.12472040107333282, 0.15334466097066657, 0.1498058371036317, 0.14258424502200362, 0.1664543849512372, 0.13721571957738, 0.13829349168946847, 0.15697561392362624, 0.16127926627877953, 0.1363369501145817, 0.09227573576588988, 0.11628962259256626, 0.1645871421259344, 0.18359296655780133, 0.1838060529305714, 0.17818095660016076, 0.17638350658398538, 0.18184510411298316, 0.1774056651194985, 0.18385683430674693, 0.17557886807894918, 0.18426975609118712, 0.1870881274760665, 0.18840397398794462, 0.17118637051748153, 0.03974877064299742, 0.04442825581111798, 0.04907118164484359, 0.04085749672734529, 0.043727336216617396, 0.04070467213892082, 0.04306800201607042, 0.038591725193117266, 0.04782918102756284]}, "mutation_prompt": null}
{"id": "d9bcf7a8-845d-45b1-9763-f8b10c7584c0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.elite_proportion = 0.1  # New line: elite preservation proportion\n\n    def levy_flight(self, step_size=0.1):  # New function for Lvy flight\n        return step_size * np.random.normal(size=self.dim) / (np.abs(np.random.normal()) ** (1/3))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_pop = []\n            elite_count = int(self.population_size * self.elite_proportion)  # New line: calculate elite count\n            elite_indices = np.argsort(personal_best_values)[:elite_count]  # New line: get indices of elites\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                if i not in elite_indices:  # New line: apply Lvy flight only to non-elite individuals\n                    candidate += self.levy_flight()  # New line: apply Lvy flight\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Integrate a Lvy flight strategy and introduce elite preservation to enhance exploration and convergence speed.", "configspace": "", "generation": 37, "fitness": 0.13130542883932533, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.23307229488258907, 0.20427322119177493, 0.20348339138139027, 0.23652199899628945, 0.23682105189728464, 0.2394947215870472, 0.2377208739693495, 0.22544392793705803, 0.23020024603092093, 0.004412450627721554, 0.016117582117544438, 0.0013104541231047095, 0.004474941044146918, 0.00770448728063744, 0.010727140820440018, 0.004665568597073788, 0.006195988461519253, 0.009603928011720164, 0.045206264623740555, 0.05330990473895725, 0.04852389805523982, 0.05181020785401891, 0.058148506087021046, 0.04865537566542899, 0.0533221904308957, 0.060438155358354506, 0.06068846431400621, 0.03665443245107414, 0.040221304443165184, 0.033854449300998346, 0.047253735534693586, 0.033239976435993634, 0.032500161496295754, 0.03518192110013896, 0.037363065718895805, 0.043243928674104204, 0.8727998883081098, 0.9616004786598192, 0.9575360743625708, 0.9366707841079256, 0.9581595931282725, 0.9229040154476662, 0.9734742206895959, 0.8601422934953725, 0.9454461753028349, 0.1089578322478214, 0.11478251257434402, 0.11593430652250003, 0.10197996284380295, 0.10287613055408906, 0.09879364827538462, 0.10842327533662777, 0.10292904862318208, 0.12400779680694063, 0.14795240492906958, 0.1295907730707191, 0.10743139383023803, 0.14384097217160363, 0.1367448304711243, 0.13061235425036155, 0.14066641227768972, 0.15933000257985896, 0.15480514089562858, 0.029396635587452313, 0.03452180698120033, 0.04495362676430936, 0.03279785567482629, 0.029667750193324016, 0.041163004927627145, 0.03340474345084299, 0.018082323604599715, 0.04329024145629501, 0.059560938796123786, 0.054809177157903455, 0.04860480843010695, 0.04282881104786551, 0.04323377663002681, 0.04314832079971653, 0.01765017973495231, 0.022122054716919193, 0.02422109754303403, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015613373838101463, 9.999999999998899e-05, 0.003560913040982827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025646700084557827, 0.029463187726793127, 0.05825264066046587, 0.008966586610973715, 0.04324770803651479, 0.05509478775129739, 0.02111505341771247, 0.025036913986448583, 0.034455516038978895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008769249081005737, 0.014586997268591029, 0.03026626693739376, 0.01603740053630065, 0.021044631683763693, 0.020587211195142507, 0.01675823432215462, 0.02590570819639393, 0.015501396926256183, 0.2098976354048785, 0.22209954193337456, 0.22026859187501546, 0.2327710721603422, 0.22834459633396786, 0.23642301515332187, 0.20172480451707153, 0.22370119198052418, 0.21808947647599064, 0.05956035238109758, 0.0574758361950346, 0.06406681986779372, 0.04811483048477527, 0.05781117261545843, 0.044652015419230695, 0.03907791802639071, 0.04860173435543924, 0.0513686447724514, 0.16031065943614853, 0.1456168849160433, 0.15826886038879706, 0.12596351491340863, 0.13809185551313052, 0.15391178327460187, 0.15116528311729327, 0.1417798711651772, 0.15060758481717273, 0.17871017916754794, 0.17419851723358393, 0.18347818586715858, 0.15899655610622887, 0.1578852219422865, 0.18753604503862642, 0.18009328725818252, 0.1974766643902709, 0.19618072755003257, 0.11234487484421551, 0.13126513110575322, 0.12267884760004599, 0.11170395152494239, 0.11723569256557442, 0.10938135979931118, 0.1268712501266438, 0.12857561182531152, 0.12319266576936794, 0.1449906088347117, 0.14396698547868414, 0.14485681554657526, 0.14287763684094879, 0.15120079764383532, 0.14685136835801482, 0.13868351561439263, 0.14449976925837804, 0.14151297755798875, 0.07675724143129936, 0.14509408669422197, 0.09487352890487732, 0.08211551346167034, 0.08448706788662241, 0.10318590427259389, 0.07941080983336857, 0.07328285323859995, 0.12469037260164206, 0.1397443349993457, 0.14072787781618312, 0.1732992141241677, 0.24862051631767879, 0.14781741812938765, 0.1544137819793504, 0.162829734374892, 0.13736511235645466, 0.1627983894627859, 0.13912245943255508, 0.15911640126687232, 0.1728392505365326, 0.11671377927969351, 0.15646306044380687, 0.12302435621518526, 0.1867226062412859, 0.1959936452847233, 0.18993002985199614, 0.17268804795663562, 0.18280854151133996, 0.18585209396109603, 0.18433972490992334, 0.18454838501523396, 0.19084138079178214, 0.19300018462941348, 0.2105315909197477, 0.20037822822479956, 0.04796533138611614, 0.03986903431542632, 0.05134871396390894, 0.044677679736743636, 0.04263113853375655, 0.044583300760766, 0.03887331073716016, 0.051305351201899274, 0.046112324571729535]}, "mutation_prompt": null}
{"id": "e55f458c-f6bd-49ae-a85d-d8067c4cb510", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + 2 * int(np.sqrt(dim))\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n            # Adaptive population size\n            self.population_size = max(5, int(self.initial_population_size - eval_count/self.budget * self.initial_population_size))\n\n            # Elite retention strategy\n            elite_count = max(1, self.population_size // 10)\n            elite_indices = np.argsort(personal_best_values)[:elite_count]\n            pop[:elite_count] = personal_best[elite_indices]\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive population size and elite retention strategy to HybridPSODE for improved convergence and diversity.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (13,) (14,) ').", "error": "ValueError('operands could not be broadcast together with shapes (13,) (14,) ')", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {}, "mutation_prompt": null}
{"id": "cf74f42d-dfea-44f3-a3d6-b0a15c845e3f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.5 * np.random.rand()  # Broadened adaptive range\n        self.social_coefficient = 1.2 + 0.5 * np.random.rand()  # Broadened adaptive range\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.95  # Slightly increased for higher diversity\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.5 + 0.5 * (1 - eval_count/self.budget)  # More dynamic range for mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.7 * (eval_count/self.budget)**2  # Adjusted decrement\n\n            if eval_count % 50 == 0:\n                perturbation = 0.2 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))  # Increased perturbation\n                new_pop += perturbation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An improved HybridPSODE with chaotic sequence initialization and enhanced adaptive parameters for better convergence and diversity maintenance.", "configspace": "", "generation": 39, "fitness": 0.12995124480588371, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.2357306580212275, 0.2011643090603027, 0.2480547592931187, 0.24477258994310125, 0.2695516237325507, 0.28141217757983694, 0.2304024077258644, 0.24728736221539693, 0.2553882030755984, 0.023242507193026007, 0.011582526178133268, 0.04205519739037955, 0.025964361364215205, 0.02899568779074857, 0.0458157515340315, 0.007286337296338541, 0.030686007540169147, 0.03313085310792363, 0.049473170438356306, 0.03407874490428908, 0.04055510795967587, 0.03693024068376294, 0.046485024706242606, 0.05065459767357827, 0.036822839016347086, 0.03529646508579842, 0.047378954836500675, 0.02717097731720186, 0.039107063239144146, 0.035732617992607074, 0.027471498928698712, 0.029397186011568377, 0.03505811667210823, 0.03758464351107216, 0.0312777744689523, 0.0434554828266952, 0.9394350198137446, 0.9643916644654789, 0.9715165341312327, 0.9749286377056069, 0.9287060568797603, 0.9781053903991817, 0.9897740588450784, 0.9362473349959183, 0.9762182085398914, 0.10914473638247324, 0.10157586387336048, 0.12284498808395605, 0.09553001078135515, 0.0837422552875674, 0.10487429141377747, 0.11583273406882855, 0.11825058578839653, 0.11923274728474986, 0.14928076595809348, 0.12388699169369832, 0.12025583486382707, 0.11617892118620621, 0.10963189996837641, 0.15365065479115203, 0.1707011545950562, 0.1475169143019992, 0.11863105742068203, 0.046270663850182636, 0.03245698589961099, 0.03849738931541469, 0.016258125537968793, 0.026882618371161127, 0.029480714886065518, 0.031086265584339134, 0.02705836402586792, 0.03476400595202489, 0.04695455177272145, 0.04203774428141516, 0.04176571127311768, 0.01779012916985412, 0.019105679856920355, 0.03344947768448314, 0.023711337029596713, 0.017822268013888642, 0.03444844879078701, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024916458749007275, 0.03091507561083895, 0.02895694904221413, 0.023721038089267177, 0.0004356114298667002, 0.02330899551200838, 0.035610472326845444, 0.0171840168693429, 0.03838362048750332, 0.0039027243153699764, 0.003078411579898188, 0.005068021879620188, 0.008747770459128335, 0.007410109060040693, 0.01404364410998482, 0.009720848872462606, 0.009999937983978247, 0.011909531540362672, 0.012240327923833894, 0.01626987958569648, 0.010432441925488423, 0.03151768232988783, 0.027317976141312483, 0.03582273859613727, 0.014926179267553574, 0.015794886049812384, 0.01697518319946756, 0.20025605933256907, 0.19752136033258438, 0.22713193554719568, 0.22460250344001287, 0.2301711283409068, 0.24505564288585224, 0.20486638140726787, 0.2058067464544523, 0.2189563246880093, 0.055024486856469546, 0.05690439338820541, 0.050618729117029804, 0.0382672192720116, 0.04821646103910249, 0.05259376284023187, 0.036728159272083616, 0.037425930355488024, 0.05815399723355552, 0.14336092866721506, 0.15113680650127337, 0.1400505845313046, 0.13300648012843708, 0.14596435227763216, 0.14294542191412452, 0.1450597653784651, 0.13834831420132854, 0.1353660475433297, 0.16998944942182803, 0.16820989509697537, 0.16894472527853066, 0.16317321077994618, 0.1547149760658374, 0.1921438312330802, 0.1719042080259876, 0.18038254981023694, 0.21373638120230232, 0.10933480627544345, 0.11196225393181425, 0.11288942733075968, 0.13140720824142516, 0.10733610026911067, 0.11168930028503388, 0.13253900829816534, 0.12169888485805991, 0.1307944685664656, 0.13736092399730637, 0.14087590169587316, 0.15301896683803629, 0.13235984915987264, 0.1466386645926523, 0.14050664295327642, 0.1438332118599699, 0.13841678679579594, 0.14909864710319565, 0.085281026002201, 0.14098174583575274, 0.10334708278605942, 0.08077118513302284, 0.09237467507336117, 0.08505943033953933, 0.07216032239703452, 0.09859156595441254, 0.09077489846355125, 0.13834601671392777, 0.135306325387604, 0.13353870677977464, 0.14034931350055724, 0.15721217984411817, 0.14869577721900218, 0.1342749073844749, 0.13133736825711606, 0.16165022611784463, 0.13557206990900528, 0.13742499791219287, 0.14191622632477208, 0.12910006003520225, 0.11655022935214965, 0.09329148451756497, 0.1869417054279493, 0.17646419790751844, 0.16492758796684448, 0.1770125659294599, 0.1847596032277351, 0.19037073099369362, 0.1765369743044899, 0.18687341135401747, 0.18550376622869535, 0.17262301728807194, 0.18014845980027294, 0.18405170429491846, 0.040975106257620464, 0.04722458448299238, 0.04972501503150395, 0.04037171424474195, 0.04100563784666578, 0.0423105372983138, 0.050867120339835314, 0.03716138302407346, 0.04531587660174574]}, "mutation_prompt": null}
{"id": "e8f93cfe-57ea-493d-b1b9-c055e8b20f45", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive mutation factor and non-linear decrement of inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.27645983867888535, 0.2734052946573263, 0.2951968790424191, 0.3236876237910845, 0.3111327690999296, 0.3366631818665402, 0.3014517014992669, 0.30265602693045646, 0.3259611517056985, 0.06927515491900338, 0.0728202904602342, 0.09064341578465063, 0.018274557202308972, 0.0836055924845559, 0.08708427942004726, 0.08213467212645087, 0.015657530154919552, 0.09874359461109239, 0.05572992051379644, 0.04602828281078586, 0.04973505274164969, 0.05166184957930986, 0.06543081421334496, 0.06681316310913421, 0.0525751224694081, 0.03411661596921367, 0.058726274400968226, 0.04664186575381768, 0.03579160620486144, 0.04154388285785793, 0.03217977689063012, 0.04330045116124315, 0.04325593532391303, 0.04350622358603562, 0.03982134578240826, 0.0424007791897415, 0.9749515564330257, 0.9748700610041535, 0.979065583224945, 0.9726240411996282, 0.9721106004054992, 0.9894867093717948, 0.989966802301645, 0.9802323865683243, 0.9925534054267503, 0.14747262697223595, 0.13492479206779484, 0.16168910604918163, 0.13091039231222634, 0.13668014625792224, 0.13166283890868802, 0.14757052146798555, 0.12906877550228057, 0.1650829401664372, 0.14068495968182237, 0.10695497065278081, 0.11607641551266512, 0.12095967881714809, 0.11415006280337803, 0.12307819791525476, 0.2493521959675823, 0.16016357820046379, 0.11698968857210434, 0.04403809148504567, 0.038298534084797, 0.02283716185300777, 0.021973546909706654, 0.026994484334624258, 0.04953124848338064, 0.04518760816841183, 0.032924775794698546, 0.05064333296772405, 0.04746825814450972, 0.06478197432722954, 0.05404154227037705, 0.03956678499742994, 0.03929822669032168, 0.04375414726064575, 0.023791652972716126, 0.028469909310170127, 0.033954727311948596, 9.999999999998899e-05, 9.999999999998899e-05, 0.003604100774422525, 0.0005228264033827479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532104915019185, 0.0449542429962454, 0.027390876051247348, 0.026562637211086426, 0.03274111679823777, 0.018628164521597323, 0.017893670905259063, 0.019337188950557693, 0.019904794955726723, 0.005827063469677207, 0.006444838250501572, 0.007935474826890276, 0.009686676026362862, 0.015637457382735365, 0.019875135672004607, 0.01547343632243714, 0.017986992961139703, 0.021191952429984284, 0.011650753551044501, 0.017738494811366246, 0.04338701705535608, 0.04815592009027403, 0.020234989308852924, 0.05251048808348946, 0.02100390619282666, 0.018989148255075472, 0.023074151489173134, 0.22374997692629717, 0.23689390208037253, 0.2562470854119123, 0.2560250208645749, 0.24317046071082327, 0.2704115875701033, 0.22214308311030917, 0.24210924968096748, 0.23718097532977278, 0.05606435621165906, 0.06938040467293427, 0.05653524935761289, 0.055818490815769284, 0.0485428990871416, 0.06970394700061866, 0.047418030383963194, 0.041577064732171265, 0.05266429706062503, 0.1508203885163193, 0.17076022343376496, 0.1642236769532689, 0.1578003172816036, 0.1340384037753911, 0.14364576116799654, 0.14175901271265923, 0.11999294912791503, 0.15047669176347722, 0.19978329856147137, 0.19933273038564225, 0.17449169536395293, 0.16116274095526772, 0.1818992848230795, 0.1782594420603515, 0.2034964277670619, 0.20502683640786756, 0.23354560824672177, 0.11969197288380651, 0.11384498506838481, 0.1063596086139843, 0.11746607381637009, 0.11791758313476419, 0.11546861565577071, 0.13948814793797715, 0.13821104828188313, 0.1253553021553684, 0.15108382154305822, 0.15169564093901133, 0.14110504248413214, 0.1460772322631526, 0.14387538574564185, 0.14135270875533845, 0.15060347776651906, 0.1477266674529989, 0.14752564238279886, 0.0917983686406958, 0.14674382188580637, 0.07884834793729134, 0.08144790878786357, 0.10434150576030221, 0.07292694078366713, 0.09303208715859435, 0.12359828142802143, 0.09116492429759893, 0.15048935597581525, 0.16224470233911248, 0.13881561976323298, 0.14929630172552477, 0.1364999418320929, 0.27020363686798454, 0.13280323250909554, 0.1463246639091873, 0.16353273819295777, 0.11892047644342396, 0.14333609945265324, 0.13557359897505417, 0.14912922730993305, 0.1418093988724508, 0.09246485401646354, 0.18928050030406007, 0.18800706083036334, 0.18328068341281956, 0.17956920630007622, 0.19069066771864995, 0.1890132491208194, 0.17813051081262243, 0.18209319752037045, 0.18055901312382627, 0.17885310198967852, 0.1805472514817158, 0.1817027612309523, 0.04559022055495332, 0.046704168260388035, 0.04283516018658151, 0.04173925863017647, 0.04772424768794026, 0.0425105158630209, 0.04231056768790442, 0.03914441950709657, 0.04508895327503193]}, "mutation_prompt": null}
{"id": "a7dc53a8-4bd2-49fc-a7af-8848677922f5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive mutation factor and non-linear decrement of inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.27645983867888535, 0.2734052946573263, 0.2951968790424191, 0.3236876237910845, 0.3111327690999296, 0.3366631818665402, 0.3014517014992669, 0.30265602693045646, 0.3259611517056985, 0.06927515491900338, 0.0728202904602342, 0.09064341578465063, 0.018274557202308972, 0.0836055924845559, 0.08708427942004726, 0.08213467212645087, 0.015657530154919552, 0.09874359461109239, 0.05572992051379644, 0.04602828281078586, 0.04973505274164969, 0.05166184957930986, 0.06543081421334496, 0.06681316310913421, 0.0525751224694081, 0.03411661596921367, 0.058726274400968226, 0.04664186575381768, 0.03579160620486144, 0.04154388285785793, 0.03217977689063012, 0.04330045116124315, 0.04325593532391303, 0.04350622358603562, 0.03982134578240826, 0.0424007791897415, 0.9749515564330257, 0.9748700610041535, 0.979065583224945, 0.9726240411996282, 0.9721106004054992, 0.9894867093717948, 0.989966802301645, 0.9802323865683243, 0.9925534054267503, 0.14747262697223595, 0.13492479206779484, 0.16168910604918163, 0.13091039231222634, 0.13668014625792224, 0.13166283890868802, 0.14757052146798555, 0.12906877550228057, 0.1650829401664372, 0.14068495968182237, 0.10695497065278081, 0.11607641551266512, 0.12095967881714809, 0.11415006280337803, 0.12307819791525476, 0.2493521959675823, 0.16016357820046379, 0.11698968857210434, 0.04403809148504567, 0.038298534084797, 0.02283716185300777, 0.021973546909706654, 0.026994484334624258, 0.04953124848338064, 0.04518760816841183, 0.032924775794698546, 0.05064333296772405, 0.04746825814450972, 0.06478197432722954, 0.05404154227037705, 0.03956678499742994, 0.03929822669032168, 0.04375414726064575, 0.023791652972716126, 0.028469909310170127, 0.033954727311948596, 9.999999999998899e-05, 9.999999999998899e-05, 0.003604100774422525, 0.0005228264033827479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532104915019185, 0.0449542429962454, 0.027390876051247348, 0.026562637211086426, 0.03274111679823777, 0.018628164521597323, 0.017893670905259063, 0.019337188950557693, 0.019904794955726723, 0.005827063469677207, 0.006444838250501572, 0.007935474826890276, 0.009686676026362862, 0.015637457382735365, 0.019875135672004607, 0.01547343632243714, 0.017986992961139703, 0.021191952429984284, 0.011650753551044501, 0.017738494811366246, 0.04338701705535608, 0.04815592009027403, 0.020234989308852924, 0.05251048808348946, 0.02100390619282666, 0.018989148255075472, 0.023074151489173134, 0.22374997692629717, 0.23689390208037253, 0.2562470854119123, 0.2560250208645749, 0.24317046071082327, 0.2704115875701033, 0.22214308311030917, 0.24210924968096748, 0.23718097532977278, 0.05606435621165906, 0.06938040467293427, 0.05653524935761289, 0.055818490815769284, 0.0485428990871416, 0.06970394700061866, 0.047418030383963194, 0.041577064732171265, 0.05266429706062503, 0.1508203885163193, 0.17076022343376496, 0.1642236769532689, 0.1578003172816036, 0.1340384037753911, 0.14364576116799654, 0.14175901271265923, 0.11999294912791503, 0.15047669176347722, 0.19978329856147137, 0.19933273038564225, 0.17449169536395293, 0.16116274095526772, 0.1818992848230795, 0.1782594420603515, 0.2034964277670619, 0.20502683640786756, 0.23354560824672177, 0.11969197288380651, 0.11384498506838481, 0.1063596086139843, 0.11746607381637009, 0.11791758313476419, 0.11546861565577071, 0.13948814793797715, 0.13821104828188313, 0.1253553021553684, 0.15108382154305822, 0.15169564093901133, 0.14110504248413214, 0.1460772322631526, 0.14387538574564185, 0.14135270875533845, 0.15060347776651906, 0.1477266674529989, 0.14752564238279886, 0.0917983686406958, 0.14674382188580637, 0.07884834793729134, 0.08144790878786357, 0.10434150576030221, 0.07292694078366713, 0.09303208715859435, 0.12359828142802143, 0.09116492429759893, 0.15048935597581525, 0.16224470233911248, 0.13881561976323298, 0.14929630172552477, 0.1364999418320929, 0.27020363686798454, 0.13280323250909554, 0.1463246639091873, 0.16353273819295777, 0.11892047644342396, 0.14333609945265324, 0.13557359897505417, 0.14912922730993305, 0.1418093988724508, 0.09246485401646354, 0.18928050030406007, 0.18800706083036334, 0.18328068341281956, 0.17956920630007622, 0.19069066771864995, 0.1890132491208194, 0.17813051081262243, 0.18209319752037045, 0.18055901312382627, 0.17885310198967852, 0.1805472514817158, 0.1817027612309523, 0.04559022055495332, 0.046704168260388035, 0.04283516018658151, 0.04173925863017647, 0.04772424768794026, 0.0425105158630209, 0.04231056768790442, 0.03914441950709657, 0.04508895327503193]}, "mutation_prompt": null}
{"id": "84013f23-3b8c-4870-8332-81053121af1a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive mutation factor and non-linear decrement of inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.27645983867888535, 0.2734052946573263, 0.2951968790424191, 0.3236876237910845, 0.3111327690999296, 0.3366631818665402, 0.3014517014992669, 0.30265602693045646, 0.3259611517056985, 0.06927515491900338, 0.0728202904602342, 0.09064341578465063, 0.018274557202308972, 0.0836055924845559, 0.08708427942004726, 0.08213467212645087, 0.015657530154919552, 0.09874359461109239, 0.05572992051379644, 0.04602828281078586, 0.04973505274164969, 0.05166184957930986, 0.06543081421334496, 0.06681316310913421, 0.0525751224694081, 0.03411661596921367, 0.058726274400968226, 0.04664186575381768, 0.03579160620486144, 0.04154388285785793, 0.03217977689063012, 0.04330045116124315, 0.04325593532391303, 0.04350622358603562, 0.03982134578240826, 0.0424007791897415, 0.9749515564330257, 0.9748700610041535, 0.979065583224945, 0.9726240411996282, 0.9721106004054992, 0.9894867093717948, 0.989966802301645, 0.9802323865683243, 0.9925534054267503, 0.14747262697223595, 0.13492479206779484, 0.16168910604918163, 0.13091039231222634, 0.13668014625792224, 0.13166283890868802, 0.14757052146798555, 0.12906877550228057, 0.1650829401664372, 0.14068495968182237, 0.10695497065278081, 0.11607641551266512, 0.12095967881714809, 0.11415006280337803, 0.12307819791525476, 0.2493521959675823, 0.16016357820046379, 0.11698968857210434, 0.04403809148504567, 0.038298534084797, 0.02283716185300777, 0.021973546909706654, 0.026994484334624258, 0.04953124848338064, 0.04518760816841183, 0.032924775794698546, 0.05064333296772405, 0.04746825814450972, 0.06478197432722954, 0.05404154227037705, 0.03956678499742994, 0.03929822669032168, 0.04375414726064575, 0.023791652972716126, 0.028469909310170127, 0.033954727311948596, 9.999999999998899e-05, 9.999999999998899e-05, 0.003604100774422525, 0.0005228264033827479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532104915019185, 0.0449542429962454, 0.027390876051247348, 0.026562637211086426, 0.03274111679823777, 0.018628164521597323, 0.017893670905259063, 0.019337188950557693, 0.019904794955726723, 0.005827063469677207, 0.006444838250501572, 0.007935474826890276, 0.009686676026362862, 0.015637457382735365, 0.019875135672004607, 0.01547343632243714, 0.017986992961139703, 0.021191952429984284, 0.011650753551044501, 0.017738494811366246, 0.04338701705535608, 0.04815592009027403, 0.020234989308852924, 0.05251048808348946, 0.02100390619282666, 0.018989148255075472, 0.023074151489173134, 0.22374997692629717, 0.23689390208037253, 0.2562470854119123, 0.2560250208645749, 0.24317046071082327, 0.2704115875701033, 0.22214308311030917, 0.24210924968096748, 0.23718097532977278, 0.05606435621165906, 0.06938040467293427, 0.05653524935761289, 0.055818490815769284, 0.0485428990871416, 0.06970394700061866, 0.047418030383963194, 0.041577064732171265, 0.05266429706062503, 0.1508203885163193, 0.17076022343376496, 0.1642236769532689, 0.1578003172816036, 0.1340384037753911, 0.14364576116799654, 0.14175901271265923, 0.11999294912791503, 0.15047669176347722, 0.19978329856147137, 0.19933273038564225, 0.17449169536395293, 0.16116274095526772, 0.1818992848230795, 0.1782594420603515, 0.2034964277670619, 0.20502683640786756, 0.23354560824672177, 0.11969197288380651, 0.11384498506838481, 0.1063596086139843, 0.11746607381637009, 0.11791758313476419, 0.11546861565577071, 0.13948814793797715, 0.13821104828188313, 0.1253553021553684, 0.15108382154305822, 0.15169564093901133, 0.14110504248413214, 0.1460772322631526, 0.14387538574564185, 0.14135270875533845, 0.15060347776651906, 0.1477266674529989, 0.14752564238279886, 0.0917983686406958, 0.14674382188580637, 0.07884834793729134, 0.08144790878786357, 0.10434150576030221, 0.07292694078366713, 0.09303208715859435, 0.12359828142802143, 0.09116492429759893, 0.15048935597581525, 0.16224470233911248, 0.13881561976323298, 0.14929630172552477, 0.1364999418320929, 0.27020363686798454, 0.13280323250909554, 0.1463246639091873, 0.16353273819295777, 0.11892047644342396, 0.14333609945265324, 0.13557359897505417, 0.14912922730993305, 0.1418093988724508, 0.09246485401646354, 0.18928050030406007, 0.18800706083036334, 0.18328068341281956, 0.17956920630007622, 0.19069066771864995, 0.1890132491208194, 0.17813051081262243, 0.18209319752037045, 0.18055901312382627, 0.17885310198967852, 0.1805472514817158, 0.1817027612309523, 0.04559022055495332, 0.046704168260388035, 0.04283516018658151, 0.04173925863017647, 0.04772424768794026, 0.0425105158630209, 0.04231056768790442, 0.03914441950709657, 0.04508895327503193]}, "mutation_prompt": null}
{"id": "4f40998d-0729-485b-9758-c0fbd746c3d7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Chaotic initialization and random perturbation to enhance diversity\n            if eval_count % 50 == 0:\n                perturbation = 0.1 * np.random.uniform(-1, 1, size=(self.population_size, self.dim))\n                new_pop += perturbation\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive mutation factor and non-linear decrement of inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.27645983867888535, 0.2734052946573263, 0.2951968790424191, 0.3236876237910845, 0.3111327690999296, 0.3366631818665402, 0.3014517014992669, 0.30265602693045646, 0.3259611517056985, 0.06927515491900338, 0.0728202904602342, 0.09064341578465063, 0.018274557202308972, 0.0836055924845559, 0.08708427942004726, 0.08213467212645087, 0.015657530154919552, 0.09874359461109239, 0.05572992051379644, 0.04602828281078586, 0.04973505274164969, 0.05166184957930986, 0.06543081421334496, 0.06681316310913421, 0.0525751224694081, 0.03411661596921367, 0.058726274400968226, 0.04664186575381768, 0.03579160620486144, 0.04154388285785793, 0.03217977689063012, 0.04330045116124315, 0.04325593532391303, 0.04350622358603562, 0.03982134578240826, 0.0424007791897415, 0.9749515564330257, 0.9748700610041535, 0.979065583224945, 0.9726240411996282, 0.9721106004054992, 0.9894867093717948, 0.989966802301645, 0.9802323865683243, 0.9925534054267503, 0.14747262697223595, 0.13492479206779484, 0.16168910604918163, 0.13091039231222634, 0.13668014625792224, 0.13166283890868802, 0.14757052146798555, 0.12906877550228057, 0.1650829401664372, 0.14068495968182237, 0.10695497065278081, 0.11607641551266512, 0.12095967881714809, 0.11415006280337803, 0.12307819791525476, 0.2493521959675823, 0.16016357820046379, 0.11698968857210434, 0.04403809148504567, 0.038298534084797, 0.02283716185300777, 0.021973546909706654, 0.026994484334624258, 0.04953124848338064, 0.04518760816841183, 0.032924775794698546, 0.05064333296772405, 0.04746825814450972, 0.06478197432722954, 0.05404154227037705, 0.03956678499742994, 0.03929822669032168, 0.04375414726064575, 0.023791652972716126, 0.028469909310170127, 0.033954727311948596, 9.999999999998899e-05, 9.999999999998899e-05, 0.003604100774422525, 0.0005228264033827479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532104915019185, 0.0449542429962454, 0.027390876051247348, 0.026562637211086426, 0.03274111679823777, 0.018628164521597323, 0.017893670905259063, 0.019337188950557693, 0.019904794955726723, 0.005827063469677207, 0.006444838250501572, 0.007935474826890276, 0.009686676026362862, 0.015637457382735365, 0.019875135672004607, 0.01547343632243714, 0.017986992961139703, 0.021191952429984284, 0.011650753551044501, 0.017738494811366246, 0.04338701705535608, 0.04815592009027403, 0.020234989308852924, 0.05251048808348946, 0.02100390619282666, 0.018989148255075472, 0.023074151489173134, 0.22374997692629717, 0.23689390208037253, 0.2562470854119123, 0.2560250208645749, 0.24317046071082327, 0.2704115875701033, 0.22214308311030917, 0.24210924968096748, 0.23718097532977278, 0.05606435621165906, 0.06938040467293427, 0.05653524935761289, 0.055818490815769284, 0.0485428990871416, 0.06970394700061866, 0.047418030383963194, 0.041577064732171265, 0.05266429706062503, 0.1508203885163193, 0.17076022343376496, 0.1642236769532689, 0.1578003172816036, 0.1340384037753911, 0.14364576116799654, 0.14175901271265923, 0.11999294912791503, 0.15047669176347722, 0.19978329856147137, 0.19933273038564225, 0.17449169536395293, 0.16116274095526772, 0.1818992848230795, 0.1782594420603515, 0.2034964277670619, 0.20502683640786756, 0.23354560824672177, 0.11969197288380651, 0.11384498506838481, 0.1063596086139843, 0.11746607381637009, 0.11791758313476419, 0.11546861565577071, 0.13948814793797715, 0.13821104828188313, 0.1253553021553684, 0.15108382154305822, 0.15169564093901133, 0.14110504248413214, 0.1460772322631526, 0.14387538574564185, 0.14135270875533845, 0.15060347776651906, 0.1477266674529989, 0.14752564238279886, 0.0917983686406958, 0.14674382188580637, 0.07884834793729134, 0.08144790878786357, 0.10434150576030221, 0.07292694078366713, 0.09303208715859435, 0.12359828142802143, 0.09116492429759893, 0.15048935597581525, 0.16224470233911248, 0.13881561976323298, 0.14929630172552477, 0.1364999418320929, 0.27020363686798454, 0.13280323250909554, 0.1463246639091873, 0.16353273819295777, 0.11892047644342396, 0.14333609945265324, 0.13557359897505417, 0.14912922730993305, 0.1418093988724508, 0.09246485401646354, 0.18928050030406007, 0.18800706083036334, 0.18328068341281956, 0.17956920630007622, 0.19069066771864995, 0.1890132491208194, 0.17813051081262243, 0.18209319752037045, 0.18055901312382627, 0.17885310198967852, 0.1805472514817158, 0.1817027612309523, 0.04559022055495332, 0.046704168260388035, 0.04283516018658151, 0.04173925863017647, 0.04772424768794026, 0.0425105158630209, 0.04231056768790442, 0.03914441950709657, 0.04508895327503193]}, "mutation_prompt": null}
{"id": "022c01de-3b7a-4d3c-9581-335cc6a6b9cf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant1 = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n                d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n                mutant2 = np.clip(d + self.mutation_factor * (e - f), lower_bound, upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant1, candidate)\n                candidate = np.where(~crossover_mask, mutant2, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                chaotic_map = np.tan(np.random.rand(self.population_size, self.dim) * np.pi) % 5\n                perturbation = 0.1 * chaotic_map\n                new_pop += perturbation\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "An enhanced HybridPSODE with adaptive learning rates, chaotic maps for initialization and reinitialization, and combined mutation strategies for balanced exploration and exploitation.", "configspace": "", "generation": 44, "fitness": 0.10141094334065463, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.17.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.15695205897448217, 0.1374075116374166, 0.12652304474168374, 0.14820158852249665, 0.14609370957058088, 0.1467102267578222, 0.15054208674655623, 0.13370778772762792, 0.16504183928625205, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017734827818877474, 0.017303687512226884, 0.019596484620712395, 0.021292015528031172, 0.026246992584358808, 0.019917117202505108, 0.03802397393808865, 0.020831359955966966, 0.0218738797829503, 0.00948008629201691, 0.0032199807948947168, 0.009568544281446156, 0.0052987670767986605, 0.009281785303421386, 0.011109503274613797, 0.008324240231137092, 0.023849465479454324, 0.006726376471120954, 0.8935167933670372, 0.8320468104715022, 0.9867601864825982, 0.5634656234157844, 0.981388330958787, 0.9078891313553693, 0.8655621016826078, 0.8751164408087415, 0.9707930569836287, 0.04837854998339275, 0.043711656764664264, 0.029956802424193296, 0.025206145469161445, 0.06481175570249542, 0.046693905449239126, 0.06327202392581621, 0.0800163382996254, 0.03404926195530367, 0.08821953958351314, 0.06572774555948158, 0.07023155804891845, 0.08428562954468366, 0.0956991216023576, 0.07823955369764257, 0.09037903987484952, 0.11811872256399147, 0.08328742522995358, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007012778091971539, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014702987398768075, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004407910522442604, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005241481364995915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01440622937238445, 0.036948744208302964, 0.02292062316800425, 0.01658566260683858, 0.039342683896951725, 0.015566634207260899, 0.027843879512573055, 0.03380077309129759, 0.01632571902409563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16339946988175835, 0.16615565708478608, 0.15608670323774043, 0.15810085904561033, 0.16801533384197864, 0.1500642256580884, 0.14384703034760626, 0.16019334101939187, 0.1514992095564759, 0.04642681945273741, 0.031292452308484986, 0.04230370228682967, 0.024287655351654558, 0.03088900986830123, 0.018540428687173205, 0.022186041778500476, 0.018462858778446334, 0.03142944048785323, 0.13210502280789826, 0.13693301378176748, 0.12991965441266784, 0.13648826535105618, 0.13046281446359353, 0.13823801312871764, 0.12853992737408848, 0.16599928933178887, 0.12639040801095325, 0.14091510171214794, 0.14582749206130485, 0.14417962613864932, 0.15426999112977358, 0.1481374984034326, 0.14749100555467454, 0.15288438549524253, 0.13961141669968202, 0.1399519307733511, 0.08166566739250358, 0.0798858829662471, 0.10641241166057458, 0.0936891847912521, 0.07955217952876703, 0.10612711135824249, 0.09682813454035655, 0.09020355056051899, 0.0925259236840057, 0.12935992650011852, 0.12303873313262792, 0.13476281295483983, 0.13495684476179537, 0.12765210633805002, 0.12026723965982689, 0.11812931706646779, 0.1298139494181927, 0.1298077710633968, 0.007582697487630297, 0.12052387682087884, 0.05617745585311262, 0.055969675167561794, 0.0934328085317806, 0.08965535660082447, 0.028400293794800247, 0.03892214139408312, 0.08042853708627995, 0.12909764539456792, 0.1237606991673128, 0.11440708168173841, 0.15072001417851622, 0.11914781460105661, 0.12165643404447857, 0.10858298339749328, 0.15981745118854673, 0.11948016357991253, 0.11531831053021047, 0.1189164899317573, 0.09542783183029935, 0.11183126740405025, 0.099766545090195, 0.11441987773105322, 0.1438900172454649, 0.14790812709174972, 0.12826852557800228, 0.20705456027819746, 0.1940007289485367, 0.1944679433484593, 0.18061252988779475, 0.19986061684230005, 0.1818350370888635, 0.18854026381641498, 0.18722237134406527, 0.18640778593451923, 0.029797662525297364, 0.03220067139538407, 0.03159621339156582, 0.033693050716601114, 0.029672208146938828, 0.027152860114721622, 0.029008059772073436, 0.0332043087134416, 0.02916326608646902]}, "mutation_prompt": null}
{"id": "45711685-bc82-44ce-b585-12bd22cec221", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 45, "fitness": 0.15356687690882773, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "c9528234-f406-42cc-80ad-129dc6be6a4f", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "818f0547-9199-48fc-ac49-3fef1c439dc0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "66cbb286-b986-48b3-a7fc-645843b8b0b8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "757668b8-f7d1-4c7d-8692-ea756dab5f0b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Initial inertia weight for exploration\n        self.cognitive_coefficient = 1.5  # Increased for stronger local search\n        self.social_coefficient = 1.5  # Increased for stronger global search\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Levy flight-based mutation\n                levy = np.random.standard_cauchy(size=self.dim)\n                mutant += 0.01 * levy * (mutant - personal_best[i])\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.5 * (eval_count/self.budget)**2  # Adaptive inertia weight\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Improved exploration and convergence by introducing adaptive inertia weight and Levy flight-based mutation.", "configspace": "", "generation": 48, "fitness": 0.13279955683373, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.22013538542893285, 0.23747411361607895, 0.2142654204312362, 0.2353790379978805, 0.2435240410034908, 0.24359120396258782, 0.2232324710652004, 0.22930709756219625, 0.22364174459484198, 0.02258226793839202, 0.017093384288046742, 0.002180017523543243, 0.020889525278959042, 0.0031694071423744585, 0.008282107525977356, 0.009104474401721241, 0.01860896900542397, 0.009011888610326424, 0.0550340943444273, 0.04284365967974901, 0.045699600501919124, 0.04654296955536552, 0.04915551222448189, 0.05109779759690847, 0.04798620624164518, 0.048960577746190226, 0.047812119295909894, 0.03722452069813975, 0.035985730293115026, 0.0315008776323058, 0.04235880284924565, 0.030204184330211326, 0.04155451996291448, 0.03523982994596386, 0.03904921654703375, 0.03704940574280824, 0.8790415218395359, 0.9403440444060004, 0.9188827250961283, 0.8996174711947473, 0.925721956301068, 0.973312898848526, 0.9234511534875339, 0.9327057080028042, 0.9579805234767257, 0.10656979516273368, 0.08884609307816227, 0.11283905940285599, 0.09399320474962225, 0.1553186521118629, 0.10975272464267904, 0.08867718509102196, 0.09870815910549335, 0.08976570625515146, 0.1428474815613161, 0.12681876829065153, 0.1269051016128191, 0.14301851030028356, 0.132263771131942, 0.1321553390849114, 0.14892742569717488, 0.14433290218218475, 0.12824748269215236, 0.028118497240489537, 0.02591030410482076, 0.04118167679014895, 0.03811807324626282, 0.02674545006585305, 0.03409383881584327, 0.03718891579636696, 0.018026709737021918, 0.02806376142077771, 0.021703231835806358, 0.04225481608194548, 0.030016060531703803, 0.03578230928929804, 0.02385392556507282, 0.03178170040943773, 0.040664647641829976, 0.025023569975121118, 0.02553617839312572, 0.000752662605462362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06491486046579376, 0.046107466858789525, 0.06988442968920316, 0.05387908127946661, 0.05097797413350269, 0.009694044750300002, 0.043529602394999034, 0.03570604627001139, 0.028919940145272105, 0.0003914088969020346, 0.00022453816501233348, 0.0016106104181915493, 0.00030972711376031636, 0.004162168952691947, 0.002714049209178171, 0.0010417691243445049, 0.0032848196783521466, 9.999999999998899e-05, 0.006050433508794084, 0.007720582050137259, 0.01605499055772619, 0.004666885735690629, 0.015866241038228868, 0.008144069241289076, 0.015226705806812624, 0.013877203072840572, 0.016883621120320602, 0.22474458652902773, 0.2097204224122804, 0.21668177712253645, 0.22768053202569494, 0.22786591056114258, 0.23069644379485843, 0.21694525014371924, 0.2078232357894495, 0.21279558677962473, 0.0598931005703256, 0.053601382103370065, 0.05844554232867216, 0.05495869951474486, 0.047435423386474995, 0.060458060543710834, 0.04467672416573076, 0.05199365113906573, 0.05439453519765525, 0.15887356861661883, 0.13512178505094707, 0.14231157291820784, 0.13549055010342548, 0.14092361267796483, 0.1227319234844153, 0.12983888396671972, 0.13816887680780565, 0.15775374631718497, 0.1609089284816373, 0.17672832846298137, 0.17242858568967878, 0.1684528827935965, 0.18497611835292915, 0.1977852293841813, 0.19480282106452584, 0.18378848627448663, 0.17559668415070828, 0.1242278160933512, 0.12188742491792959, 0.12006205865247799, 0.11552660256274627, 0.12549265637072438, 0.11716211501241303, 0.12363849595433551, 0.12348989488609441, 0.12259704339335253, 0.1598736395940059, 0.15956359329887548, 0.15567344972396968, 0.14521901844529816, 0.1537397497749351, 0.18230898132217266, 0.15509530682847295, 0.1491960383881833, 0.16571260010883326, 0.10838941792635648, 0.10503212557640673, 0.1137636376546699, 0.14491495230091678, 0.12326985355712983, 0.14092678020658567, 0.12131135816420524, 0.09885776851095585, 0.13755498835675917, 0.14634507433508004, 0.18763518020314485, 0.15008375528103557, 0.14965071508490368, 0.14420255832616835, 0.21114173323081065, 0.2247683254665177, 0.19618202391151418, 0.20375419569170694, 0.15088727369177346, 0.13586431375740937, 0.15874297062776, 0.15561102966882223, 0.1384368280623165, 0.1995060854324452, 0.1685005645071196, 0.18691539813215718, 0.18035547505500693, 0.17940000402908596, 0.18495392985220438, 0.18126978431796603, 0.18383006687305126, 0.18766722850728212, 0.1878235384582353, 0.1830144828412703, 0.17005256041910122, 0.18673632424547837, 0.04765576941887961, 0.05113136997957446, 0.057854003368372986, 0.0457298525178339, 0.047430286553209355, 0.053745907250076885, 0.053028304638304546, 0.04619398408827058, 0.0512454153778954]}, "mutation_prompt": null}
{"id": "d87b2013-3b3f-4a96-a46c-bbd661704bac", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n        self.performance_memory = []\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n            self.performance_memory.append(np.min(new_values))\n            if len(self.performance_memory) > 5:\n                recent_improvement = np.min(self.performance_memory[-5:])\n                if recent_improvement < np.min(self.performance_memory[:-5]):\n                    self.cognitive_coefficient *= 1.1\n                    self.social_coefficient *= 0.9\n                else:\n                    self.cognitive_coefficient *= 0.9\n                    self.social_coefficient *= 1.1\n\n        return global_best", "name": "HybridPSODE", "description": "Enhance global exploration by incorporating a memory mechanism for dynamically adjusting social and cognitive coefficients based on historical performance.", "configspace": "", "generation": 49, "fitness": 0.11465502054338285, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.13279106130250362, 0.1429977445576971, 0.1688202633399276, 0.16062163954492603, 0.15107269706867887, 0.15653111765684335, 0.15887888801063077, 0.15980946661682682, 0.16358960200328132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033096773014501424, 0.03299026557148532, 0.03296843927038973, 0.030646067705239144, 0.02882843526629908, 0.035850071670255224, 0.035961992834465106, 0.0276257063578752, 0.034510347277654674, 0.021986460196218416, 0.024654404876141567, 0.0215691358921547, 0.030665720173380207, 0.015838430879786425, 0.004076757666977793, 0.015436975229703442, 0.03179573320987661, 0.019656452355590215, 0.9712062254651973, 0.9680448710814171, 0.9739857833925467, 0.9721439905468138, 0.9676748458248964, 0.9743900807513162, 0.9733022684459995, 0.9476974649313454, 0.9925168796630046, 0.04523140517723201, 0.045932494753802344, 0.054901844982489845, 0.07508595699624332, 0.0743559314741733, 0.05334989262223988, 0.0708145753852053, 0.06400025576108404, 0.05324799242912848, 0.11825925567866302, 0.1289970599346838, 0.11550428073379748, 0.10260007477324329, 0.09874057123546098, 0.12329815809389566, 0.1227699560037745, 0.10676312193879334, 0.1171757973944193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012616175366540694, 0.014299729068686262, 9.999999999998899e-05, 0.025376890915971617, 9.999999999998899e-05, 0.0302471062512637, 0.023728864588054566, 0.016951297081375882, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013206587026368122, 0.02195972539524682, 0.03816422806779485, 0.026590197974281415, 0.05455189011634043, 0.05108634227853859, 0.003588546244491231, 0.009958181676365863, 0.015130581669932641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16359656345972584, 0.17339639301495424, 0.14209578847585747, 0.17714879281467732, 0.1839005923487146, 0.17903826970167247, 0.14910753617398698, 0.15939955225885238, 0.17166452927876452, 0.03167032256445512, 0.03799691052567811, 0.03429708997444536, 0.03381630875585995, 0.02515866813886647, 0.029856753894681787, 0.030309519204295476, 0.03482512652766179, 0.04216294410512322, 0.13813573720064765, 0.13665350731455161, 0.13507544241683533, 0.1412179457859305, 0.1327173334025279, 0.12993166353513985, 0.13268235485786284, 0.15011656784249972, 0.14484486460683332, 0.1521331269341536, 0.1510056813352052, 0.15711590838509948, 0.1703565367719584, 0.14525368715096698, 0.15892583499569934, 0.14953841315870375, 0.149072670090738, 0.15211557046469204, 0.11246763875307442, 0.10681795360778379, 0.10497893649863677, 0.10514779608155878, 0.06977589043828958, 0.10193035273099871, 0.08918560881062054, 0.08908593686664512, 0.09937682690439764, 0.13857998333234678, 0.1441731099317758, 0.13654069288134174, 0.16191730325942733, 0.14197459202015195, 0.13037175405041668, 0.15058253751397643, 0.2099218094223282, 0.1343155679330199, 0.0882655380343309, 0.14654829326031626, 0.09659130013341932, 0.1277909215912607, 0.08734385339126438, 0.11297771675120127, 0.10645106382866942, 0.08379227501773234, 0.0838927950278201, 0.1509323944404437, 0.12269150951181218, 0.13823285793164142, 0.1347721891538688, 0.11209365250926662, 0.11967631638786091, 0.1437764724462146, 0.10784962848311608, 0.12948464218757438, 0.1477253506316012, 0.13517903899589712, 0.1279157398670051, 0.13415918577744546, 0.16976962520715988, 0.17926938554093774, 0.17835762224319007, 0.16772260984585086, 0.17022382488821552, 0.19842428635167875, 0.18542234650055212, 0.17647447246144543, 0.19462070297885348, 0.18002558889175257, 0.1732200544892155, 0.18817582598511828, 0.18817314647233918, 0.17915706814999555, 0.04365322029576091, 0.0382323844518907, 0.04372246963912607, 0.03057544894121511, 0.037163145646905815, 0.04618701549243465, 0.04020419668739739, 0.057401961035350224, 0.06016847256801139]}, "mutation_prompt": null}
{"id": "1804dc51-eec7-4651-b554-c992e722d0eb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "4aa8c14e-37cd-461f-aeaa-88968060d115", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.8 + 0.2 * np.random.rand()  # Made adaptive\n        self.cognitive_coefficient = 1.5  # Increased for stronger local exploration\n        self.social_coefficient = 1.5  # Increased for better global exploitation\n        self.mutation_factor = 0.6 + 0.4 * np.random.rand()  # Randomized\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.4 * (5.0 - (-5.0))  # Tightened clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.3 * (1 - eval_count/self.budget)  # Adjusted\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n                \n                if eval_count % 4 == 0:  # Local search strategy\n                    perturbation = np.random.uniform(-0.1, 0.1, size=self.dim)\n                    candidate = np.clip(candidate + perturbation, lower_bound, upper_bound)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.8 - 0.5 * (eval_count/self.budget)**2  # Updated decrement\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced adaptive coefficients and local search integrate a tighter feedback loop for improved convergence.", "configspace": "", "generation": 51, "fitness": 0.11166648676543861, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.15913485360656032, 0.13903826266006347, 0.1758975768196397, 0.1787559231740935, 0.15780865092570073, 0.17119458792986664, 0.1640299522756904, 0.17929017650396073, 0.1523512494054614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029772820945460854, 0.05762329219198803, 0.03021356255262453, 0.0348267613771015, 0.03238215063176808, 0.0436970590211444, 0.057537886564084095, 0.03134296771092504, 0.03657232048829828, 0.020457779258188036, 0.019269095262589908, 0.034248448514566876, 0.014156703451767116, 0.024091886079364522, 0.01678695417483922, 0.030649016797539064, 0.024983417005903896, 0.017809614624174186, 0.7412765131983395, 0.9177451573011828, 0.9148362591080429, 0.4454339382915802, 0.8031365995408164, 0.9896273237449973, 0.973459455974389, 0.8637430640274215, 0.8238464647490703, 0.054565669121836025, 0.06256168609112012, 0.075716984622209, 0.05984175063087682, 0.09449271273597293, 0.04933717083579925, 0.09298296818846319, 0.06341539687500553, 0.06428059628487459, 0.10949866525903651, 0.11884630656507034, 0.10813727190703082, 0.11438526387034942, 0.12434477834479163, 0.09071217680620702, 0.11066820637451635, 0.13649659143317416, 0.12432663752608752, 9.999999999998899e-05, 0.004783298844011408, 0.0010777152611681773, 9.999999999998899e-05, 0.01192467475589909, 9.999999999998899e-05, 0.006572393320702363, 9.999999999998899e-05, 9.999999999998899e-05, 0.003851222805477672, 9.999999999998899e-05, 0.005121883047835785, 0.04457411165661984, 0.005392579735612135, 9.999999999998899e-05, 9.999999999998899e-05, 0.006042408081893491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023006296779383595, 0.042214884982151535, 0.035045152286924175, 0.048035429668301766, 0.01029488107550569, 0.031607666396813894, 0.026166544222194, 0.01662720160846798, 0.03236144679544972, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013671240377758354, 9.999999999998899e-05, 9.999999999998899e-05, 0.17717515781240267, 0.19797351524796136, 0.17716276715969526, 0.1804530532521883, 0.17805914124909994, 0.16597588581832556, 0.17191664998344935, 0.17336691673786186, 0.16692490604262622, 0.05410305579248431, 0.036591749822721065, 0.037181181446360845, 0.050592012905439354, 0.043218011223511765, 0.04081082375177392, 0.027502696539074223, 0.03639135980447428, 0.04956720984910212, 0.14134854171687516, 0.15550269058635435, 0.1340029769193012, 0.15658455035072805, 0.17473431651764637, 0.1498539911668244, 0.1216630950848967, 0.13774920515684097, 0.1326490224908048, 0.1508921303460775, 0.15024832997905946, 0.15785317022768686, 0.15119205234765465, 0.15305947008701826, 0.16854837877405549, 0.1482777616619535, 0.14944855044332084, 0.14892458442748213, 0.08905540051859295, 0.10468772016811123, 0.09652902864796775, 0.11086418966269651, 0.0941558796285542, 0.10679263732012167, 0.1035224969579771, 0.10426972181322147, 0.09649271057917774, 0.1420276264122221, 0.13174049097392015, 0.13608711463652157, 0.1448675860332087, 0.14247369516426622, 0.1449900826684387, 0.144614899714682, 0.15384982122610114, 0.17138511868555473, 0.11887154598036831, 0.14854548448471905, 0.1290364394903445, 0.12283465169286667, 0.12505398305378035, 0.12545251643276134, 0.07776534220047893, 0.14249563262589215, 0.10245449197052803, 0.14491092253977222, 0.13549544978184314, 0.15047389377062081, 0.12433652363390102, 0.1415981683926213, 0.12127893664721612, 0.13446403472989243, 0.12287770550835775, 0.13654824499308793, 0.1372735058821709, 0.19316414858025643, 0.133548863547445, 0.10450446363742083, 0.1908490949479652, 0.1466547958863681, 0.1564168048410718, 0.1549232489874801, 0.1494487189619027, 0.1840562260863201, 0.18633408009421004, 0.1889516493910126, 0.17436467177915527, 0.19849135493203762, 0.19663532126829586, 0.18041972260216155, 0.17831946638933727, 0.18590275693459712, 0.04875416435949431, 0.04440222145981976, 0.04904710156013703, 0.03913997885750631, 0.03838271535666937, 0.04088457802178158, 0.04001238840411059, 0.036803745305469926, 0.0497707570732131]}, "mutation_prompt": null}
{"id": "8c8d8dfb-8d34-4121-824c-8bf652dbb9fe", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "d0c2211c-70ed-4dc9-be45-fb1b19ae60bd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "88cc6fa9-06dd-426f-8408-0a7a2276dcb3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n        self.local_search_prob = 0.1  # New parameter for local search\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                if np.random.rand() < self.local_search_prob:  # Local search\n                    local_perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(candidate + local_perturbation, lower_bound, upper_bound)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                diversity = np.std(new_pop, axis=0).mean()\n                if diversity < 1e-3:  # Check for stagnation\n                    np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive local search and diversity-preserving strategies to enhance global convergence and robustness.", "configspace": "", "generation": 54, "fitness": 0.14890050835319574, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.2677947649037117, 0.2744704894974107, 0.28823059673893126, 0.2853474619204476, 0.2925797414210165, 0.2865430865419559, 0.2731130637808379, 0.2870198466672601, 0.2965812353380004, 0.0345436337854097, 0.05029618334154018, 0.03792452549162917, 0.02109696710846276, 0.046647769939765604, 0.039991121692441456, 0.03051287804806213, 0.03850597006241352, 0.0446682617236156, 0.052303844572872515, 0.06508942781878435, 0.06229133318883873, 0.05818243823250324, 0.059373373036861854, 0.06075002422648701, 0.06162257945704763, 0.060159901857947284, 0.05819783214678664, 0.058010153998342084, 0.04450394900284027, 0.05451637409845156, 0.04485685446563348, 0.0536310371177291, 0.04817123261460199, 0.04170278378210246, 0.05028478417079918, 0.045725620146715995, 0.955209745685457, 0.9809767081379615, 0.9628674279135466, 0.9829117798270176, 0.9801203489906352, 0.9319724469790973, 0.9560558772786054, 0.9795181274294545, 0.9631475716668715, 0.14681353574443634, 0.14116301982374824, 0.15354328539259654, 0.17109848308316855, 0.14551594629733156, 0.13750653568319016, 0.12470492929525967, 0.14089249345659538, 0.15582108835572694, 0.17466483434546243, 0.15897846012616978, 0.16838475077125126, 0.138697896607202, 0.1275929454963558, 0.1437227177933308, 0.15269773665572373, 0.15251718158065908, 0.15482864004887198, 0.044211406725358615, 0.05313054325312372, 0.04645625392493946, 0.043393924806171325, 0.052246893543115736, 0.05729112386775126, 0.07075127015908689, 0.056864507595359326, 0.04858767144290976, 0.04531331332383792, 0.052677882161295764, 0.047334688469119146, 0.04737984935684458, 0.0699438497684719, 0.03935490645944539, 0.04351767980748611, 0.06282633099178747, 0.0360148895439083, 0.0022734110742110847, 0.0038959519427819167, 9.999999999998899e-05, 0.00010417895176884073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0743720502842582, 0.057223619416290394, 0.0554166040877071, 0.05915123729632776, 0.06183121147743165, 0.05368317701386427, 0.03264922452429042, 0.052917755615983664, 0.05437653297176348, 0.004695158496593077, 0.01680570752441435, 0.017626565749750855, 0.010771617014518564, 0.013732675987610521, 0.019088490613261233, 0.011439641184025962, 0.015938202138820134, 0.011535695598697049, 0.03679498493179567, 0.010124029175773264, 0.013971771490040696, 0.026462014377771625, 0.020960095744905094, 0.03508461030756138, 0.029404421877063602, 0.0188143565150225, 0.018135536318979573, 0.2522980433639752, 0.24431415830787806, 0.2598969447410465, 0.2690422460246342, 0.2817579825854565, 0.2630678967146235, 0.25155426734665376, 0.27685659381026084, 0.2700624270165677, 0.06267570229821973, 0.06903445615926651, 0.05935227605275872, 0.05201979259376199, 0.06080598871943621, 0.062428667723107956, 0.060976317017083836, 0.05099203107489447, 0.05896611346107872, 0.14420667244800423, 0.14031494966206592, 0.13439946563659289, 0.16104542643199216, 0.15475969443131, 0.13179103913656376, 0.14852819542769613, 0.1323798541965414, 0.16178786950977408, 0.18364237246902582, 0.1814311775166021, 0.20760841715396272, 0.18855027894413046, 0.18541813712264632, 0.19781694330310873, 0.18603566604073718, 0.20828490874199646, 0.2218134807089992, 0.13308016585550808, 0.1551022145702109, 0.13743551449084257, 0.13692069064929524, 0.140405572057819, 0.12626345505267222, 0.1343032290726216, 0.145837248743658, 0.13554964793816848, 0.15609411522218164, 0.1641027289427237, 0.16741023841256408, 0.15920957024225713, 0.1664240571822213, 0.1618487431427411, 0.14637162782576452, 0.159813281718017, 0.15625715711925547, 0.1409969626514721, 0.1524743130818853, 0.11533894069228223, 0.12425911571298365, 0.16190681480765068, 0.1425704902621836, 0.13447958862180753, 0.1170503253547589, 0.15573988288960572, 0.14058511879669278, 0.1609791152077369, 0.29897050799956404, 0.14488647175646874, 0.11147585173019448, 0.11511094016926038, 0.15031788650770883, 0.30008480472843724, 0.15170147228670594, 0.1925695381802498, 0.23530176811073744, 0.14351130618575625, 0.10007181337516036, 0.185144228055115, 0.13699916745632668, 0.1742849630521156, 0.23800706228238755, 0.17309079681016504, 0.18587793290673404, 0.19058729951621667, 0.17887823623197274, 0.18158142596079252, 0.18427146837192498, 0.18136395401660954, 0.17289024345002546, 0.1816840202547696, 0.17240517069999384, 0.05223255582530928, 0.047905098055839646, 0.05498674545558968, 0.059207147541095906, 0.049525530522051886, 0.053886917008903024, 0.04839395841601746, 0.04654325274495297, 0.049690717107812254]}, "mutation_prompt": null}
{"id": "cd4b19d4-77c7-4703-9484-95558bb51094", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n\n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Neighborhood-based crossover\n                neighborhood_size = max(1, int(0.1 * self.population_size))\n                neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n                best_neighbor_idx = neighbors[np.argmin([func(pop[n]) for n in neighbors])]\n                crossover_candidate = pop[best_neighbor_idx] + self.mutation_factor * (mutant - pop[best_neighbor_idx])\n                \n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, crossover_candidate, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            # Adaptive population size adjustment\n            if eval_count % (self.budget // 10) == 0:\n                self.population_size = max(5, int(self.population_size * 0.9))\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive population size and neighborhood-based crossover for improved convergence.", "configspace": "", "generation": 55, "fitness": 0.10691521943120288, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.15130738813577005, 0.15051998809060418, 0.1476381475578581, 0.18646977758957628, 0.18642381893424187, 0.18564488654444788, 0.18341959889203552, 0.17607345761508675, 0.16476904380334667, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02520853379052146, 0.038782448835152694, 0.03726071383923879, 0.0389735765572361, 0.03887534117066005, 0.03330516101514658, 0.034699406310520264, 0.03693164121660253, 0.030827341942068376, 0.02518065513518486, 0.015312209493270945, 0.02060343387821084, 0.02130694884758033, 0.01647390446084751, 0.03528797998151134, 0.02538157443111666, 0.023440454504428998, 0.025012513556788907, 0.8337584783162677, 0.7442150302420001, 0.7686479873882356, 0.8411052434998072, 0.706059446829894, 0.7314429164420582, 0.7659701598756992, 0.7174511061298674, 0.7190224784320781, 0.05959894716609959, 0.06568697538593316, 0.062243139769063816, 0.06544141683880311, 0.08105637940259602, 0.07716899222542284, 0.0812913038009192, 0.07363902436818204, 0.08478695833498584, 0.11986165746406152, 0.12494363239071371, 0.09762038416450436, 0.10720313183251728, 0.11871985777567229, 0.11883080737307705, 0.10107617450644935, 0.11324109369968882, 0.10492949118680206, 0.002350164200425775, 0.000362254712419241, 0.022412335463497746, 0.00886830789119597, 0.01064084543724897, 0.0006356735222767806, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014218197467745775, 0.01076236279430598, 0.01663461454910975, 9.999999999998899e-05, 9.999999999998899e-05, 0.008135680789549626, 9.999999999998899e-05, 9.999999999998899e-05, 0.003337243688828262, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03163874981727044, 0.004125543098069229, 0.051178758692035475, 0.039437756962081405, 0.042978835969735285, 0.00409058027996434, 0.003029536126296639, 0.017332234105413624, 0.03639255891645787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009226222955361907, 9.999999999998899e-05, 0.004880722857101283, 0.003955557761901929, 0.0005507774611743788, 0.15997649125650992, 0.1685181412859985, 0.1745265336944447, 0.18663286802490775, 0.17838428688997132, 0.18503566977482955, 0.1969152028118547, 0.15791380722630277, 0.16794482237153385, 0.041701816072730935, 0.03759010863933365, 0.043415978545014666, 0.0347521294587666, 0.030855486880194127, 0.03630962019748407, 0.029376242096557315, 0.04040916451472654, 0.048976020855992286, 0.10503543315087138, 0.12129634745298956, 0.1242156545355767, 0.14743170306170128, 0.1431605167199832, 0.15514635094065, 0.1303917646431857, 0.1511853741835555, 0.13646055872411378, 0.16814803992313065, 0.1500354343976401, 0.15210380872392326, 0.14441503895519558, 0.14757714724163884, 0.1497199366954084, 0.15789602312122664, 0.15703190326129168, 0.16780938449960336, 0.09985348069202316, 0.08891255497284278, 0.10317635608997222, 0.09933199743328514, 0.0940176989630529, 0.09392477441409552, 0.09805214498555959, 0.11904492676825995, 0.09821342569682945, 0.13544049643551226, 0.13583106123130928, 0.1370550588060947, 0.14898527866007738, 0.13110098320299912, 0.14077360907035852, 0.13476263285277168, 0.15219550340628996, 0.13894247913411162, 0.13358694207069532, 0.13477809866785395, 0.0572421688917375, 0.07684752336200273, 0.10313063724785443, 0.13147276901736205, 0.12957204432634684, 0.11004170502123889, 0.10238221045869067, 0.13903739869185772, 0.13673039746796, 0.14292057245649537, 0.1413768854172962, 0.11618539393159222, 0.12256481364137273, 0.16019338544079387, 0.1470518405389203, 0.17270173869661243, 0.12801561013646368, 0.12560095359468193, 0.13421066477962618, 0.11661277391144342, 0.14713610589269088, 0.11517236293293642, 0.15881611077267588, 0.17959482902008372, 0.16021380841203714, 0.18641002624827252, 0.18020645745897323, 0.1796408453723949, 0.17807616399632387, 0.181999457812569, 0.1724374086399021, 0.17996434416889573, 0.1797475178625928, 0.18376622752750083, 0.04827396686928531, 0.049292499091924014, 0.0397197529825386, 0.04385296104785097, 0.03854155480863941, 0.041870963822233875, 0.0340196145890963, 0.04155879875495283, 0.05029574181217489]}, "mutation_prompt": null}
{"id": "0117a062-74b2-4177-8a68-ba1b5b4c59da", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "26cc6d9a-f63c-486b-9bf5-0c256eea3718", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "a18f870b-2307-42eb-ad74-2ef2a7b3b291", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n            \n            # Adaptive neighborhood search\n            if eval_count > 0.8 * self.budget:\n                neighborhood_size = 0.1 * (upper_bound - lower_bound)\n                for i in range(self.population_size):\n                    neighborhood_candidate = global_best + np.random.uniform(-neighborhood_size, neighborhood_size, self.dim)\n                    neighborhood_candidate = np.clip(neighborhood_candidate, lower_bound, upper_bound)\n                    neighborhood_value = func(neighborhood_candidate)\n                    eval_count += 1\n                    if neighborhood_value < func(global_best):\n                        global_best = neighborhood_candidate\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced stochastically-ranked HybridPSODE with an adaptive neighborhood search for improved exploitation in final stages.", "configspace": "", "generation": 58, "fitness": 0.15047080140822858, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.31630638298077096, 0.2908041527615086, 0.31558487489619325, 0.3229723568865236, 0.3083889969392055, 0.3435648780650601, 0.31075798483504025, 0.3068806216028287, 0.35244132697629527, 0.08959808406412739, 0.07557408293927914, 0.11787052625660377, 0.10070459190694492, 0.014408544314583938, 0.11689972394897974, 0.10319525096067406, 0.0836665014238388, 0.00887198681958834, 0.07619826680154218, 0.05825860131987026, 0.051616170787992965, 0.05767958115925398, 0.04806483853310106, 0.05814816845619497, 0.05947235265603179, 0.05760106656155162, 0.054578814371842976, 0.04676806617606577, 0.04592519461851041, 0.04051709648122814, 0.04081154827747835, 0.050970364094693243, 0.04838555713326731, 0.039918919506850226, 0.03756574020340031, 0.05116887208901322, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.13607395133941735, 0.1399723417042622, 0.16587923224722634, 0.14644557055794416, 0.15174544942226154, 0.15524401366129836, 0.15374943322736578, 0.13938287748185463, 0.08959101153173632, 0.13130469159105485, 0.126389981896184, 0.17390025696688916, 0.14973554101826125, 0.13594155171715228, 0.15268556764846364, 0.1251367022418446, 0.18535081635392892, 0.14094730283862844, 0.03290607804024126, 0.04141072441411253, 0.04626019331274833, 0.04000882287238383, 0.04826362017085373, 0.04816161231355831, 0.05144532796055168, 0.047100426546026974, 0.04617848127838786, 0.030912096010723644, 0.027262300335711753, 0.03089088515955174, 0.06499917274030576, 0.036155516424222656, 0.046331624868968135, 0.056158527151472515, 0.04774021073593593, 0.05468576773478506, 9.999999999998899e-05, 0.0005115787370737479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04231065463054329, 0.04430800112027611, 0.03871540361398307, 0.030773529203855232, 0.05829940356495811, 0.07424576298710295, 0.06534990132739293, 0.04440569482832757, 0.059181428316852136, 0.009650782779837774, 0.007087257117375345, 9.999999999998899e-05, 0.018539202832067003, 0.02106608291764933, 0.021095900203526474, 0.01885651083364792, 0.014436381938471632, 0.0321980662387239, 0.03420836481724632, 0.026511564097171147, 0.024856072004970198, 0.024579703475683945, 0.04063890856148589, 0.005405213577803436, 0.04088240578418523, 0.018033154073568425, 0.02622439791196629, 0.2562893107314368, 0.24288888145959087, 0.27013854529115233, 0.2856437183923838, 0.2756208040920971, 0.2732510556592066, 0.2507016991570413, 0.2634775871289924, 0.25390997546690974, 0.0556335414656014, 0.05989631591638045, 0.06273532572472962, 0.06100904916763228, 0.04904186623466067, 0.05525912540743627, 0.052901828582831545, 0.04843015435633169, 0.06147772054456113, 0.1812125572666018, 0.16114441537661928, 0.15007352548865782, 0.1428216118756811, 0.1590308551016264, 0.14889658212475387, 0.14623048022327456, 0.14900940946998287, 0.1397713643155737, 0.19805817369714274, 0.18050312593021267, 0.17684308333694954, 0.21519626994348207, 0.20061392202532002, 0.1850385425382437, 0.2002970364748321, 0.20200027979887014, 0.21548481594956026, 0.12202535588809349, 0.1289625224689409, 0.1324387228169338, 0.11831808610244388, 0.13595451961270133, 0.14381261919202748, 0.11287112150654743, 0.12928248404580622, 0.12799326278225232, 0.1687745903584268, 0.1541722565924729, 0.156088154552945, 0.1531034524986291, 0.15284142505479625, 0.15085973712727174, 0.16352001365633217, 0.15352655370129997, 0.1815320825557707, 0.11580820938152014, 0.15054780944853197, 0.10539151766542676, 0.12415355708306175, 0.1156408891359142, 0.1081954764915517, 0.12759018659748222, 0.1421849418746739, 0.14636113844301868, 0.1308366212130968, 0.15384440866560545, 0.3073742574651843, 0.16209690566750612, 0.14626736801973816, 0.1473901461652637, 0.15423855168371192, 0.14456853460706187, 0.2721344637541838, 0.14111161441334208, 0.14002984796969287, 0.2199608092869373, 0.18624886366311333, 0.20296363538060702, 0.13854421956940355, 0.1770536910570103, 0.1786589212633709, 0.1870361953178613, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19047693075182792, 0.17574374679410298, 0.17732412460063374, 0.18076302628317786, 0.1805182042079927, 0.18417377736906027, 0.05299303829941149, 0.05784041324958966, 0.05050217572850835, 0.053952773445364755, 0.056332181684630056, 0.048527312896679775, 0.04757704116258887, 0.04862225532795306, 0.05033493528982258]}, "mutation_prompt": null}
{"id": "c2c99109-3dad-4896-9983-d3e835a4080d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "a0ed87c5-5be5-4874-ac4d-f811d3064c96", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "54eaee0d-d36f-4dd7-be43-45b169965c56", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "8ff4e848-2455-41c2-9bcc-24c78ae4bbdc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "124c7c5e-4a4a-4814-ad2d-d3845400457e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "7506fcbf-c8cf-49a7-8925-eb125b96c53d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.5  # Slightly increased for better local exploitation\n        self.social_coefficient = 1.5  # Slightly increased for better global exploration\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Adaptive learning rate adjustments\n            if eval_count % 100 == 0:\n                self.cognitive_coefficient = 1.2 + 0.6 * np.random.rand()\n                self.social_coefficient = 1.2 + 0.6 * np.random.rand()\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n            # Periodic local search boost\n            if eval_count % 200 == 0:\n                local_candidates = global_best + 0.1 * np.random.randn(5, self.dim)\n                local_candidates = np.clip(local_candidates, lower_bound, upper_bound)\n                local_values = np.array([func(ind) for ind in local_candidates])\n                if np.min(local_values) < func(global_best):\n                    global_best = local_candidates[np.argmin(local_values)]\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive learning rates and periodic local search to enhance convergence speed and solution precision.", "configspace": "", "generation": 64, "fitness": 0.15212824032931824, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.28935388618264013, 0.27552606972166427, 0.27322029961917016, 0.31887780134201504, 0.3085732610582681, 0.30699221600641546, 0.29312733446038375, 0.3088917450344506, 0.2870855869761384, 0.0896292840128251, 0.08018398483836608, 0.007152979119642411, 0.09843727601986374, 0.09740327647881097, 0.06598732657874007, 0.0010886785000083776, 0.08676402500609548, 0.06925606365914971, 0.0634479525357361, 0.05297845502671006, 0.05611995017760252, 0.06164002199437002, 0.062318975393977016, 0.06639301766014427, 0.07004350815951221, 0.04947782410127455, 0.05025878675355888, 0.04748817711153064, 0.04537854492804638, 0.059124124590068994, 0.04684654972650171, 0.05441388249148005, 0.044983398925785845, 0.05016518621074684, 0.03479486003362342, 0.046092148286420165, 0.9590130075518841, 0.9801909788843437, 0.955466869348145, 0.9901000411374052, 0.9777436365915839, 0.9803524622808262, 0.9719243407725116, 0.9164872673623535, 0.9281414245335904, 0.12520252516569985, 0.11461506634195939, 0.12491314369369955, 0.15016771707211174, 0.154213242099128, 0.09810470110649727, 0.15152376228766207, 0.13403718758498762, 0.13939633975621546, 0.2381927641161916, 0.19810140987304625, 0.14992484461325672, 0.23227790657318226, 0.20155643366114018, 0.14242027188317374, 0.1458612473232973, 0.17587475064124514, 0.15242507109286274, 0.0831931600772392, 0.04472041137124039, 0.04136938284581315, 0.03963282253043887, 0.04412333313076744, 0.05298163948065682, 0.041175595841038026, 0.026909305753977097, 0.03982397467258947, 0.026618963940772677, 0.03426001823945113, 0.0626446522505858, 0.04465622906754885, 0.03153849310420087, 0.04803112648106367, 0.0702010412648102, 0.062460110708124184, 0.04263980399470935, 0.00505280349519055, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017057016424915084, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041454221509148015, 0.06282022049949576, 0.08267726471330228, 0.03850448671616358, 0.006764458368896387, 0.054655158970742024, 0.052051616256599265, 0.041050354347298756, 0.021159618267392766, 0.00865700631738986, 0.006200725359191139, 0.016874673279827945, 0.01834031695234295, 0.015994636508244175, 0.020158253466807552, 0.013733236913146762, 0.016465138044579164, 0.008806874463744174, 0.014913437547996011, 0.019716981005703405, 0.015084295701688677, 0.03242277840283225, 0.013583437613409521, 0.022834368442374964, 0.025454628164767512, 0.015002750287600564, 0.022653313312817613, 0.23952339390437805, 0.2701982999429079, 0.2383871393596183, 0.2652096988293553, 0.25745572013437334, 0.2557969605626571, 0.2563751083021627, 0.24590711877977334, 0.2577232733857434, 0.05817914495940135, 0.06345195346896748, 0.06198483065475502, 0.0525547970587793, 0.053202835738840215, 0.0518416447965343, 0.056193764065508356, 0.05454036374148796, 0.06436262834209627, 0.1282474860553624, 0.15811265461800572, 0.13246743968262653, 0.12751502460381725, 0.13845044147933172, 0.17380843205897578, 0.171930309601941, 0.1665149576163114, 0.14496864228449868, 0.19415832524628962, 0.1875773493421855, 0.19900037037753315, 0.20230799866267757, 0.19322451950026442, 0.1791828100183338, 0.19591334885279088, 0.20288084178817178, 0.2060423670720879, 0.13562595468436522, 0.1490330948585612, 0.13448455593048236, 0.1438412242529914, 0.12459834045626061, 0.1242423986561747, 0.11344903452640553, 0.14672789547354437, 0.14528856621973574, 0.15713745892363773, 0.17125973778043901, 0.17120721587323495, 0.1531554391878266, 0.15703205175746549, 0.16181207704802913, 0.16336191723860105, 0.15302264577455027, 0.16056270858895838, 0.12438928897705859, 0.1170368606717519, 0.15662941199037983, 0.14686204120735513, 0.11467149323636727, 0.175754946990214, 0.14054630025314196, 0.14801709942790253, 0.129518042946841, 0.23017523943419882, 0.1583476915908102, 0.1514385384495528, 0.15124533080480884, 0.24221141696504833, 0.24616593835722145, 0.32885176824962503, 0.18005291373101495, 0.14966684856971701, 0.25324287091068975, 0.14133559777063587, 0.18420929618668513, 0.14776217511007095, 0.27336159001623683, 0.12207032015274255, 0.17845541746001092, 0.3048680959309862, 0.1981414656749958, 0.18605795557301819, 0.18506295373052228, 0.18719255134636992, 0.18717427859864255, 0.18881802355754496, 0.18338885035062558, 0.17578639429487286, 0.17994468466770508, 0.1870178199606375, 0.05606678389061348, 0.04695096201732396, 0.04796704296438348, 0.05099628898214359, 0.043920188256174386, 0.06317009171144894, 0.06175152276806661, 0.048453592675638535, 0.05523505068342549]}, "mutation_prompt": null}
{"id": "4815c6d8-4c18-4720-a4f9-a1bb05d658d8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "5912a330-0c83-42fe-9fac-0af846a5f3ea", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "9df00188-c12b-4ec3-9fe7-bb30e131d859", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "40eb6488-57e1-49e3-ba9b-1d610acd18a7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "bedff9e2-b1d5-4bcd-a875-7f90fc1cd634", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "83e09625-acf1-44a5-906c-2fe4393514b4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2\n        self.social_coefficient = 1.2\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def levy_flight(self, dim):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(dim) * sigma\n        v = np.random.randn(dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.cognitive_coefficient = 1.2 + 0.5 * np.random.rand()\n                self.social_coefficient = 1.2 + 0.5 * np.random.rand()\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i] + self.levy_flight(self.dim)\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Integrating Lvy flights and adaptive social and cognitive coefficients to enhance global search and convergence.", "configspace": "", "generation": 70, "fitness": 0.12302822770419625, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.16627851019938822, 0.15974536789626292, 0.18010794639262662, 0.17914849259659382, 0.19189802151903623, 0.1833649161969847, 0.1809269889151267, 0.19251027561870127, 0.21052471433865672, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00665964143252773, 9.999999999998899e-05, 9.999999999998899e-05, 0.057638141417015176, 0.03974792536784988, 0.039403450317382016, 0.045036878068958175, 0.04531667450443422, 0.04074915835428872, 0.04025292144346093, 0.057059519410611936, 0.041839743636178484, 0.029924503095243415, 0.030550727274842204, 0.026119974615926522, 0.030595178020236702, 0.03383122504837033, 0.03648389536517804, 0.025095069793980795, 0.029412582696647815, 0.03528628736425121, 0.9302553037343078, 0.9346996807876395, 0.9565632343332379, 0.9516992553895607, 0.9392141273323077, 0.9845904018724633, 0.9491954958968296, 0.9785676953120785, 0.9256120519439384, 0.0884861476791271, 0.06843325245033305, 0.06856422813357144, 0.07736690457911977, 0.09168437473545987, 0.09536390354106261, 0.09550679363876391, 0.08321313774445027, 0.08320072023891267, 0.12021079037400939, 0.12091525482122067, 0.12342978599409649, 0.12575678966599158, 0.12889070385126356, 0.12858671642999164, 0.1195712423566967, 0.1212939930401975, 0.12234021272276441, 0.004121627458958721, 0.01602934346783258, 0.01302351459080131, 0.01919381253218866, 0.021776846977240583, 0.010818451475185453, 0.011721519176170148, 0.04192606096567619, 0.01751829500287272, 0.01707565967787883, 0.018007699674462807, 0.014951295275053567, 0.016745072924088333, 0.007733270297676009, 0.01854123426876375, 0.013229479062227822, 0.007210524262105, 0.028354621010939773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040747245042686564, 0.025292054200249603, 0.060048610336351116, 0.030166556209025308, 0.038867057619972556, 0.006980554734906219, 0.021461833836477817, 0.04587059695393547, 0.04325772484713741, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016612203459362984, 0.008550095285196901, 0.01012830658750008, 0.006515083220607454, 0.0016447521446157909, 0.005084830589556777, 0.008030208012623885, 0.012096440474608228, 0.013789794361660834, 0.1848377816274943, 0.1857939400804023, 0.2001966671414077, 0.19332566376879323, 0.19879458989238175, 0.18285038274201315, 0.1985252827807905, 0.1785848946296068, 0.20094684811913655, 0.049760226828269194, 0.04500961720240504, 0.05206278223166172, 0.03980928431565556, 0.05662817642317408, 0.04684585621198134, 0.036739769145866186, 0.04660814965063309, 0.04755077460813917, 0.14474183551991915, 0.12476594427667664, 0.15038625043606502, 0.12990173902148905, 0.14411444487559133, 0.18541066127635264, 0.1350669271672157, 0.15232753785086406, 0.12630233658779821, 0.17132530355915676, 0.16667560977304696, 0.15401424841177724, 0.1631720363327258, 0.15980565146729986, 0.15444952982265492, 0.1652932520328928, 0.1578440099426327, 0.15825067165146178, 0.11211453742861699, 0.10374508291515794, 0.10527149249747947, 0.1125126618756751, 0.11102532317180758, 0.11101128111336456, 0.11315937020262878, 0.10640356489940239, 0.11976934090887703, 0.1390096081001475, 0.1847302033042879, 0.14505791674132906, 0.14180361540955122, 0.14660770965267056, 0.14958318372825163, 0.156156918935893, 0.145384078418187, 0.14940721121043132, 0.12624985385555354, 0.12024815777813491, 0.09724662132946937, 0.11179797695546845, 0.10657205451832963, 0.12500594330733183, 0.10997649386820885, 0.11271898898989208, 0.14769807228342213, 0.17611953291605387, 0.14006290600421978, 0.15275094872671435, 0.14561117715428007, 0.16404037922793346, 0.1326553333714402, 0.14382539769117175, 0.12862874005157898, 0.1473099761590596, 0.14243972658546733, 0.15268073319923514, 0.14472401699619564, 0.1410346761389104, 0.14653497918101543, 0.13243357801134792, 0.17320265575507854, 0.18171998227690156, 0.18105151380173035, 0.18725149569471222, 0.18781300406455748, 0.19327842991624788, 0.20917491581341074, 0.21001595694627295, 0.17494310004652602, 0.18130861043338753, 0.17478695933806399, 0.18349709621113675, 0.039921267320060405, 0.04565197344390526, 0.047374959354309576, 0.04763619596920876, 0.04770710285493407, 0.05227898899017813, 0.048540288444419266, 0.040808143301958255, 0.04680427950643551]}, "mutation_prompt": null}
{"id": "350bb60c-c5ea-4ec9-b243-6bbec5aa8379", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "7e407c63-cbe1-422c-8321-ccacab147c8b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "f53218f5-7176-42af-81a7-252ac25bb37d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "cf32847b-1d24-4dc8-b0ae-3948eb034f67", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "1b1ce309-857f-4e77-819d-82c3a815d08b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "59e62d7a-9269-4621-b8e2-f9f07c5c1167", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "dfafdda9-b8d5-4c5c-aab6-0594f069cd50", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "71bde893-194d-48b7-ab72-7f71ecfed3b4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "38db0280-1686-461b-814d-cae7568d93bf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "8900e0d7-e73b-4fc7-b6a2-5a47698a74c3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "b6d23945-50cd-4476-a381-f998a299f031", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "242f7b7f-ab34-4d19-888f-9e4d6c930fd6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * np.exp(-eval_count/self.budget)  # Adjusted adaptive mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_rate_adaptive = self.crossover_rate * (1 - np.cos(np.pi * eval_count/self.budget))  # Adaptive crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_rate_adaptive\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Periodic global reinitialization for diversity enhancement\n            if eval_count % 100 == 0:\n                pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive mutation and crossover strategies with enhanced diversity through periodic global reinitialization for improved convergence.", "configspace": "", "generation": 82, "fitness": 0.1491440234489257, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.264621592274214, 0.3129163606010673, 0.2760368911590074, 0.18840404321518267, 0.11448761375623784, 0.18966520473216775, 0.2660714275973157, 0.32873017478249944, 0.2944449864413061, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06155767368537912, 0.0741004568044642, 0.07772575072273391, 0.06677792888145306, 0.08082159366778718, 0.06932799336375028, 0.05708820634273215, 0.04917421523577048, 0.07057457993689764, 0.056774664287501775, 0.05068516707139148, 0.057338233770962366, 0.06727257126230013, 0.06548770499805645, 0.04942485102681182, 0.0538135798867756, 0.06339675729192662, 0.0605363508479555, 0.9937265287879158, 0.99549407561454, 0.9886616509538656, 0.9904394019242703, 0.0749312161230633, 0.9893516498456695, 0.9932494948637818, 0.9921181683020004, 0.9931379678693748, 0.05504959981738178, 0.15049710318755827, 0.1696374388274955, 0.13746635620364012, 0.13245537299162702, 0.140271143129011, 0.10453069614845478, 0.0307598949883664, 0.08887707803531453, 0.14143251192643236, 0.17607165221539867, 0.19681512656065392, 0.17332086320026996, 0.16378962109576878, 0.17822913862703793, 0.11645972366457136, 0.18937242198903792, 0.19641126192548586, 0.06658147943380788, 0.08201398769918156, 0.08457500160287723, 0.058794914761028494, 0.1081266139715561, 0.05174615652188441, 0.09917663082390682, 0.10733211700126444, 0.08449788717013651, 0.07651694372228834, 0.08389258938087318, 0.04660275110742007, 0.08237013874865129, 0.09280245436340961, 0.13275788810778777, 0.10998570387555229, 0.055140294584403615, 0.037917669096216966, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03638951196266227, 0.04205894896153217, 0.11934927889524538, 0.025003797887778623, 0.0648239020694722, 0.02212752835680043, 0.007959478434075073, 0.0059892330100299596, 0.03289555156153201, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03031854712719395, 0.010480037091297523, 0.014746569433781054, 9.999999999998899e-05, 0.0014667960781807876, 0.0363443017980406, 0.018654669352225373, 0.04101704052935351, 0.0028859167887504977, 0.23705130379388362, 0.3135553958784413, 0.2699042660199027, 0.181804301502402, 0.3039240781175655, 0.27890999603529976, 0.29287523951897965, 0.27037173649078694, 0.24291861300208528, 0.05294769414581113, 0.054023776445355165, 0.05895390377427756, 0.07539457254435544, 0.09051095534029541, 0.06326750493348265, 0.057720720810527704, 0.04338663489130301, 0.08552802726221453, 0.15837996986428748, 0.12337134025573104, 0.14874122198895712, 0.1531261940485107, 0.1753645802526489, 0.1321793981589482, 0.1662238063338729, 0.16126979452489154, 0.1786838681240419, 0.20808206147317487, 0.21605277231607645, 0.23617880359733368, 0.18717559838847053, 0.19395238147376181, 0.20191355938451105, 0.21277400731550122, 0.1959352619515261, 0.23873022470886707, 0.12640529716891435, 0.14170488948887616, 0.1453315093648505, 0.13433399218944708, 0.14537998685499387, 0.17017315381549647, 0.1533298777375277, 0.10162626854179779, 0.15802206086175885, 0.19163709517357286, 0.18743862290534852, 0.16410469140063633, 0.16387545029142403, 0.1824696212725051, 0.16874501849453505, 0.17297570236560145, 0.15944487845512378, 0.15996541306920298, 0.15777458800319144, 0.1655457798753296, 0.16158422730077504, 0.16578142652556704, 0.15650380816003306, 0.16830638342948756, 0.1634272012881398, 0.17448697367527188, 0.15549796483716216, 0.15600480534324468, 0.16363805776228724, 0.16764066248754683, 0.1649542934188355, 0.16869899927022147, 0.16710837976998372, 0.16999151525415623, 0.16639271878041506, 0.4000830585310571, 0.12892846167019267, 0.16800016646005222, 0.21065423580799525, 0.1687302274208623, 0.18030001206370994, 0.18428893208990016, 0.23000721056402185, 0.2777123017975641, 0.22556858034855487, 0.17888972415150728, 0.18437017235854214, 0.19169154068170424, 0.1929233430910512, 0.18455840999686568, 0.1827565414543526, 0.1958318768050834, 0.17600656796824332, 0.1783877578167603, 0.0634656730340104, 0.0662279206302201, 0.07126604144863413, 0.06509230810297906, 0.05719961958455899, 0.0641662739550648, 0.07132283284154695, 0.07939399679234738, 0.05984433442739301]}, "mutation_prompt": null}
{"id": "19b96701-3f9f-4248-8f08-3ff10f62f7aa", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n\n                # Dynamic crossover rate\n                self.crossover_rate = 0.6 + 0.3 * (1 - eval_count/self.budget)\n\n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Tournament selection for increased selection pressure\n            tournament_size = 3\n            winners = []\n            for _ in range(self.population_size):\n                contenders = np.random.choice(self.population_size, tournament_size, replace=False)\n                winner = min(contenders, key=lambda idx: func(new_pop[idx]))\n                winners.append(new_pop[winner])\n\n            # Evaluate new population\n            new_pop = np.array(winners)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive selection pressure through tournament selection and dynamic crossover rate for enhanced exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.11617819990468638, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.15456352737296297, 0.14842895242528453, 0.18434935952289777, 0.17515065202032842, 0.16479844605736982, 0.22446207286888364, 0.2433483945573518, 0.17558790575809302, 0.1923951954194869, 0.004905108122845392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017534373750015542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043260336317315184, 0.043336805182609406, 0.03676480353610312, 0.025576836197830577, 0.06459245828152793, 0.05597121245078984, 0.04804859712841625, 0.023990611636583004, 0.04048194567026708, 0.01761037711929636, 0.022533403792533324, 0.01885801428975664, 0.024737111514480103, 0.017480759848456207, 0.01975213793624553, 0.016150512187605104, 0.024115353692661712, 0.03690919657708236, 0.9751870569063618, 0.9682634468409907, 0.84444549786745, 0.9871960136157367, 0.967638061234464, 0.9609621815476401, 0.9557534779376737, 0.9601970283920044, 0.9711080766527257, 0.07431961107833618, 0.07224456908637167, 0.04748815187991162, 0.05753310094111441, 0.05855111484132469, 0.065682929280238, 0.07229819224316492, 0.06574925977862822, 0.043719707684978126, 0.09071010403094737, 0.08956420925823516, 0.10758395532718501, 0.11816924746579593, 0.08634441538670146, 0.09992132748895022, 0.08934972949251041, 0.1334865412109446, 0.1140316509385979, 9.999999999998899e-05, 0.034174635022003574, 9.999999999998899e-05, 0.04779885061293099, 9.999999999998899e-05, 0.031367904507158206, 9.999999999998899e-05, 9.999999999998899e-05, 0.006685753491787572, 0.038692813614460864, 0.016379314354760255, 0.07429820610308868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006318435570306202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020097718941700093, 0.027220916803582296, 0.02917083943654597, 9.999999999998899e-05, 0.01212515129382885, 0.03550752330608409, 0.016000701897827985, 9.999999999998899e-05, 0.023755097274923864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005063398278184139, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008572297172265708, 0.007764302525239519, 0.008142887592980874, 9.999999999998899e-05, 0.16419495700578557, 0.1742118281155436, 0.16688558616860083, 0.16857718237775188, 0.17726739130558256, 0.17803616815351853, 0.17418252337198215, 0.1564135930531957, 0.16973323265856521, 0.03925781066100176, 0.04644630699297159, 0.046941867819555005, 0.031079055986328985, 0.050713184984793824, 0.029993841686468348, 0.042642904199024834, 0.03523425070899133, 0.03590559715783115, 0.1377300546808643, 0.11218469234804651, 0.14078847010146478, 0.147058668621304, 0.13746600071429982, 0.12828273083572928, 0.12616681768602356, 0.15179849541155854, 0.1679872006335703, 0.15200946783867653, 0.15529914066384332, 0.155672196686793, 0.15033382801922812, 0.14511892683860983, 0.1728438500468148, 0.15907764601122565, 0.16454962157770314, 0.15621494306561579, 0.1075439102243767, 0.09635909936518505, 0.05999910275349152, 0.10244583155002351, 0.10047499062900656, 0.08768911651892719, 0.10423283815553863, 0.08771929743381734, 0.09722169697248029, 0.14406950274057873, 0.14203698368242657, 0.1449758575021337, 0.14906425299355253, 0.1471999915588551, 0.14038702492221677, 0.1681351726405128, 0.1339763006375455, 0.13795920874919865, 0.14653426842389106, 0.15129279792239447, 0.12555175362697335, 0.15406007550476752, 0.14533347189164547, 0.09967588212850664, 0.07130376437852337, 0.13544585308775425, 0.07135279243603732, 0.13139565839502754, 0.1314319959174176, 0.16843364046658693, 0.14962286530364088, 0.16103785820301186, 0.13257837501250602, 0.0845733960641033, 0.13347784186035683, 0.15592793916444658, 0.14535295494263778, 0.14612989063566184, 0.14343097480376743, 0.12613589468471997, 0.15421606998534132, 0.08891609169836634, 0.15662950670720133, 0.10860890251557775, 0.20244291955841442, 0.16332206510796954, 0.17120702579393798, 0.17064230093211286, 0.18166513139991236, 0.18830260454622694, 0.1969903261078031, 0.17840300468449588, 0.1722064665463675, 0.16179941118198582, 0.05338653479925992, 0.04640794647751567, 0.04557329417362266, 0.03787694927781704, 0.04562044230243045, 0.0442245626020078, 0.044294729604463456, 0.059529667408456444, 0.03932120431419628]}, "mutation_prompt": null}
{"id": "85586c81-20da-4572-b27e-68fb31809fba", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Local search enhancement\n            if eval_count > self.budget * 0.8 and i == 0:\n                result = minimize(func, global_best, method='Nelder-Mead', bounds=[(lower_bound, upper_bound)] * self.dim)\n                if result.fun < func(global_best):\n                    global_best = result.x\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhance exploration with adaptive population size and introduce local search via Nelder-Mead for refined exploitation.", "configspace": "", "generation": 84, "fitness": 0.15356687690882773, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "c074501f-af72-488b-aa0c-bbd7268d4709", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "c2e6889f-eb0f-4573-ba94-cf055ed3783e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                adaptive_crossover_rate = self.crossover_rate * np.exp(-3 * eval_count/self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            sorted_indices = np.argsort(new_values)\n            pop = new_pop[sorted_indices]\n            pop[0] = global_best\n\n        return global_best", "name": "HybridPSODE", "description": "Enhancing convergence by integrating dynamic adaptive crossover rate and employing elitism in population updates.", "configspace": "", "generation": 86, "fitness": 0.1404255627413016, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.22594101191825067, 0.24853476208031977, 0.26074383476718155, 0.25168630903031497, 0.24889441821558456, 0.26023069277137856, 0.2495422741091763, 0.16658161563697993, 0.2813036558642271, 0.04832349453208262, 0.06356343850653323, 0.06830187153074008, 0.033484640526370124, 0.06671389281357465, 0.08456059380774172, 0.028207259228765547, 0.05637090053645366, 0.07042747126162718, 0.04875351899468083, 0.048417858690612436, 0.0541438977089147, 0.049168235008478, 0.05057406455476243, 0.05211122857875794, 0.058287807663573, 0.04423587900514869, 0.048039798268165734, 0.032785125975248075, 0.032141681314289405, 0.04893520502052506, 0.06856075810093576, 0.029787376154655987, 0.027201982973341532, 0.034614470763787764, 0.04007769362431535, 0.0332881638290905, 0.9802388156195644, 0.9839684709474804, 0.9822348496182896, 0.9412816334088555, 0.9614149755562792, 0.9766277133526633, 0.9592795924982388, 0.9795964204305887, 0.9897437002414509, 0.08336471485027963, 0.08792513917240286, 0.08583537530014096, 0.09731623046899762, 0.11629004709871882, 0.10206900602011393, 0.10052720810886262, 0.07798185682188286, 0.10071247543277073, 0.16370363369476093, 0.1424710484237368, 0.1525839708161899, 0.13863771782459988, 0.13385221810271308, 0.1392327101626002, 0.15244553316710807, 0.16890830431842419, 0.15231947917029542, 0.030178087387744523, 0.03279028700045439, 0.03353881051334007, 0.019445907768298132, 0.024626031163019646, 0.03205080522274617, 0.013243787725074951, 0.020450011900717602, 0.01921104422098574, 0.03418359760963252, 0.05331813445812006, 0.04455388257602877, 0.03502072143824431, 0.0810542075200783, 0.04043888387585448, 0.015319584213253412, 0.06653730752175946, 0.04800296228761758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04129327184917986, 0.05034450654571887, 0.050264975885074836, 0.046825268658688746, 0.03166104058212715, 0.023573962876834775, 0.029429392597325577, 0.044682695064934386, 0.03413639429315385, 9.999999999998899e-05, 0.00039436046788654533, 0.006524422017051057, 9.999999999998899e-05, 9.999999999998899e-05, 0.008710258383512914, 0.008977103887101712, 0.009264579261083927, 0.00838272649227978, 0.011978077818906807, 0.005418449400792502, 0.009868041324828658, 0.0067836401423506665, 0.010226859962508605, 0.012844836614437027, 0.01328596755046707, 0.01198091803591339, 0.026147790639087676, 0.2207259800052186, 0.2443689909875678, 0.22926283740672815, 0.23274463773881848, 0.24711908246961378, 0.24598965251353722, 0.2331537428977819, 0.23429598844105826, 0.2540253905681248, 0.05242569100862149, 0.0556810014856739, 0.049142921424322195, 0.05769193245104198, 0.054572634829203714, 0.054026223412862784, 0.05077933799429879, 0.058488970636046744, 0.06104751076683168, 0.14794785314352543, 0.14701424338906177, 0.1453130913917663, 0.13882137762085112, 0.16523601410828614, 0.1377835848176292, 0.1458806550607702, 0.13695684760754534, 0.1464016719537079, 0.17745982411057326, 0.17031816814910783, 0.17414894102648304, 0.16906750760744393, 0.18537039540299116, 0.18796443377120398, 0.17187955722289805, 0.178880496498114, 0.18300498019448774, 0.10558080875484088, 0.12304997543054819, 0.1264299043916408, 0.14258358845710317, 0.1275226606661003, 0.11484204240230644, 0.12530849249763254, 0.11726598461795767, 0.13481855501912976, 0.15818061579143328, 0.16410536703603917, 0.165707329990747, 0.17264183164756264, 0.14579813386482887, 0.16087675809782054, 0.19077720949889354, 0.1666063858932637, 0.18807492152623362, 0.13459816125063206, 0.14938889359579566, 0.11480477505205855, 0.1459039375483997, 0.13690040263689884, 0.12351249779599072, 0.14842798183610395, 0.14159675483405754, 0.13839396361669842, 0.14462094357229816, 0.13070833257243142, 0.20143297458587972, 0.19148439482248292, 0.18921957195354822, 0.1305209335174632, 0.15590498806417963, 0.14489677496246656, 0.1661560548829224, 0.14063921691447812, 0.16593282295255363, 0.1837489090551877, 0.18952826520717292, 0.21151404458352818, 0.18611703394946721, 0.17962925057864598, 0.20370343531634116, 0.1874657853398053, 0.18829266868121253, 0.20090603356195225, 0.22332827211761896, 0.1772765921678643, 0.19133632071184326, 0.1802792396401126, 0.21888744695296336, 0.18062292349728815, 0.18566482699321485, 0.046442556870455176, 0.04877203577260625, 0.05434963854676533, 0.04424579643784288, 0.06339024692905659, 0.04712436746500659, 0.05341763419623824, 0.04912517654255788, 0.05328261959236713]}, "mutation_prompt": null}
{"id": "ac75aeea-3b66-48c7-87fc-9fc3b727bb54", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                # Adaptive local search enhancement\n                if np.random.rand() < 0.3:\n                    local_search = np.random.uniform(low=-0.1, high=0.1, size=self.dim)\n                    candidate = np.clip(candidate + local_search, lower_bound, upper_bound)\n                \n                new_pop.append(candidate)\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Incorporating adaptive local search and enhanced mutation strategies to improve convergence rates and solution accuracy.", "configspace": "", "generation": 87, "fitness": 0.14768071189307388, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.26467996741921673, 0.2641888153478321, 0.24977526676965855, 0.28385996433226623, 0.2700736053393429, 0.28551037739960816, 0.2710225817867308, 0.2990242092189781, 0.27707764512010347, 0.022671233415706205, 0.014344093703646421, 0.025855815292642914, 0.027556520123361072, 0.017146618794142476, 0.02667391817168996, 0.01852718467930603, 0.03320497361278796, 0.035940885679629164, 0.05975486057549806, 0.054324450292500104, 0.05383619799398931, 0.05324919216956714, 0.05634488593185327, 0.05407847238392627, 0.060653198209026815, 0.058508868319638196, 0.05342526118178814, 0.045974378745780475, 0.04922513410984497, 0.044212448051000885, 0.04285534878864583, 0.047100911196666484, 0.06335926423176896, 0.043163450453700736, 0.046476341332421955, 0.048518787093754345, 0.9939856577156776, 0.8674920639563485, 0.9454407378589649, 0.951228137526167, 0.917446538325955, 0.9521853138693345, 0.9653090088340645, 0.9726596358404076, 0.9693273197386005, 0.13624636774968635, 0.1298110987705282, 0.12418830862050911, 0.14171666751945233, 0.13833425087568862, 0.1547370387821977, 0.13156563867828175, 0.1345592634513474, 0.14224666992061297, 0.131417652467976, 0.22831798163598294, 0.1276519431464358, 0.1357364943744005, 0.15524194109810308, 0.22241812107525905, 0.1780915442366262, 0.15550171425420778, 0.15960844926192785, 0.04333820050781656, 0.040685745451667255, 0.04778578197914407, 0.04975975820350065, 0.04643248026861546, 0.046722115236218054, 0.04909200153372362, 0.04592917522255757, 0.053586405428949546, 0.04701190049044657, 0.06321318539916843, 0.054550581146588284, 0.048217182011805915, 0.04689988074928986, 0.049951732022259776, 0.059205315793388724, 0.061758133415379945, 0.04541522364216943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036960794674852915, 9.999999999998899e-05, 0.004974035691338363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0600727919928864, 0.04658329391048899, 0.06321139092711803, 0.03228625953821851, 0.04027721640505366, 0.043166438519853356, 0.04989248399066559, 0.058152366582754245, 0.03562118350043708, 0.003312172160037652, 0.003806066133073327, 0.005529955886984461, 0.006990698812196938, 0.0035493114681947047, 0.006600925190142104, 0.004339974575209293, 0.005621201032707912, 0.012665140146300491, 0.011559345347102123, 0.020483094366241184, 0.032248937318087756, 0.037407984649910575, 0.0333960829448553, 0.03455909799375256, 0.021929925036810016, 0.03205902530061433, 0.03633381096756694, 0.22993305164657496, 0.24118679501165385, 0.2497838152955002, 0.26189051762337545, 0.2558334931749586, 0.2596145668751094, 0.2536599084032116, 0.2514237610465204, 0.2670585636833235, 0.05929456890540319, 0.06164899652249567, 0.06073660501052325, 0.05334133274659181, 0.048757442311218036, 0.0599064204112143, 0.05703875517399015, 0.051471663330457385, 0.08536551710084073, 0.13175217698539166, 0.18103601408573122, 0.15324023105650764, 0.12931975602156764, 0.18735967675517706, 0.1425206361077992, 0.14431164214314685, 0.16149407773604074, 0.13469299160965076, 0.20643167419632003, 0.18780696810204944, 0.20070599307972004, 0.1902060389739132, 0.1992591411673058, 0.19891323237965108, 0.20132821327109363, 0.2008898066638165, 0.20170662814832574, 0.1340656686811843, 0.11073961883849737, 0.13436210257692893, 0.12150392940540644, 0.14798925661181928, 0.14749758065281549, 0.1376131749141425, 0.14628704247191615, 0.14177329299768626, 0.16424022636512325, 0.1433181455209558, 0.16226520334442862, 0.17134153736924818, 0.15732517125578704, 0.1572969331125036, 0.16196310038416162, 0.1568602088206228, 0.1696925792304046, 0.15376596749798077, 0.15661396240282832, 0.09295796522434119, 0.15148638731644493, 0.15136008538586976, 0.14546156707022695, 0.11742358006193532, 0.15169603290374634, 0.15448675421683944, 0.24539124416780256, 0.29239040248329995, 0.14614584447706203, 0.11437038600064897, 0.14113142154424663, 0.15272074252571077, 0.29583308075275805, 0.14881517739929018, 0.1412378183862173, 0.16073253280565192, 0.18064497072801644, 0.146334894836593, 0.16892625048074006, 0.21429273768620194, 0.14830062810467914, 0.18369366510009388, 0.1776041167048803, 0.17767544307280891, 0.18977824788830167, 0.1810123023325173, 0.20717838566302704, 0.20395369631302385, 0.20967015233282038, 0.17453205944172712, 0.18105233903771534, 0.19270883754682178, 0.2045492584340335, 0.0547833802238622, 0.04868625090842926, 0.05529830464423635, 0.05546497953838314, 0.05422968439092968, 0.0500364994273812, 0.05986325054598185, 0.04943589119811587, 0.05300936917839494]}, "mutation_prompt": null}
{"id": "a0aeb520-2c48-496e-80cd-3fda546d358d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "3e64fd43-7cbb-407b-ab63-9ddb0769e0f5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                # Particle Swarm Optimization Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)  # Velocity clamping\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Differential Evolution Mutation\n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)  # Adaptive mutation factor\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2  # Non-linear decrement\n\n            # Stochastic ranking to promote diversity\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            # Evaluate new population\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing stochastic ranking to balance exploration and exploitation with adaptive velocity clamping for enhanced convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.3189433505914192, 0.30812113648547157, 0.32374731924256717, 0.32793073145440943, 0.32095632926605444, 0.3453865097499924, 0.3220289820634499, 0.31865879969746025, 0.35420969568461147, 0.12394394228041505, 0.1176612858186189, 0.1415739736698184, 0.1293019240230927, 0.029516842563553802, 0.15076345088784926, 0.13117908206210993, 0.11792883156834011, 0.04668946716243427, 0.09970546726034046, 0.05819217817024569, 0.055668064092096015, 0.06142062340030041, 0.048191127433290015, 0.06229197902197048, 0.06633686176896736, 0.06302997508902008, 0.058489149315646305, 0.05322073665380356, 0.048459897532515006, 0.04623418542028357, 0.04450943616874614, 0.051560749377544735, 0.04844196816387447, 0.043410817956442194, 0.044330880040520215, 0.05133275004595583, 0.9712243752147212, 0.9703793785923429, 0.9632712043033396, 0.9469161445242121, 0.9675286638485162, 0.9752496173735353, 0.9731899420874001, 0.9248558808105819, 0.9925168796630046, 0.1473046733413581, 0.1482561203891395, 0.1790718621274331, 0.14222460905632128, 0.16540624667914694, 0.157812820803788, 0.15960635360159336, 0.16232649990571768, 0.07504291356710435, 0.13134660194893788, 0.12165391715728568, 0.17222820079633294, 0.14911766922560343, 0.13594155171715228, 0.15268556764846364, 0.11243053462969133, 0.18621963703976485, 0.1408894008306919, 0.03302443285457579, 0.042379506341741924, 0.046468180769044576, 0.04003174957193534, 0.04825199430458649, 0.04816563035666643, 0.05113191799098549, 0.04780556840568784, 0.04624439408408876, 0.03119331402762382, 0.027262300340001655, 0.02323522708205017, 0.06515560233974171, 0.036167777963078906, 0.04637940039018773, 0.05682119523816198, 0.04865989820298977, 0.054666948852313935, 9.999999999998899e-05, 0.005800516642164966, 0.0008261298410617846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04225941207609063, 0.04656132751279585, 0.04122920716522005, 0.03039855961002247, 0.06249797773206467, 0.07784513825605466, 0.06534990132739293, 0.04295638098080912, 0.05867308096437396, 0.009643302944248533, 0.00864125604110011, 9.999999999998899e-05, 0.018726229892102153, 0.024139589005578443, 0.021097417229920423, 0.01886839194484835, 0.015794338772836092, 0.03309791427199271, 0.035684685043532394, 0.027265060200716285, 0.0249657076018317, 0.02477620855256757, 0.054292666670720746, 0.005419983769879622, 0.04159228931563552, 0.01807078829868336, 0.026242958232512992, 0.26222159901252506, 0.2509323338922058, 0.2715170723775331, 0.2858942950493605, 0.27670650752776504, 0.28615205309341907, 0.25672723518425633, 0.264625195644559, 0.25906358434072874, 0.05766808749681296, 0.061652564016312694, 0.06403646649158123, 0.06196167322843815, 0.05215976895394392, 0.05766481782838817, 0.05368888865856569, 0.05072557333706318, 0.0632999535470341, 0.18303398267740012, 0.16046748676099465, 0.15319071786582394, 0.14572500669825983, 0.15926277960612645, 0.1441600652876256, 0.14702531787993178, 0.15020058717912033, 0.14144428648226426, 0.20185414556784342, 0.18103042311469764, 0.17679873167754445, 0.22071257686204326, 0.2089480917477795, 0.18722978914264, 0.20002204927500766, 0.21555776160228945, 0.21372392861057665, 0.12252383971138425, 0.1303940534666499, 0.13341915500508073, 0.1206807040595611, 0.13907713803935096, 0.14275181417591543, 0.11591442917519967, 0.1315948493178828, 0.12907106329327944, 0.1687745903584268, 0.1556117446915548, 0.15578266223362647, 0.15239649045245496, 0.15341290147168807, 0.15138414057760818, 0.1620100018568904, 0.1599585467904241, 0.18170841012636896, 0.11967144650523387, 0.15111153086485907, 0.1063779867944129, 0.12559931613720188, 0.11789853147607032, 0.10983821042004116, 0.13062752615691187, 0.15092679606157144, 0.14671203757176432, 0.13113477870787427, 0.15384135853109038, 0.3073742574651843, 0.16211515673413301, 0.14626753575264573, 0.14811116491358367, 0.154236848821943, 0.1445782979499587, 0.29481251758627514, 0.14203549599685505, 0.1400298602993153, 0.2212164431731699, 0.17859759740985537, 0.1983247261701998, 0.1385442293265935, 0.1770536941757619, 0.17865892147173978, 0.18703619537387206, 0.20279860186837795, 0.1776655105038315, 0.19581357396424148, 0.19194751192232518, 0.175870607888314, 0.17806647976206658, 0.18076302628317786, 0.1805182042079927, 0.1842205964976441, 0.054267436846522465, 0.057868072152693406, 0.0526688048607622, 0.053931713014301, 0.05595629162310489, 0.04915621415863902, 0.04766461123626542, 0.048777174925106026, 0.05157935914286593]}, "mutation_prompt": null}
{"id": "2492a0e5-ff7d-46e4-9a8d-20bb1f38d1c8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8  # Removed fixed assignment\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))  # Velocity clamping\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                # Adaptive crossover rate based on progress\n                self.crossover_rate = 0.7 + 0.3 * (eval_count/self.budget)\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Dynamic inertia weight adjustment\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            # Dynamic population size adaptation\n            self.population_size = 10 + 2 * int(np.sqrt(self.dim)) * (1 + eval_count/self.budget)**0.5\n            pop = new_pop[:self.population_size]\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic population size adaptation and adaptive crossover rate for improved convergence.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('slice indices must be integers or None or have an __index__ method').", "error": "TypeError('slice indices must be integers or None or have an __index__ method')", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {}, "mutation_prompt": null}
{"id": "9888f03d-35f4-4fb0-97cd-4f5465a624bc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                # Local search enhancement\n                local_search_rate = 0.1 * np.exp(-eval_count/self.budget)\n                if np.random.rand() < local_search_rate:\n                    candidate += np.random.uniform(-0.1, 0.1, self.dim)\n                    candidate = np.clip(candidate, lower_bound, upper_bound)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhance Particle Swarm Optimization by introducing a dynamic local search mechanism and adaptive parameter tuning to improve convergence.", "configspace": "", "generation": 91, "fitness": 0.15199687443186413, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.31360521370835637, 0.2860808621484866, 0.2794259191466889, 0.30728016428480764, 0.31239617139277553, 0.3162597061806084, 0.2954800251518026, 0.31857886777385225, 0.30910869400404395, 0.059030539987393826, 0.05363770057426098, 0.06209606469153717, 0.06936113935630661, 0.06265373637217597, 0.06921421573993303, 0.06166886593978904, 0.062322292461458484, 0.047508439757177445, 0.05989667490136075, 0.06261683597451972, 0.05145676539277122, 0.05786361857452671, 0.07032588817737506, 0.06105734849871647, 0.057146124636158646, 0.058508230028670005, 0.06668497744674717, 0.053664218957563015, 0.05326941093771842, 0.04728795608446834, 0.046331774336379694, 0.05035407495184152, 0.0483756418070318, 0.04267696941341159, 0.04426907375927858, 0.04287103256279157, 0.9601969557247839, 0.9839790779990302, 0.9607202360632262, 0.9887973094006095, 0.9901344985024663, 0.980147270168386, 0.9344900692795429, 0.9189361194137993, 0.9461319477987122, 0.140255732811706, 0.15294179688667642, 0.16330318299017677, 0.12631868852695083, 0.15872376544964806, 0.13754961185328407, 0.1621655014274882, 0.1639046543237862, 0.13870419289376024, 0.145250664773943, 0.13574741578243033, 0.14283357558415577, 0.14200572239376874, 0.15074988628195274, 0.14981036075246645, 0.15499708497617826, 0.144414813040037, 0.13172633238957676, 0.04148032226429299, 0.05191744791295749, 0.05394459659580331, 0.04197918803046019, 0.04968857736136556, 0.04911764928129947, 0.04638243687078014, 0.044470490831337695, 0.04885940009891199, 0.03576567677582332, 0.04479948907399589, 0.04249400583085261, 0.06896227386342557, 0.039129260683015255, 0.04520251556082533, 0.05384996093909811, 0.05359266755361691, 0.04646735474451669, 9.999999999998899e-05, 0.00018271381058510006, 9.999999999998899e-05, 0.0017730265587307947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03147637953554294, 0.052395405468366185, 0.05385246205733074, 0.04137841196861303, 0.019907239824893952, 0.03441935092001802, 0.0675228663207863, 0.050649070275137986, 0.07311605773226237, 0.005901068245217522, 0.01958783562635069, 0.01714001077198679, 0.014101139370091054, 0.015961966683958773, 0.016397497535178274, 0.013469921078611113, 0.014737083105642146, 0.0181278977472763, 0.039660239668641184, 0.01380906763176204, 0.030106166437595117, 0.0446389253360272, 0.04281475524282796, 0.04948048378241743, 0.021829709835415656, 0.03983470110400378, 0.021301294553471073, 0.24151668265010362, 0.2598107987124312, 0.2499095449222023, 0.2573068514462362, 0.26367547024894156, 0.2721072472661422, 0.25417034609259115, 0.25748928696706397, 0.25737852991531385, 0.05936538075620956, 0.06226975924183187, 0.06537384521890277, 0.06261643545510798, 0.06522560598267879, 0.0653058446880872, 0.060616178162087864, 0.06357662671712372, 0.05557628949115245, 0.14402178106228636, 0.1604320612257807, 0.15174238794375783, 0.11971688436396344, 0.15936378452415978, 0.13867527728752815, 0.14897639400140328, 0.14146907392021435, 0.1402542723818968, 0.20076762627893718, 0.1918394891059636, 0.1918768850164102, 0.20643604510916003, 0.19796413469997343, 0.18639163688914262, 0.22001087260566943, 0.21880509692628725, 0.21869081030872872, 0.1408234452966819, 0.13035958758478905, 0.13518305943371545, 0.1329739726876753, 0.1453319916616207, 0.1448704375218085, 0.13062768350120768, 0.12207069729897957, 0.15506494552682215, 0.14359344809384633, 0.17120584741497535, 0.1597440298502938, 0.14606295288588322, 0.17082356554550748, 0.14160464656413174, 0.18163368863097507, 0.16238061824000583, 0.15756696502756062, 0.14108610654966436, 0.150066709035249, 0.13397917329793696, 0.12237334946746392, 0.13560832205599704, 0.1251134632023646, 0.16034128759684896, 0.1430264719625608, 0.12645888315284104, 0.2681776691219676, 0.3212363620315798, 0.23910565653368854, 0.14873107363832783, 0.15680067765221084, 0.15263409322372645, 0.16004671627857492, 0.15228892724817, 0.30834891002333253, 0.13989476107288612, 0.16995536574077286, 0.16906921287693644, 0.16280327419470064, 0.14110215109906588, 0.1412778457694689, 0.18653319472935415, 0.18405366224562592, 0.2600970610281942, 0.1821286662960665, 0.18690779713818484, 0.18837443316112545, 0.17411531256469948, 0.1795707520523785, 0.20740094825190314, 0.19686545296135827, 0.18424598641669254, 0.1814765248224819, 0.050468316416041326, 0.052248214785195146, 0.055131523634092794, 0.05665404595328838, 0.05097354886116501, 0.049814332089706315, 0.056140630007685655, 0.05729660363456246, 0.04897682195211839]}, "mutation_prompt": null}
{"id": "4dbec6e2-de9d-4a25-baa6-7d3499a5e1b1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9  # Adjusted for more exploration initially\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive cognitive coefficient\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                # Begin of adaptive local search\n                if np.random.rand() < 0.2:\n                    local_search = candidate + 0.1 * np.random.randn(self.dim)\n                    local_search = np.clip(local_search, lower_bound, upper_bound)\n                    if func(local_search) < func(candidate):\n                        candidate = local_search\n                # End of adaptive local search\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive local search and improved crossover for enhanced exploitation and diversity.", "configspace": "", "generation": 92, "fitness": 0.12039926770084054, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.15556864649344893, 0.15883355891259032, 0.16637229100116457, 0.1834142726443495, 0.19478327152235375, 0.19963049457420035, 0.18368488344491618, 0.1918848264503844, 0.18942468103880372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038135958006900506, 0.033891916709741565, 0.044880480537251244, 0.038486114683717876, 0.04478490235810473, 0.04189896936445381, 0.029518769653395394, 0.04451593786288721, 0.05499987373171422, 0.03972161028608023, 0.027282399373675603, 0.03587222481868135, 0.027304945169982386, 0.02723215492027553, 0.020011051466652496, 0.02400227670732824, 0.027671768212298553, 0.023353132114735664, 0.9776988084198165, 0.9747264066963325, 0.8603761856892358, 0.9419333331897335, 0.9547142222055794, 0.8944169993122797, 0.929227228484457, 0.9600016980504029, 0.9883741822468481, 0.06569455510044431, 0.06796024336526718, 0.07125304610594518, 0.08526676487110074, 0.06863750059938178, 0.0799763587217247, 0.07191308773358618, 0.0844590850278939, 0.08929373241632654, 0.11946498719990961, 0.17023030802459105, 0.11879703760774496, 0.1201985062040285, 0.11412941283700406, 0.10931403971776976, 0.10671842518320496, 0.12492984522235151, 0.11843829177298615, 0.0033283042795592133, 0.013310453175760628, 0.00015459807476125853, 0.016870156842477946, 0.011179225463246123, 0.007776927382700194, 0.0016961231167668123, 0.030114083170277417, 0.00850946217045001, 0.013016236346393262, 0.035743566097995116, 0.028109843644555932, 0.00767404380127612, 0.003105377842116064, 0.03699705706488099, 0.005663799248228352, 0.017417355871018114, 0.009492521427116318, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03815668992234933, 0.04662880754626697, 0.04369954114352348, 0.00820242041351471, 0.05221018443455827, 0.06800564356169836, 0.04510509527150075, 0.04164073458863804, 0.02947857736086046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031570496125538083, 0.0012561874900735015, 0.002799311057382514, 0.00270085420695354, 0.000491751000957108, 0.0024317214377466145, 0.007049490593476704, 0.01749678470567506, 0.0015955888046433886, 0.17149020016142513, 0.17527881629913644, 0.19302114552204352, 0.19692081136632633, 0.19795817262768123, 0.20236020926126463, 0.17841006484650845, 0.17889307016817368, 0.1907436448377281, 0.05620713041862002, 0.043021540206753195, 0.04566775125062683, 0.045292570532293075, 0.04538883188287324, 0.04557045073170485, 0.0415587145145222, 0.04702956145733295, 0.04647074023862585, 0.14023682641252055, 0.14435709134414465, 0.13303292410582268, 0.14917237898369917, 0.12544465690155537, 0.13032936432989317, 0.1400364583756053, 0.13667098344800777, 0.13516843479845497, 0.16866642955818956, 0.1642867136954812, 0.16087885676274005, 0.15033649464411392, 0.17231151896830343, 0.16311346809552596, 0.16416470231409164, 0.1743801331358238, 0.17126792117434453, 0.10758129655945503, 0.1003084213853801, 0.10129336751939666, 0.10293064429782484, 0.1066853073589833, 0.09516314654761304, 0.10398346521253587, 0.10083226883495733, 0.10506271932414968, 0.13263789812270588, 0.14065020615541668, 0.1451050224549435, 0.15311608952440015, 0.14334433382761635, 0.13749444754761275, 0.1554272019088827, 0.1403079221655551, 0.15086656757840977, 0.13640103053246366, 0.13561286984290488, 0.09255550176623761, 0.08977338482651087, 0.11934991533909833, 0.1541742073375748, 0.10178141164476806, 0.09934569089844847, 0.14643714604832825, 0.1558648410107799, 0.14095946617398059, 0.16420697965511355, 0.12416486555409023, 0.14748887507866693, 0.14935716661196508, 0.12578530396160037, 0.1650058149612771, 0.1377230183998186, 0.1609785869836189, 0.1425810264324724, 0.15481686863325483, 0.10443636566287273, 0.137567091753254, 0.13636280042973759, 0.1778896681726726, 0.16016090347079115, 0.18492331836182696, 0.1825063742128864, 0.18692246960088377, 0.1759208325252395, 0.17712530511083857, 0.1902390812861926, 0.17187838467811312, 0.19107045153985402, 0.18647458391923255, 0.20200729060228528, 0.0416269479778093, 0.039197641036124, 0.04253143568919715, 0.04449216527654842, 0.03928544274270407, 0.042081363226633806, 0.039775284620800044, 0.03893572381279131, 0.04026654404351104]}, "mutation_prompt": null}
{"id": "3083ddf6-4703-45d9-a746-cfd602b194a9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n\n        # Initialize chaotic map for improved exploration\n        chaotic_map = np.random.rand(self.dim)\n\n        while eval_count < self.budget:\n            new_pop = []\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -self.velocity_clamp, self.velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                # Apply chaotic map to mutation factor for adaptive changes\n                chaotic_map = 4 * chaotic_map * (1 - chaotic_map)  # Logistic map\n                self.mutation_factor = 0.6 + 0.4 * chaotic_map.mean()\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                # Adjust dynamic inertia weight using chaotic influence\n                self.inertia_weight = 0.9 - 0.9 * chaotic_map.mean()\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration with chaotic maps and adaptive dynamic parameters for improved convergence in hybrid PSO-DE.", "configspace": "", "generation": 93, "fitness": 0.1172298633261187, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.16916167604289734, 0.18509798614360917, 0.16024937728818256, 0.16327730210632707, 0.1539417161186558, 0.19082614179843893, 0.17793853467404608, 0.17481049369253088, 0.1521630912515457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03862982575620877, 0.03059232316861693, 0.037898575134980295, 0.03748122107393648, 0.03806530272900277, 0.04219378469740498, 0.03911709212032077, 0.03150747905136453, 0.038251600948655096, 0.04030122305129513, 0.030531697882267284, 0.018460318826047817, 0.031702692666418786, 0.03968443571516922, 0.02273965090279484, 0.023130976619114008, 0.020516230664771817, 0.01587746535328971, 0.9641879767711647, 0.9732182880079904, 0.8259232345398768, 0.9607929051982673, 0.9066142519259783, 0.8944240269650195, 0.8634301702540377, 0.9269862855508872, 0.9130552359404405, 0.047059335311120054, 0.05932952257544455, 0.04536534055115937, 0.06311793553632539, 0.07729102577873814, 0.08643608933908986, 0.0738918869647055, 0.07153804927620788, 0.061880172709037784, 0.1081465721565259, 0.10101388597455718, 0.1465979891557918, 0.12153738531798097, 0.1002129148348535, 0.09766537509521445, 0.11629142818163218, 0.10613627882568366, 0.11656030167090725, 0.0005105368000934973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02146670785383753, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030303251883058713, 9.999999999998899e-05, 9.999999999998899e-05, 0.008022774825220735, 0.022097182050587638, 0.02486498634931178, 0.00015108194083912618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042659663512337964, 0.055877007367898135, 0.03649069637956659, 0.03228922628782671, 0.010939611642173608, 0.03555582338147123, 0.09459062491747772, 0.029280711991448105, 0.029348556019178962, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010924938848033694, 9.999999999998899e-05, 0.00367620784688516, 0.17040902250508916, 0.19816234439919644, 0.19936161098211513, 0.19402915883599603, 0.1754652045154217, 0.17625027727690945, 0.20015217548172437, 0.1951363752039661, 0.17985342772115565, 0.039621727199360746, 0.043692156910074886, 0.03697647509599533, 0.0494541439164925, 0.0366935772298721, 0.059047513084146575, 0.033354440964510235, 0.035235907515409615, 0.03695233399598874, 0.12871613235408408, 0.1376756487108023, 0.14021987576207207, 0.1361681895504967, 0.15229262728837634, 0.14914210898868407, 0.13446013534237267, 0.11824893491558464, 0.14127507317962262, 0.16449535923468628, 0.16253305253568884, 0.15541036137172792, 0.15229881610241114, 0.15976963450267745, 0.15103720142860544, 0.1446860994701703, 0.14981088968040202, 0.1486671825180521, 0.08953688500466817, 0.09149655790237377, 0.10397587298886524, 0.10064430112412415, 0.08855714675645032, 0.13857231887875043, 0.11681369834169364, 0.10820439947301275, 0.09135532649649702, 0.14737233230206515, 0.14598231227970604, 0.14402675709443957, 0.16194083294360628, 0.13781934358746561, 0.15479083497988655, 0.14607970810996507, 0.14314302650707955, 0.16255115867614678, 0.1365109590433381, 0.14697629567157577, 0.13133691452474572, 0.11544996001179775, 0.1365098862956856, 0.1388878594071442, 0.10116899524024903, 0.12284455831083996, 0.13920092938778073, 0.14577668609543726, 0.1288532469239, 0.1466892571763776, 0.14271541191539217, 0.1307676361476593, 0.13352966889935813, 0.15610141793755317, 0.1327652289892136, 0.14501320782971638, 0.14674653339219845, 0.18656405609250737, 0.11941607381790487, 0.15243033207126522, 0.16131820712283262, 0.14155872365482247, 0.160688250403056, 0.15573927301708368, 0.1932468067210682, 0.19769024175126404, 0.21308323390736927, 0.17748594091438585, 0.18736171773801946, 0.1918134651881669, 0.19410326477900375, 0.1887567476277775, 0.1800068309754359, 0.17782941522757667, 0.04518068099057926, 0.044888721191905234, 0.05053026154489648, 0.04304776420551548, 0.039061506868684814, 0.045453222984038644, 0.03927314471113619, 0.040220316797261346, 0.04185363539716058]}, "mutation_prompt": null}
{"id": "c8fe3a91-57d9-4b8e-848a-4ce817cbb194", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced local search through dynamic velocity adjustment and memory-based mutation for improved convergence stability.", "configspace": "", "generation": 94, "fitness": 0.31737948617967926, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "45711685-bc82-44ce-b585-12bd22cec221", "metadata": {"aucs": [0.7245648176266754, 0.7463826304926682, 0.7414969474633857, 0.7751800298084601, 0.7506160987799055, 0.7690928285273666, 0.727435393802685, 0.7502930809829704, 0.7649515338962627, 0.6097866681620863, 0.6094784572094292, 0.6037499599822704, 0.6062625674648436, 0.5843252947692719, 0.5873983817240134, 0.5922853193647586, 0.601578003033659, 0.6124151095082896, 0.16649777471279448, 0.5363300904607349, 0.11463127808424611, 0.14141707907048318, 0.4666699229090865, 0.131303109551678, 0.1436505647630476, 0.17275578529515645, 0.12042426107905235, 0.11611592592852416, 0.1248554603545663, 0.09502634187699854, 0.11659790788694502, 0.13269024840891774, 0.12433686367746688, 0.09872338399475489, 0.11977990121136117, 0.10066016334590133, 0.9655116893024094, 0.9744465598848518, 0.9729262302626218, 0.9775469327078556, 0.9797090973534657, 0.9693565144774623, 0.9745190528156219, 0.9872578179887014, 0.9921564825108657, 0.5005028956684857, 0.4943923254184823, 0.5068218412988925, 0.5075227020666273, 0.49470584172026444, 0.5107645065985233, 0.5279822939976815, 0.5058559136798255, 0.5444508432677633, 0.730931776166481, 0.6410254002530003, 0.7039036564333776, 0.5406378024406795, 0.6360502048973089, 0.7365508339582567, 0.8187425951198208, 0.7851197715793664, 0.7028000892224069, 0.2053607567218232, 0.24275245217175967, 0.18629477082471235, 0.21373443314236873, 0.18955283958752955, 0.2181598042559707, 0.2042366299116477, 0.21227142580450142, 0.22550015278559843, 0.20427450482301535, 0.05304586321436455, 0.1096407672485964, 0.31601950121457756, 0.23681337550705994, 0.22054292262300346, 0.1097508767883355, 0.24279875290580166, 0.22841415291928024, 0.06749948429597097, 0.1311779154462045, 0.05018733034489631, 9.999999999998899e-05, 0.042243545672678184, 0.04338974914928473, 0.09951054012247473, 0.11041667151952061, 0.10937409791047026, 0.15218232769490747, 0.1770861548691428, 0.22258269455200164, 0.18957570899275022, 0.1910216725685394, 0.15580017772930332, 0.19418930289128855, 0.2012018937447786, 0.243423023443476, 0.0006316323634942833, 0.004634880486398707, 0.04785746027034199, 0.06683036817161225, 0.06819039673292793, 0.027336824422444117, 0.08302477567774602, 0.01197528157465133, 9.999999999998899e-05, 0.15026337974624582, 0.153361375845668, 0.16138429875769567, 0.13314770211635918, 0.15813691353368575, 0.186568515347312, 0.15908545146035524, 0.17040892030393828, 0.15537547312505962, 0.49102681534803505, 0.45317372934525224, 0.48548476760521364, 0.5148315234700107, 0.4987972533964593, 0.5141904591702892, 0.5126854045928606, 0.5152326174630628, 0.4912616112344439, 0.14681077355647176, 0.09928817777785715, 0.12634256282605805, 0.096120679187502, 0.12796693410834992, 0.12379198841680772, 0.13192462310389652, 0.10900756955687263, 0.12755791214463952, 0.12275334913537606, 0.1397344543689376, 0.15829049363635006, 0.4130156359892456, 0.1844740035559994, 0.2830252319728077, 0.23847714047042567, 0.4422884987360195, 0.2784134049512569, 0.32291618852287085, 0.3528642554733832, 0.3495195529641869, 0.39573761811687913, 0.44916883696746945, 0.32158190700208666, 0.3924668716529688, 0.3550775958322949, 0.3982165022693529, 0.288800396960448, 0.23151317774175417, 0.25702054841294797, 0.2516630976466254, 0.30620665236974964, 0.25875027960143926, 0.2705433026284382, 0.2936349730736424, 0.3034985373197078, 0.17909639858367576, 0.17340662960621045, 0.17625052278963815, 0.16554877673542234, 0.182345314506551, 0.1856073369003005, 0.18494748758438861, 0.2173999301864321, 0.1936258924357499, 0.21335487492152738, 0.2121873857636115, 0.5527361234770911, 0.32033378822809133, 0.4199136941236682, 0.19462339657685102, 0.2224827280127013, 0.2910549473773173, 0.5365227417107621, 0.16711641403549526, 0.18212141693487127, 0.14267356356320016, 0.15446039171883075, 0.17748542674888923, 0.16486490180678937, 0.1819676184959217, 0.7934181162759619, 0.1813456149409698, 0.1671937399059965, 0.2080884753168959, 0.48665734976997976, 0.6628189800523439, 0.20092009591260251, 0.2022287888949097, 0.12773860247828783, 0.7549965778841846, 0.125226314055777, 0.18498693324556048, 0.18312371665729743, 0.18488259307946542, 0.2742712240472538, 0.17231086537603746, 0.25700424118380405, 0.21337395102168433, 0.24117239658274503, 0.2121209127014333, 0.07612051823777344, 0.08086332259971118, 0.08093731554807948, 0.08141546674166233, 0.06717841412405157, 0.08191158817327249, 0.07761459812019511, 0.07737373469726538, 0.07900817504938806]}, "mutation_prompt": null}
{"id": "9e10cf4e-3b1c-498a-9a40-0614d7493d09", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    vel[i] = np.random.uniform(-dynamic_velocity_clamp, dynamic_velocity_clamp, self.dim)\n                else:\n                    r1 = np.random.rand(self.dim)\n                    r2 = np.random.rand(self.dim)\n                    vel[i] = (self.inertia_weight * vel[i] +\n                              self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                              self.social_coefficient * r2 * (global_best - pop[i]))\n                \n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Optimized hybrid algorithm with adaptive diversity injection and enhanced exploration through intermittent random walks.", "configspace": "", "generation": 95, "fitness": 0.2779917368896423, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "c8fe3a91-57d9-4b8e-848a-4ce817cbb194", "metadata": {"aucs": [0.6421094378951202, 0.6288505666750702, 0.6726991304611236, 0.6738172158266384, 0.6936197404019855, 0.6807767592046315, 0.6551221266170376, 0.6362905489787106, 0.6617491611404158, 0.4200349223902794, 0.38202307746087394, 0.3915265083240814, 0.38496817802415517, 0.3757377256811013, 0.3911716559719617, 0.38892567211762863, 0.39190442671571724, 0.4255294435567598, 0.18517523742320952, 0.13664049636596443, 0.10119026318215418, 0.10290291586588396, 0.16567714960075997, 0.11130768995652274, 0.11659508581420486, 0.1653252614717743, 0.12470022403772141, 0.12031806549674928, 0.12290035616945882, 0.12820729550481225, 0.11247098324268334, 0.11786573511015797, 0.10206642614627803, 0.1009052677786747, 0.09408887379550723, 0.11311836140256915, 0.9534741857448964, 0.9837070225253278, 0.9638127924057118, 0.9621868075835838, 0.9689503543255652, 0.9617868870683418, 0.9706475475511078, 0.9861843278535322, 0.9854130723209117, 0.3830586986358864, 0.4237301995778011, 0.3867078832583918, 0.3876416570260337, 0.3949688610618943, 0.42050821069903155, 0.3972124477516521, 0.3885839234053331, 0.39531987350714315, 0.736233119463054, 0.747827282825196, 0.6194289718585295, 0.7315046231693914, 0.6453621054349585, 0.6288816903827854, 0.5583077455367085, 0.7149692647414945, 0.708624021676181, 0.18534507169288428, 0.20292756590491612, 0.2439825509391922, 0.18238541548876575, 0.18111779906453018, 0.20748670260150592, 0.2036582646668912, 0.1971496759309761, 0.21727717787819234, 0.1254119430718018, 0.23644161957943732, 0.12571415569229594, 0.22407970675049682, 0.20714460600761253, 0.23203407709436308, 0.20267932950390455, 0.20143976826055476, 0.2299395469393587, 0.10258018079093523, 0.06810024126920367, 0.08926448224884642, 0.038575624076810366, 0.0018771394074831305, 0.10962497559229978, 0.03928387245956566, 9.999999999998899e-05, 0.043981094122907405, 0.18749437915521971, 0.2897780905346977, 0.24191878804547173, 0.18464585090385777, 0.22190281448298133, 0.04435802894757557, 0.24932796713912608, 0.23578561322480884, 0.2674088909111415, 0.0008417471581000369, 0.02280987095394338, 0.0011673382533059495, 0.07139515348754777, 0.0020934632289303368, 0.00011622934855326505, 9.999999999998899e-05, 0.05033917151462175, 0.024731118749256153, 0.13648464668912696, 0.13608598432120722, 0.13456225489696738, 0.14513116005434623, 0.13859217854927264, 0.1597321132276709, 0.1345153373758723, 0.14092969750064954, 0.12754789371382702, 0.48410909526432133, 0.5010823763031169, 0.4770055156540197, 0.4647107746128004, 0.49092372518622096, 0.49691424864852196, 0.45584807636230495, 0.47802806451166735, 0.46038763984620834, 0.10658147915968186, 0.11346664447684451, 0.10939538592966769, 0.11507201203456807, 0.11664690271775502, 0.09488308333181117, 0.13680888147768877, 0.103266709381452, 0.09379192680235537, 0.1469619698063056, 0.386023992715954, 0.39266859471614934, 0.4353778618287786, 0.1209906272071245, 0.14602855143185767, 0.20959041238595377, 0.15590087442803047, 0.19748638342650138, 0.3276513856535338, 0.3272505343796105, 0.3355151658782938, 0.33978549907771616, 0.3389881654302258, 0.330949213554377, 0.35576551053095506, 0.3449868063271154, 0.3614174580713827, 0.24497875785162282, 0.23543028438066882, 0.24143808036144865, 0.2463287418586042, 0.24715158495384837, 0.23251579812420198, 0.2436013805297882, 0.14550821204210884, 0.2696419891945534, 0.181953987934662, 0.1833641269287276, 0.1876879894293928, 0.20341518455499885, 0.17148189073211284, 0.18343639223102615, 0.18214217681442924, 0.1890499290137887, 0.22266239861951398, 0.22726789401290548, 0.21219997405705404, 0.27913822625650553, 0.30545155012365355, 0.19829291168903806, 0.24486162428981162, 0.3874913240497224, 0.19789096570493658, 0.21338690342421884, 0.16528927136357818, 0.16002894354519848, 0.15284242718647711, 0.1738445288029712, 0.1726817494400168, 0.2086159902063882, 0.20506356079296117, 0.18581990960617534, 0.1999918305448356, 0.20712632994356317, 0.16767568084469953, 0.20856559868616464, 0.1997615969507306, 0.20289252014726167, 0.20312909530470025, 0.20874165206894868, 0.12650541567172435, 0.21229744562066255, 0.19386752769595084, 0.1842988213440936, 0.19484809035963224, 0.22440202943800092, 0.19965103644323956, 0.18248537707772616, 0.1846905542213888, 0.19056054805956169, 0.19063871316013425, 0.08991614983340512, 0.09036759558519802, 0.08073344685285788, 0.07076335260019728, 0.08571864161192644, 0.07928558871293112, 0.07446659186673188, 0.08534412373104827, 0.08052767252480442]}, "mutation_prompt": null}
{"id": "044a112a-8bb8-423a-bf8b-a201427018fc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * (1 - eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 - 0.9 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced local search through dynamic velocity adjustment and memory-based mutation for improved convergence stability.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c8fe3a91-57d9-4b8e-848a-4ce817cbb194", "metadata": {"aucs": [0.7245648176266754, 0.7463826304926682, 0.7414969474633857, 0.7751800298084601, 0.7506160987799055, 0.7690928285273666, 0.727435393802685, 0.7502930809829704, 0.7649515338962627, 0.6097866681620863, 0.6094784572094292, 0.6037499599822704, 0.6062625674648436, 0.5843252947692719, 0.5873983817240134, 0.5922853193647586, 0.601578003033659, 0.6124151095082896, 0.16649777471279448, 0.5363300904607349, 0.11463127808424611, 0.14141707907048318, 0.4666699229090865, 0.131303109551678, 0.1436505647630476, 0.17275578529515645, 0.12042426107905235, 0.11611592592852416, 0.1248554603545663, 0.09502634187699854, 0.11659790788694502, 0.13269024840891774, 0.12433686367746688, 0.09872338399475489, 0.11977990121136117, 0.10066016334590133, 0.9655116893024094, 0.9744465598848518, 0.9729262302626218, 0.9775469327078556, 0.9797090973534657, 0.9693565144774623, 0.9745190528156219, 0.9872578179887014, 0.9921564825108657, 0.5005028956684857, 0.4943923254184823, 0.5068218412988925, 0.5075227020666273, 0.49470584172026444, 0.5107645065985233, 0.5279822939976815, 0.5058559136798255, 0.5444508432677633, 0.730931776166481, 0.6410254002530003, 0.7039036564333776, 0.5406378024406795, 0.6360502048973089, 0.7365508339582567, 0.8187425951198208, 0.7851197715793664, 0.7028000892224069, 0.2053607567218232, 0.24275245217175967, 0.18629477082471235, 0.21373443314236873, 0.18955283958752955, 0.2181598042559707, 0.2042366299116477, 0.21227142580450142, 0.22550015278559843, 0.20427450482301535, 0.05304586321436455, 0.1096407672485964, 0.31601950121457756, 0.23681337550705994, 0.22054292262300346, 0.1097508767883355, 0.24279875290580166, 0.22841415291928024, 0.06749948429597097, 0.1311779154462045, 0.05018733034489631, 9.999999999998899e-05, 0.042243545672678184, 0.04338974914928473, 0.09951054012247473, 0.11041667151952061, 0.10937409791047026, 0.15218232769490747, 0.1770861548691428, 0.22258269455200164, 0.18957570899275022, 0.1910216725685394, 0.15580017772930332, 0.19418930289128855, 0.2012018937447786, 0.243423023443476, 0.0006316323634942833, 0.004634880486398707, 0.04785746027034199, 0.06683036817161225, 0.06819039673292793, 0.027336824422444117, 0.08302477567774602, 0.01197528157465133, 9.999999999998899e-05, 0.15026337974624582, 0.153361375845668, 0.16138429875769567, 0.13314770211635918, 0.15813691353368575, 0.186568515347312, 0.15908545146035524, 0.17040892030393828, 0.15537547312505962, 0.49102681534803505, 0.45317372934525224, 0.48548476760521364, 0.5148315234700107, 0.4987972533964593, 0.5141904591702892, 0.5126854045928606, 0.5152326174630628, 0.4912616112344439, 0.14681077355647176, 0.09928817777785715, 0.12634256282605805, 0.096120679187502, 0.12796693410834992, 0.12379198841680772, 0.13192462310389652, 0.10900756955687263, 0.12755791214463952, 0.12275334913537606, 0.1397344543689376, 0.15829049363635006, 0.4130156359892456, 0.1844740035559994, 0.2830252319728077, 0.23847714047042567, 0.4422884987360195, 0.2784134049512569, 0.32291618852287085, 0.3528642554733832, 0.3495195529641869, 0.39573761811687913, 0.44916883696746945, 0.32158190700208666, 0.3924668716529688, 0.3550775958322949, 0.3982165022693529, 0.288800396960448, 0.23151317774175417, 0.25702054841294797, 0.2516630976466254, 0.30620665236974964, 0.25875027960143926, 0.2705433026284382, 0.2936349730736424, 0.3034985373197078, 0.17909639858367576, 0.17340662960621045, 0.17625052278963815, 0.16554877673542234, 0.182345314506551, 0.1856073369003005, 0.18494748758438861, 0.2173999301864321, 0.1936258924357499, 0.21335487492152738, 0.2121873857636115, 0.5527361234770911, 0.32033378822809133, 0.4199136941236682, 0.19462339657685102, 0.2224827280127013, 0.2910549473773173, 0.5365227417107621, 0.16711641403549526, 0.18212141693487127, 0.14267356356320016, 0.15446039171883075, 0.17748542674888923, 0.16486490180678937, 0.1819676184959217, 0.7934181162759619, 0.1813456149409698, 0.1671937399059965, 0.2080884753168959, 0.48665734976997976, 0.6628189800523439, 0.20092009591260251, 0.2022287888949097, 0.12773860247828783, 0.7549965778841846, 0.125226314055777, 0.18498693324556048, 0.18312371665729743, 0.18488259307946542, 0.2742712240472538, 0.17231086537603746, 0.25700424118380405, 0.21337395102168433, 0.24117239658274503, 0.2121209127014333, 0.07612051823777344, 0.08086332259971118, 0.08093731554807948, 0.08141546674166233, 0.06717841412405157, 0.08191158817327249, 0.07761459812019511, 0.07737373469726538, 0.07900817504938806]}, "mutation_prompt": null}
{"id": "e972127f-e7f1-4b8d-bcbb-8938af396dfe", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * np.exp(-0.5 * eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 * (1 - eval_count/self.budget) + 0.4 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Adaptive inertia weight and self-adaptive crossover rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.3608379634177561, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "c8fe3a91-57d9-4b8e-848a-4ce817cbb194", "metadata": {"aucs": [0.8115185469934141, 0.7794303003420799, 0.7815917797844647, 0.8152016287793051, 0.8124656537157376, 0.7889352936527309, 0.7851916786537118, 0.7845683763654545, 0.7974943569136586, 0.6488251563573092, 0.6349511324122172, 0.6828481469324157, 0.6564935143606184, 0.6592149097705289, 0.6496206775261351, 0.6688301092668836, 0.6650144664675957, 0.6594332337995152, 0.1296287570158171, 0.14462422990430002, 0.14993607054368918, 0.39457477378417793, 0.1509140750380582, 0.17114836013188883, 0.16341363945916532, 0.144012402618934, 0.12093764025274845, 0.12339118214643152, 0.15149272005255465, 0.12306536587682915, 0.11490006730349323, 0.10446463443516352, 0.12673312633624578, 0.10562349780418012, 0.13316699576641278, 0.14504516665673128, 0.972981441355913, 0.9681935372138087, 0.977851093533458, 0.9691323290227607, 0.9797069528963764, 0.9706472594249115, 0.9653395812374643, 0.98725783059153, 0.9921564825108657, 0.5707640246327617, 0.5587653857968028, 0.5594866225035993, 0.5836827965070777, 0.542992913149785, 0.6091226009732508, 0.5450949323964953, 0.5665299472424697, 0.5772350009097501, 0.8056127560408601, 0.6876351663073524, 0.8007509060881246, 0.8142777188226814, 0.7807948388085139, 0.7724002900979704, 0.8194003017473027, 0.23165628785199355, 0.8187909065356762, 0.4217705662233717, 0.3865858503031341, 0.38524138473976055, 0.4363013935764345, 0.37978882932500846, 0.12669362487931557, 0.3531722590541675, 0.4323701210060059, 0.35132114657975666, 0.13171032327263676, 0.05258688461077399, 0.33990465260083524, 0.3838355975583787, 0.3719982849584532, 0.3921369753130576, 0.11813502680720323, 0.43935220407522435, 0.37960519337836374, 0.41624439731886476, 0.1796165094354012, 0.14001382733325285, 0.07262042562358706, 0.04679302573382971, 0.14517167088549687, 0.2220357055945953, 0.21152124978921316, 0.17244332613327695, 0.14200576646522278, 0.1400358908332322, 0.21724484558908985, 0.1539207402799373, 0.15019748369290575, 0.39492291148583525, 0.45194618480632687, 0.44410114561679115, 0.364450396607254, 0.1168756382092424, 0.05244898113619201, 0.057547494328599735, 0.15405576673280885, 0.08475577496431885, 0.17194846689696874, 0.0915997851967002, 0.21914372487710498, 0.0908152455727319, 0.2914319549300888, 0.25849630580778415, 0.24368419442783118, 0.24300968720439775, 0.20737571411168332, 0.2880505963542438, 0.28078142952276497, 0.2539500484719621, 0.24645147288151092, 0.5868779646281443, 0.6160243858360479, 0.6317438311716047, 0.617757097448322, 0.5430409071999632, 0.680075448377125, 0.6114710601521891, 0.5964589242867016, 0.6259733958193281, 0.10120418409697562, 0.08763713399128104, 0.1473208729292248, 0.10787659143544137, 0.12301756091119243, 0.10383306249111723, 0.10789729460413688, 0.13263850442093772, 0.1285351920612251, 0.34314204561883976, 0.12669878783686184, 0.1875070044421836, 0.6467174450792219, 0.19584621250372714, 0.41459462852538076, 0.22579208494391145, 0.18115908546828385, 0.33670096018854645, 0.387254676157168, 0.38563849790897775, 0.40265200265933265, 0.38020672683192913, 0.3950452253896808, 0.37842303277812084, 0.45403270599163703, 0.41871066837082294, 0.38467870582064556, 0.2542452090595275, 0.2926191979894933, 0.26994060384319596, 0.30460194016170394, 0.260936938943124, 0.3456037409984062, 0.3386216901680238, 0.2895603173837683, 0.3044853447782617, 0.23850341040877354, 0.2266363193008697, 0.20146490376846293, 0.16713121341691461, 0.19101107772027714, 0.1855895623391628, 0.1935795048984298, 0.18343868096704496, 0.1756365773497195, 0.21460690797997428, 0.23144186989007476, 0.20876759058588157, 0.5522956838000507, 0.2537642086702444, 0.21042351840550122, 0.4170873398351307, 0.21100046293387664, 0.5626044292657846, 0.17069405880157917, 0.15898272033012906, 0.14264092358938474, 0.18418206671694182, 0.17747796685738593, 0.16543389937456288, 0.1825067811442307, 0.18340333507261652, 0.16586330749341127, 0.16023839800819883, 0.20883435359501312, 0.20321186762856513, 0.7250467413772499, 0.2055156741027645, 0.7807047113215458, 0.12739145453855472, 0.8230602983685049, 0.8090092157931528, 0.1828245979763493, 0.2162448934054253, 0.19414451133923005, 0.17386927358979032, 0.37433077366528156, 0.257902552438132, 0.2244990875863958, 0.25555346509585974, 0.22980513505887834, 0.06871839572403537, 0.06986578610196537, 0.08761345544848487, 0.07478179947636254, 0.06674661585370145, 0.07872816760496448, 0.06947637367799764, 0.07526989145605034, 0.07946572085163484]}, "mutation_prompt": null}
{"id": "474201bc-ffa8-4d94-8450-a02ce2ac13e5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                adaptive_learning_rate = 0.5 + 0.5 * (eval_count/self.budget)\n                candidate = pop[i] + adaptive_learning_rate * vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * np.exp(-0.8 * eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 * (1 - eval_count/self.budget) + 0.4 * (eval_count/self.budget)**2\n\n            if eval_count % 50 == 0:\n                np.random.shuffle(new_pop)\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced particle adaptation via dual learning rates and dynamic crossover, improving convergence efficiency.", "configspace": "", "generation": 98, "fitness": 0.3385661132277974, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "e972127f-e7f1-4b8d-bcbb-8938af396dfe", "metadata": {"aucs": [0.787218459695718, 0.7960265185923444, 0.7970265122156216, 0.8077859336586616, 0.8100032512695128, 0.830792252693426, 0.8263666355027867, 0.8301069590731052, 0.8246384362863998, 0.6733824410345626, 0.7096146054750171, 0.7054187865407102, 0.6697913051070568, 0.7048567249868398, 0.7206423008708691, 0.6949178825520107, 0.7227001365010873, 0.6905904861557741, 0.10990858307892126, 0.12358401883764747, 0.10929009826254565, 0.06703929387462781, 0.13561645912843268, 0.13526940494840223, 0.16613291317458334, 0.11069219487167214, 0.16920450521479236, 0.09916222398312435, 0.10403421307398097, 0.13949837690186817, 0.10345493659119165, 0.11684171164022206, 0.08761908198776347, 0.10991072267523305, 0.34629722265606855, 0.12283457609819981, 0.9769342768684024, 0.9772412243567656, 0.9661764904948333, 0.9646120028539671, 0.9670560713859864, 0.9819117859781911, 0.9703607332916778, 0.9873018507869447, 0.9891809732497924, 0.5799720871272522, 0.5859831878153805, 0.6356080965903873, 0.6158326581651086, 0.607557500732151, 0.5970404206090723, 0.08549392038976622, 0.5933070454998776, 0.6064078060290254, 0.2010009452142153, 0.7250001769120693, 0.6956986935579881, 0.7546605841722586, 0.7459982739506366, 0.6902943446211508, 0.7463636293860256, 0.7282199475618095, 0.22029051873862382, 0.2643863050669817, 0.2572709715387639, 0.35563395693432476, 0.31991949919267026, 0.12402244282705432, 0.4286242103049718, 0.33487595469112963, 0.2810616151201456, 0.3470442422081178, 0.11266918068641285, 0.05402450760182875, 0.13000610557443726, 0.20019596662375394, 0.33747969239736997, 0.3277372594221055, 0.2126068846980378, 0.3223491995853316, 0.33126481068009095, 0.005849577970456821, 0.1036278386899725, 0.12184706034902448, 0.05347826069107464, 0.03120582590496579, 0.16029484784219206, 0.005439494597621941, 0.07382245738143389, 0.08237611231221398, 0.10940537853376697, 0.18107567558232163, 0.21445675764792915, 0.21986599115326766, 0.25362788054444374, 0.20298970715809905, 0.3235662356407073, 0.2588744618485318, 0.17490264004237233, 0.08906780356741306, 0.05689068994710356, 9.999999999998899e-05, 0.07381270033273923, 0.10629496909425429, 0.08312106449736834, 0.1090826099682265, 0.07892967582062627, 0.09010648105835317, 0.20263940116798207, 0.15777953714893833, 0.1999802221708632, 0.25965724296356707, 0.21025517349019185, 0.22205644843766592, 0.19470605679018027, 0.18775165601770305, 0.19256094635943677, 0.5401705075441832, 0.5353037062272828, 0.5514834736750877, 0.551423752741351, 0.5791292585229474, 0.5482160170278039, 0.5867608847057529, 0.5700727360798337, 0.5730832991750692, 0.10868287337460147, 0.14655774482436812, 0.1615184715571899, 0.12332817028207232, 0.1032520650608787, 0.09632006018060346, 0.10246554886514392, 0.1072205416687555, 0.08618602592174773, 0.14950541156285546, 0.14627519177718384, 0.17585658862631448, 0.2579646643268846, 0.5437874013901576, 0.5424204714362242, 0.19745496835433218, 0.5962111151670968, 0.13642877281857824, 0.38374952151721053, 0.36644507952387917, 0.3916532862468056, 0.3990943107899547, 0.44543524342645047, 0.45017377157049876, 0.4474741795856769, 0.4721552961985722, 0.5184701131601192, 0.26798701562858473, 0.23193319284144265, 0.26895989789089636, 0.233136406883243, 0.30235107715475273, 0.2788880424099883, 0.33274008860975135, 0.322685472290665, 0.3113438099811049, 0.17960153775489562, 0.18548246564567517, 0.18042691231958163, 0.18373894501473598, 0.19488954043221096, 0.17496521189598313, 0.18414699735312356, 0.19497032619804777, 0.17016800998077142, 0.6526217651154453, 0.5283645880653645, 0.20263567072947186, 0.5643101257340704, 0.5856500681507733, 0.45494083357384496, 0.1999954059578003, 0.1966087804445661, 0.2472340847392409, 0.19748370086091227, 0.8245580004803984, 0.15290955868645706, 0.1604102648900816, 0.17683606745970448, 0.19584139404346101, 0.1344255854935673, 0.17042973302988906, 0.1878149578126862, 0.1677637587466646, 0.20627041403057778, 0.1663564374693145, 0.7843873665534168, 0.20483481908842027, 0.6964582633122796, 0.1251453293361472, 0.21017728351572673, 0.20774451472753108, 0.31612120100249463, 0.20464137710349573, 0.19313543357824514, 0.1802063160514903, 0.1932583451267864, 0.1809931486649935, 0.3348677927372966, 0.18226292643193753, 0.1752591135060968, 0.07156497695459496, 0.07795377045231777, 0.07048542396815505, 0.07469238947319934, 0.0712718983276156, 0.09144152263959349, 0.07828622543202113, 0.08207684867082721, 0.07296040040965579]}, "mutation_prompt": null}
{"id": "42cbe5dd-5afd-41f0-8c93-b70a776eb9f5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + 2 * int(np.sqrt(dim))\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.social_coefficient = 1.2 + 0.3 * np.random.rand()\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity_clamp = 0.5 * (5.0 - (-5.0))\n\n    def __call__(self, func):\n        lower_bound = -5.0\n        upper_bound = 5.0\n        pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(self.population_size, self.dim))\n        vel = np.random.uniform(low=-1, high=1, size=(self.population_size, self.dim))\n        personal_best = np.copy(pop)\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        \n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            new_pop = []\n            dynamic_velocity_clamp = 0.3 * (1 - eval_count / self.budget) + 0.2\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coefficient * r1 * (personal_best[i] - pop[i]) +\n                          self.social_coefficient * r2 * (global_best - pop[i]))\n                vel[i] = np.clip(vel[i], -dynamic_velocity_clamp, dynamic_velocity_clamp)\n                candidate = pop[i] + vel[i]\n                candidate = np.clip(candidate, lower_bound, upper_bound)\n                \n                self.mutation_factor = 0.6 + 0.4 * (1 - eval_count/self.budget)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = personal_best[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lower_bound, upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * np.exp(-0.5 * eval_count/self.budget))\n                candidate = np.where(crossover_mask, mutant, candidate)\n\n                new_pop.append(candidate)\n\n                self.inertia_weight = 0.9 * (1 - eval_count/self.budget) + 0.4 * (eval_count/self.budget)**2\n\n            new_pop = np.array(new_pop)\n            new_values = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            improved = new_values < personal_best_values\n            personal_best[improved] = new_pop[improved]\n            personal_best_values[improved] = new_values[improved]\n\n            if np.min(new_values) < func(global_best):\n                global_best = new_pop[np.argmin(new_values)]\n\n            pop = new_pop\n            \n            diversity = np.std(pop, axis=0)\n            if np.any(diversity < 1e-5):\n                pop += np.random.uniform(-0.1, 0.1, size=pop.shape)  # Enhance diversity\n\n        return global_best", "name": "HybridPSODE", "description": "Hybrid adaptive algorithm with dynamic inertia and diversity preservation for improved convergence and exploration.", "configspace": "", "generation": 99, "fitness": 0.3593026252709122, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "e972127f-e7f1-4b8d-bcbb-8938af396dfe", "metadata": {"aucs": [0.7749142341529174, 0.7783495600789666, 0.7972860046156132, 0.8349367676203556, 0.8133505473681437, 0.8011407268655414, 0.7850094181101064, 0.7676242227983125, 0.8163723260858962, 0.5973141568330707, 0.5811880821613853, 0.5835622390746076, 0.5939250736396645, 0.6179615305410819, 0.6002078172991832, 0.6278333485538414, 0.6655519953104887, 0.6510908987293196, 0.4103898453932733, 0.11760258346430019, 0.14695561266132484, 0.14358167886551143, 0.22049842928619223, 0.17163593166124425, 0.13729135958606098, 0.4649559233424623, 0.40767365236658193, 0.16528800920835385, 0.13601977922067598, 0.08884729891160204, 0.12802153516337245, 0.10391355948412873, 0.1369496915235281, 0.11778247667004016, 0.11090976681774845, 0.12809986292802478, 0.972981441355913, 0.9757055714195567, 0.976027631622119, 0.977125619420647, 0.9823853527997488, 0.9734986410427618, 0.9752163989807487, 0.98725783059153, 0.9921564825108657, 0.5440080108342957, 0.6331351677999688, 0.5669643795521299, 0.6104323027345773, 0.5205889925624136, 0.5660205304742671, 0.5516002364401498, 0.6071947609968721, 0.5820397945895941, 0.63578118490594, 0.6773660722150938, 0.6946201020674643, 0.8406047046494014, 0.7578175457786227, 0.7866927696446442, 0.7353837401921792, 0.8269233239891889, 0.7764361869101617, 0.4550679375383404, 0.2752273881445403, 0.3430831296545178, 0.3640985736922353, 0.35415543318819775, 0.12487776140736007, 0.3884990721996282, 0.3431530708655741, 0.4219662584473458, 0.3213992905284627, 0.2569881473513246, 0.1271591779557968, 0.4040939020421749, 0.32570024264404884, 0.41791249806193287, 0.41175090510272827, 0.3766344949014092, 0.12716829191250145, 0.4163555662927335, 0.31049007593391753, 0.07857375002978573, 0.23466825474670927, 0.03390347798018889, 0.290776586753961, 0.21825355835892823, 0.1452438857065116, 0.11882169072579585, 0.40477649441443986, 0.2038095011974258, 0.3793398445568933, 0.48677248143675045, 0.420258771210437, 0.14647797722061573, 0.35103322089763456, 0.4196804571387388, 0.4622278363684683, 0.06111645159870527, 0.20276063899081442, 0.06741768046856489, 0.15703506461717787, 0.1219683430399231, 0.15850889136184465, 0.09480181365536611, 0.13395672032920447, 0.19091962528207007, 0.26114791064232445, 0.24388744929714246, 0.25413607288204143, 0.26905333485837823, 0.2638807765460325, 0.3258850492170987, 0.2595074994890728, 0.2676930778111707, 0.2592427356913193, 0.6237882861477223, 0.686685570320996, 0.64150371251372, 0.6439877682584969, 0.6135314679698971, 0.626530271110163, 0.5704212106078516, 0.6098165843910841, 0.536117788511839, 0.10579847819677868, 0.13877028235253652, 0.08992391392048282, 0.10913613480395179, 0.1414654291684292, 0.14367203370715664, 0.11882673352605799, 0.13056454444632004, 0.1446782866355032, 0.22109477215758078, 0.27013512914412785, 0.32619671576812526, 0.15704854214197728, 0.2206389371331734, 0.3095573677366792, 0.2080891875058294, 0.17948238332450417, 0.4580366108633124, 0.3669661704200581, 0.3755450336803453, 0.39899684655355006, 0.3920580676859995, 0.40646858131595387, 0.4026995373423703, 0.412440314999322, 0.41631902462237935, 0.399044475784614, 0.27784566672919686, 0.29300443861061953, 0.2835600862005503, 0.26627509564841456, 0.20178255983084348, 0.2913571065568621, 0.3204497229779435, 0.29416369357410443, 0.2724331984300006, 0.18959968255301896, 0.21930357744246054, 0.18325886397987734, 0.1704446030370136, 0.1768862701881575, 0.23852280455268948, 0.17471118225023163, 0.17768631742462837, 0.1888683043993764, 0.37081141341104173, 0.20323567851624347, 0.5077926832815184, 0.19372450023374466, 0.22757486455738085, 0.41687513119025976, 0.220252909835288, 0.2370072441108544, 0.18344754006395725, 0.16803345540710957, 0.16184759727940257, 0.14255269168470786, 0.18323043795829197, 0.17782658770816107, 0.16535386303381128, 0.17993083700499446, 0.15859066717795323, 0.16578272380795533, 0.16663737154885772, 0.20802552492258597, 0.20440139434356241, 0.20915085839175718, 0.16618489625531563, 0.8232309075897124, 0.12626567438702274, 0.7679120179378849, 0.2070888460619581, 0.2244071428788874, 0.17256324671528034, 0.19744168480925395, 0.2097178821298744, 0.1783144742630386, 0.19440510534155786, 0.22426420168522487, 0.22603910052520504, 0.20570939878878092, 0.08171865202996964, 0.08312548273982123, 0.09210254196994172, 0.07489745554106997, 0.07712370793815393, 0.07409958706613251, 0.08191528129381609, 0.07828999044467311, 0.07095557064005786]}, "mutation_prompt": null}
