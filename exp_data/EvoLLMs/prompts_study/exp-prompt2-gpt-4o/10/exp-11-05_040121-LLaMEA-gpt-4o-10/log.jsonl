{"id": "c0dba1ae-a36c-4385-a725-d3ed167e0233", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                # Periodically inject random solutions to avoid local optima\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveDifferentialEvolution", "description": "Combines differential evolution with adaptive step sizes and random search restart to efficiently explore diverse regions of the search space.", "configspace": "", "generation": 0, "fitness": 0.1878905752246138, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4056668137375694, 0.4056668137375694, 0.4056668137375694, 0.42526714648898234, 0.42526714648898234, 0.42526714648898234, 0.4396851582701722, 0.4396851582701722, 0.4396851582701722, 0.2176232153274409, 0.2176232153274409, 0.2176232153274409, 0.18251245082659817, 0.18251245082659817, 0.18251245082659817, 0.20547433552408523, 0.20547433552408523, 0.20547433552408523, 0.11419491725787934, 0.11419491725787934, 0.11419491725787934, 0.07438265727073867, 0.07438265727073867, 0.07438265727073867, 0.08128767581230001, 0.08128767581230001, 0.08128767581230001, 0.07080841338617194, 0.07080841338617194, 0.07080841338617194, 0.06907952322129662, 0.06907952322129662, 0.06907952322129662, 0.07384980488420823, 0.07384980488420823, 0.07384980488420823, 0.9373565011077352, 0.9373565011077352, 0.9373565011077352, 0.968801452262915, 0.968801452262915, 0.968801452262915, 0.9078758190382291, 0.9078758190382291, 0.9078758190382291, 0.1569893579078323, 0.1569893579078323, 0.1569893579078323, 0.18806305473715346, 0.18806305473715346, 0.18806305473715346, 0.18356401656306742, 0.18356401656306742, 0.18356401656306742, 0.20561001334941753, 0.20561001334941753, 0.20561001334941753, 0.21553386499399196, 0.21553386499399196, 0.21553386499399196, 0.24534293288554865, 0.24534293288554865, 0.24534293288554865, 0.11757988114935491, 0.11757988114935491, 0.11757988114935491, 0.11922844485889694, 0.11922844485889694, 0.11922844485889694, 0.09143309910127917, 0.09143309910127917, 0.09143309910127917, 0.10383067882279706, 0.10383067882279706, 0.10383067882279706, 0.11193711964654174, 0.11193711964654174, 0.11193711964654174, 0.09624034852499497, 0.09624034852499497, 0.09624034852499497, 0.014075917290421458, 0.014075917290421458, 0.014075917290421458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08386477454714458, 0.08386477454714458, 0.08386477454714458, 0.07221907236820824, 0.07221907236820824, 0.07221907236820824, 0.107622410978233, 0.107622410978233, 0.107622410978233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07116071784412048, 0.07116071784412048, 0.07116071784412048, 0.06189620309953647, 0.06189620309953647, 0.06189620309953647, 0.08827355636158973, 0.08827355636158973, 0.08827355636158973, 0.3720939871204034, 0.3720939871204034, 0.3720939871204034, 0.35239774985598393, 0.35239774985598393, 0.35239774985598393, 0.3647589420776348, 0.3647589420776348, 0.3647589420776348, 0.0808165152992042, 0.0808165152992042, 0.0808165152992042, 0.07001402608331209, 0.07001402608331209, 0.07001402608331209, 0.07384749581937444, 0.07384749581937444, 0.07384749581937444, 0.12778973927223414, 0.12778973927223414, 0.12778973927223414, 0.13184811166327204, 0.13184811166327204, 0.13184811166327204, 0.125127575223563, 0.125127575223563, 0.125127575223563, 0.21979473169969022, 0.21979473169969022, 0.21979473169969022, 0.2089236394790629, 0.2089236394790629, 0.2089236394790629, 0.24530042649811956, 0.24530042649811956, 0.24530042649811956, 0.1499034180974641, 0.1499034180974641, 0.1499034180974641, 0.14458151321923773, 0.14458151321923773, 0.14458151321923773, 0.15170429092640403, 0.15170429092640403, 0.15170429092640403, 0.19913211692339294, 0.19913211692339294, 0.19913211692339294, 0.17447588055709207, 0.17447588055709207, 0.17447588055709207, 0.1795795635888493, 0.1795795635888493, 0.1795795635888493, 0.16952414840912466, 0.16952414840912466, 0.16952414840912466, 0.1740863497958498, 0.1740863497958498, 0.1740863497958498, 0.1690283977540279, 0.1690283977540279, 0.1690283977540279, 0.44152140393868033, 0.44152140393868033, 0.44152140393868033, 0.23082983682103564, 0.23082983682103564, 0.23082983682103564, 0.1598995886918465, 0.1598995886918465, 0.1598995886918465, 0.191601936147485, 0.191601936147485, 0.191601936147485, 0.16926126452124768, 0.16926126452124768, 0.16926126452124768, 0.20278692293433664, 0.20278692293433664, 0.20278692293433664, 0.17173285820731055, 0.17173285820731055, 0.17173285820731055, 0.19886437414221214, 0.19886437414221214, 0.19886437414221214, 0.18023270353007248, 0.18023270353007248, 0.18023270353007248, 0.06379978502407246, 0.06379978502407246, 0.06379978502407246, 0.062461672174199734, 0.062461672174199734, 0.062461672174199734, 0.061569101229944634, 0.061569101229944634, 0.061569101229944634]}, "mutation_prompt": null}
{"id": "51eda974-fe89-4faf-a4c5-1631907884e0", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.18950765105586218, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "c0dba1ae-a36c-4385-a725-d3ed167e0233", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "64644503-6c9a-490d-be99-cc609fb2ff52", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "49679798-9501-472b-a3be-6a07d147d414", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "3d12b636-f350-4ac1-8fc7-a2f2aa0932ff", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "7e10c543-4ae0-45ee-9c14-d45dd39a9f63", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "cb7c65ca-7bdf-41a8-9e2e-c92e33f63c91", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates a memory mechanism to adapt F and CR dynamically per individual based on historical success to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "cf3335ab-5a55-4afa-8f88-c68ab317e6c3", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            population_std = np.std(population, axis=0).mean()  # Average standard deviation across dimensions\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n\n                # Dynamically adjust F based on population diversity\n                F = max(0.4, min(1.2, mem_F[np.random.randint(memory_size)] * (1 + 0.1 * population_std)))\n\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive mutation strategy by dynamically tuning F using population diversity to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.13920912806302357, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.23867615765290928, 0.23867615765290928, 0.23867615765290928, 0.2723788379410045, 0.2723788379410045, 0.2723788379410045, 0.2724563958029812, 0.2724563958029812, 0.2724563958029812, 0.04629846709741081, 0.04629846709741081, 0.04629846709741081, 0.04066775640872533, 0.04066775640872533, 0.04066775640872533, 0.042190979319379984, 0.042190979319379984, 0.042190979319379984, 0.06580437391555494, 0.06580437391555494, 0.06580437391555494, 0.061219639349668564, 0.061219639349668564, 0.061219639349668564, 0.06777307640981822, 0.06777307640981822, 0.06777307640981822, 0.06570028379046433, 0.06570028379046433, 0.06570028379046433, 0.04295128916364643, 0.04295128916364643, 0.04295128916364643, 0.04994401995639419, 0.04994401995639419, 0.04994401995639419, 0.9950445067520778, 0.9950445067520778, 0.9950445067520778, 0.9434722240455543, 0.9434722240455543, 0.9434722240455543, 0.9554942854536724, 0.9554942854536724, 0.9554942854536724, 0.09463673237673098, 0.09463673237673098, 0.09463673237673098, 0.1031188986336179, 0.1031188986336179, 0.1031188986336179, 0.10435374383898399, 0.10435374383898399, 0.10435374383898399, 0.14272135660300012, 0.14272135660300012, 0.14272135660300012, 0.15049327055295347, 0.15049327055295347, 0.15049327055295347, 0.14482882702652, 0.14482882702652, 0.14482882702652, 0.016625941926666, 0.016625941926666, 0.016625941926666, 0.04298217073522337, 0.04298217073522337, 0.04298217073522337, 0.028333720506961257, 0.028333720506961257, 0.028333720506961257, 0.03152781670415583, 0.03152781670415583, 0.03152781670415583, 0.017157833769699704, 0.017157833769699704, 0.017157833769699704, 0.01847806219354242, 0.01847806219354242, 0.01847806219354242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04718713908672889, 0.04718713908672889, 0.04718713908672889, 0.055903608705243246, 0.055903608705243246, 0.055903608705243246, 0.056879707632849774, 0.056879707632849774, 0.056879707632849774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008924219051377635, 0.008924219051377635, 0.008924219051377635, 0.006235005875526056, 0.006235005875526056, 0.006235005875526056, 0.022956990718651427, 0.022956990718651427, 0.022956990718651427, 0.24751390129049344, 0.24751390129049344, 0.24751390129049344, 0.234559517624918, 0.234559517624918, 0.234559517624918, 0.2203348738291907, 0.2203348738291907, 0.2203348738291907, 0.06771130011803361, 0.06771130011803361, 0.06771130011803361, 0.05652692700745121, 0.05652692700745121, 0.05652692700745121, 0.062370342410574264, 0.062370342410574264, 0.062370342410574264, 0.1882149295336052, 0.1882149295336052, 0.1882149295336052, 0.13364595690044756, 0.13364595690044756, 0.13364595690044756, 0.12261893414130409, 0.12261893414130409, 0.12261893414130409, 0.17318228586686035, 0.17318228586686035, 0.17318228586686035, 0.1698341167306553, 0.1698341167306553, 0.1698341167306553, 0.17434004463453023, 0.17434004463453023, 0.17434004463453023, 0.11203762385302873, 0.11203762385302873, 0.11203762385302873, 0.1241305053735583, 0.1241305053735583, 0.1241305053735583, 0.12373013407462208, 0.12373013407462208, 0.12373013407462208, 0.16196510812644194, 0.16196510812644194, 0.16196510812644194, 0.16324072374848675, 0.16324072374848675, 0.16324072374848675, 0.16070789505999294, 0.16070789505999294, 0.16070789505999294, 0.14931545014840863, 0.14931545014840863, 0.14931545014840863, 0.14078493843717155, 0.14078493843717155, 0.14078493843717155, 0.14373893725814446, 0.14373893725814446, 0.14373893725814446, 0.15842682526937146, 0.15842682526937146, 0.15842682526937146, 0.15971398241484203, 0.15971398241484203, 0.15971398241484203, 0.1481013230430812, 0.1481013230430812, 0.1481013230430812, 0.1589262677004042, 0.1589262677004042, 0.1589262677004042, 0.10731444714358163, 0.10731444714358163, 0.10731444714358163, 0.19172598740994296, 0.19172598740994296, 0.19172598740994296, 0.19726195960097603, 0.19726195960097603, 0.19726195960097603, 0.18305987020445513, 0.18305987020445513, 0.18305987020445513, 0.1738159067636963, 0.1738159067636963, 0.1738159067636963, 0.05750996473263292, 0.05750996473263292, 0.05750996473263292, 0.04230301064531272, 0.04230301064531272, 0.04230301064531272, 0.06037589044378622, 0.06037589044378622, 0.06037589044378622]}, "mutation_prompt": null}
{"id": "c117b096-7ca5-4f53-8c44-cb223c31ecc8", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n            \n            if evaluations % (population_size * 20) == 0:\n                population_size = max(5 * self.dim, int(population_size * 0.9))\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhance exploration by introducing adaptive population size adjustment based on current performance.", "configspace": "", "generation": 8, "fitness": 0.18950765105586218, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.4474327174987768, 0.4474327174987768, 0.4474327174987768, 0.43782628003964996, 0.43782628003964996, 0.43782628003964996, 0.47571048457891096, 0.47571048457891096, 0.47571048457891096, 0.194285729011609, 0.194285729011609, 0.194285729011609, 0.2102928159272187, 0.2102928159272187, 0.2102928159272187, 0.20656952869497525, 0.20656952869497525, 0.20656952869497525, 0.07679530795487388, 0.07679530795487388, 0.07679530795487388, 0.10563903483262582, 0.10563903483262582, 0.10563903483262582, 0.09762020582717013, 0.09762020582717013, 0.09762020582717013, 0.07523622057725388, 0.07523622057725388, 0.07523622057725388, 0.07173417831871898, 0.07173417831871898, 0.07173417831871898, 0.08118040217359124, 0.08118040217359124, 0.08118040217359124, 0.9449410774975893, 0.9449410774975893, 0.9449410774975893, 0.9466388876662652, 0.9466388876662652, 0.9466388876662652, 0.9607754620346677, 0.9607754620346677, 0.9607754620346677, 0.16903993413831797, 0.16903993413831797, 0.16903993413831797, 0.17536885068206853, 0.17536885068206853, 0.17536885068206853, 0.183259951559135, 0.183259951559135, 0.183259951559135, 0.22819001926386073, 0.22819001926386073, 0.22819001926386073, 0.25481471431155456, 0.25481471431155456, 0.25481471431155456, 0.2639619854083548, 0.2639619854083548, 0.2639619854083548, 0.10216246717980937, 0.10216246717980937, 0.10216246717980937, 0.1335276834359871, 0.1335276834359871, 0.1335276834359871, 0.1117233991241674, 0.1117233991241674, 0.1117233991241674, 0.10090770721702824, 0.10090770721702824, 0.10090770721702824, 0.09124467843953243, 0.09124467843953243, 0.09124467843953243, 0.14455616760174583, 0.14455616760174583, 0.14455616760174583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023590397860175916, 0.0023590397860175916, 0.0023590397860175916, 0.08716685108994371, 0.08716685108994371, 0.08716685108994371, 0.07762136659789831, 0.07762136659789831, 0.07762136659789831, 0.12246941999631511, 0.12246941999631511, 0.12246941999631511, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058262680659535326, 0.058262680659535326, 0.058262680659535326, 0.08203373697045258, 0.08203373697045258, 0.08203373697045258, 0.06409733702621256, 0.06409733702621256, 0.06409733702621256, 0.3504770372996281, 0.3504770372996281, 0.3504770372996281, 0.36105434467048403, 0.36105434467048403, 0.36105434467048403, 0.36434145479289415, 0.36434145479289415, 0.36434145479289415, 0.07120945285915237, 0.07120945285915237, 0.07120945285915237, 0.08113260542587031, 0.08113260542587031, 0.08113260542587031, 0.06547978488794093, 0.06547978488794093, 0.06547978488794093, 0.15804301091512096, 0.15804301091512096, 0.15804301091512096, 0.1728709236777426, 0.1728709236777426, 0.1728709236777426, 0.1482142609869861, 0.1482142609869861, 0.1482142609869861, 0.22723511634937654, 0.22723511634937654, 0.22723511634937654, 0.21924763097818012, 0.21924763097818012, 0.21924763097818012, 0.22780963018935252, 0.22780963018935252, 0.22780963018935252, 0.16607989500536624, 0.16607989500536624, 0.16607989500536624, 0.14924645486817167, 0.14924645486817167, 0.14924645486817167, 0.17417982341364657, 0.17417982341364657, 0.17417982341364657, 0.1945588962231113, 0.1945588962231113, 0.1945588962231113, 0.17049455296509275, 0.17049455296509275, 0.17049455296509275, 0.18931404033521604, 0.18931404033521604, 0.18931404033521604, 0.18121531405599867, 0.18121531405599867, 0.18121531405599867, 0.16267931200277053, 0.16267931200277053, 0.16267931200277053, 0.17117448577787053, 0.17117448577787053, 0.17117448577787053, 0.21914236236303974, 0.21914236236303974, 0.21914236236303974, 0.14547159800587506, 0.14547159800587506, 0.14547159800587506, 0.18826126009689503, 0.18826126009689503, 0.18826126009689503, 0.18786588265968163, 0.18786588265968163, 0.18786588265968163, 0.15549249107890173, 0.15549249107890173, 0.15549249107890173, 0.2017684894789612, 0.2017684894789612, 0.2017684894789612, 0.17543358773191453, 0.17543358773191453, 0.17543358773191453, 0.18571839694182313, 0.18571839694182313, 0.18571839694182313, 0.17890528905702108, 0.17890528905702108, 0.17890528905702108, 0.06850167624550285, 0.06850167624550285, 0.06850167624550285, 0.07452947185762715, 0.07452947185762715, 0.07452947185762715, 0.07145601970302617, 0.07145601970302617, 0.07145601970302617]}, "mutation_prompt": null}
{"id": "70abc713-1a69-4430-ad35-297943e7d1ca", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 9, "fitness": 0.27680713070197005, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "51eda974-fe89-4faf-a4c5-1631907884e0", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "7f7fc3c3-53a8-437c-8626-994aa717c944", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "50905e2a-30b5-4953-a73a-20a290271894", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "54d18d19-7fbe-4d90-9521-bd5e6758cafd", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "eb044d35-b0e9-4bfd-93db-f40caf3c82c8", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "765a52e6-aa33-418b-83c3-f417ccc835b9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            diversity = np.std(population, axis=0)  # Track diversity of the population\n            adaptive_F = F * (1 + np.mean(diversity) / 5)  # Adjust mutation factor based on diversity\n            adaptive_CR = CR * (1 - np.mean(diversity) / 5)  # Adjust crossover rate\n\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + adaptive_F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < adaptive_CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive mutation and crossover rates based on population diversity to enhance convergence speed and solution quality.", "configspace": "", "generation": 14, "fitness": 0.20339514851854684, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6221578446513254, 0.6221578446513254, 0.6221578446513254, 0.6640991438912132, 0.6640991438912132, 0.6640991438912132, 0.6440928772869807, 0.6440928772869807, 0.6440928772869807, 0.3305959200038602, 0.3305959200038602, 0.3305959200038602, 0.32868055680351493, 0.32868055680351493, 0.32868055680351493, 0.3386371926444892, 0.3386371926444892, 0.3386371926444892, 0.12006805537063303, 0.12006805537063303, 0.12006805537063303, 0.12223994480054878, 0.12223994480054878, 0.12223994480054878, 0.12171239625166541, 0.12171239625166541, 0.12171239625166541, 0.10114104532195056, 0.10114104532195056, 0.10114104532195056, 0.09889975646829885, 0.09889975646829885, 0.09889975646829885, 0.09232522812360167, 0.09232522812360167, 0.09232522812360167, 0.959075200254228, 0.959075200254228, 0.959075200254228, 0.9627238779390624, 0.9627238779390624, 0.9627238779390624, 0.9480661696831487, 0.9480661696831487, 0.9480661696831487, 0.21266126360847082, 0.21266126360847082, 0.21266126360847082, 0.21691140443191592, 0.21691140443191592, 0.21691140443191592, 0.2440579113434792, 0.2440579113434792, 0.2440579113434792, 0.1250893519631614, 0.1250893519631614, 0.1250893519631614, 0.20166347751226876, 0.20166347751226876, 0.20166347751226876, 0.18093588294603513, 0.18093588294603513, 0.18093588294603513, 0.1251844213719403, 0.1251844213719403, 0.1251844213719403, 0.15722621891325383, 0.15722621891325383, 0.15722621891325383, 0.1587782659991369, 0.1587782659991369, 0.1587782659991369, 0.053437258460620085, 0.053437258460620085, 0.053437258460620085, 0.10326404936503275, 0.10326404936503275, 0.10326404936503275, 0.08993522754811334, 0.08993522754811334, 0.08993522754811334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04322115471554755, 0.04322115471554755, 0.04322115471554755, 0.04175699778496733, 0.04175699778496733, 0.04175699778496733, 0.036573187724684764, 0.036573187724684764, 0.036573187724684764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037571953219236454, 0.0037571953219236454, 0.0037571953219236454, 0.09425549781620679, 0.09425549781620679, 0.09425549781620679, 0.11268326219489078, 0.11268326219489078, 0.11268326219489078, 0.07679926677899551, 0.07679926677899551, 0.07679926677899551, 0.4129138807796058, 0.4129138807796058, 0.4129138807796058, 0.4247570217044415, 0.4247570217044415, 0.4247570217044415, 0.4172976566909625, 0.4172976566909625, 0.4172976566909625, 0.09438992832420534, 0.09438992832420534, 0.09438992832420534, 0.0763997675933824, 0.0763997675933824, 0.0763997675933824, 0.07609056674561765, 0.07609056674561765, 0.07609056674561765, 0.12717991884623003, 0.12717991884623003, 0.12717991884623003, 0.12886688873040275, 0.12886688873040275, 0.12886688873040275, 0.14810738695698888, 0.14810738695698888, 0.14810738695698888, 0.19263070903617885, 0.19263070903617885, 0.19263070903617885, 0.1929689365516989, 0.1929689365516989, 0.1929689365516989, 0.22566322637923375, 0.22566322637923375, 0.22566322637923375, 0.14234678132570533, 0.14234678132570533, 0.14234678132570533, 0.12237892074605461, 0.12237892074605461, 0.12237892074605461, 0.1377164553789071, 0.1377164553789071, 0.1377164553789071, 0.16817165072786644, 0.16817165072786644, 0.16817165072786644, 0.17291958123382078, 0.17291958123382078, 0.17291958123382078, 0.16299208662080145, 0.16299208662080145, 0.16299208662080145, 0.17575596610045885, 0.17575596610045885, 0.17575596610045885, 0.1834653918777862, 0.1834653918777862, 0.1834653918777862, 0.1642536930177243, 0.1642536930177243, 0.1642536930177243, 0.18223645238596264, 0.18223645238596264, 0.18223645238596264, 0.268172600685638, 0.268172600685638, 0.268172600685638, 0.15437473850811878, 0.15437473850811878, 0.15437473850811878, 0.24127257804742253, 0.24127257804742253, 0.24127257804742253, 0.17328857650220142, 0.17328857650220142, 0.17328857650220142, 0.1863683344934638, 0.1863683344934638, 0.1863683344934638, 0.21072054962052433, 0.21072054962052433, 0.21072054962052433, 0.176628961009191, 0.176628961009191, 0.176628961009191, 0.1804018775463494, 0.1804018775463494, 0.1804018775463494, 0.06430688217093117, 0.06430688217093117, 0.06430688217093117, 0.06552113344760924, 0.06552113344760924, 0.06552113344760924, 0.060685088254721076, 0.060685088254721076, 0.060685088254721076]}, "mutation_prompt": null}
{"id": "95e2e6fe-fbf9-4717-be14-f7186a0d1f08", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "b51257ef-cf97-4c17-b5d0-bb0887890dd0", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "6904e9b0-ea88-4b54-9954-2aae00315150", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "dcb0850a-c4fc-4fee-ac6f-d06e81cd09a0", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "677f8cc1-c6ca-4828-926a-c01b0936caa9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = min(fitness)\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if new_fitness < best_fitness:\n                    best_solution = crossover\n                    best_fitness = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return best_solution, best_fitness", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive mutation strategies and elitism to enhance convergence and solution quality.", "configspace": "", "generation": 19, "fitness": 0.27680713070197005, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "8124db5a-adf5-4572-8573-d87ba121bc70", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "ebd1e95a-2b32-48b5-910c-96d034183aaf", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "31ae9279-3e05-44e6-a69d-47a2fe02d2dc", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "bd52e0b6-3c36-442e-b5b0-a83689005ee6", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "3d8c4a69-138a-4433-ad85-7c5e19438f70", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        exploration_chance = 0.1  # Introduce an exploration chance\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                random_indices = np.random.rand(population_size, self.dim) < exploration_chance\n                new_vals = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n                population = np.where(random_indices, new_vals, population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive parameter control and environmental reinitialization to enhance exploration and convergence robustness.", "configspace": "", "generation": 24, "fitness": 0.27680713070197005, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "c63673cb-b056-4787-8619-424e252886a2", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "10be1c24-36ea-4d89-a3e7-9664879fec6a", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "a0704db9-1630-438d-8ceb-ba280dd720b2", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "1a651e8b-5d09-4727-bd30-765d2692a2d1", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "25489c3d-0498-481c-a486-80776d5f39c9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "88142c53-eae4-485c-837b-eff52a072e97", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "2eea75f2-330a-4d67-afc2-e2954901fd56", "solution": "import numpy as np\nimport scipy.stats as stats\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (stats.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (stats.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n            # Local search with Lvy flights\n            if evaluations < self.budget and np.random.rand() < 0.3:\n                step = self.levy_flight(self.dim)\n                for i in range(population_size):\n                    candidate = population[i] + step\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n                    if evaluations >= self.budget:\n                        break\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces local search with Lvy flights to enhance exploration capabilities and improve convergence speed.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for *: 'rv_continuous_frozen' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for *: 'rv_continuous_frozen' and 'float'\")", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {}, "mutation_prompt": null}
{"id": "2bfa3f2e-5318-4d87-8ad0-6b1ac38eb6b6", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        success_rate = 0.0\n\n        while evaluations < self.budget:\n            successful_mutations = 0\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n                    successful_mutations += 1\n\n                if evaluations >= self.budget:\n                    break\n\n            success_rate = successful_mutations / population_size\n            if evaluations < self.budget and success_rate < 0.2:\n                mem_F[mem_idx] = mem_F[mem_idx] * 1.1\n                mem_CR[mem_idx] = max(0.1, mem_CR[mem_idx] * 0.9)\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive control of crossover and mutation parameters based on success history to improve exploration-exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.22264712700715455, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.7042621751603011, 0.7042621751603011, 0.7042621751603011, 0.6485747895690015, 0.6485747895690015, 0.6485747895690015, 0.6094905178196598, 0.6094905178196598, 0.6094905178196598, 0.40686703152119075, 0.40686703152119075, 0.40686703152119075, 0.4353428374654854, 0.4353428374654854, 0.4353428374654854, 0.4413236963861151, 0.4413236963861151, 0.4413236963861151, 0.11301667345552346, 0.11301667345552346, 0.11301667345552346, 0.205521540769234, 0.205521540769234, 0.205521540769234, 0.19898541133525105, 0.19898541133525105, 0.19898541133525105, 0.0985693150884448, 0.0985693150884448, 0.0985693150884448, 0.12762205574716967, 0.12762205574716967, 0.12762205574716967, 0.13857201299842947, 0.13857201299842947, 0.13857201299842947, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.24077907704573964, 0.24077907704573964, 0.24077907704573964, 0.2535417506576332, 0.2535417506576332, 0.2535417506576332, 0.23501714194306111, 0.23501714194306111, 0.23501714194306111, 0.21626350004024342, 0.21626350004024342, 0.21626350004024342, 0.29032940941560736, 0.29032940941560736, 0.29032940941560736, 0.256112523554894, 0.256112523554894, 0.256112523554894, 0.1201472678631893, 0.1201472678631893, 0.1201472678631893, 0.12301822656702555, 0.12301822656702555, 0.12301822656702555, 0.15280103982217097, 0.15280103982217097, 0.15280103982217097, 0.12500226134258396, 0.12500226134258396, 0.12500226134258396, 0.11929873186008877, 0.11929873186008877, 0.11929873186008877, 0.12097613395553075, 0.12097613395553075, 0.12097613395553075, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01215660138274366, 0.01215660138274366, 0.01215660138274366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08507212787684271, 0.08507212787684271, 0.08507212787684271, 0.13134916508549122, 0.13134916508549122, 0.13134916508549122, 0.09180547364733394, 0.09180547364733394, 0.09180547364733394, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09986667427571361, 0.09986667427571361, 0.09986667427571361, 0.1120370567557476, 0.1120370567557476, 0.1120370567557476, 0.09652906619909918, 0.09652906619909918, 0.09652906619909918, 0.3955163707947692, 0.3955163707947692, 0.3955163707947692, 0.4438414123053447, 0.4438414123053447, 0.4438414123053447, 0.43123362776549456, 0.43123362776549456, 0.43123362776549456, 0.0867408296944171, 0.0867408296944171, 0.0867408296944171, 0.0786472658863051, 0.0786472658863051, 0.0786472658863051, 0.08408638408049152, 0.08408638408049152, 0.08408638408049152, 0.1384541393627251, 0.1384541393627251, 0.1384541393627251, 0.13650740813138384, 0.13650740813138384, 0.13650740813138384, 0.13741710375863514, 0.13741710375863514, 0.13741710375863514, 0.2311224466407259, 0.2311224466407259, 0.2311224466407259, 0.22404144605114307, 0.22404144605114307, 0.22404144605114307, 0.21658467781065305, 0.21658467781065305, 0.21658467781065305, 0.15377451652677065, 0.15377451652677065, 0.15377451652677065, 0.14533646261495392, 0.14533646261495392, 0.14533646261495392, 0.15679038077922325, 0.15679038077922325, 0.15679038077922325, 0.1828431295886902, 0.1828431295886902, 0.1828431295886902, 0.17870345387669062, 0.17870345387669062, 0.17870345387669062, 0.1982830034891847, 0.1982830034891847, 0.1982830034891847, 0.1937560887551859, 0.1937560887551859, 0.1937560887551859, 0.18344260026796932, 0.18344260026796932, 0.18344260026796932, 0.18980952393355144, 0.18980952393355144, 0.18980952393355144, 0.2219788166723824, 0.2219788166723824, 0.2219788166723824, 0.19662480336724986, 0.19662480336724986, 0.19662480336724986, 0.1609972740533131, 0.1609972740533131, 0.1609972740533131, 0.26742394546275694, 0.26742394546275694, 0.26742394546275694, 0.1734297477909107, 0.1734297477909107, 0.1734297477909107, 0.20669922252423212, 0.20669922252423212, 0.20669922252423212, 0.18674995322199806, 0.18674995322199806, 0.18674995322199806, 0.20542400521842674, 0.20542400521842674, 0.20542400521842674, 0.18716069463178842, 0.18716069463178842, 0.18716069463178842, 0.07887322159088306, 0.07887322159088306, 0.07887322159088306, 0.07013309291376968, 0.07013309291376968, 0.07013309291376968, 0.06611321863371267, 0.06611321863371267, 0.06611321863371267]}, "mutation_prompt": null}
{"id": "855e19a7-6f5b-407b-b733-38f4f9176b1e", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "56bf8a76-8d2f-437c-81fa-20ac3ffd030d", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "213d6ff3-1d6f-4d2b-ac78-fc86dafa4151", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        success_rates = np.zeros(memory_size)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    # Update success rate\n                    success_rates[mem_idx] += 1\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adjust F based on historical success\n            success_sum = np.sum(success_rates)\n            if success_sum > 0:\n                mem_F = mem_F * (success_rates / success_sum)\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Incorporates adaptive mutation strategies based on success history to enhance convergence in diverse optimization landscapes.", "configspace": "", "generation": 35, "fitness": 0.09303520035851447, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.15269976790737205, 0.15269976790737205, 0.15269976790737205, 0.23191977134698794, 0.23191977134698794, 0.23191977134698794, 0.16238539824839449, 0.16238539824839449, 0.16238539824839449, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08024493706111024, 0.08024493706111024, 0.08024493706111024, 0.07778623740431889, 0.07778623740431889, 0.07778623740431889, 0.06766259392642515, 0.06766259392642515, 0.06766259392642515, 0.04100841175487113, 0.04100841175487113, 0.04100841175487113, 0.07024914853756947, 0.07024914853756947, 0.07024914853756947, 0.060755403174638345, 0.060755403174638345, 0.060755403174638345, 0.2553362766111503, 0.2553362766111503, 0.2553362766111503, 0.1691493651813054, 0.1691493651813054, 0.1691493651813054, 0.1311772865241534, 0.1311772865241534, 0.1311772865241534, 0.0338577277104789, 0.0338577277104789, 0.0338577277104789, 0.06311651890102166, 0.06311651890102166, 0.06311651890102166, 0.11224949478393742, 0.11224949478393742, 0.11224949478393742, 0.12889800257091188, 0.12889800257091188, 0.12889800257091188, 0.1064409674415816, 0.1064409674415816, 0.1064409674415816, 0.09135631578726278, 0.09135631578726278, 0.09135631578726278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015428646629850995, 0.015428646629850995, 0.015428646629850995, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05342981635686461, 0.05342981635686461, 0.05342981635686461, 0.013633757326207752, 0.013633757326207752, 0.013633757326207752, 0.042730491715375685, 0.042730491715375685, 0.042730491715375685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017759961707118466, 0.017759961707118466, 0.017759961707118466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009675822965021452, 0.009675822965021452, 0.009675822965021452, 0.27543803781345866, 0.27543803781345866, 0.27543803781345866, 0.19345086021404334, 0.19345086021404334, 0.19345086021404334, 0.19274771994870976, 0.19274771994870976, 0.19274771994870976, 0.07270594924998952, 0.07270594924998952, 0.07270594924998952, 0.042478562929120556, 0.042478562929120556, 0.042478562929120556, 0.041514275361203334, 0.041514275361203334, 0.041514275361203334, 0.11237354346979378, 0.11237354346979378, 0.11237354346979378, 0.10627816490022324, 0.10627816490022324, 0.10627816490022324, 0.12776482874608663, 0.12776482874608663, 0.12776482874608663, 0.1877204269917061, 0.1877204269917061, 0.1877204269917061, 0.15705780693365123, 0.15705780693365123, 0.15705780693365123, 0.1631860849000113, 0.1631860849000113, 0.1631860849000113, 0.07425198971031188, 0.07425198971031188, 0.07425198971031188, 0.1077447419408103, 0.1077447419408103, 0.1077447419408103, 0.10758861576620671, 0.10758861576620671, 0.10758861576620671, 0.18903695634149575, 0.18903695634149575, 0.18903695634149575, 0.17110460678292128, 0.17110460678292128, 0.17110460678292128, 0.1912203970488866, 0.1912203970488866, 0.1912203970488866, 0.1703846314026618, 0.1703846314026618, 0.1703846314026618, 0.1444928265640536, 0.1444928265640536, 0.1444928265640536, 0.14932022564473213, 0.14932022564473213, 0.14932022564473213, 0.22392913259851022, 0.22392913259851022, 0.22392913259851022, 0.11497140122118454, 0.11497140122118454, 0.11497140122118454, 0.12137882136946931, 0.12137882136946931, 0.12137882136946931, 0.1333635376137281, 0.1333635376137281, 0.1333635376137281, 0.1104647235274584, 0.1104647235274584, 0.1104647235274584, 0.1158037985307665, 0.1158037985307665, 0.1158037985307665, 0.1723372412249793, 0.1723372412249793, 0.1723372412249793, 0.1752995509266022, 0.1752995509266022, 0.1752995509266022, 0.19763671924276383, 0.19763671924276383, 0.19763671924276383, 0.06010849422107678, 0.06010849422107678, 0.06010849422107678, 0.0560488041325401, 0.0560488041325401, 0.0560488041325401, 0.048878826969954714, 0.048878826969954714, 0.048878826969954714]}, "mutation_prompt": null}
{"id": "95c6bc0b-76f8-4239-be6e-a68bf12c8d27", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < (CR if np.random.rand() > 0.5 else 1 - CR) else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                # Introduce random immigrants\n                immigrants = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                immigrants_fitness = np.array([func(ind) for ind in immigrants])\n                evaluations += population_size\n                population = np.where((fitness < immigrants_fitness)[:, None], population, immigrants)\n                fitness = np.minimum(fitness, immigrants_fitness)\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive crossover and mutation strategies with random immigrant approaches for enhanced diversity.", "configspace": "", "generation": 36, "fitness": 0.22935028582834244, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6953170197637777, 0.6953170197637777, 0.6953170197637777, 0.7071834417539484, 0.7071834417539484, 0.7071834417539484, 0.7263124144344634, 0.7263124144344634, 0.7263124144344634, 0.44530484463138476, 0.44530484463138476, 0.44530484463138476, 0.46678847484197694, 0.46678847484197694, 0.46678847484197694, 0.48293010045974527, 0.48293010045974527, 0.48293010045974527, 0.22395271342107448, 0.22395271342107448, 0.22395271342107448, 0.23410930417593723, 0.23410930417593723, 0.23410930417593723, 0.27108414302380046, 0.27108414302380046, 0.27108414302380046, 0.1674790364526223, 0.1674790364526223, 0.1674790364526223, 0.19823101419937583, 0.19823101419937583, 0.19823101419937583, 0.1817425660119255, 0.1817425660119255, 0.1817425660119255, 0.9510782207046071, 0.9510782207046071, 0.9510782207046071, 0.9570899056919842, 0.9570899056919842, 0.9570899056919842, 0.9581069819846714, 0.9581069819846714, 0.9581069819846714, 0.23554929611612974, 0.23554929611612974, 0.23554929611612974, 0.2334646021505229, 0.2334646021505229, 0.2334646021505229, 0.21772539390024392, 0.21772539390024392, 0.21772539390024392, 0.17412302470191388, 0.17412302470191388, 0.17412302470191388, 0.2532183461768427, 0.2532183461768427, 0.2532183461768427, 0.24309627861640903, 0.24309627861640903, 0.24309627861640903, 0.13944133878340204, 0.13944133878340204, 0.13944133878340204, 0.14987747923652328, 0.14987747923652328, 0.14987747923652328, 0.13838365963336197, 0.13838365963336197, 0.13838365963336197, 0.09052631131544553, 0.09052631131544553, 0.09052631131544553, 0.15148264992156224, 0.15148264992156224, 0.15148264992156224, 0.10161059624117175, 0.10161059624117175, 0.10161059624117175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1073645119846185, 0.1073645119846185, 0.1073645119846185, 0.04574143604992731, 0.04574143604992731, 0.04574143604992731, 0.05453431663447994, 0.05453431663447994, 0.05453431663447994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06861554055658547, 0.06861554055658547, 0.06861554055658547, 0.07763629587310683, 0.07763629587310683, 0.07763629587310683, 0.08362907888438653, 0.08362907888438653, 0.08362907888438653, 0.4509689131542618, 0.4509689131542618, 0.4509689131542618, 0.44879869602303835, 0.44879869602303835, 0.44879869602303835, 0.41811471492497376, 0.41811471492497376, 0.41811471492497376, 0.08711219845809115, 0.08711219845809115, 0.08711219845809115, 0.07764685503547775, 0.07764685503547775, 0.07764685503547775, 0.08992719287152307, 0.08992719287152307, 0.08992719287152307, 0.1602878767526803, 0.1602878767526803, 0.1602878767526803, 0.14185361469346647, 0.14185361469346647, 0.14185361469346647, 0.14796798205690953, 0.14796798205690953, 0.14796798205690953, 0.24262989357363496, 0.24262989357363496, 0.24262989357363496, 0.24373313789977047, 0.24373313789977047, 0.24373313789977047, 0.257234765947151, 0.257234765947151, 0.257234765947151, 0.16382844260658025, 0.16382844260658025, 0.16382844260658025, 0.1590101511445926, 0.1590101511445926, 0.1590101511445926, 0.1547394001841128, 0.1547394001841128, 0.1547394001841128, 0.19521382504867069, 0.19521382504867069, 0.19521382504867069, 0.18240293027961108, 0.18240293027961108, 0.18240293027961108, 0.2075508126493658, 0.2075508126493658, 0.2075508126493658, 0.19954936255209665, 0.19954936255209665, 0.19954936255209665, 0.2144239086447416, 0.2144239086447416, 0.2144239086447416, 0.19836625082880843, 0.19836625082880843, 0.19836625082880843, 0.17612287272430838, 0.17612287272430838, 0.17612287272430838, 0.18101309931814835, 0.18101309931814835, 0.18101309931814835, 0.15450675833232164, 0.15450675833232164, 0.15450675833232164, 0.17791217411837112, 0.17791217411837112, 0.17791217411837112, 0.18143039266110494, 0.18143039266110494, 0.18143039266110494, 0.1940894872211868, 0.1940894872211868, 0.1940894872211868, 0.1982067039048777, 0.1982067039048777, 0.1982067039048777, 0.17956059220982756, 0.17956059220982756, 0.17956059220982756, 0.17615887981761735, 0.17615887981761735, 0.17615887981761735, 0.07067335685607701, 0.07067335685607701, 0.07067335685607701, 0.07543710669644721, 0.07543710669644721, 0.07543710669644721, 0.07341789212288097, 0.07341789212288097, 0.07341789212288097]}, "mutation_prompt": null}
{"id": "d40bc97f-9077-4efb-873c-6ed0232a5bf9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.1,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.9))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive memory with dynamic population resizing to balance exploration and exploitation across varying problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6611966411830577, 0.6611966411830577, 0.6611966411830577, 0.6849436491265545, 0.6849436491265545, 0.6849436491265545, 0.6737330361728551, 0.6737330361728551, 0.6737330361728551, 0.44422762312025343, 0.44422762312025343, 0.44422762312025343, 0.43458081532334714, 0.43458081532334714, 0.43458081532334714, 0.46179681793845184, 0.46179681793845184, 0.46179681793845184, 0.09010100455950565, 0.09010100455950565, 0.09010100455950565, 0.10599048406322054, 0.10599048406322054, 0.10599048406322054, 0.12864833046547575, 0.12864833046547575, 0.12864833046547575, 0.09201242340572224, 0.09201242340572224, 0.09201242340572224, 0.08227634972646303, 0.08227634972646303, 0.08227634972646303, 0.0933610451746113, 0.0933610451746113, 0.0933610451746113, 0.9124717034128103, 0.9124717034128103, 0.9124717034128103, 0.9424520096242133, 0.9424520096242133, 0.9424520096242133, 0.9563778766758267, 0.9563778766758267, 0.9563778766758267, 0.31991479949803947, 0.31991479949803947, 0.31991479949803947, 0.29610222474554304, 0.29610222474554304, 0.29610222474554304, 0.31405914013689784, 0.31405914013689784, 0.31405914013689784, 0.5793016437707736, 0.5793016437707736, 0.5793016437707736, 0.5850697030148779, 0.5850697030148779, 0.5850697030148779, 0.6464930701602443, 0.6464930701602443, 0.6464930701602443, 0.20161132776645352, 0.20161132776645352, 0.20161132776645352, 0.23103752433817304, 0.23103752433817304, 0.23103752433817304, 0.21344760795931883, 0.21344760795931883, 0.21344760795931883, 0.2492719636171693, 0.2492719636171693, 0.2492719636171693, 0.24496346602077868, 0.24496346602077868, 0.24496346602077868, 0.2162668879811327, 0.2162668879811327, 0.2162668879811327, 0.13860527762695396, 0.13860527762695396, 0.13860527762695396, 0.1144460012873516, 0.1144460012873516, 0.1144460012873516, 0.1450780003173937, 0.1450780003173937, 0.1450780003173937, 0.23443950631690602, 0.23443950631690602, 0.23443950631690602, 0.23685516049681177, 0.23685516049681177, 0.23685516049681177, 0.3126579126244542, 0.3126579126244542, 0.3126579126244542, 0.06738022271761601, 0.06738022271761601, 0.06738022271761601, 0.046395010192732844, 0.046395010192732844, 0.046395010192732844, 0.03004944527042064, 0.03004944527042064, 0.03004944527042064, 0.1893689804175419, 0.1893689804175419, 0.1893689804175419, 0.1946833442058793, 0.1946833442058793, 0.1946833442058793, 0.16749636586853922, 0.16749636586853922, 0.16749636586853922, 0.5046178093520599, 0.5046178093520599, 0.5046178093520599, 0.551063854536338, 0.551063854536338, 0.551063854536338, 0.5211510323195594, 0.5211510323195594, 0.5211510323195594, 0.08228019611947712, 0.08228019611947712, 0.08228019611947712, 0.07703967448944626, 0.07703967448944626, 0.07703967448944626, 0.10186737186089811, 0.10186737186089811, 0.10186737186089811, 0.1441543456522748, 0.1441543456522748, 0.1441543456522748, 0.13333255198010496, 0.13333255198010496, 0.13333255198010496, 0.202227179550572, 0.202227179550572, 0.202227179550572, 0.2886957258868109, 0.2886957258868109, 0.2886957258868109, 0.2759562955696335, 0.2759562955696335, 0.2759562955696335, 0.2957971779822466, 0.2957971779822466, 0.2957971779822466, 0.21044569125011614, 0.21044569125011614, 0.21044569125011614, 0.21683343801778965, 0.21683343801778965, 0.21683343801778965, 0.22802879579874602, 0.22802879579874602, 0.22802879579874602, 0.18960883311235732, 0.18960883311235732, 0.18960883311235732, 0.17535095262510625, 0.17535095262510625, 0.17535095262510625, 0.16755962869791396, 0.16755962869791396, 0.16755962869791396, 0.1821499678159153, 0.1821499678159153, 0.1821499678159153, 0.17532990328330322, 0.17532990328330322, 0.17532990328330322, 0.17997459687990536, 0.17997459687990536, 0.17997459687990536, 0.6062154048242127, 0.6062154048242127, 0.6062154048242127, 0.15962769790474518, 0.15962769790474518, 0.15962769790474518, 0.1743181939971249, 0.1743181939971249, 0.1743181939971249, 0.19437647676864567, 0.19437647676864567, 0.19437647676864567, 0.1892319324709738, 0.1892319324709738, 0.1892319324709738, 0.20418495713071227, 0.20418495713071227, 0.20418495713071227, 0.1822646272496815, 0.1822646272496815, 0.1822646272496815, 0.18230512846781244, 0.18230512846781244, 0.18230512846781244, 0.19220245449032625, 0.19220245449032625, 0.19220245449032625, 0.07052335372984087, 0.07052335372984087, 0.07052335372984087, 0.06550504164267845, 0.06550504164267845, 0.06550504164267845, 0.06672872276014552, 0.06672872276014552, 0.06672872276014552]}, "mutation_prompt": null}
{"id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 38, "fitness": 0.2887852691153724, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "70abc713-1a69-4430-ad35-297943e7d1ca", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "eab35769-dbd2-432d-ac83-41d683fc2a69", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        prev_best_fitness = min(fitness)\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            current_best_fitness = min(fitness)\n            if current_best_fitness < prev_best_fitness:\n                F = min(1.0, F + 0.1)  # Increase mutation factor slightly if improvement is observed\n                CR = max(0.5, CR - 0.1)  # Decrease crossover rate slightly \n            prev_best_fitness = current_best_fitness\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces a dynamic adaptation of mutation and crossover rates based on fitness improvement trends to enhance exploration-exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.2887852691153724, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "7b2c4816-871a-45e8-899a-a810a6c830e2", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "bb873fb0-33ae-4fbc-a723-fb2c0c27a594", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        elite_individuals = 2\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if i < elite_individuals:  # Preserve elites\n                    continue\n\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 8) == 0:  # Altered mutation probability timing\n                population = np.where(np.random.rand(population_size, self.dim) < 0.15,  # Slightly reduced mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Combines adaptive memory and dynamic parameter tuning with elite preservation to enhance exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.2821887257992704, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6396027930064094, 0.6396027930064094, 0.6396027930064094, 0.6501704339323859, 0.6501704339323859, 0.6501704339323859, 0.6365115048535389, 0.6365115048535389, 0.6365115048535389, 0.48821260583890347, 0.48821260583890347, 0.48821260583890347, 0.45232862810691177, 0.45232862810691177, 0.45232862810691177, 0.4244800291872829, 0.4244800291872829, 0.4244800291872829, 0.09835039581870386, 0.09835039581870386, 0.09835039581870386, 0.09156071066466864, 0.09156071066466864, 0.09156071066466864, 0.08234049726722936, 0.08234049726722936, 0.08234049726722936, 0.10164719462692662, 0.10164719462692662, 0.10164719462692662, 0.07812880050277471, 0.07812880050277471, 0.07812880050277471, 0.08896540684204302, 0.08896540684204302, 0.08896540684204302, 0.9860692656955512, 0.9860692656955512, 0.9860692656955512, 0.9603894159916044, 0.9603894159916044, 0.9603894159916044, 0.9612447684004658, 0.9612447684004658, 0.9612447684004658, 0.3059606489111517, 0.3059606489111517, 0.3059606489111517, 0.31424034012081015, 0.31424034012081015, 0.31424034012081015, 0.3428199716864355, 0.3428199716864355, 0.3428199716864355, 0.5176972354373, 0.5176972354373, 0.5176972354373, 0.5949026239781787, 0.5949026239781787, 0.5949026239781787, 0.5695310077766642, 0.5695310077766642, 0.5695310077766642, 0.23333112697839142, 0.23333112697839142, 0.23333112697839142, 0.23588488265572427, 0.23588488265572427, 0.23588488265572427, 0.23824153166119877, 0.23824153166119877, 0.23824153166119877, 0.1877436248199813, 0.1877436248199813, 0.1877436248199813, 0.24884105357011355, 0.24884105357011355, 0.24884105357011355, 0.20775372961082794, 0.20775372961082794, 0.20775372961082794, 0.1700306219559281, 0.1700306219559281, 0.1700306219559281, 0.15335852054815335, 0.15335852054815335, 0.15335852054815335, 0.15746872650201005, 0.15746872650201005, 0.15746872650201005, 0.29235389130944245, 0.29235389130944245, 0.29235389130944245, 0.2787452739177475, 0.2787452739177475, 0.2787452739177475, 0.33927650928111197, 0.33927650928111197, 0.33927650928111197, 0.023578213937528347, 0.023578213937528347, 0.023578213937528347, 0.027458233434893398, 0.027458233434893398, 0.027458233434893398, 0.049515396197811756, 0.049515396197811756, 0.049515396197811756, 0.17314076002743262, 0.17314076002743262, 0.17314076002743262, 0.17716500758960596, 0.17716500758960596, 0.17716500758960596, 0.1580390362368176, 0.1580390362368176, 0.1580390362368176, 0.5095691922539478, 0.5095691922539478, 0.5095691922539478, 0.4959918386862475, 0.4959918386862475, 0.4959918386862475, 0.48651448907049255, 0.48651448907049255, 0.48651448907049255, 0.0902451412273223, 0.0902451412273223, 0.0902451412273223, 0.07707027510890818, 0.07707027510890818, 0.07707027510890818, 0.07343792482161116, 0.07343792482161116, 0.07343792482161116, 0.18445042889919705, 0.18445042889919705, 0.18445042889919705, 0.16862885471372624, 0.16862885471372624, 0.16862885471372624, 0.14562624437026261, 0.14562624437026261, 0.14562624437026261, 0.2764691551063826, 0.2764691551063826, 0.2764691551063826, 0.2818572734365673, 0.2818572734365673, 0.2818572734365673, 0.2710763507148515, 0.2710763507148515, 0.2710763507148515, 0.21658829698872828, 0.21658829698872828, 0.21658829698872828, 0.20249286391866905, 0.20249286391866905, 0.20249286391866905, 0.2163145730014796, 0.2163145730014796, 0.2163145730014796, 0.17401748490324243, 0.17401748490324243, 0.17401748490324243, 0.1732049730049443, 0.1732049730049443, 0.1732049730049443, 0.18784743755934297, 0.18784743755934297, 0.18784743755934297, 0.17740988345063613, 0.17740988345063613, 0.17740988345063613, 0.19160117529146048, 0.19160117529146048, 0.19160117529146048, 0.17753762383008065, 0.17753762383008065, 0.17753762383008065, 0.6462131957928655, 0.6462131957928655, 0.6462131957928655, 0.17517227590782258, 0.17517227590782258, 0.17517227590782258, 0.1738809692395269, 0.1738809692395269, 0.1738809692395269, 0.25969657719233696, 0.25969657719233696, 0.25969657719233696, 0.19213820397016257, 0.19213820397016257, 0.19213820397016257, 0.5987271785828951, 0.5987271785828951, 0.5987271785828951, 0.18698834853466406, 0.18698834853466406, 0.18698834853466406, 0.17349130702430682, 0.17349130702430682, 0.17349130702430682, 0.19252076639391502, 0.19252076639391502, 0.19252076639391502, 0.06805651245600597, 0.06805651245600597, 0.06805651245600597, 0.06959676380988988, 0.06959676380988988, 0.06959676380988988, 0.0660742594043171, 0.0660742594043171, 0.0660742594043171]}, "mutation_prompt": null}
{"id": "0ec9d1f4-42df-4415-bec9-6738089096d6", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "b0d0b7ce-964a-4757-8ea2-f60e88177e55", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "736de9dd-f16a-4273-967a-587e73198246", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "51416142-2b92-4e83-b4db-a6e296a4cb31", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "805d8879-2071-4352-b3ae-d2128cc967e5", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "ccd62db9-574c-46c1-b838-80d1a74d1580", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "669a5048-ffed-4370-bbd0-0e95b3ae3546", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "7466961a-731e-4fa8-8087-fd1331bf8b37", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "1f7715a9-4671-4b93-8345-39ee646a85dd", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85)) \n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n            # New adaptive scaling strategy\n            if evaluations < self.budget and evaluations % (population_size * 7) == 0:\n                F = np.random.uniform(0.5, 0.9)  # Introduce variability in scaling factor\n                mem_F[mem_idx] = F  # Update memory with new scaling factor\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive scaling strategies with multi-phase learning for improved exploration and convergence stability.", "configspace": "", "generation": 50, "fitness": 0.2887852691153724, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "f4932be0-02a0-4bca-aac0-1939a059fd11", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "1236e70a-f6bd-4db2-8490-c6babc045756", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "20885df4-f2aa-4680-aeb7-59b796d01496", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "f1e511dd-b293-4830-8362-6d7b7c43636f", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "202b320d-4c0b-4e6c-9495-98e35b2a2513", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "c0f1b758-6af3-4b68-b6f8-12ddf6c55d1d", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.2,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Dynamic population resizing\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))  # More aggressive size reduction\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates adaptive memory with rotating scaling factors and crossover rates to improve diversity and convergence in dynamic landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6839668955449114, 0.6839668955449114, 0.6839668955449114, 0.7060370611764123, 0.7060370611764123, 0.7060370611764123, 0.6904723278057227, 0.6904723278057227, 0.6904723278057227, 0.4501726468644308, 0.4501726468644308, 0.4501726468644308, 0.47472881865328187, 0.47472881865328187, 0.47472881865328187, 0.4251159764918109, 0.4251159764918109, 0.4251159764918109, 0.10049583801368445, 0.10049583801368445, 0.10049583801368445, 0.10014021044102572, 0.10014021044102572, 0.10014021044102572, 0.10616573397963258, 0.10616573397963258, 0.10616573397963258, 0.08313073409502392, 0.08313073409502392, 0.08313073409502392, 0.10220713000399173, 0.10220713000399173, 0.10220713000399173, 0.0912746232380316, 0.0912746232380316, 0.0912746232380316, 0.9615548511934222, 0.9615548511934222, 0.9615548511934222, 0.9506406273023768, 0.9506406273023768, 0.9506406273023768, 0.9306382719743723, 0.9306382719743723, 0.9306382719743723, 0.31204966179244975, 0.31204966179244975, 0.31204966179244975, 0.3321998648986839, 0.3321998648986839, 0.3321998648986839, 0.3559353241681218, 0.3559353241681218, 0.3559353241681218, 0.5717956058805593, 0.5717956058805593, 0.5717956058805593, 0.5806008420997844, 0.5806008420997844, 0.5806008420997844, 0.6194468925036197, 0.6194468925036197, 0.6194468925036197, 0.26911705379868467, 0.26911705379868467, 0.26911705379868467, 0.19929019636557, 0.19929019636557, 0.19929019636557, 0.24521914783863508, 0.24521914783863508, 0.24521914783863508, 0.21834498263757962, 0.21834498263757962, 0.21834498263757962, 0.23993604555025416, 0.23993604555025416, 0.23993604555025416, 0.23591483726532647, 0.23591483726532647, 0.23591483726532647, 0.16591220838216336, 0.16591220838216336, 0.16591220838216336, 0.15790061880750927, 0.15790061880750927, 0.15790061880750927, 0.19353010872180998, 0.19353010872180998, 0.19353010872180998, 0.28571872011074495, 0.28571872011074495, 0.28571872011074495, 0.2674867351419602, 0.2674867351419602, 0.2674867351419602, 0.35654753320749166, 0.35654753320749166, 0.35654753320749166, 0.039728320582561705, 0.039728320582561705, 0.039728320582561705, 0.08469113508707415, 0.08469113508707415, 0.08469113508707415, 0.049614863996151004, 0.049614863996151004, 0.049614863996151004, 0.1721712374055594, 0.1721712374055594, 0.1721712374055594, 0.20535573960887898, 0.20535573960887898, 0.20535573960887898, 0.18035102838637906, 0.18035102838637906, 0.18035102838637906, 0.5182760599394066, 0.5182760599394066, 0.5182760599394066, 0.528631959790864, 0.528631959790864, 0.528631959790864, 0.5614384018559793, 0.5614384018559793, 0.5614384018559793, 0.0887491228492363, 0.0887491228492363, 0.0887491228492363, 0.08769194101624411, 0.08769194101624411, 0.08769194101624411, 0.08717774557149771, 0.08717774557149771, 0.08717774557149771, 0.12828940929197197, 0.12828940929197197, 0.12828940929197197, 0.12851749544704072, 0.12851749544704072, 0.12851749544704072, 0.21284535631776658, 0.21284535631776658, 0.21284535631776658, 0.2922149283523888, 0.2922149283523888, 0.2922149283523888, 0.26235548521537355, 0.26235548521537355, 0.26235548521537355, 0.2921846407593317, 0.2921846407593317, 0.2921846407593317, 0.23205021280021176, 0.23205021280021176, 0.23205021280021176, 0.20188559135869288, 0.20188559135869288, 0.20188559135869288, 0.24487396668503236, 0.24487396668503236, 0.24487396668503236, 0.19375674271542465, 0.19375674271542465, 0.19375674271542465, 0.188180041668641, 0.188180041668641, 0.188180041668641, 0.1926246788130166, 0.1926246788130166, 0.1926246788130166, 0.18064516836317435, 0.18064516836317435, 0.18064516836317435, 0.1798504076484081, 0.1798504076484081, 0.1798504076484081, 0.18253325136319243, 0.18253325136319243, 0.18253325136319243, 0.6507199215489284, 0.6507199215489284, 0.6507199215489284, 0.18294347905113806, 0.18294347905113806, 0.18294347905113806, 0.18712315785621092, 0.18712315785621092, 0.18712315785621092, 0.2013144677844343, 0.2013144677844343, 0.2013144677844343, 0.39701057337695944, 0.39701057337695944, 0.39701057337695944, 0.20669676133622894, 0.20669676133622894, 0.20669676133622894, 0.19077336697947078, 0.19077336697947078, 0.19077336697947078, 0.1873451972826562, 0.1873451972826562, 0.1873451972826562, 0.19319139056845003, 0.19319139056845003, 0.19319139056845003, 0.07196051546273508, 0.07196051546273508, 0.07196051546273508, 0.0731011894146526, 0.0731011894146526, 0.0731011894146526, 0.06998629680636914, 0.06998629680636914, 0.06998629680636914]}, "mutation_prompt": null}
{"id": "6383d96d-c096-4dc0-8878-8fd6e3f68a5b", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = mem_F[np.random.randint(memory_size)]\n                CR = mem_CR[np.random.randint(memory_size)]\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive population diversity control and inertia weighing to enhance exploration-exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.2894692537319567, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "d73a9a92-42c3-4e89-9e06-07ecbf4e1f09", "metadata": {"aucs": [0.6442996425622911, 0.6442996425622911, 0.6442996425622911, 0.6758336516240427, 0.6758336516240427, 0.6758336516240427, 0.703888625931113, 0.703888625931113, 0.703888625931113, 0.4590866220527855, 0.4590866220527855, 0.4590866220527855, 0.46336501861803636, 0.46336501861803636, 0.46336501861803636, 0.44852039448374104, 0.44852039448374104, 0.44852039448374104, 0.10048151185184384, 0.10048151185184384, 0.10048151185184384, 0.10480014928961956, 0.10480014928961956, 0.10480014928961956, 0.10075802217580909, 0.10075802217580909, 0.10075802217580909, 0.09210357201495167, 0.09210357201495167, 0.09210357201495167, 0.08737233850771242, 0.08737233850771242, 0.08737233850771242, 0.10852713198245023, 0.10852713198245023, 0.10852713198245023, 0.9400016265038676, 0.9400016265038676, 0.9400016265038676, 0.9509286370508735, 0.9509286370508735, 0.9509286370508735, 0.9457643258574324, 0.9457643258574324, 0.9457643258574324, 0.31824180968294435, 0.31824180968294435, 0.31824180968294435, 0.33248265554750833, 0.33248265554750833, 0.33248265554750833, 0.3758842559333261, 0.3758842559333261, 0.3758842559333261, 0.5979109529726327, 0.5979109529726327, 0.5979109529726327, 0.6585962041527651, 0.6585962041527651, 0.6585962041527651, 0.6347536717127462, 0.6347536717127462, 0.6347536717127462, 0.22044079663960736, 0.22044079663960736, 0.22044079663960736, 0.2156295215848859, 0.2156295215848859, 0.2156295215848859, 0.27385487900471184, 0.27385487900471184, 0.27385487900471184, 0.11111479388832102, 0.11111479388832102, 0.11111479388832102, 0.25608342564617337, 0.25608342564617337, 0.25608342564617337, 0.21294798275791127, 0.21294798275791127, 0.21294798275791127, 0.14125897351865624, 0.14125897351865624, 0.14125897351865624, 0.22264591295335867, 0.22264591295335867, 0.22264591295335867, 0.14825392806221893, 0.14825392806221893, 0.14825392806221893, 0.26916755958239813, 0.26916755958239813, 0.26916755958239813, 0.2802767046007414, 0.2802767046007414, 0.2802767046007414, 0.3217429121273264, 0.3217429121273264, 0.3217429121273264, 0.047635792014067424, 0.047635792014067424, 0.047635792014067424, 0.0942608721803021, 0.0942608721803021, 0.0942608721803021, 0.08201543724014027, 0.08201543724014027, 0.08201543724014027, 0.19520252037257413, 0.19520252037257413, 0.19520252037257413, 0.20621313404475838, 0.20621313404475838, 0.20621313404475838, 0.19256897243177784, 0.19256897243177784, 0.19256897243177784, 0.5434534720820925, 0.5434534720820925, 0.5434534720820925, 0.5630510273906595, 0.5630510273906595, 0.5630510273906595, 0.5157699742311446, 0.5157699742311446, 0.5157699742311446, 0.0992369064725297, 0.0992369064725297, 0.0992369064725297, 0.08362872908161223, 0.08362872908161223, 0.08362872908161223, 0.07725297377694662, 0.07725297377694662, 0.07725297377694662, 0.13170876252771302, 0.13170876252771302, 0.13170876252771302, 0.15858557806273532, 0.15858557806273532, 0.15858557806273532, 0.18032663997021714, 0.18032663997021714, 0.18032663997021714, 0.27634994836124294, 0.27634994836124294, 0.27634994836124294, 0.27166530394633126, 0.27166530394633126, 0.27166530394633126, 0.30450592521222675, 0.30450592521222675, 0.30450592521222675, 0.21520075298543817, 0.21520075298543817, 0.21520075298543817, 0.22009969882975156, 0.22009969882975156, 0.22009969882975156, 0.2219808803641583, 0.2219808803641583, 0.2219808803641583, 0.18514261230242612, 0.18514261230242612, 0.18514261230242612, 0.19774657932558382, 0.19774657932558382, 0.19774657932558382, 0.20819016515780142, 0.20819016515780142, 0.20819016515780142, 0.18285737133868596, 0.18285737133868596, 0.18285737133868596, 0.18649003886559923, 0.18649003886559923, 0.18649003886559923, 0.17329877450430287, 0.17329877450430287, 0.17329877450430287, 0.5979411705493523, 0.5979411705493523, 0.5979411705493523, 0.3226332428610794, 0.3226332428610794, 0.3226332428610794, 0.37068207095512584, 0.37068207095512584, 0.37068207095512584, 0.19873333618488576, 0.19873333618488576, 0.19873333618488576, 0.1865315288953282, 0.1865315288953282, 0.1865315288953282, 0.20739729082163882, 0.20739729082163882, 0.20739729082163882, 0.17350954787852713, 0.17350954787852713, 0.17350954787852713, 0.18060418281026747, 0.18060418281026747, 0.18060418281026747, 0.17476218997400772, 0.17476218997400772, 0.17476218997400772, 0.05985182839815428, 0.05985182839815428, 0.05985182839815428, 0.06914222511614987, 0.06914222511614987, 0.06914222511614987, 0.06854060030873965, 0.06854060030873965, 0.06854060030873965]}, "mutation_prompt": null}
{"id": "6d84150b-ad16-462d-8940-494179994f63", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 58, "fitness": 0.32274510331653966, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "6383d96d-c096-4dc0-8878-8fd6e3f68a5b", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "e62dc87f-5a61-41b7-a4e6-2b5c88fc95ce", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "f3005d5f-7532-4775-b1a3-8747155e1ebc", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "0cd526a3-d148-4585-adff-9303a0920c40", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "a1c6da49-daa5-4ae6-8187-6f9cc1ea3545", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "60fe51b9-950e-4255-855d-3ad6e47e1885", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "17d060fa-fd25-427b-8c6c-32e35b51195c", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "a8bfd750-d4c3-41df-a5ae-667738aed095", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "0e9d2d2e-8074-4f7c-95f1-392e8ec10504", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 8) == 0:  # Adjusted frequency\n                population = np.where(np.random.rand(population_size, self.dim) < 0.35,  # Adjusted mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                inertia_weight = np.random.uniform(0.7, 1.0)  # Added adaptive inertia weight\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces periodic random sampling and adaptive inertia weight to balance exploration and exploitation in differential evolution.", "configspace": "", "generation": 66, "fitness": 0.3157474672507203, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7255696443063642, 0.7255696443063642, 0.7255696443063642, 0.7450158696219995, 0.7450158696219995, 0.7450158696219995, 0.7359119930357964, 0.7359119930357964, 0.7359119930357964, 0.5460928671736776, 0.5460928671736776, 0.5460928671736776, 0.5351118570336328, 0.5351118570336328, 0.5351118570336328, 0.5583355873213189, 0.5583355873213189, 0.5583355873213189, 0.11881970585284818, 0.11881970585284818, 0.11881970585284818, 0.12147247162946118, 0.12147247162946118, 0.12147247162946118, 0.12490666363614567, 0.12490666363614567, 0.12490666363614567, 0.09454929255250177, 0.09454929255250177, 0.09454929255250177, 0.09615165900602551, 0.09615165900602551, 0.09615165900602551, 0.1065165655450031, 0.1065165655450031, 0.1065165655450031, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9484947399795295, 0.9484947399795295, 0.9484947399795295, 0.9122558560740924, 0.9122558560740924, 0.9122558560740924, 0.37128227604921904, 0.37128227604921904, 0.37128227604921904, 0.33399497313038073, 0.33399497313038073, 0.33399497313038073, 0.3772338973393705, 0.3772338973393705, 0.3772338973393705, 0.662069883535179, 0.662069883535179, 0.662069883535179, 0.5902280147144165, 0.5902280147144165, 0.5902280147144165, 0.613073431562731, 0.613073431562731, 0.613073431562731, 0.24491317604976826, 0.24491317604976826, 0.24491317604976826, 0.28537824577496096, 0.28537824577496096, 0.28537824577496096, 0.22424908038070157, 0.22424908038070157, 0.22424908038070157, 0.22776054180054395, 0.22776054180054395, 0.22776054180054395, 0.3125931461409982, 0.3125931461409982, 0.3125931461409982, 0.2854669199057167, 0.2854669199057167, 0.2854669199057167, 0.22865824356645814, 0.22865824356645814, 0.22865824356645814, 0.16344757108473695, 0.16344757108473695, 0.16344757108473695, 0.17378910104662937, 0.17378910104662937, 0.17378910104662937, 0.3226226110927104, 0.3226226110927104, 0.3226226110927104, 0.286556729755736, 0.286556729755736, 0.286556729755736, 0.3151120668134214, 0.3151120668134214, 0.3151120668134214, 0.04345508120119179, 0.04345508120119179, 0.04345508120119179, 0.02964883452790712, 0.02964883452790712, 0.02964883452790712, 0.06829919043502009, 0.06829919043502009, 0.06829919043502009, 0.2015904336092369, 0.2015904336092369, 0.2015904336092369, 0.2062979754237767, 0.2062979754237767, 0.2062979754237767, 0.17661736787451132, 0.17661736787451132, 0.17661736787451132, 0.556602134820783, 0.556602134820783, 0.556602134820783, 0.5663459786667835, 0.5663459786667835, 0.5663459786667835, 0.5494567809135162, 0.5494567809135162, 0.5494567809135162, 0.09307257119129242, 0.09307257119129242, 0.09307257119129242, 0.09209709670900268, 0.09209709670900268, 0.09209709670900268, 0.09233845923573702, 0.09233845923573702, 0.09233845923573702, 0.1502104885931549, 0.1502104885931549, 0.1502104885931549, 0.17073127175747127, 0.17073127175747127, 0.17073127175747127, 0.17711206744900065, 0.17711206744900065, 0.17711206744900065, 0.3412417552224766, 0.3412417552224766, 0.3412417552224766, 0.30734461347451847, 0.30734461347451847, 0.30734461347451847, 0.34223898294588095, 0.34223898294588095, 0.34223898294588095, 0.2226023401092394, 0.2226023401092394, 0.2226023401092394, 0.21515948899010895, 0.21515948899010895, 0.21515948899010895, 0.24803233281168435, 0.24803233281168435, 0.24803233281168435, 0.184643029038827, 0.184643029038827, 0.184643029038827, 0.19404245183838664, 0.19404245183838664, 0.19404245183838664, 0.18741787653741027, 0.18741787653741027, 0.18741787653741027, 0.19800448325838638, 0.19800448325838638, 0.19800448325838638, 0.1902135812197152, 0.1902135812197152, 0.1902135812197152, 0.18143355826446872, 0.18143355826446872, 0.18143355826446872, 0.6551582099561042, 0.6551582099561042, 0.6551582099561042, 0.4558080501887348, 0.4558080501887348, 0.4558080501887348, 0.4189421352977696, 0.4189421352977696, 0.4189421352977696, 0.1893669094023589, 0.1893669094023589, 0.1893669094023589, 0.18895101325244767, 0.18895101325244767, 0.18895101325244767, 0.6984259872617062, 0.6984259872617062, 0.6984259872617062, 0.1923855435766063, 0.1923855435766063, 0.1923855435766063, 0.18408652042269913, 0.18408652042269913, 0.18408652042269913, 0.17708354753713995, 0.17708354753713995, 0.17708354753713995, 0.07004213376047264, 0.07004213376047264, 0.07004213376047264, 0.07502726201067123, 0.07502726201067123, 0.07502726201067123, 0.07280562556437675, 0.07280562556437675, 0.07280562556437675]}, "mutation_prompt": null}
{"id": "86c4a8b1-dd93-400f-b42f-9366a2cc609a", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "4554fa40-e185-4762-8abe-c420d27394e3", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "fad9dba4-18c3-4e22-aa4e-831d9f5db5aa", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "63f6a73d-cae7-4fc0-b24f-1b20abce4db3", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "6457c0d8-0d99-41f6-9498-e5bc7ccf211d", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                # Adjusted mutation probability and tournament selection\n                for j in range(population_size):\n                    if np.random.rand() < 0.3:\n                        candidates = np.random.choice(range(population_size), 4, replace=False)\n                        selected = min(candidates, key=lambda x: fitness[x])\n                        population[j] = population[selected]\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                inertia_weight = max(0.4, inertia_weight * 0.95)  # Adaptive inertia weight\n                population += np.random.normal(0, inertia_weight, population.shape)\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Incorporate adaptive inertia weight scheduling and tournament selection to balance exploration and exploitation effectively.", "configspace": "", "generation": 71, "fitness": 0.3119981505948062, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7280661667139228, 0.7280661667139228, 0.7280661667139228, 0.7375034773936784, 0.7375034773936784, 0.7375034773936784, 0.727736238323469, 0.727736238323469, 0.727736238323469, 0.5624207401682686, 0.5624207401682686, 0.5624207401682686, 0.5158856232610858, 0.5158856232610858, 0.5158856232610858, 0.5434627139037169, 0.5434627139037169, 0.5434627139037169, 0.11215107237227517, 0.11215107237227517, 0.11215107237227517, 0.10690259827996473, 0.10690259827996473, 0.10690259827996473, 0.12062672394149743, 0.12062672394149743, 0.12062672394149743, 0.0992132213767043, 0.0992132213767043, 0.0992132213767043, 0.10140788507491583, 0.10140788507491583, 0.10140788507491583, 0.10120369901789494, 0.10120369901789494, 0.10120369901789494, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9483515004326024, 0.9483515004326024, 0.9483515004326024, 0.9705943493543704, 0.9705943493543704, 0.9705943493543704, 0.36783969922569815, 0.36783969922569815, 0.36783969922569815, 0.35495763884315834, 0.35495763884315834, 0.35495763884315834, 0.3597752084761221, 0.3597752084761221, 0.3597752084761221, 0.5925104103105072, 0.5925104103105072, 0.5925104103105072, 0.6491522614898887, 0.6491522614898887, 0.6491522614898887, 0.5919970842775326, 0.5919970842775326, 0.5919970842775326, 0.2650719615944276, 0.2650719615944276, 0.2650719615944276, 0.2706814218328001, 0.2706814218328001, 0.2706814218328001, 0.20309237112192235, 0.20309237112192235, 0.20309237112192235, 0.1958303670934689, 0.1958303670934689, 0.1958303670934689, 0.3031429683790018, 0.3031429683790018, 0.3031429683790018, 0.2663109327214448, 0.2663109327214448, 0.2663109327214448, 0.18402547618129605, 0.18402547618129605, 0.18402547618129605, 0.20263518116339296, 0.20263518116339296, 0.20263518116339296, 0.13808433305597323, 0.13808433305597323, 0.13808433305597323, 0.2833138217498301, 0.2833138217498301, 0.2833138217498301, 0.2617470533732399, 0.2617470533732399, 0.2617470533732399, 0.35703785544434363, 0.35703785544434363, 0.35703785544434363, 0.09736139539952893, 0.09736139539952893, 0.09736139539952893, 0.08210144190686575, 0.08210144190686575, 0.08210144190686575, 0.1075727489369036, 0.1075727489369036, 0.1075727489369036, 0.19520219233410663, 0.19520219233410663, 0.19520219233410663, 0.22028196888325913, 0.22028196888325913, 0.22028196888325913, 0.20644682070367137, 0.20644682070367137, 0.20644682070367137, 0.539844262212348, 0.539844262212348, 0.539844262212348, 0.5644565710609177, 0.5644565710609177, 0.5644565710609177, 0.5468503174217152, 0.5468503174217152, 0.5468503174217152, 0.09192919669126987, 0.09192919669126987, 0.09192919669126987, 0.0854694030956451, 0.0854694030956451, 0.0854694030956451, 0.10669110614303157, 0.10669110614303157, 0.10669110614303157, 0.1365441457125366, 0.1365441457125366, 0.1365441457125366, 0.1941497267731579, 0.1941497267731579, 0.1941497267731579, 0.15807030709734649, 0.15807030709734649, 0.15807030709734649, 0.2971919737326355, 0.2971919737326355, 0.2971919737326355, 0.2978174217726318, 0.2978174217726318, 0.2978174217726318, 0.34324994884369453, 0.34324994884369453, 0.34324994884369453, 0.21931336645640354, 0.21931336645640354, 0.21931336645640354, 0.2187949214268854, 0.2187949214268854, 0.2187949214268854, 0.2324621225751844, 0.2324621225751844, 0.2324621225751844, 0.1876886708215436, 0.1876886708215436, 0.1876886708215436, 0.19040684629581583, 0.19040684629581583, 0.19040684629581583, 0.19770492666932993, 0.19770492666932993, 0.19770492666932993, 0.17806626314111473, 0.17806626314111473, 0.17806626314111473, 0.18631133460410954, 0.18631133460410954, 0.18631133460410954, 0.18116685346094397, 0.18116685346094397, 0.18116685346094397, 0.6509528367626183, 0.6509528367626183, 0.6509528367626183, 0.19061472008156188, 0.19061472008156188, 0.19061472008156188, 0.5155987742205247, 0.5155987742205247, 0.5155987742205247, 0.18772405533502157, 0.18772405533502157, 0.18772405533502157, 0.1909723038678548, 0.1909723038678548, 0.1909723038678548, 0.6754401652154538, 0.6754401652154538, 0.6754401652154538, 0.17955567602525913, 0.17955567602525913, 0.17955567602525913, 0.2016339620429909, 0.2016339620429909, 0.2016339620429909, 0.17826256936162443, 0.17826256936162443, 0.17826256936162443, 0.06565569894390078, 0.06565569894390078, 0.06565569894390078, 0.07575480414852243, 0.07575480414852243, 0.07575480414852243, 0.08397317151049011, 0.08397317151049011, 0.08397317151049011]}, "mutation_prompt": null}
{"id": "09cc5feb-6a05-4250-a73a-438a1f7ffbbe", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "352eec8d-6e0d-49b3-a3c7-9ac66cc4e9c0", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n        success_rate = np.zeros(memory_size)  # Track success rates\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR based on past successes\n                F = np.random.uniform(0.5, 1.0) * (1 + 0.1 * success_rate.mean())\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    success_rate[mem_idx] = 1  # Log success\n                    mem_idx = (mem_idx + 1) % memory_size\n                else:\n                    success_rate[mem_idx] = 0  # Log failure\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                mutation_prob = 0.3 + 0.1 * success_rate.mean()  # Adjust mutation probability\n                population = np.where(np.random.rand(population_size, self.dim) < mutation_prob,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces adaptive learning of scaling factors using historical successes to improve convergence.", "configspace": "", "generation": 73, "fitness": 0.29980750043263893, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.6992129906096863, 0.6992129906096863, 0.6992129906096863, 0.7313268367502959, 0.7313268367502959, 0.7313268367502959, 0.7135583621591182, 0.7135583621591182, 0.7135583621591182, 0.47418929919505026, 0.47418929919505026, 0.47418929919505026, 0.4918340451123606, 0.4918340451123606, 0.4918340451123606, 0.46079939522429525, 0.46079939522429525, 0.46079939522429525, 0.10714128517310273, 0.10714128517310273, 0.10714128517310273, 0.1093740838414955, 0.1093740838414955, 0.1093740838414955, 0.11530611565136295, 0.11530611565136295, 0.11530611565136295, 0.0875478385555476, 0.0875478385555476, 0.0875478385555476, 0.1112047312968325, 0.1112047312968325, 0.1112047312968325, 0.09781233060520667, 0.09781233060520667, 0.09781233060520667, 0.9736056685847176, 0.9736056685847176, 0.9736056685847176, 0.9674998199028514, 0.9674998199028514, 0.9674998199028514, 0.9284422914112105, 0.9284422914112105, 0.9284422914112105, 0.31489955536882575, 0.31489955536882575, 0.31489955536882575, 0.31056869988023883, 0.31056869988023883, 0.31056869988023883, 0.3463750333300084, 0.3463750333300084, 0.3463750333300084, 0.41142634036292847, 0.41142634036292847, 0.41142634036292847, 0.6290032991994725, 0.6290032991994725, 0.6290032991994725, 0.5025028234121813, 0.5025028234121813, 0.5025028234121813, 0.24809956476132378, 0.24809956476132378, 0.24809956476132378, 0.2293484457143662, 0.2293484457143662, 0.2293484457143662, 0.21013803260063235, 0.21013803260063235, 0.21013803260063235, 0.3090648513506139, 0.3090648513506139, 0.3090648513506139, 0.21615188960399778, 0.21615188960399778, 0.21615188960399778, 0.2764780546088065, 0.2764780546088065, 0.2764780546088065, 0.16351814177806612, 0.16351814177806612, 0.16351814177806612, 0.12509429650130366, 0.12509429650130366, 0.12509429650130366, 0.15107480034876075, 0.15107480034876075, 0.15107480034876075, 0.259314510600527, 0.259314510600527, 0.259314510600527, 0.190624766512132, 0.190624766512132, 0.190624766512132, 0.2912535784539999, 0.2912535784539999, 0.2912535784539999, 0.05551544532520036, 0.05551544532520036, 0.05551544532520036, 0.04926750938454183, 0.04926750938454183, 0.04926750938454183, 0.0787391043381116, 0.0787391043381116, 0.0787391043381116, 0.1652540479266983, 0.1652540479266983, 0.1652540479266983, 0.20640386129428367, 0.20640386129428367, 0.20640386129428367, 0.17120669840038083, 0.17120669840038083, 0.17120669840038083, 0.5268166461710445, 0.5268166461710445, 0.5268166461710445, 0.515209928134268, 0.515209928134268, 0.515209928134268, 0.4926451800543531, 0.4926451800543531, 0.4926451800543531, 0.08435217936327066, 0.08435217936327066, 0.08435217936327066, 0.08055205002476795, 0.08055205002476795, 0.08055205002476795, 0.09120515162489173, 0.09120515162489173, 0.09120515162489173, 0.14629794061412216, 0.14629794061412216, 0.14629794061412216, 0.2124070066937228, 0.2124070066937228, 0.2124070066937228, 0.14586720613344406, 0.14586720613344406, 0.14586720613344406, 0.2653877667572001, 0.2653877667572001, 0.2653877667572001, 0.2972933830738601, 0.2972933830738601, 0.2972933830738601, 0.31888855238374814, 0.31888855238374814, 0.31888855238374814, 0.23555364364349085, 0.23555364364349085, 0.23555364364349085, 0.22971504557551847, 0.22971504557551847, 0.22971504557551847, 0.23970407011380634, 0.23970407011380634, 0.23970407011380634, 0.1886149406173543, 0.1886149406173543, 0.1886149406173543, 0.17388829662220728, 0.17388829662220728, 0.17388829662220728, 0.19780220662953085, 0.19780220662953085, 0.19780220662953085, 0.17648868596995415, 0.17648868596995415, 0.17648868596995415, 0.1880015522851728, 0.1880015522851728, 0.1880015522851728, 0.18512934199592168, 0.18512934199592168, 0.18512934199592168, 0.7310759249781691, 0.7310759249781691, 0.7310759249781691, 0.4795980631535989, 0.4795980631535989, 0.4795980631535989, 0.4569978938240944, 0.4569978938240944, 0.4569978938240944, 0.16261324420064993, 0.16261324420064993, 0.16261324420064993, 0.3154185171660816, 0.3154185171660816, 0.3154185171660816, 0.6567805129915087, 0.6567805129915087, 0.6567805129915087, 0.19401227604270954, 0.19401227604270954, 0.19401227604270954, 0.18860864442492675, 0.18860864442492675, 0.18860864442492675, 0.20248480071321662, 0.20248480071321662, 0.20248480071321662, 0.0737137800792268, 0.0737137800792268, 0.0737137800792268, 0.07063230193136916, 0.07063230193136916, 0.07063230193136916, 0.08220485203226635, 0.08220485203226635, 0.08220485203226635]}, "mutation_prompt": null}
{"id": "c743985d-d85b-44dd-ac41-2b5043292027", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "f15e53bb-cb9b-4acc-9b2f-8ba291b2a710", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        # Chaotic sequence parameters\n        chaotic_r = 3.8\n        chaotic_x = 0.4\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                chaotic_x = chaotic_r * chaotic_x * (1 - chaotic_x)  # Logistic map\n                F = 0.5 + chaotic_x * 0.5\n                CR = 0.7 + chaotic_x * 0.3\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                inertia_weight = 0.5 + (0.4 * np.cos(np.pi * evaluations / self.budget))  # Adaptive inertia\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhanced exploration using chaotic sequences and adaptive inertia weights to improve global searchability.", "configspace": "", "generation": 75, "fitness": 0.2769269435769028, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.6659512621028632, 0.6659512621028632, 0.6659512621028632, 0.7173555516196601, 0.7173555516196601, 0.7173555516196601, 0.6936528075292989, 0.6936528075292989, 0.6936528075292989, 0.439087806662945, 0.439087806662945, 0.439087806662945, 0.4453188454772772, 0.4453188454772772, 0.4453188454772772, 0.4424260840990535, 0.4424260840990535, 0.4424260840990535, 0.1112885555586387, 0.1112885555586387, 0.1112885555586387, 0.10876273634500355, 0.10876273634500355, 0.10876273634500355, 0.10020443263312317, 0.10020443263312317, 0.10020443263312317, 0.09834007849806115, 0.09834007849806115, 0.09834007849806115, 0.10257233774029006, 0.10257233774029006, 0.10257233774029006, 0.09858134289777676, 0.09858134289777676, 0.09858134289777676, 0.9787273511515998, 0.9787273511515998, 0.9787273511515998, 0.9495361725349526, 0.9495361725349526, 0.9495361725349526, 0.9543715193661959, 0.9543715193661959, 0.9543715193661959, 0.30133652043161185, 0.30133652043161185, 0.30133652043161185, 0.3098869034528404, 0.3098869034528404, 0.3098869034528404, 0.34734638024594655, 0.34734638024594655, 0.34734638024594655, 0.5136260570178915, 0.5136260570178915, 0.5136260570178915, 0.5597469048197922, 0.5597469048197922, 0.5597469048197922, 0.7258024004473643, 0.7258024004473643, 0.7258024004473643, 0.25950598252226087, 0.25950598252226087, 0.25950598252226087, 0.2548725859364137, 0.2548725859364137, 0.2548725859364137, 0.2012863982751818, 0.2012863982751818, 0.2012863982751818, 0.26200093886519693, 0.26200093886519693, 0.26200093886519693, 0.2299303863437996, 0.2299303863437996, 0.2299303863437996, 0.23467096350230465, 0.23467096350230465, 0.23467096350230465, 0.13686829584954208, 0.13686829584954208, 0.13686829584954208, 0.15455818130254106, 0.15455818130254106, 0.15455818130254106, 0.11943171441164357, 0.11943171441164357, 0.11943171441164357, 0.2940204777771772, 0.2940204777771772, 0.2940204777771772, 0.23865781133210628, 0.23865781133210628, 0.23865781133210628, 0.29780410975107185, 0.29780410975107185, 0.29780410975107185, 0.037337579858408354, 0.037337579858408354, 0.037337579858408354, 0.06032229831089697, 0.06032229831089697, 0.06032229831089697, 0.035577494168576584, 0.035577494168576584, 0.035577494168576584, 0.15854750867043443, 0.15854750867043443, 0.15854750867043443, 0.17399034057827978, 0.17399034057827978, 0.17399034057827978, 0.16163501096267863, 0.16163501096267863, 0.16163501096267863, 0.47834542180847506, 0.47834542180847506, 0.47834542180847506, 0.4842461728626314, 0.4842461728626314, 0.4842461728626314, 0.509451428523144, 0.509451428523144, 0.509451428523144, 0.0871388962591727, 0.0871388962591727, 0.0871388962591727, 0.10288781205482067, 0.10288781205482067, 0.10288781205482067, 0.08208082525819005, 0.08208082525819005, 0.08208082525819005, 0.1664021418926952, 0.1664021418926952, 0.1664021418926952, 0.19003861034965408, 0.19003861034965408, 0.19003861034965408, 0.16610864887992538, 0.16610864887992538, 0.16610864887992538, 0.26391568580074387, 0.26391568580074387, 0.26391568580074387, 0.27708508582730496, 0.27708508582730496, 0.27708508582730496, 0.3054394123878038, 0.3054394123878038, 0.3054394123878038, 0.20485531622547837, 0.20485531622547837, 0.20485531622547837, 0.18997156806277138, 0.18997156806277138, 0.18997156806277138, 0.2126458483840209, 0.2126458483840209, 0.2126458483840209, 0.16976421786961438, 0.16976421786961438, 0.16976421786961438, 0.17968438273090448, 0.17968438273090448, 0.17968438273090448, 0.18729081462021624, 0.18729081462021624, 0.18729081462021624, 0.1808656983704955, 0.1808656983704955, 0.1808656983704955, 0.17585323161816435, 0.17585323161816435, 0.17585323161816435, 0.1734434199260666, 0.1734434199260666, 0.1734434199260666, 0.1603989502632508, 0.1603989502632508, 0.1603989502632508, 0.17979922274692306, 0.17979922274692306, 0.17979922274692306, 0.4827636949664498, 0.4827636949664498, 0.4827636949664498, 0.20404575883044318, 0.20404575883044318, 0.20404575883044318, 0.19712430195662667, 0.19712430195662667, 0.19712430195662667, 0.20279112156412715, 0.20279112156412715, 0.20279112156412715, 0.1816184785645205, 0.1816184785645205, 0.1816184785645205, 0.18193561045099993, 0.18193561045099993, 0.18193561045099993, 0.18373361995008985, 0.18373361995008985, 0.18373361995008985, 0.07154350621318062, 0.07154350621318062, 0.07154350621318062, 0.0671855992117153, 0.0671855992117153, 0.0671855992117153, 0.06334530405567962, 0.06334530405567962, 0.06334530405567962]}, "mutation_prompt": null}
{"id": "7b3aca62-1354-4356-9549-05c8afab97f7", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "f50fe18a-b7eb-423d-92f3-4c17401b0ea8", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "27651a0b-5eb4-4c77-9f3f-6c08bf419838", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                \n                # Opposition-based learning\n                opposite = self.lower_bound + self.upper_bound - crossover\n                opposite_fitness = func(opposite)\n                evaluations += 1\n                \n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i] or opposite_fitness < fitness[i]:\n                    if opposite_fitness < new_fitness:\n                        population[i] = opposite\n                        fitness[i] = opposite_fitness\n                    else:\n                        population[i] = crossover\n                        fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Incorporates dynamic opposition-based learning and variable neighborhood search to enhance exploration and exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.20988199117160772, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.48886077160684693, 0.48886077160684693, 0.48886077160684693, 0.5114803950583258, 0.5114803950583258, 0.5114803950583258, 0.4894604000843221, 0.4894604000843221, 0.4894604000843221, 0.25369471711083313, 0.25369471711083313, 0.25369471711083313, 0.20352312198223244, 0.20352312198223244, 0.20352312198223244, 0.25038374024858867, 0.25038374024858867, 0.25038374024858867, 0.09397579322869165, 0.09397579322869165, 0.09397579322869165, 0.08743434416596918, 0.08743434416596918, 0.08743434416596918, 0.0923899926491285, 0.0923899926491285, 0.0923899926491285, 0.07876402829823004, 0.07876402829823004, 0.07876402829823004, 0.08601511382437566, 0.08601511382437566, 0.08601511382437566, 0.0773672570680547, 0.0773672570680547, 0.0773672570680547, 0.8665749748186028, 0.8665749748186028, 0.8665749748186028, 0.907346202032406, 0.907346202032406, 0.907346202032406, 0.9313549809752034, 0.9313549809752034, 0.9313549809752034, 0.18251364416603788, 0.18251364416603788, 0.18251364416603788, 0.20123688166080345, 0.20123688166080345, 0.20123688166080345, 0.21466057291580787, 0.21466057291580787, 0.21466057291580787, 0.2208249688473759, 0.2208249688473759, 0.2208249688473759, 0.34557628685341046, 0.34557628685341046, 0.34557628685341046, 0.26631935106172455, 0.26631935106172455, 0.26631935106172455, 0.13222356255555756, 0.13222356255555756, 0.13222356255555756, 0.11177874454140779, 0.11177874454140779, 0.11177874454140779, 0.1241372116782663, 0.1241372116782663, 0.1241372116782663, 0.20752704161267743, 0.20752704161267743, 0.20752704161267743, 0.12723893336976055, 0.12723893336976055, 0.12723893336976055, 0.12578357340855417, 0.12578357340855417, 0.12578357340855417, 0.058857264743839566, 0.058857264743839566, 0.058857264743839566, 0.03627463262144315, 0.03627463262144315, 0.03627463262144315, 0.028956727531907034, 0.028956727531907034, 0.028956727531907034, 0.16494121901807102, 0.16494121901807102, 0.16494121901807102, 0.16571048614588268, 0.16571048614588268, 0.16571048614588268, 0.15057804881022807, 0.15057804881022807, 0.15057804881022807, 0.0023260414885714065, 0.0023260414885714065, 0.0023260414885714065, 0.006858338081556892, 0.006858338081556892, 0.006858338081556892, 0.002394895866790314, 0.002394895866790314, 0.002394895866790314, 0.0838307434651413, 0.0838307434651413, 0.0838307434651413, 0.0875341081714851, 0.0875341081714851, 0.0875341081714851, 0.10496826958030325, 0.10496826958030325, 0.10496826958030325, 0.38502787422397, 0.38502787422397, 0.38502787422397, 0.3916765590672292, 0.3916765590672292, 0.3916765590672292, 0.4110049257975019, 0.4110049257975019, 0.4110049257975019, 0.07534458044125714, 0.07534458044125714, 0.07534458044125714, 0.06647015963190372, 0.06647015963190372, 0.06647015963190372, 0.08613217635472015, 0.08613217635472015, 0.08613217635472015, 0.13311550155675034, 0.13311550155675034, 0.13311550155675034, 0.12113643045302636, 0.12113643045302636, 0.12113643045302636, 0.1478802031635993, 0.1478802031635993, 0.1478802031635993, 0.2274600936801009, 0.2274600936801009, 0.2274600936801009, 0.22457555095252524, 0.22457555095252524, 0.22457555095252524, 0.25489408061920904, 0.25489408061920904, 0.25489408061920904, 0.17797830035520767, 0.17797830035520767, 0.17797830035520767, 0.15640224012236503, 0.15640224012236503, 0.15640224012236503, 0.18318196397129827, 0.18318196397129827, 0.18318196397129827, 0.1685121576737314, 0.1685121576737314, 0.1685121576737314, 0.16707103842666604, 0.16707103842666604, 0.16707103842666604, 0.18086537611910858, 0.18086537611910858, 0.18086537611910858, 0.1856711853677271, 0.1856711853677271, 0.1856711853677271, 0.1566400745794475, 0.1566400745794475, 0.1566400745794475, 0.17292528997884438, 0.17292528997884438, 0.17292528997884438, 0.45229639085044704, 0.45229639085044704, 0.45229639085044704, 0.16907478290347522, 0.16907478290347522, 0.16907478290347522, 0.25386956676794203, 0.25386956676794203, 0.25386956676794203, 0.3092204575770573, 0.3092204575770573, 0.3092204575770573, 0.18206222203241718, 0.18206222203241718, 0.18206222203241718, 0.29427410967108325, 0.29427410967108325, 0.29427410967108325, 0.18065525294830898, 0.18065525294830898, 0.18065525294830898, 0.1926384874182664, 0.1926384874182664, 0.1926384874182664, 0.2212716177166809, 0.2212716177166809, 0.2212716177166809, 0.07262556277006116, 0.07262556277006116, 0.07262556277006116, 0.06762823998626755, 0.06762823998626755, 0.06762823998626755, 0.07024352982914372, 0.07024352982914372, 0.07024352982914372]}, "mutation_prompt": null}
{"id": "65083186-0b86-4df6-8cdc-1f8a9469bdea", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "d52a9a13-a5e8-425f-9e9c-3b3d4ee597b2", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "868ae0f1-ca46-4667-b7a9-0d89b77a6fc4", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n        local_search_prob = 0.1  # Probability of performing local search\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                # Perform local search\n                if np.random.rand() < local_search_prob:\n                    for _ in range(3):  # Attempt a few local moves\n                        local_move = population[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                        local_move = np.clip(local_move, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_move)\n                        evaluations += 1\n                        if local_fitness < fitness[i]:\n                            population[i] = local_move\n                            fitness[i] = local_fitness\n                            break\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors, stochastic adjustments, and local search to improve convergence speed and accuracy.", "configspace": "", "generation": 81, "fitness": 0.2534419465672887, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.6285013682808525, 0.6285013682808525, 0.6285013682808525, 0.5657021301267061, 0.5657021301267061, 0.5657021301267061, 0.6509870236458491, 0.6509870236458491, 0.6509870236458491, 0.29272042451795366, 0.29272042451795366, 0.29272042451795366, 0.36512497829087565, 0.36512497829087565, 0.36512497829087565, 0.38466466260276766, 0.38466466260276766, 0.38466466260276766, 0.1155393011080641, 0.1155393011080641, 0.1155393011080641, 0.10540397706583315, 0.10540397706583315, 0.10540397706583315, 0.13101015036573993, 0.13101015036573993, 0.13101015036573993, 0.10471131217076513, 0.10471131217076513, 0.10471131217076513, 0.10076898365388476, 0.10076898365388476, 0.10076898365388476, 0.10406507082487115, 0.10406507082487115, 0.10406507082487115, 0.9218500099568792, 0.9218500099568792, 0.9218500099568792, 0.9015892727910193, 0.9015892727910193, 0.9015892727910193, 0.8729861725248694, 0.8729861725248694, 0.8729861725248694, 0.21802126338615146, 0.21802126338615146, 0.21802126338615146, 0.28842428256505237, 0.28842428256505237, 0.28842428256505237, 0.2714882329065553, 0.2714882329065553, 0.2714882329065553, 0.4710898743530241, 0.4710898743530241, 0.4710898743530241, 0.24445653537144008, 0.24445653537144008, 0.24445653537144008, 0.3253180053174425, 0.3253180053174425, 0.3253180053174425, 0.17174908948765766, 0.17174908948765766, 0.17174908948765766, 0.19201222340291524, 0.19201222340291524, 0.19201222340291524, 0.21373049744549244, 0.21373049744549244, 0.21373049744549244, 0.27603517199431193, 0.27603517199431193, 0.27603517199431193, 0.2105350623377008, 0.2105350623377008, 0.2105350623377008, 0.18976639791078997, 0.18976639791078997, 0.18976639791078997, 0.13330749052049928, 0.13330749052049928, 0.13330749052049928, 0.11292945923586262, 0.11292945923586262, 0.11292945923586262, 0.11179662505670329, 0.11179662505670329, 0.11179662505670329, 0.2495089731928961, 0.2495089731928961, 0.2495089731928961, 0.22468721017441495, 0.22468721017441495, 0.22468721017441495, 0.2582623256920966, 0.2582623256920966, 0.2582623256920966, 0.029512624687422995, 0.029512624687422995, 0.029512624687422995, 0.03512592287645533, 0.03512592287645533, 0.03512592287645533, 0.02073888476452035, 0.02073888476452035, 0.02073888476452035, 0.14848442685396546, 0.14848442685396546, 0.14848442685396546, 0.156404766015956, 0.156404766015956, 0.156404766015956, 0.16574362795747744, 0.16574362795747744, 0.16574362795747744, 0.48579921895615696, 0.48579921895615696, 0.48579921895615696, 0.4670141764697603, 0.4670141764697603, 0.4670141764697603, 0.43567126014451796, 0.43567126014451796, 0.43567126014451796, 0.11718971799934919, 0.11718971799934919, 0.11718971799934919, 0.1135788199986435, 0.1135788199986435, 0.1135788199986435, 0.10106644657057295, 0.10106644657057295, 0.10106644657057295, 0.1904312083472357, 0.1904312083472357, 0.1904312083472357, 0.18261537921226156, 0.18261537921226156, 0.18261537921226156, 0.22010279218341, 0.22010279218341, 0.22010279218341, 0.23918431752362657, 0.23918431752362657, 0.23918431752362657, 0.24697994448970972, 0.24697994448970972, 0.24697994448970972, 0.28635332357288446, 0.28635332357288446, 0.28635332357288446, 0.1948231001591496, 0.1948231001591496, 0.1948231001591496, 0.17179652329593353, 0.17179652329593353, 0.17179652329593353, 0.19370044844877032, 0.19370044844877032, 0.19370044844877032, 0.19443564087657916, 0.19443564087657916, 0.19443564087657916, 0.1850957550456963, 0.1850957550456963, 0.1850957550456963, 0.20232284572040427, 0.20232284572040427, 0.20232284572040427, 0.18444800245522952, 0.18444800245522952, 0.18444800245522952, 0.2188983640037684, 0.2188983640037684, 0.2188983640037684, 0.20092938327419874, 0.20092938327419874, 0.20092938327419874, 0.36215367778746643, 0.36215367778746643, 0.36215367778746643, 0.2794166803341456, 0.2794166803341456, 0.2794166803341456, 0.34315526015668363, 0.34315526015668363, 0.34315526015668363, 0.21472689413104817, 0.21472689413104817, 0.21472689413104817, 0.26926089249239515, 0.26926089249239515, 0.26926089249239515, 0.20901452438122137, 0.20901452438122137, 0.20901452438122137, 0.17849046175105354, 0.17849046175105354, 0.17849046175105354, 0.19583587471112962, 0.19583587471112962, 0.19583587471112962, 0.18084972218024165, 0.18084972218024165, 0.18084972218024165, 0.07549424597724375, 0.07549424597724375, 0.07549424597724375, 0.07177399748855207, 0.07177399748855207, 0.07177399748855207, 0.07045744127201325, 0.07045744127201325, 0.07045744127201325]}, "mutation_prompt": null}
{"id": "4e24291a-c803-4e71-8871-148b10cef38b", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "ff59be44-98a8-4359-b5bc-0706a2b0a222", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # Initial inertia weight\n        decay_rate = 0.99  # Inertia weight decay\n        chaotic_seq = np.random.rand(population_size)  # Chaotic sequence initialization\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                chaotic_seq = np.mod(4.0 * chaotic_seq * (1.0 - chaotic_seq), 1.0)  # Update chaotic sequence\n                population = np.where(np.random.rand(population_size, self.dim) < chaotic_seq[:, None],\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                inertia_weight *= decay_rate  # Apply inertia weight decay\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Refines adaptive control by integrating chaotic sequences and inertia weight decay for enhanced convergence and diversity in solutions.", "configspace": "", "generation": 83, "fitness": 0.310808114043967, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7106092502145377, 0.7106092502145377, 0.7106092502145377, 0.7401221898951158, 0.7401221898951158, 0.7401221898951158, 0.7310808125889907, 0.7310808125889907, 0.7310808125889907, 0.5120559212679274, 0.5120559212679274, 0.5120559212679274, 0.5522208991057773, 0.5522208991057773, 0.5522208991057773, 0.5193786104950786, 0.5193786104950786, 0.5193786104950786, 0.12418317895600772, 0.12418317895600772, 0.12418317895600772, 0.11340477166712748, 0.11340477166712748, 0.11340477166712748, 0.13616644721625393, 0.13616644721625393, 0.13616644721625393, 0.09581837664443027, 0.09581837664443027, 0.09581837664443027, 0.09690459010155938, 0.09690459010155938, 0.09690459010155938, 0.09942317479533558, 0.09942317479533558, 0.09942317479533558, 0.9304905896183727, 0.9304905896183727, 0.9304905896183727, 0.9491187466269179, 0.9491187466269179, 0.9491187466269179, 0.9257196498037472, 0.9257196498037472, 0.9257196498037472, 0.3597606927049084, 0.3597606927049084, 0.3597606927049084, 0.39176340014864663, 0.39176340014864663, 0.39176340014864663, 0.3628544311944062, 0.3628544311944062, 0.3628544311944062, 0.6955508068328526, 0.6955508068328526, 0.6955508068328526, 0.5794416456371067, 0.5794416456371067, 0.5794416456371067, 0.6481810388647744, 0.6481810388647744, 0.6481810388647744, 0.2687239441676478, 0.2687239441676478, 0.2687239441676478, 0.26910438276294346, 0.26910438276294346, 0.26910438276294346, 0.2731020474906368, 0.2731020474906368, 0.2731020474906368, 0.11244792549032989, 0.11244792549032989, 0.11244792549032989, 0.2698884202651859, 0.2698884202651859, 0.2698884202651859, 0.23302722934483167, 0.23302722934483167, 0.23302722934483167, 0.18187453219058491, 0.18187453219058491, 0.18187453219058491, 0.18981758112274105, 0.18981758112274105, 0.18981758112274105, 0.1727529412372213, 0.1727529412372213, 0.1727529412372213, 0.3182271467618635, 0.3182271467618635, 0.3182271467618635, 0.26401421674732906, 0.26401421674732906, 0.26401421674732906, 0.3137212698842108, 0.3137212698842108, 0.3137212698842108, 0.07267386636172013, 0.07267386636172013, 0.07267386636172013, 0.0686476987390231, 0.0686476987390231, 0.0686476987390231, 0.05911770784385717, 0.05911770784385717, 0.05911770784385717, 0.19047522231451863, 0.19047522231451863, 0.19047522231451863, 0.2024815507043528, 0.2024815507043528, 0.2024815507043528, 0.18819137646282746, 0.18819137646282746, 0.18819137646282746, 0.5355517829312594, 0.5355517829312594, 0.5355517829312594, 0.5220888227380278, 0.5220888227380278, 0.5220888227380278, 0.5266804852507265, 0.5266804852507265, 0.5266804852507265, 0.09427467079380492, 0.09427467079380492, 0.09427467079380492, 0.10003646239653641, 0.10003646239653641, 0.10003646239653641, 0.08858919976035706, 0.08858919976035706, 0.08858919976035706, 0.13721717799259714, 0.13721717799259714, 0.13721717799259714, 0.1345233378011067, 0.1345233378011067, 0.1345233378011067, 0.16314372200246596, 0.16314372200246596, 0.16314372200246596, 0.3266334088378474, 0.3266334088378474, 0.3266334088378474, 0.32173956378674606, 0.32173956378674606, 0.32173956378674606, 0.31302496876618613, 0.31302496876618613, 0.31302496876618613, 0.22625834813139067, 0.22625834813139067, 0.22625834813139067, 0.22228513760821367, 0.22228513760821367, 0.22228513760821367, 0.24358427741253197, 0.24358427741253197, 0.24358427741253197, 0.190148005585824, 0.190148005585824, 0.190148005585824, 0.19677886414341506, 0.19677886414341506, 0.19677886414341506, 0.1833040467159427, 0.1833040467159427, 0.1833040467159427, 0.18638878348563415, 0.18638878348563415, 0.18638878348563415, 0.19058671040044284, 0.19058671040044284, 0.19058671040044284, 0.188208185883867, 0.188208185883867, 0.188208185883867, 0.5659815514103924, 0.5659815514103924, 0.5659815514103924, 0.39217850151505684, 0.39217850151505684, 0.39217850151505684, 0.7226321749510278, 0.7226321749510278, 0.7226321749510278, 0.16353162447999925, 0.16353162447999925, 0.16353162447999925, 0.5259905065983894, 0.5259905065983894, 0.5259905065983894, 0.20714311317431477, 0.20714311317431477, 0.20714311317431477, 0.1840357018974349, 0.1840357018974349, 0.1840357018974349, 0.17710962406792818, 0.17710962406792818, 0.17710962406792818, 0.1980406281868906, 0.1980406281868906, 0.1980406281868906, 0.07159949021744016, 0.07159949021744016, 0.07159949021744016, 0.0748485581884355, 0.0748485581884355, 0.0748485581884355, 0.08150848978168923, 0.08150848978168923, 0.08150848978168923]}, "mutation_prompt": null}
{"id": "93014248-4554-44e1-a7d3-84dde8d17f79", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "dab5996a-1eb3-43cb-ba1f-9b192bd1c6dc", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)\n\n            # Local search intensification using gradient approximation\n            if evaluations < self.budget and np.random.rand() < 0.1:  # 10% chance to perform local intensification\n                for j in range(population_size):\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(population[j] + perturbation, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[j]:\n                        population[j] = candidate\n                        fitness[j] = candidate_fitness\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates local search intensification through gradient-based perturbations to enhance convergence in complex landscapes.", "configspace": "", "generation": 85, "fitness": 0.3100362056917711, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.698780831068163, 0.698780831068163, 0.698780831068163, 0.7359496161262717, 0.7359496161262717, 0.7359496161262717, 0.6980593674888199, 0.6980593674888199, 0.6980593674888199, 0.4812645963822929, 0.4812645963822929, 0.4812645963822929, 0.5142693776948953, 0.5142693776948953, 0.5142693776948953, 0.5196204020483901, 0.5196204020483901, 0.5196204020483901, 0.11720153252266408, 0.11720153252266408, 0.11720153252266408, 0.10723439505938004, 0.10723439505938004, 0.10723439505938004, 0.11382052739402593, 0.11382052739402593, 0.11382052739402593, 0.10348814947977558, 0.10348814947977558, 0.10348814947977558, 0.0953491749943921, 0.0953491749943921, 0.0953491749943921, 0.10190888116969932, 0.10190888116969932, 0.10190888116969932, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9200693861067576, 0.9200693861067576, 0.9200693861067576, 0.9706018196265379, 0.9706018196265379, 0.9706018196265379, 0.33829404350217296, 0.33829404350217296, 0.33829404350217296, 0.3109583676171357, 0.3109583676171357, 0.3109583676171357, 0.34585262820279317, 0.34585262820279317, 0.34585262820279317, 0.5826313962113314, 0.5826313962113314, 0.5826313962113314, 0.6668501635267282, 0.6668501635267282, 0.6668501635267282, 0.614394446334811, 0.614394446334811, 0.614394446334811, 0.2600831508795096, 0.2600831508795096, 0.2600831508795096, 0.21880006025997467, 0.21880006025997467, 0.21880006025997467, 0.21158281234143506, 0.21158281234143506, 0.21158281234143506, 0.2129400263409187, 0.2129400263409187, 0.2129400263409187, 0.2426840672429521, 0.2426840672429521, 0.2426840672429521, 0.24294740131896753, 0.24294740131896753, 0.24294740131896753, 0.1651062653453449, 0.1651062653453449, 0.1651062653453449, 0.17892282007067517, 0.17892282007067517, 0.17892282007067517, 0.1512417191114066, 0.1512417191114066, 0.1512417191114066, 0.2958912763134244, 0.2958912763134244, 0.2958912763134244, 0.24607280817501254, 0.24607280817501254, 0.24607280817501254, 0.33088912406920623, 0.33088912406920623, 0.33088912406920623, 0.05942201635946198, 0.05942201635946198, 0.05942201635946198, 0.08458458748227204, 0.08458458748227204, 0.08458458748227204, 0.06027330669337372, 0.06027330669337372, 0.06027330669337372, 0.1876879605224201, 0.1876879605224201, 0.1876879605224201, 0.2012879965222638, 0.2012879965222638, 0.2012879965222638, 0.18929210070988378, 0.18929210070988378, 0.18929210070988378, 0.5345158849453159, 0.5345158849453159, 0.5345158849453159, 0.5366676952318511, 0.5366676952318511, 0.5366676952318511, 0.5300726779446046, 0.5300726779446046, 0.5300726779446046, 0.1008328810498833, 0.1008328810498833, 0.1008328810498833, 0.09106538369883621, 0.09106538369883621, 0.09106538369883621, 0.09246523869900736, 0.09246523869900736, 0.09246523869900736, 0.15883001631605198, 0.15883001631605198, 0.15883001631605198, 0.2517855493015827, 0.2517855493015827, 0.2517855493015827, 0.2344366808584767, 0.2344366808584767, 0.2344366808584767, 0.2833524096714951, 0.2833524096714951, 0.2833524096714951, 0.29649637961444675, 0.29649637961444675, 0.29649637961444675, 0.3177426999353442, 0.3177426999353442, 0.3177426999353442, 0.22594182841712818, 0.22594182841712818, 0.22594182841712818, 0.20032788622154685, 0.20032788622154685, 0.20032788622154685, 0.23265825295315268, 0.23265825295315268, 0.23265825295315268, 0.2030570261177017, 0.2030570261177017, 0.2030570261177017, 0.21343860535913195, 0.21343860535913195, 0.21343860535913195, 0.2071806539236266, 0.2071806539236266, 0.2071806539236266, 0.20959679882602766, 0.20959679882602766, 0.20959679882602766, 0.18481672986116637, 0.18481672986116637, 0.18481672986116637, 0.18535121053137316, 0.18535121053137316, 0.18535121053137316, 0.6982409291425703, 0.6982409291425703, 0.6982409291425703, 0.1709286791208242, 0.1709286791208242, 0.1709286791208242, 0.6060400400544272, 0.6060400400544272, 0.6060400400544272, 0.16229151180520296, 0.16229151180520296, 0.16229151180520296, 0.4330001480995528, 0.4330001480995528, 0.4330001480995528, 0.606327509904877, 0.606327509904877, 0.606327509904877, 0.20207772604927943, 0.20207772604927943, 0.20207772604927943, 0.18718481653062746, 0.18718481653062746, 0.18718481653062746, 0.178461367898615, 0.178461367898615, 0.178461367898615, 0.08694719856527011, 0.08694719856527011, 0.08694719856527011, 0.07395865525033973, 0.07395865525033973, 0.07395865525033973, 0.06835734040343011, 0.06835734040343011, 0.06835734040343011]}, "mutation_prompt": null}
{"id": "0dd02934-4250-4b00-9483-0c531270ebd9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)\n\n            # Environment-driven local search to enhance exploration-exploitation balance\n            if evaluations < self.budget and evaluations % (population_size * 3) == 0:\n                local_search_radius = 0.1\n                for j in range(population_size):\n                    local_variation = np.random.uniform(-local_search_radius, local_search_radius, self.dim)\n                    candidate = np.clip(population[j] + local_variation, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < fitness[j]:\n                        population[j] = candidate\n                        fitness[j] = candidate_fitness\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Integrates environment-driven local search with adaptive memory to enhance exploitation and exploration balance.", "configspace": "", "generation": 86, "fitness": 0.3103789096868371, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7252434216891024, 0.7252434216891024, 0.7252434216891024, 0.7162364382102275, 0.7162364382102275, 0.7162364382102275, 0.7372601627357336, 0.7372601627357336, 0.7372601627357336, 0.547688173201649, 0.547688173201649, 0.547688173201649, 0.5569367854715639, 0.5569367854715639, 0.5569367854715639, 0.5549547285493772, 0.5549547285493772, 0.5549547285493772, 0.11495965791042895, 0.11495965791042895, 0.11495965791042895, 0.11025926176595935, 0.11025926176595935, 0.11025926176595935, 0.109078928649608, 0.109078928649608, 0.109078928649608, 0.09732241078646098, 0.09732241078646098, 0.09732241078646098, 0.09029283855918036, 0.09029283855918036, 0.09029283855918036, 0.10031034577970332, 0.10031034577970332, 0.10031034577970332, 0.9741081344191738, 0.9741081344191738, 0.9741081344191738, 0.9510400325901558, 0.9510400325901558, 0.9510400325901558, 0.9404964294558186, 0.9404964294558186, 0.9404964294558186, 0.4035686002027351, 0.4035686002027351, 0.4035686002027351, 0.3459317445891752, 0.3459317445891752, 0.3459317445891752, 0.3620574321043145, 0.3620574321043145, 0.3620574321043145, 0.5484823029579509, 0.5484823029579509, 0.5484823029579509, 0.6200062669249429, 0.6200062669249429, 0.6200062669249429, 0.6145567745894547, 0.6145567745894547, 0.6145567745894547, 0.30092171462321815, 0.30092171462321815, 0.30092171462321815, 0.2611260854206535, 0.2611260854206535, 0.2611260854206535, 0.202893232549202, 0.202893232549202, 0.202893232549202, 0.23776717605759645, 0.23776717605759645, 0.23776717605759645, 0.27197030881920714, 0.27197030881920714, 0.27197030881920714, 0.25232424867204717, 0.25232424867204717, 0.25232424867204717, 0.17070647007516815, 0.17070647007516815, 0.17070647007516815, 0.16125289211091254, 0.16125289211091254, 0.16125289211091254, 0.17672363887979858, 0.17672363887979858, 0.17672363887979858, 0.27643469663936093, 0.27643469663936093, 0.27643469663936093, 0.30713993117873317, 0.30713993117873317, 0.30713993117873317, 0.3416431903344638, 0.3416431903344638, 0.3416431903344638, 0.06708657471492774, 0.06708657471492774, 0.06708657471492774, 0.05486593399854722, 0.05486593399854722, 0.05486593399854722, 0.06138946601163242, 0.06138946601163242, 0.06138946601163242, 0.17652075964063463, 0.17652075964063463, 0.17652075964063463, 0.1992344232780422, 0.1992344232780422, 0.1992344232780422, 0.210485995755341, 0.210485995755341, 0.210485995755341, 0.5507545805118036, 0.5507545805118036, 0.5507545805118036, 0.5624221134691192, 0.5624221134691192, 0.5624221134691192, 0.5333018868422483, 0.5333018868422483, 0.5333018868422483, 0.10883747431565916, 0.10883747431565916, 0.10883747431565916, 0.0961921739514775, 0.0961921739514775, 0.0961921739514775, 0.09751946072041395, 0.09751946072041395, 0.09751946072041395, 0.18551822040544985, 0.18551822040544985, 0.18551822040544985, 0.18703983946373637, 0.18703983946373637, 0.18703983946373637, 0.15447185743798275, 0.15447185743798275, 0.15447185743798275, 0.31939635808740185, 0.31939635808740185, 0.31939635808740185, 0.3152588720191296, 0.3152588720191296, 0.3152588720191296, 0.3276114218040763, 0.3276114218040763, 0.3276114218040763, 0.2409548142538167, 0.2409548142538167, 0.2409548142538167, 0.2163165676132126, 0.2163165676132126, 0.2163165676132126, 0.25853578377243736, 0.25853578377243736, 0.25853578377243736, 0.16385837108818524, 0.16385837108818524, 0.16385837108818524, 0.18741920648528732, 0.18741920648528732, 0.18741920648528732, 0.18805845425617107, 0.18805845425617107, 0.18805845425617107, 0.1819021939690153, 0.1819021939690153, 0.1819021939690153, 0.18945576401117825, 0.18945576401117825, 0.18945576401117825, 0.19445112278225785, 0.19445112278225785, 0.19445112278225785, 0.7137864954770496, 0.7137864954770496, 0.7137864954770496, 0.17696568339280383, 0.17696568339280383, 0.17696568339280383, 0.46330074612804195, 0.46330074612804195, 0.46330074612804195, 0.19972999484723442, 0.19972999484723442, 0.19972999484723442, 0.1934267746143148, 0.1934267746143148, 0.1934267746143148, 0.5817680593931995, 0.5817680593931995, 0.5817680593931995, 0.19570139324479396, 0.19570139324479396, 0.19570139324479396, 0.19444609339217367, 0.19444609339217367, 0.19444609339217367, 0.19531660008773466, 0.19531660008773466, 0.19531660008773466, 0.07537721799801622, 0.07537721799801622, 0.07537721799801622, 0.07037250380840065, 0.07037250380840065, 0.07037250380840065, 0.07653578790624793, 0.07653578790624793, 0.07653578790624793]}, "mutation_prompt": null}
{"id": "31274b13-7e49-4511-a178-a45b00e4df88", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 8) == 0:  # Adjust frequency\n                population = np.where(np.random.rand(population_size, self.dim) < 0.35,  # Adjust mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight * 0.9, population.shape)  # Adjust inertia weight\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Incorporates dynamic population adaptation and enhanced mutation strategies to improve convergence and diversity in complex landscapes.", "configspace": "", "generation": 87, "fitness": 0.3039698343120377, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7200447422958983, 0.7200447422958983, 0.7200447422958983, 0.7738446073700123, 0.7738446073700123, 0.7738446073700123, 0.7580223074113617, 0.7580223074113617, 0.7580223074113617, 0.5699650103411285, 0.5699650103411285, 0.5699650103411285, 0.55807596419548, 0.55807596419548, 0.55807596419548, 0.549274440560257, 0.549274440560257, 0.549274440560257, 0.12456913385388957, 0.12456913385388957, 0.12456913385388957, 0.10442744299182827, 0.10442744299182827, 0.10442744299182827, 0.11884596439694761, 0.11884596439694761, 0.11884596439694761, 0.09476159702352815, 0.09476159702352815, 0.09476159702352815, 0.09297476209502709, 0.09297476209502709, 0.09297476209502709, 0.12384533634410089, 0.12384533634410089, 0.12384533634410089, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9437373172466561, 0.9437373172466561, 0.9437373172466561, 0.9705947355835122, 0.9705947355835122, 0.9705947355835122, 0.34584666320051927, 0.34584666320051927, 0.34584666320051927, 0.3548571350534552, 0.3548571350534552, 0.3548571350534552, 0.3573742177900624, 0.3573742177900624, 0.3573742177900624, 0.589618464536787, 0.589618464536787, 0.589618464536787, 0.690399768800861, 0.690399768800861, 0.690399768800861, 0.6261641038769147, 0.6261641038769147, 0.6261641038769147, 0.23360163399591616, 0.23360163399591616, 0.23360163399591616, 0.22507462180758908, 0.22507462180758908, 0.22507462180758908, 0.27565491766105765, 0.27565491766105765, 0.27565491766105765, 0.28956674589227016, 0.28956674589227016, 0.28956674589227016, 0.3116959058178922, 0.3116959058178922, 0.3116959058178922, 0.2254635429810381, 0.2254635429810381, 0.2254635429810381, 0.1436559157530206, 0.1436559157530206, 0.1436559157530206, 0.18074833618261876, 0.18074833618261876, 0.18074833618261876, 0.15588246054637234, 0.15588246054637234, 0.15588246054637234, 0.301516807830547, 0.301516807830547, 0.301516807830547, 0.260060881799722, 0.260060881799722, 0.260060881799722, 0.3036506105933686, 0.3036506105933686, 0.3036506105933686, 0.058507513657146015, 0.058507513657146015, 0.058507513657146015, 0.0861381731351144, 0.0861381731351144, 0.0861381731351144, 0.09331116213506263, 0.09331116213506263, 0.09331116213506263, 0.17603874444324552, 0.17603874444324552, 0.17603874444324552, 0.2152563878810677, 0.2152563878810677, 0.2152563878810677, 0.20941822322980364, 0.20941822322980364, 0.20941822322980364, 0.5509019749850734, 0.5509019749850734, 0.5509019749850734, 0.5755996391015408, 0.5755996391015408, 0.5755996391015408, 0.5396112852573964, 0.5396112852573964, 0.5396112852573964, 0.09807678758548011, 0.09807678758548011, 0.09807678758548011, 0.08092833303363567, 0.08092833303363567, 0.08092833303363567, 0.09496412043289659, 0.09496412043289659, 0.09496412043289659, 0.1464358804438992, 0.1464358804438992, 0.1464358804438992, 0.14200928022941295, 0.14200928022941295, 0.14200928022941295, 0.14497859270526647, 0.14497859270526647, 0.14497859270526647, 0.31285668045474835, 0.31285668045474835, 0.31285668045474835, 0.3005112984029771, 0.3005112984029771, 0.3005112984029771, 0.3341474616527328, 0.3341474616527328, 0.3341474616527328, 0.2534849631455802, 0.2534849631455802, 0.2534849631455802, 0.2290192721199693, 0.2290192721199693, 0.2290192721199693, 0.23989379369644526, 0.23989379369644526, 0.23989379369644526, 0.18305498461570224, 0.18305498461570224, 0.18305498461570224, 0.1995430011903886, 0.1995430011903886, 0.1995430011903886, 0.18293289370121657, 0.18293289370121657, 0.18293289370121657, 0.17965428051774746, 0.17965428051774746, 0.17965428051774746, 0.18446186130575315, 0.18446186130575315, 0.18446186130575315, 0.18752470258282816, 0.18752470258282816, 0.18752470258282816, 0.5902425210959626, 0.5902425210959626, 0.5902425210959626, 0.1835434662632942, 0.1835434662632942, 0.1835434662632942, 0.21914201740652184, 0.21914201740652184, 0.21914201740652184, 0.19147439663407873, 0.19147439663407873, 0.19147439663407873, 0.4217994813855718, 0.4217994813855718, 0.4217994813855718, 0.15065854302822423, 0.15065854302822423, 0.15065854302822423, 0.18818559513356825, 0.18818559513356825, 0.18818559513356825, 0.1940594617828042, 0.1940594617828042, 0.1940594617828042, 0.17818808257597596, 0.17818808257597596, 0.17818808257597596, 0.07036496008231075, 0.07036496008231075, 0.07036496008231075, 0.07252546439056351, 0.07252546439056351, 0.07252546439056351, 0.07071689802686232, 0.07071689802686232, 0.07071689802686232]}, "mutation_prompt": null}
{"id": "81e9df14-d86a-40a8-b38a-8becf0249a6d", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "2cc26428-164c-4ead-a9c0-6e96a186885c", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "12db4fb4-8d06-487f-9d3d-e40abf062c16", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9  # New inertia weight\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Dynamically adjust F and CR for exploration\n                F = np.random.uniform(0.5, 1.0)\n                CR = np.random.uniform(0.7, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 10) == 0:\n                population = np.where(np.random.rand(population_size, self.dim) < 0.3,  # Increased mutation probability\n                                      np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim)),\n                                      population)\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            # Adaptive population resizing and inertia application\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.85))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Enhances adaptive control with dynamic scaling factors and stochastic adjustments to improve convergence speed.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7163540248770981, 0.7163540248770981, 0.7163540248770981, 0.7444173247472381, 0.7444173247472381, 0.7444173247472381, 0.7461165983057898, 0.7461165983057898, 0.7461165983057898, 0.5317630476214859, 0.5317630476214859, 0.5317630476214859, 0.5199471808487524, 0.5199471808487524, 0.5199471808487524, 0.5435931582176803, 0.5435931582176803, 0.5435931582176803, 0.12062196090381605, 0.12062196090381605, 0.12062196090381605, 0.13453345644614856, 0.13453345644614856, 0.13453345644614856, 0.12312247316279246, 0.12312247316279246, 0.12312247316279246, 0.09477839441998781, 0.09477839441998781, 0.09477839441998781, 0.10065184231888269, 0.10065184231888269, 0.10065184231888269, 0.1027155803493961, 0.1027155803493961, 0.1027155803493961, 0.9818497951892091, 0.9818497951892091, 0.9818497951892091, 0.9461823319139404, 0.9461823319139404, 0.9461823319139404, 0.9705939695464697, 0.9705939695464697, 0.9705939695464697, 0.41317014545371544, 0.41317014545371544, 0.41317014545371544, 0.3430268341510324, 0.3430268341510324, 0.3430268341510324, 0.40084479421001584, 0.40084479421001584, 0.40084479421001584, 0.5842878674343416, 0.5842878674343416, 0.5842878674343416, 0.6907568860347018, 0.6907568860347018, 0.6907568860347018, 0.6909800891145694, 0.6909800891145694, 0.6909800891145694, 0.2583703563046327, 0.2583703563046327, 0.2583703563046327, 0.23235212294203056, 0.23235212294203056, 0.23235212294203056, 0.25940550924774963, 0.25940550924774963, 0.25940550924774963, 0.2603176153950324, 0.2603176153950324, 0.2603176153950324, 0.20501233628493842, 0.20501233628493842, 0.20501233628493842, 0.23672415669203506, 0.23672415669203506, 0.23672415669203506, 0.22824176175042832, 0.22824176175042832, 0.22824176175042832, 0.17038862419538892, 0.17038862419538892, 0.17038862419538892, 0.1620868310134489, 0.1620868310134489, 0.1620868310134489, 0.2876434141072167, 0.2876434141072167, 0.2876434141072167, 0.2972292753322948, 0.2972292753322948, 0.2972292753322948, 0.3508425499029282, 0.3508425499029282, 0.3508425499029282, 0.0839242259585069, 0.0839242259585069, 0.0839242259585069, 0.06917350701836733, 0.06917350701836733, 0.06917350701836733, 0.041826051236803274, 0.041826051236803274, 0.041826051236803274, 0.2022777072615971, 0.2022777072615971, 0.2022777072615971, 0.21686126727282595, 0.21686126727282595, 0.21686126727282595, 0.20150620392215568, 0.20150620392215568, 0.20150620392215568, 0.5720155911135345, 0.5720155911135345, 0.5720155911135345, 0.5745063543162925, 0.5745063543162925, 0.5745063543162925, 0.5553437298068848, 0.5553437298068848, 0.5553437298068848, 0.0979864954286972, 0.0979864954286972, 0.0979864954286972, 0.08328343821128714, 0.08328343821128714, 0.08328343821128714, 0.09203299222466266, 0.09203299222466266, 0.09203299222466266, 0.13443600272570622, 0.13443600272570622, 0.13443600272570622, 0.16718379998305244, 0.16718379998305244, 0.16718379998305244, 0.14103138796208692, 0.14103138796208692, 0.14103138796208692, 0.3188772913021882, 0.3188772913021882, 0.3188772913021882, 0.275417741605979, 0.275417741605979, 0.275417741605979, 0.32830137025932526, 0.32830137025932526, 0.32830137025932526, 0.24206224044770708, 0.24206224044770708, 0.24206224044770708, 0.22171841701769512, 0.22171841701769512, 0.22171841701769512, 0.24210591086711708, 0.24210591086711708, 0.24210591086711708, 0.18351552486608458, 0.18351552486608458, 0.18351552486608458, 0.18530697925140138, 0.18530697925140138, 0.18530697925140138, 0.19012406610808263, 0.19012406610808263, 0.19012406610808263, 0.18776024393425828, 0.18776024393425828, 0.18776024393425828, 0.17718392760939972, 0.17718392760939972, 0.17718392760939972, 0.17326832708568074, 0.17326832708568074, 0.17326832708568074, 0.6740694727602901, 0.6740694727602901, 0.6740694727602901, 0.5196771560427144, 0.5196771560427144, 0.5196771560427144, 0.5505528466898195, 0.5505528466898195, 0.5505528466898195, 0.5639986328016771, 0.5639986328016771, 0.5639986328016771, 0.19349053543141204, 0.19349053543141204, 0.19349053543141204, 0.5427611627487867, 0.5427611627487867, 0.5427611627487867, 0.181790318278089, 0.181790318278089, 0.181790318278089, 0.17105620414974654, 0.17105620414974654, 0.17105620414974654, 0.21151331179848754, 0.21151331179848754, 0.21151331179848754, 0.07854754302766453, 0.07854754302766453, 0.07854754302766453, 0.07544557041223221, 0.07544557041223221, 0.07544557041223221, 0.06679158141736385, 0.06679158141736385, 0.06679158141736385]}, "mutation_prompt": null}
{"id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.33721944458967906, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "6d84150b-ad16-462d-8940-494179994f63", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "ea09001a-4160-4729-b611-160c5aa5537c", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "d9272405-18b8-470e-9b14-42a1aa341c70", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n        best_idx = np.argmin(fitness)\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if new_fitness < fitness[best_idx]:\n                    best_idx = i\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)\n                inertia_weight *= 0.95  # Damping inertia weight\n\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Incorporates adaptive learning of control parameters and elitism to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 40')", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {}, "mutation_prompt": null}
{"id": "bf12555a-3309-4c4b-b2c8-a31b90388c07", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "ce9195ec-7579-4194-a4ef-db44194c03e4", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "4998a78d-86ab-41ea-b57b-ce84588fc896", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "0917dff1-d24c-4291-a585-62bf94e3fe35", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "fd89001a-d948-432e-91cb-833a97293b81", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
{"id": "055be13b-c74d-4d75-9f06-3eeb030f17ca", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population_size = 10 * self.dim\n        F = 0.8\n        CR = 0.9\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        memory_size = 5\n        mem_F = np.full(memory_size, F)\n        mem_CR = np.full(memory_size, CR)\n        mem_idx = 0\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F = np.clip(np.random.normal(0.7, 0.1), 0.5, 1.0)  # Adjusted dynamic scaling of F\n                CR = np.clip(np.random.normal(0.85, 0.1), 0.6, 1.0)  # Adjusted dynamic scaling of CR\n                mutated = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.array([mutated[j] if np.random.rand() < CR else population[i][j] for j in range(self.dim)])\n                new_fitness = func(crossover)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = crossover\n                    fitness[i] = new_fitness\n                    mem_F[mem_idx] = F\n                    mem_CR[mem_idx] = CR\n                    mem_idx = (mem_idx + 1) % memory_size\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget and evaluations % (population_size * 5) == 0:\n                population_size = max(4, int(population_size * 0.8))  # More aggressive population resizing\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n                population += np.random.normal(0, inertia_weight, population.shape)  # Apply inertia weight effect\n\n        return population[np.argmin(fitness)], min(fitness)", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Introduces dynamic scaling of population size and enhanced adaptive parameter tuning to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75f46cc9-3fce-4faf-a9ea-81de307abe9f", "metadata": {"aucs": [0.7778543846732718, 0.7778543846732718, 0.7778543846732718, 0.770914357756449, 0.770914357756449, 0.770914357756449, 0.7834513285301513, 0.7834513285301513, 0.7834513285301513, 0.6237416309437838, 0.6237416309437838, 0.6237416309437838, 0.5930755501137606, 0.5930755501137606, 0.5930755501137606, 0.6140581720787452, 0.6140581720787452, 0.6140581720787452, 0.1317968980542994, 0.1317968980542994, 0.1317968980542994, 0.11304994701123428, 0.11304994701123428, 0.11304994701123428, 0.12227208249527066, 0.12227208249527066, 0.12227208249527066, 0.10000836756367393, 0.10000836756367393, 0.10000836756367393, 0.10924656192154325, 0.10924656192154325, 0.10924656192154325, 0.0979338916552106, 0.0979338916552106, 0.0979338916552106, 0.9584121425141073, 0.9584121425141073, 0.9584121425141073, 0.968132406902837, 0.968132406902837, 0.968132406902837, 0.9563101246396588, 0.9563101246396588, 0.9563101246396588, 0.4468682901061304, 0.4468682901061304, 0.4468682901061304, 0.40194666438006144, 0.40194666438006144, 0.40194666438006144, 0.4255131316734104, 0.4255131316734104, 0.4255131316734104, 0.61287905483746, 0.61287905483746, 0.61287905483746, 0.6679672957463453, 0.6679672957463453, 0.6679672957463453, 0.6995564431021479, 0.6995564431021479, 0.6995564431021479, 0.2723181634148064, 0.2723181634148064, 0.2723181634148064, 0.22680081377841732, 0.22680081377841732, 0.22680081377841732, 0.2861573255087052, 0.2861573255087052, 0.2861573255087052, 0.27145610435501943, 0.27145610435501943, 0.27145610435501943, 0.3429376109667893, 0.3429376109667893, 0.3429376109667893, 0.305863799733334, 0.305863799733334, 0.305863799733334, 0.2542572461293119, 0.2542572461293119, 0.2542572461293119, 0.1913465682283204, 0.1913465682283204, 0.1913465682283204, 0.23730116006197222, 0.23730116006197222, 0.23730116006197222, 0.3504766661966139, 0.3504766661966139, 0.3504766661966139, 0.28997480012142685, 0.28997480012142685, 0.28997480012142685, 0.45321584151004535, 0.45321584151004535, 0.45321584151004535, 0.07558698934842012, 0.07558698934842012, 0.07558698934842012, 0.06451974200571964, 0.06451974200571964, 0.06451974200571964, 0.08769438347994274, 0.08769438347994274, 0.08769438347994274, 0.22360623054557793, 0.22360623054557793, 0.22360623054557793, 0.23475276862755456, 0.23475276862755456, 0.23475276862755456, 0.23917667103295293, 0.23917667103295293, 0.23917667103295293, 0.5828463961470098, 0.5828463961470098, 0.5828463961470098, 0.603125156405353, 0.603125156405353, 0.603125156405353, 0.6094278659992599, 0.6094278659992599, 0.6094278659992599, 0.10175297283910056, 0.10175297283910056, 0.10175297283910056, 0.09128665179015916, 0.09128665179015916, 0.09128665179015916, 0.10676949540163228, 0.10676949540163228, 0.10676949540163228, 0.15455313250137936, 0.15455313250137936, 0.15455313250137936, 0.14894125020575588, 0.14894125020575588, 0.14894125020575588, 0.14963002956104687, 0.14963002956104687, 0.14963002956104687, 0.3684130764348501, 0.3684130764348501, 0.3684130764348501, 0.31763131324060256, 0.31763131324060256, 0.31763131324060256, 0.35935725970759536, 0.35935725970759536, 0.35935725970759536, 0.2584665483471046, 0.2584665483471046, 0.2584665483471046, 0.26071249365750326, 0.26071249365750326, 0.26071249365750326, 0.2514660984457391, 0.2514660984457391, 0.2514660984457391, 0.19461018577402178, 0.19461018577402178, 0.19461018577402178, 0.2064430674552159, 0.2064430674552159, 0.2064430674552159, 0.22508267368164803, 0.22508267368164803, 0.22508267368164803, 0.21040927993161995, 0.21040927993161995, 0.21040927993161995, 0.1839262355151221, 0.1839262355151221, 0.1839262355151221, 0.2332584293118991, 0.2332584293118991, 0.2332584293118991, 0.7312741090753665, 0.7312741090753665, 0.7312741090753665, 0.5639667952070242, 0.5639667952070242, 0.5639667952070242, 0.6081856596905948, 0.6081856596905948, 0.6081856596905948, 0.2027048906711758, 0.2027048906711758, 0.2027048906711758, 0.18937115220558176, 0.18937115220558176, 0.18937115220558176, 0.2061006366678847, 0.2061006366678847, 0.2061006366678847, 0.18268940622451235, 0.18268940622451235, 0.18268940622451235, 0.1835197538837271, 0.1835197538837271, 0.1835197538837271, 0.1882363190208176, 0.1882363190208176, 0.1882363190208176, 0.07979429793138038, 0.07979429793138038, 0.07979429793138038, 0.07243254676535704, 0.07243254676535704, 0.07243254676535704, 0.07098321901536819, 0.07098321901536819, 0.07098321901536819]}, "mutation_prompt": null}
